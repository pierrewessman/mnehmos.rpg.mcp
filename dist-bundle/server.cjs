"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/zod/v3/helpers/util.js
var util, objectUtil, ZodParsedType, getParsedType;
var init_util = __esm({
  "node_modules/zod/v3/helpers/util.js"() {
    (function(util2) {
      util2.assertEqual = (_) => {
      };
      function assertIs2(_arg) {
      }
      util2.assertIs = assertIs2;
      function assertNever2(_x) {
        throw new Error();
      }
      util2.assertNever = assertNever2;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object3) => {
        const keys = [];
        for (const key in object3) {
          if (Object.prototype.hasOwnProperty.call(object3, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
      function joinValues2(array2, separator = " | ") {
        return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      util2.joinValues = joinValues2;
      util2.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
          return value.toString();
        }
        return value;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = (data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    };
  }
});

// node_modules/zod/v3/ZodError.js
var ZodIssueCode, quotelessJson, ZodError;
var init_ZodError = __esm({
  "node_modules/zod/v3/ZodError.js"() {
    init_util();
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = (obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    };
    ZodError = class _ZodError extends Error {
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue2) {
          return issue2.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
          for (const issue2 of error.issues) {
            if (issue2.code === "invalid_union") {
              issue2.unionErrors.map(processError);
            } else if (issue2.code === "invalid_return_type") {
              processError(issue2.returnTypeError);
            } else if (issue2.code === "invalid_arguments") {
              processError(issue2.argumentsError);
            } else if (issue2.path.length === 0) {
              fieldErrors._errors.push(mapper(issue2));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue2.path.length) {
                const el = issue2.path[i];
                const terminal = i === issue2.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue2));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        };
        processError(this);
        return fieldErrors;
      }
      static assert(value) {
        if (!(value instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue2) => issue2.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            const firstEl = sub.path[0];
            fieldErrors[firstEl] = fieldErrors[firstEl] || [];
            fieldErrors[firstEl].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
  }
});

// node_modules/zod/v3/locales/en.js
var errorMap, en_default;
var init_en = __esm({
  "node_modules/zod/v3/locales/en.js"() {
    init_ZodError();
    init_util();
    errorMap = (issue2, _ctx) => {
      let message;
      switch (issue2.code) {
        case ZodIssueCode.invalid_type:
          if (issue2.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue2.expected}, received ${issue2.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue2.validation === "object") {
            if ("includes" in issue2.validation) {
              message = `Invalid input: must include "${issue2.validation.includes}"`;
              if (typeof issue2.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`;
              }
            } else if ("startsWith" in issue2.validation) {
              message = `Invalid input: must start with "${issue2.validation.startsWith}"`;
            } else if ("endsWith" in issue2.validation) {
              message = `Invalid input: must end with "${issue2.validation.endsWith}"`;
            } else {
              util.assertNever(issue2.validation);
            }
          } else if (issue2.validation !== "regex") {
            message = `Invalid ${issue2.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `more than`} ${issue2.minimum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? `at least` : `over`} ${issue2.minimum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "bigint")
            message = `Number must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${issue2.minimum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly equal to ` : issue2.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue2.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue2.type === "array")
            message = `Array must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `less than`} ${issue2.maximum} element(s)`;
          else if (issue2.type === "string")
            message = `String must contain ${issue2.exact ? `exactly` : issue2.inclusive ? `at most` : `under`} ${issue2.maximum} character(s)`;
          else if (issue2.type === "number")
            message = `Number must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "bigint")
            message = `BigInt must be ${issue2.exact ? `exactly` : issue2.inclusive ? `less than or equal to` : `less than`} ${issue2.maximum}`;
          else if (issue2.type === "date")
            message = `Date must be ${issue2.exact ? `exactly` : issue2.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue2.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue2.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue2);
      }
      return { message };
    };
    en_default = errorMap;
  }
});

// node_modules/zod/v3/errors.js
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var overrideErrorMap;
var init_errors = __esm({
  "node_modules/zod/v3/errors.js"() {
    init_en();
    overrideErrorMap = en_default;
  }
});

// node_modules/zod/v3/helpers/parseUtil.js
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync;
var init_parseUtil = __esm({
  "node_modules/zod/v3/helpers/parseUtil.js"() {
    init_errors();
    init_en();
    makeIssue = (params) => {
      const { data, path, errorMaps, issueData } = params;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    };
    EMPTY_PATH = [];
    ParseStatus = class _ParseStatus {
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = (value) => ({ status: "dirty", value });
    OK = (value) => ({ status: "valid", value });
    isAborted = (x) => x.status === "aborted";
    isDirty = (x) => x.status === "dirty";
    isValid = (x) => x.status === "valid";
    isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
  }
});

// node_modules/zod/v3/helpers/typeAliases.js
var init_typeAliases = __esm({
  "node_modules/zod/v3/helpers/typeAliases.js"() {
  }
});

// node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
var init_errorUtil = __esm({
  "node_modules/zod/v3/helpers/errorUtil.js"() {
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message?.message;
    })(errorUtil || (errorUtil = {}));
  }
});

// node_modules/zod/v3/types.js
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message ?? ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: message ?? required_error ?? ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: message ?? invalid_type_error ?? ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let secondsRegexSource = `[0-5]\\d`;
  if (args.precision) {
    secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`;
  }
  const secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    if (!header)
      return false;
    const base642 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base642));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if ("typ" in decoded && decoded?.typ !== "JWT")
      return false;
    if (!decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
function cleanParams(params, data) {
  const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check2, _params = {}, fatal) {
  if (check2)
    return ZodAny.create().superRefine((data, ctx) => {
      const r = check2(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          if (!r2) {
            const params = cleanParams(_params, data);
            const _fatal = params.fatal ?? fatal ?? true;
            ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params = cleanParams(_params, data);
        const _fatal = params.fatal ?? fatal ?? true;
        ctx.addIssue({ code: "custom", ...params, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER;
var init_types = __esm({
  "node_modules/zod/v3/types.js"() {
    init_ZodError();
    init_errors();
    init_errorUtil();
    init_parseUtil();
    init_util();
    ParseInputLazyPath = class {
      constructor(parent, value, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (Array.isArray(this._key)) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = (ctx, result) => {
      if (isValid(result)) {
        return { success: true, data: result.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    };
    ZodType = class {
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result = this._parse(input);
        if (isAsync(result)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result;
      }
      _parseAsync(input) {
        const result = this._parse(input);
        return Promise.resolve(result);
      }
      parse(data, params) {
        const result = this.safeParse(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      safeParse(data, params) {
        const ctx = {
          common: {
            issues: [],
            async: params?.async ?? false,
            contextualErrorMap: params?.errorMap
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result);
      }
      "~validate"(data) {
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result) ? {
              value: result.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if (err?.message?.toLowerCase()?.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params) {
        const result = await this.safeParseAsync(data, params);
        if (result.success)
          return result.data;
        throw result.error;
      }
      async safeParseAsync(data, params) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params?.errorMap,
            async: true
          },
          path: params?.path || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
        const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
        return handleResult(ctx, result);
      }
      refine(check2, message) {
        const getIssueProperties = (val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        };
        return this._refinement((val, ctx) => {
          const result = check2(val);
          const setError = () => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          });
          if (typeof Promise !== "undefined" && result instanceof Promise) {
            return result.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check2, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check2(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: (data) => this["~validate"](data)
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform2) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform: transform2 }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    ZodString = class _ZodString2 extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.length < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.length > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "length") {
            const tooBig = input.data.length > check2.value;
            const tooSmall = input.data.length < check2.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check2.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check2.message
                });
              }
              status.dirty();
            }
          } else if (check2.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "url") {
            try {
              new URL(input.data);
            } catch {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "regex") {
            check2.regex.lastIndex = 0;
            const testResult = check2.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "trim") {
            input.data = input.data.trim();
          } else if (check2.kind === "includes") {
            if (!input.data.includes(check2.value, check2.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check2.value, position: check2.position },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check2.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check2.kind === "startsWith") {
            if (!input.data.startsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "endsWith") {
            if (!input.data.endsWith(check2.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check2.value },
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "datetime") {
            const regex = datetimeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "time") {
            const regex = timeRegex(check2);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "ip") {
            if (!isValidIP(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "jwt") {
            if (!isValidJWT(input.data, check2.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "cidr") {
            if (!isValidCidr(input.data, check2.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation, message) {
        return this.refinement((data) => regex.test(data), {
          validation,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check2) {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          offset: options?.offset ?? false,
          local: options?.local ?? false,
          ...errorUtil.errToObj(options?.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof options?.precision === "undefined" ? null : options?.precision,
          ...errorUtil.errToObj(options?.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value, options) {
        return this._addCheck({
          kind: "includes",
          value,
          position: options?.position,
          ...errorUtil.errToObj(options?.message)
        });
      }
      startsWith(value, message) {
        return this._addCheck({
          kind: "startsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value, message) {
        return this._addCheck({
          kind: "endsWith",
          value,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString2({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params) => {
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodNumber = class _ZodNumber extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check2.value,
                type: "number",
                inclusive: check2.inclusive,
                exact: false,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check2.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null;
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            const tooSmall = check2.inclusive ? input.data < check2.value : input.data <= check2.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            const tooBig = check2.inclusive ? input.data > check2.value : input.data >= check2.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check2.value,
                inclusive: check2.inclusive,
                message: check2.message
              });
              status.dirty();
            }
          } else if (check2.kind === "multipleOf") {
            if (input.data % check2.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check2.value,
                message: check2.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value, message) {
        return this.setLimit("min", value, true, errorUtil.toString(message));
      }
      gt(value, message) {
        return this.setLimit("min", value, false, errorUtil.toString(message));
      }
      lte(value, message) {
        return this.setLimit("max", value, true, errorUtil.toString(message));
      }
      lt(value, message) {
        return this.setLimit("max", value, false, errorUtil.toString(message));
      }
      setLimit(kind, value, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check2) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value, message) {
        return this._addCheck({
          kind: "multipleOf",
          value,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params) => {
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: params?.coerce ?? false,
        ...processCreateParams(params)
      });
    };
    ZodBoolean = class extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: params?.coerce || false,
        ...processCreateParams(params)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (Number.isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check2 of this._def.checks) {
          if (check2.kind === "min") {
            if (input.data.getTime() < check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check2.message,
                inclusive: true,
                exact: false,
                minimum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check2.kind === "max") {
            if (input.data.getTime() > check2.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check2.message,
                inclusive: true,
                exact: false,
                maximum: check2.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check2);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check2) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check2]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params) => {
      return new ZodDate({
        checks: [],
        coerce: params?.coerce || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params)
      });
    };
    ZodSymbol = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params)
      });
    };
    ZodUndefined = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params)
      });
    };
    ZodNull = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params)
      });
    };
    ZodAny = class extends ZodType {
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params)
      });
    };
    ZodUnknown = class extends ZodType {
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params)
      });
    };
    ZodNever = class extends ZodType {
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params)
      });
    };
    ZodVoid = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result2) => {
            return ParseStatus.mergeArray(status, result2);
          });
        }
        const result = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params)
      });
    };
    ZodObject = class _ZodObject extends ZodType {
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        this._cached = { shape, keys };
        return this._cached;
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") {
          } else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              syncPairs.push({
                key,
                value,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: (issue2, ctx) => {
              const defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
              if (issue2.code === "unrecognized_keys")
                return {
                  message: errorUtil.errToObj(message).message ?? defaultError
                };
              return {
                message: defaultError
              };
            }
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: () => ({
            ...this._def.shape(),
            ...augmentation
          })
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: () => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        for (const key of util.objectKeys(mask)) {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      omit(mask) {
        const shape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => shape
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      required(mask) {
        const newShape = {};
        for (const key of util.objectKeys(this.shape)) {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        }
        return new _ZodObject({
          ...this._def,
          shape: () => newShape
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.strictCreate = (shape, params) => {
      return new ZodObject({
        shape: () => shape,
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodObject.lazycreate = (shape, params) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params)
      });
    };
    ZodUnion = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result of results) {
            if (result.result.status === "valid") {
              return result.result;
            }
          }
          for (const result of results) {
            if (result.result.status === "dirty") {
              ctx.common.issues.push(...result.ctx.common.issues);
              return result.result;
            }
          }
          const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result.status === "valid") {
              return result;
            } else if (result.status === "dirty" && !dirty) {
              dirty = { result, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params)
      });
    };
    getDiscriminator = (type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    };
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value of discriminatorValues) {
            if (optionsMap.has(value)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
            }
            optionsMap.set(value, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params)
        });
      }
    };
    ZodIntersection = class extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = (parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        };
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left, right]) => handleParsed(left, right));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left, right, params) => {
      return new ZodIntersection({
        left,
        right,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value = await pair.value;
              if (key.status === "aborted" || value.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value = pair.value;
            if (key.status === "aborted" || value.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        const params = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
              error.addIssue(makeReturnsIssue(result, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result, params);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params)
        });
      }
    };
    ZodLazy = class extends ZodType {
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params)
      });
    };
    ZodLiteral = class extends ZodType {
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value, params) => {
      return new ZodLiteral({
        value,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params)
      });
    };
    ZodEnum = class _ZodEnum extends ZodType {
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(this._def.values);
        }
        if (!this._cache.has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!this._cache) {
          this._cache = new Set(util.getValidEnumValues(this._def.values));
        }
        if (!this._cache.has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    ZodNativeEnum.create = (values, params) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params)
      });
    };
    ZodPromise = class extends ZodType {
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params)
      });
    };
    ZodEffects = class extends ZodType {
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: (arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          },
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result.status === "aborted")
                return INVALID;
              if (result.status === "dirty")
                return DIRTY(result.value);
              if (status.value === "dirty")
                return DIRTY(result.value);
              return result;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result.status === "aborted")
              return INVALID;
            if (result.status === "dirty")
              return DIRTY(result.value);
            if (status.value === "dirty")
              return DIRTY(result.value);
            return result;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = (acc) => {
            const result = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result);
            }
            if (result instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          };
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return INVALID;
            const result = effect.transform(base.value, checkCtx);
            if (result instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return INVALID;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
                status: status.value,
                value: result
              }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess2, schema, params) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess2 },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params)
      });
    };
    ZodOptional = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params)
      });
    };
    ZodNullable = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params)
      });
    };
    ZodDefault = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params.default === "function" ? params.default : () => params.default,
        ...processCreateParams(params)
      });
    };
    ZodCatch = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result)) {
          return result.then((result2) => {
            return {
              status: "valid",
              value: result2.status === "valid" ? result2.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result.status === "valid" ? result.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
        ...processCreateParams(params)
      });
    };
    ZodNaN = class extends ZodType {
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          };
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      _parse(input) {
        const result = this._def.innerType._parse(input);
        const freeze = (data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        };
        return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params)
      });
    };
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = (cls, params = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params);
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = () => stringType().optional();
    onumber = () => numberType().optional();
    oboolean = () => booleanType().optional();
    coerce = {
      string: ((arg) => ZodString.create({ ...arg, coerce: true })),
      number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),
      boolean: ((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      })),
      bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),
      date: ((arg) => ZodDate.create({ ...arg, coerce: true }))
    };
    NEVER = INVALID;
  }
});

// node_modules/zod/v3/external.js
var external_exports = {};
__export(external_exports, {
  BRAND: () => BRAND,
  DIRTY: () => DIRTY,
  EMPTY_PATH: () => EMPTY_PATH,
  INVALID: () => INVALID,
  NEVER: () => NEVER,
  OK: () => OK,
  ParseStatus: () => ParseStatus,
  Schema: () => ZodType,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBigInt: () => ZodBigInt,
  ZodBoolean: () => ZodBoolean,
  ZodBranded: () => ZodBranded,
  ZodCatch: () => ZodCatch,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodEffects: () => ZodEffects,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNativeEnum: () => ZodNativeEnum,
  ZodNever: () => ZodNever,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodParsedType: () => ZodParsedType,
  ZodPipeline: () => ZodPipeline,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSchema: () => ZodType,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodSymbol: () => ZodSymbol,
  ZodTransformer: () => ZodEffects,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  addIssueToContext: () => addIssueToContext,
  any: () => anyType,
  array: () => arrayType,
  bigint: () => bigIntType,
  boolean: () => booleanType,
  coerce: () => coerce,
  custom: () => custom,
  date: () => dateType,
  datetimeRegex: () => datetimeRegex,
  defaultErrorMap: () => en_default,
  discriminatedUnion: () => discriminatedUnionType,
  effect: () => effectsType,
  enum: () => enumType,
  function: () => functionType,
  getErrorMap: () => getErrorMap,
  getParsedType: () => getParsedType,
  instanceof: () => instanceOfType,
  intersection: () => intersectionType,
  isAborted: () => isAborted,
  isAsync: () => isAsync,
  isDirty: () => isDirty,
  isValid: () => isValid,
  late: () => late,
  lazy: () => lazyType,
  literal: () => literalType,
  makeIssue: () => makeIssue,
  map: () => mapType,
  nan: () => nanType,
  nativeEnum: () => nativeEnumType,
  never: () => neverType,
  null: () => nullType,
  nullable: () => nullableType,
  number: () => numberType,
  object: () => objectType,
  objectUtil: () => objectUtil,
  oboolean: () => oboolean,
  onumber: () => onumber,
  optional: () => optionalType,
  ostring: () => ostring,
  pipeline: () => pipelineType,
  preprocess: () => preprocessType,
  promise: () => promiseType,
  quotelessJson: () => quotelessJson,
  record: () => recordType,
  set: () => setType,
  setErrorMap: () => setErrorMap,
  strictObject: () => strictObjectType,
  string: () => stringType,
  symbol: () => symbolType,
  transformer: () => effectsType,
  tuple: () => tupleType,
  undefined: () => undefinedType,
  union: () => unionType,
  unknown: () => unknownType,
  util: () => util,
  void: () => voidType
});
var init_external = __esm({
  "node_modules/zod/v3/external.js"() {
    init_errors();
    init_parseUtil();
    init_typeAliases();
    init_util();
    init_types();
    init_ZodError();
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a;
        return (_a = this._str) !== null && _a !== void 0 ? _a : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a;
        return (_a = this._names) !== null && _a !== void 0 ? _a : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate2(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate2(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a, _b;
        if (((_b = (_a = this._parent) === null || _a === void 0 ? void 0 : _a._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a = value.key) !== null && _a !== void 0 ? _a : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i, 1, ...n2);
          else if (n2)
            nodes[i] = n2;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a;
        this.else = (_a = this.else) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a, _b;
        super.optimizeNodes();
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a, _b;
        super.optimizeNames(names, constants);
        (_a = this.catch) === null || _a === void 0 ? void 0 : _a.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n2) {
        const c = constants[n2.str];
        if (c === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self: self2 } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self2.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self: self2 }, type) {
      const group = self2.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a;
      return schema[rule.keyword] !== void 0 || ((_a = rule.definition.implements) === null || _a === void 0 ? void 0 : _a.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a = def.valid) !== null && _a !== void 0 ? _a : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a2;
        gen.if((0, codegen_1.not)((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self: self2, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self2.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self2.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self: self2 }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self2.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self: self2 } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self2.RULES)) {
        self2.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self: self2 } = it;
      const { RULES } = self2;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a = env.baseId) !== null && _a !== void 0 ? _a : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a = root.localRefs) === null || _a === void 0 ? void 0 : _a[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a;
      if (((_a = parsedRef.fragment) === null || _a === void 0 ? void 0 : _a[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv62 = getIPV6(host);
      if (!ipv62.error) {
        let newHost = ipv62.address;
        let escapedHost = ipv62.address;
        if (ipv62.zone) {
          newHost += "%" + ipv62.zone;
          escapedHost += "%25" + ipv62.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path) {
      let input = path;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      const func = esc2 !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module2.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse4(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse4(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse4(baseURI, schemelessOptions), parse4(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse4(serialize(base, options), options);
        relative = parse4(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse4(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse4(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse4(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse4
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a = o.code) === null || _a === void 0 ? void 0 : _a.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta: meta2, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta2 && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta: meta2, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta2 == "object" ? meta2[schemaId] || meta2 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta2) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta2);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta2);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta2, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta2, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a = definition.implements) === null || _a === void 0 ? void 0 : _a.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self: self2 } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self2, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a === void 0 ? void 0 : _a.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self2.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self2.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a === void 0 ? void 0 : _a[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date3, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date3(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time3(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time3 = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date3(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self: self2 } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self2.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self2.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self2.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs2, exportName) {
      var _a;
      var _b;
      (_a = (_b = ajv.opts.code).formats) !== null && _a !== void 0 ? _a : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs2[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  }
});

// node_modules/zod/index.js
var init_zod = __esm({
  "node_modules/zod/index.js"() {
    init_external();
    init_external();
  }
});

// node_modules/seedrandom/lib/alea.js
var require_alea = __commonJS({
  "node_modules/seedrandom/lib/alea.js"(exports2, module2) {
    (function(global, module3, define2) {
      function Alea(seed) {
        var me = this, mash = Mash();
        me.next = function() {
          var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
          me.s0 = me.s1;
          me.s1 = me.s2;
          return me.s2 = t - (me.c = t | 0);
        };
        me.c = 1;
        me.s0 = mash(" ");
        me.s1 = mash(" ");
        me.s2 = mash(" ");
        me.s0 -= mash(seed);
        if (me.s0 < 0) {
          me.s0 += 1;
        }
        me.s1 -= mash(seed);
        if (me.s1 < 0) {
          me.s1 += 1;
        }
        me.s2 -= mash(seed);
        if (me.s2 < 0) {
          me.s2 += 1;
        }
        mash = null;
      }
      function copy(f, t) {
        t.c = f.c;
        t.s0 = f.s0;
        t.s1 = f.s1;
        t.s2 = f.s2;
        return t;
      }
      function impl(seed, opts) {
        var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
        prng.int32 = function() {
          return xg.next() * 4294967296 | 0;
        };
        prng.double = function() {
          return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
        };
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      function Mash() {
        var n2 = 4022871197;
        var mash = function(data) {
          data = String(data);
          for (var i = 0; i < data.length; i++) {
            n2 += data.charCodeAt(i);
            var h = 0.02519603282416938 * n2;
            n2 = h >>> 0;
            h -= n2;
            h *= n2;
            n2 = h >>> 0;
            h -= n2;
            n2 += h * 4294967296;
          }
          return (n2 >>> 0) * 23283064365386963e-26;
        };
        return mash;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.alea = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor128.js
var require_xor128 = __commonJS({
  "node_modules/seedrandom/lib/xor128.js"(exports2, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.next = function() {
          var t = me.x ^ me.x << 11;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
        };
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor128 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorwow.js
var require_xorwow = __commonJS({
  "node_modules/seedrandom/lib/xorwow.js"(exports2, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var t = me.x ^ me.x >>> 2;
          me.x = me.y;
          me.y = me.z;
          me.z = me.w;
          me.w = me.v;
          return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
        };
        me.x = 0;
        me.y = 0;
        me.z = 0;
        me.w = 0;
        me.v = 0;
        if (seed === (seed | 0)) {
          me.x = seed;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 64; k++) {
          me.x ^= strseed.charCodeAt(k) | 0;
          if (k == strseed.length) {
            me.d = me.x << 10 ^ me.x >>> 4;
          }
          me.next();
        }
      }
      function copy(f, t) {
        t.x = f.x;
        t.y = f.y;
        t.z = f.z;
        t.w = f.w;
        t.v = f.v;
        t.d = f.d;
        return t;
      }
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorwow = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xorshift7.js
var require_xorshift7 = __commonJS({
  "node_modules/seedrandom/lib/xorshift7.js"(exports2, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var X = me.x, i = me.i, t, v, w;
          t = X[i];
          t ^= t >>> 7;
          v = t ^ t << 24;
          t = X[i + 1 & 7];
          v ^= t ^ t >>> 10;
          t = X[i + 3 & 7];
          v ^= t ^ t >>> 3;
          t = X[i + 4 & 7];
          v ^= t ^ t << 7;
          t = X[i + 7 & 7];
          t = t ^ t << 13;
          v ^= t ^ t << 9;
          X[i] = v;
          me.i = i + 1 & 7;
          return v;
        };
        function init(me2, seed2) {
          var j, w, X = [];
          if (seed2 === (seed2 | 0)) {
            w = X[0] = seed2;
          } else {
            seed2 = "" + seed2;
            for (j = 0; j < seed2.length; ++j) {
              X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
            }
          }
          while (X.length < 8) X.push(0);
          for (j = 0; j < 8 && X[j] === 0; ++j) ;
          if (j == 8) w = X[7] = -1;
          else w = X[j];
          me2.x = X;
          me2.i = 0;
          for (j = 256; j > 0; --j) {
            me2.next();
          }
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.x = f.x.slice();
        t.i = f.i;
        return t;
      }
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.x) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xorshift7 = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/xor4096.js
var require_xor4096 = __commonJS({
  "node_modules/seedrandom/lib/xor4096.js"(exports2, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this;
        me.next = function() {
          var w = me.w, X = me.X, i = me.i, t, v;
          me.w = w = w + 1640531527 | 0;
          v = X[i + 34 & 127];
          t = X[i = i + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          v = X[i] = v ^ t;
          me.i = i;
          return v + (w ^ w >>> 16) | 0;
        };
        function init(me2, seed2) {
          var t, v, i, j, w, X = [], limit = 128;
          if (seed2 === (seed2 | 0)) {
            v = seed2;
            seed2 = null;
          } else {
            seed2 = seed2 + "\0";
            v = 0;
            limit = Math.max(limit, seed2.length);
          }
          for (i = 0, j = -32; j < limit; ++j) {
            if (seed2) v ^= seed2.charCodeAt((j + 32) % seed2.length);
            if (j === 0) w = v;
            v ^= v << 10;
            v ^= v >>> 15;
            v ^= v << 4;
            v ^= v >>> 13;
            if (j >= 0) {
              w = w + 1640531527 | 0;
              t = X[j & 127] ^= v + w;
              i = 0 == t ? i + 1 : 0;
            }
          }
          if (i >= 128) {
            X[(seed2 && seed2.length || 0) & 127] = -1;
          }
          i = 127;
          for (j = 4 * 128; j > 0; --j) {
            v = X[i + 34 & 127];
            t = X[i = i + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            X[i] = v ^ t;
          }
          me2.w = w;
          me2.X = X;
          me2.i = i;
        }
        init(me, seed);
      }
      function copy(f, t) {
        t.i = f.i;
        t.w = f.w;
        t.X = f.X.slice();
        return t;
      }
      ;
      function impl(seed, opts) {
        if (seed == null) seed = +/* @__PURE__ */ new Date();
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (state.X) copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.xor4096 = impl;
      }
    })(
      exports2,
      // window object or global
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/lib/tychei.js
var require_tychei = __commonJS({
  "node_modules/seedrandom/lib/tychei.js"(exports2, module2) {
    (function(global, module3, define2) {
      function XorGen(seed) {
        var me = this, strseed = "";
        me.next = function() {
          var b = me.b, c = me.c, d = me.d, a = me.a;
          b = b << 25 ^ b >>> 7 ^ c;
          c = c - d | 0;
          d = d << 24 ^ d >>> 8 ^ a;
          a = a - b | 0;
          me.b = b = b << 20 ^ b >>> 12 ^ c;
          me.c = c = c - d | 0;
          me.d = d << 16 ^ c >>> 16 ^ a;
          return me.a = a - b | 0;
        };
        me.a = 0;
        me.b = 0;
        me.c = 2654435769 | 0;
        me.d = 1367130551;
        if (seed === Math.floor(seed)) {
          me.a = seed / 4294967296 | 0;
          me.b = seed | 0;
        } else {
          strseed += seed;
        }
        for (var k = 0; k < strseed.length + 20; k++) {
          me.b ^= strseed.charCodeAt(k) | 0;
          me.next();
        }
      }
      function copy(f, t) {
        t.a = f.a;
        t.b = f.b;
        t.c = f.c;
        t.d = f.d;
        return t;
      }
      ;
      function impl(seed, opts) {
        var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
          return (xg.next() >>> 0) / 4294967296;
        };
        prng.double = function() {
          do {
            var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
          } while (result === 0);
          return result;
        };
        prng.int32 = xg.next;
        prng.quick = prng;
        if (state) {
          if (typeof state == "object") copy(state, xg);
          prng.state = function() {
            return copy(xg, {});
          };
        }
        return prng;
      }
      if (module3 && module3.exports) {
        module3.exports = impl;
      } else if (define2 && define2.amd) {
        define2(function() {
          return impl;
        });
      } else {
        this.tychei = impl;
      }
    })(
      exports2,
      typeof module2 == "object" && module2,
      // present in node.js
      typeof define == "function" && define
      // present with an AMD loader
    );
  }
});

// node_modules/seedrandom/seedrandom.js
var require_seedrandom = __commonJS({
  "node_modules/seedrandom/seedrandom.js"(exports2, module2) {
    (function(global, pool, math) {
      var width = 256, chunks = 6, digits = 52, rngname = "random", startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto;
      function seedrandom10(seed, options, callback) {
        var key = [];
        options = options == true ? { entropy: true } : options || {};
        var shortseed = mixkey(flatten(
          options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
          3
        ), key);
        var arc4 = new ARC4(key);
        var prng = function() {
          var n2 = arc4.g(chunks), d = startdenom, x = 0;
          while (n2 < significance) {
            n2 = (n2 + x) * width;
            d *= width;
            x = arc4.g(1);
          }
          while (n2 >= overflow) {
            n2 /= 2;
            d /= 2;
            x >>>= 1;
          }
          return (n2 + x) / d;
        };
        prng.int32 = function() {
          return arc4.g(4) | 0;
        };
        prng.quick = function() {
          return arc4.g(4) / 4294967296;
        };
        prng.double = prng;
        mixkey(tostring(arc4.S), pool);
        return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
          if (state) {
            if (state.S) {
              copy(state, arc4);
            }
            prng2.state = function() {
              return copy(arc4, {});
            };
          }
          if (is_math_call) {
            math[rngname] = prng2;
            return seed2;
          } else return prng2;
        })(
          prng,
          shortseed,
          "global" in options ? options.global : this == math,
          options.state
        );
      }
      function ARC4(key) {
        var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];
        if (!keylen) {
          key = [keylen++];
        }
        while (i < width) {
          s[i] = i++;
        }
        for (i = 0; i < width; i++) {
          s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];
          s[j] = t;
        }
        (me.g = function(count) {
          var t2, r = 0, i2 = me.i, j2 = me.j, s2 = me.S;
          while (count--) {
            t2 = s2[i2 = mask & i2 + 1];
            r = r * width + s2[mask & (s2[i2] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
          }
          me.i = i2;
          me.j = j2;
          return r;
        })(width);
      }
      function copy(f, t) {
        t.i = f.i;
        t.j = f.j;
        t.S = f.S.slice();
        return t;
      }
      ;
      function flatten(obj, depth) {
        var result = [], typ = typeof obj, prop;
        if (depth && typ == "object") {
          for (prop in obj) {
            try {
              result.push(flatten(obj[prop], depth - 1));
            } catch (e) {
            }
          }
        }
        return result.length ? result : typ == "string" ? obj : obj + "\0";
      }
      function mixkey(seed, key) {
        var stringseed = seed + "", smear, j = 0;
        while (j < stringseed.length) {
          key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
        }
        return tostring(key);
      }
      function autoseed() {
        try {
          var out;
          if (nodecrypto && (out = nodecrypto.randomBytes)) {
            out = out(width);
          } else {
            out = new Uint8Array(width);
            (global.crypto || global.msCrypto).getRandomValues(out);
          }
          return tostring(out);
        } catch (e) {
          var browser = global.navigator, plugins = browser && browser.plugins;
          return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
        }
      }
      function tostring(a) {
        return String.fromCharCode.apply(0, a);
      }
      mixkey(math.random(), pool);
      if (typeof module2 == "object" && module2.exports) {
        module2.exports = seedrandom10;
        try {
          nodecrypto = require("crypto");
        } catch (ex) {
        }
      } else if (typeof define == "function" && define.amd) {
        define(function() {
          return seedrandom10;
        });
      } else {
        math["seed" + rngname] = seedrandom10;
      }
    })(
      // global: `self` in browsers (including strict mode and web workers),
      // otherwise `this` in Node and other environments
      typeof self !== "undefined" ? self : exports2,
      [],
      // pool: entropy pool starts empty
      Math
      // math: package containing random, pow, and seedrandom
    );
  }
});

// node_modules/seedrandom/index.js
var require_seedrandom2 = __commonJS({
  "node_modules/seedrandom/index.js"(exports2, module2) {
    var alea = require_alea();
    var xor128 = require_xor128();
    var xorwow = require_xorwow();
    var xorshift7 = require_xorshift7();
    var xor4096 = require_xor4096();
    var tychei = require_tychei();
    var sr = require_seedrandom();
    sr.alea = alea;
    sr.xor128 = xor128;
    sr.xorwow = xorwow;
    sr.xorshift7 = xorshift7;
    sr.xor4096 = xor4096;
    sr.tychei = tychei;
    module2.exports = sr;
  }
});

// better-sqlite3-shim:better-sqlite3
var require_better_sqlite3 = __commonJS({
  "better-sqlite3-shim:better-sqlite3"(exports2, module2) {
    var path = require("path");
    var fs2 = require("fs");
    function getExeDir() {
      if (process.pkg) {
        return path.dirname(process.execPath);
      }
      return process.cwd();
    }
    function findNativeModule() {
      const exeDir = getExeDir();
      const possiblePaths = [
        path.join(exeDir, "better_sqlite3.node"),
        // Development fallback
        path.join(process.cwd(), "node_modules", "better-sqlite3", "build", "Release", "better_sqlite3.node")
      ];
      for (const p of possiblePaths) {
        try {
          if (fs2.existsSync(p)) {
            console.error("[SQLite] Found native module at:", p);
            return p;
          }
        } catch (e) {
        }
      }
      throw new Error("Could not find better_sqlite3.node. Searched in: " + possiblePaths.join(", "));
    }
    var SqliteError = class extends Error {
      constructor(message, code) {
        super(message);
        this.name = "SqliteError";
        this.code = code;
      }
    };
    var nativePath = findNativeModule();
    var addon = require(nativePath);
    if (!addon.isInitialized) {
      addon.setErrorConstructor(SqliteError);
      addon.isInitialized = true;
    }
    function getBooleanOption(options, key) {
      let value = false;
      if (key in options && typeof (value = options[key]) !== "boolean") {
        throw new TypeError('Expected the "' + key + '" option to be a boolean');
      }
      return value;
    }
    var cppdb = Symbol("cppdb");
    function Database2(filenameGiven, options) {
      if (new.target == null) {
        return new Database2(filenameGiven, options);
      }
      let buffer = null;
      if (Buffer.isBuffer(filenameGiven)) {
        buffer = filenameGiven;
        filenameGiven = ":memory:";
      }
      if (filenameGiven == null) filenameGiven = "";
      if (options == null) options = {};
      if (typeof filenameGiven !== "string") {
        throw new TypeError("Expected first argument to be a string");
      }
      if (typeof options !== "object") {
        throw new TypeError("Expected second argument to be an options object");
      }
      const filename = filenameGiven.trim();
      const anonymous = filename === "" || filename === ":memory:";
      const readonly2 = getBooleanOption(options, "readonly");
      const fileMustExist = getBooleanOption(options, "fileMustExist");
      const timeout = "timeout" in options ? options.timeout : 5e3;
      const verbose = "verbose" in options ? options.verbose : null;
      if (readonly2 && anonymous && !buffer) {
        throw new TypeError("In-memory/temporary databases cannot be readonly");
      }
      if (!Number.isInteger(timeout) || timeout < 0) {
        throw new TypeError('Expected the "timeout" option to be a positive integer');
      }
      if (timeout > 2147483647) {
        throw new RangeError('Option "timeout" cannot be greater than 2147483647');
      }
      if (verbose != null && typeof verbose !== "function") {
        throw new TypeError('Expected the "verbose" option to be a function');
      }
      if (!anonymous && !filename.startsWith("file:")) {
        const dir = path.dirname(filename);
        if (dir && dir !== "." && !fs2.existsSync(dir)) {
          throw new TypeError("Cannot open database because the directory does not exist");
        }
      }
      const db = new addon.Database(
        filename,
        // 1: processed filename (trimmed)
        filenameGiven,
        // 2: original filename string
        anonymous,
        // 3: boolean
        readonly2,
        // 4: boolean
        fileMustExist,
        // 5: boolean
        timeout,
        // 6: integer
        verbose || null,
        // 7: function or null
        buffer || null
        // 8: Buffer or null
      );
      Object.defineProperty(this, cppdb, { value: db });
    }
    Database2.prototype.prepare = function(sql) {
      return this[cppdb].prepare(sql, this, false);
    };
    Database2.prototype.exec = function(sql) {
      this[cppdb].exec(sql);
      return this;
    };
    Database2.prototype.pragma = function(source, options) {
      if (options == null) options = {};
      if (typeof source !== "string") throw new TypeError("Expected first argument to be a string");
      if (typeof options !== "object") throw new TypeError("Expected second argument to be an options object");
      const simple = getBooleanOption(options, "simple");
      const stmt = this[cppdb].prepare("PRAGMA " + source, this, true);
      return simple ? stmt.pluck().get() : stmt.all();
    };
    Database2.prototype.close = function() {
      this[cppdb].close();
      return this;
    };
    Database2.prototype.transaction = function(fn) {
      if (typeof fn !== "function") throw new TypeError("Expected first argument to be a function");
      const db = this;
      const begin = db.prepare("BEGIN");
      const commit = db.prepare("COMMIT");
      const rollback = db.prepare("ROLLBACK");
      function transaction(...args) {
        begin.run();
        try {
          const result = fn.apply(this, args);
          commit.run();
          return result;
        } catch (err) {
          rollback.run();
          throw err;
        }
      }
      transaction.deferred = transaction;
      transaction.immediate = function(...args) {
        db.exec("BEGIN IMMEDIATE");
        try {
          const result = fn.apply(this, args);
          commit.run();
          return result;
        } catch (err) {
          rollback.run();
          throw err;
        }
      };
      transaction.exclusive = function(...args) {
        db.exec("BEGIN EXCLUSIVE");
        try {
          const result = fn.apply(this, args);
          commit.run();
          return result;
        } catch (err) {
          rollback.run();
          throw err;
        }
      };
      return transaction;
    };
    Database2.prototype.defaultSafeIntegers = function(toggle) {
      this[cppdb].defaultSafeIntegers(toggle);
      return this;
    };
    Database2.prototype.unsafeMode = function(toggle) {
      this[cppdb].unsafeMode(toggle);
      return this;
    };
    Database2.prototype.loadExtension = function(...args) {
      this[cppdb].loadExtension(...args);
      return this;
    };
    Object.defineProperty(Database2.prototype, "open", {
      get: function() {
        return this[cppdb].open;
      },
      enumerable: true
    });
    Object.defineProperty(Database2.prototype, "inTransaction", {
      get: function() {
        return this[cppdb].inTransaction;
      },
      enumerable: true
    });
    Object.defineProperty(Database2.prototype, "name", {
      get: function() {
        return this[cppdb].name;
      },
      enumerable: true
    });
    Object.defineProperty(Database2.prototype, "memory", {
      get: function() {
        return this[cppdb].memory;
      },
      enumerable: true
    });
    Object.defineProperty(Database2.prototype, "readonly", {
      get: function() {
        return this[cppdb].readonly;
      },
      enumerable: true
    });
    module2.exports = Database2;
    module2.exports.default = Database2;
    module2.exports.Database = Database2;
    module2.exports.SqliteError = SqliteError;
  }
});

// dist/schema/party.js
var PartyStatusSchema, MemberRoleSchema, CharacterTypeSchema, PartySchema, PartyMemberSchema, PartyMemberWithCharacterSchema, PartyWithMembersSchema, PartyContextSchema;
var init_party = __esm({
  "dist/schema/party.js"() {
    "use strict";
    init_zod();
    PartyStatusSchema = external_exports.enum(["active", "dormant", "archived"]);
    MemberRoleSchema = external_exports.enum(["leader", "member", "companion", "hireling", "prisoner", "mount"]);
    CharacterTypeSchema = external_exports.enum(["pc", "npc", "enemy", "neutral"]);
    PartySchema = external_exports.object({
      id: external_exports.string(),
      name: external_exports.string().min(1),
      description: external_exports.string().optional(),
      worldId: external_exports.string().optional(),
      status: PartyStatusSchema.default("active"),
      currentLocation: external_exports.string().optional(),
      currentQuestId: external_exports.string().optional(),
      formation: external_exports.string().default("standard"),
      // NEW: Position fields for world map location tracking
      positionX: external_exports.number().int().nonnegative().optional(),
      positionY: external_exports.number().int().nonnegative().optional(),
      currentPOI: external_exports.string().optional(),
      // Structure ID if at a POI
      createdAt: external_exports.string().datetime(),
      updatedAt: external_exports.string().datetime(),
      lastPlayedAt: external_exports.string().datetime().optional()
    });
    PartyMemberSchema = external_exports.object({
      id: external_exports.string(),
      partyId: external_exports.string(),
      characterId: external_exports.string(),
      role: MemberRoleSchema.default("member"),
      isActive: external_exports.boolean().default(false),
      position: external_exports.number().int().optional(),
      sharePercentage: external_exports.number().int().min(0).max(100).default(100),
      joinedAt: external_exports.string().datetime(),
      notes: external_exports.string().optional()
    });
    PartyMemberWithCharacterSchema = PartyMemberSchema.extend({
      character: external_exports.object({
        id: external_exports.string(),
        name: external_exports.string(),
        hp: external_exports.number(),
        maxHp: external_exports.number(),
        ac: external_exports.number(),
        level: external_exports.number(),
        stats: external_exports.object({
          str: external_exports.number(),
          dex: external_exports.number(),
          con: external_exports.number(),
          int: external_exports.number(),
          wis: external_exports.number(),
          cha: external_exports.number()
        }),
        behavior: external_exports.string().optional(),
        characterType: CharacterTypeSchema.optional()
      })
    });
    PartyWithMembersSchema = PartySchema.extend({
      members: external_exports.array(PartyMemberWithCharacterSchema),
      leader: PartyMemberWithCharacterSchema.optional(),
      activeCharacter: PartyMemberWithCharacterSchema.optional(),
      memberCount: external_exports.number().int()
    });
    PartyContextSchema = external_exports.object({
      party: external_exports.object({
        id: external_exports.string(),
        name: external_exports.string(),
        status: PartyStatusSchema,
        location: external_exports.string().optional(),
        formation: external_exports.string()
      }),
      leader: external_exports.object({
        id: external_exports.string(),
        name: external_exports.string(),
        hp: external_exports.number(),
        maxHp: external_exports.number(),
        level: external_exports.number()
      }).optional(),
      activeCharacter: external_exports.object({
        id: external_exports.string(),
        name: external_exports.string(),
        hp: external_exports.number(),
        maxHp: external_exports.number(),
        level: external_exports.number(),
        conditions: external_exports.array(external_exports.string()).optional()
      }).optional(),
      members: external_exports.array(external_exports.object({
        name: external_exports.string(),
        role: MemberRoleSchema,
        hp: external_exports.string(),
        // "85/85" format for compactness
        status: external_exports.string().optional()
      })),
      activeQuest: external_exports.object({
        name: external_exports.string(),
        currentObjective: external_exports.string().optional(),
        progress: external_exports.string().optional()
      }).optional(),
      recentEvents: external_exports.array(external_exports.string()).optional()
    });
  }
});

// dist/schema/spell.js
var SpellSchoolSchema, CastingTimeSchema, SpellRangeSchema, DamageTypeSchema, SaveTypeSchema, SpellComponentsSchema, SpellTargetTypeSchema, AreaShapeSchema, SpellEffectSchema, SpellcastingClassSchema, SpellSchema, SpellSlotSchema, SpellSlotsSchema, PactMagicSlotsSchema, SpellcastingAbilitySchema, CharacterClassSchema, SubclassSchema, CastSpellRequestSchema, SpellCastResultSchema;
var init_spell = __esm({
  "dist/schema/spell.js"() {
    "use strict";
    init_zod();
    SpellSchoolSchema = external_exports.enum([
      "abjuration",
      "conjuration",
      "divination",
      "enchantment",
      "evocation",
      "illusion",
      "necromancy",
      "transmutation"
    ]);
    CastingTimeSchema = external_exports.enum([
      "action",
      "bonus_action",
      "reaction",
      "minute",
      "10_minutes",
      "hour",
      "8_hours",
      "12_hours",
      "24_hours"
    ]);
    SpellRangeSchema = external_exports.union([
      external_exports.literal("self"),
      external_exports.literal("touch"),
      external_exports.number().int().min(0)
      // Distance in feet
    ]);
    DamageTypeSchema = external_exports.enum([
      "acid",
      "bludgeoning",
      "cold",
      "fire",
      "force",
      "lightning",
      "necrotic",
      "piercing",
      "poison",
      "psychic",
      "radiant",
      "slashing",
      "thunder"
    ]);
    SaveTypeSchema = external_exports.enum([
      "strength",
      "dexterity",
      "constitution",
      "intelligence",
      "wisdom",
      "charisma",
      "none"
    ]);
    SpellComponentsSchema = external_exports.object({
      verbal: external_exports.boolean(),
      somatic: external_exports.boolean(),
      material: external_exports.boolean(),
      materialDescription: external_exports.string().optional()
    });
    SpellTargetTypeSchema = external_exports.enum([
      "self",
      "creature",
      "creatures",
      "point",
      "area",
      "object"
    ]);
    AreaShapeSchema = external_exports.enum([
      "cone",
      "cube",
      "cylinder",
      "line",
      "sphere"
    ]);
    SpellEffectSchema = external_exports.object({
      type: external_exports.enum(["damage", "healing", "buff", "debuff", "utility", "summon"]),
      dice: external_exports.string().optional(),
      // e.g., "8d6", "1d8+4"
      damageType: DamageTypeSchema.optional(),
      saveType: SaveTypeSchema.optional(),
      saveEffect: external_exports.enum(["half", "none", "special"]).optional(),
      // What happens on successful save
      upcastBonus: external_exports.object({
        dice: external_exports.string(),
        // Additional dice per level, e.g., "1d6"
        perLevel: external_exports.number().int().default(1)
        // How many levels for the bonus
      }).optional(),
      conditions: external_exports.array(external_exports.string()).optional()
      // Conditions applied
    });
    SpellcastingClassSchema = external_exports.enum([
      "bard",
      "cleric",
      "druid",
      "paladin",
      "ranger",
      "sorcerer",
      "warlock",
      "wizard",
      "artificer"
    ]);
    SpellSchema = external_exports.object({
      id: external_exports.string(),
      name: external_exports.string(),
      level: external_exports.number().int().min(0).max(9),
      // 0 = cantrip
      school: SpellSchoolSchema,
      castingTime: CastingTimeSchema,
      range: SpellRangeSchema,
      components: SpellComponentsSchema,
      duration: external_exports.string(),
      // e.g., "Instantaneous", "1 minute", "Concentration, up to 1 hour"
      concentration: external_exports.boolean(),
      ritual: external_exports.boolean().optional().default(false),
      description: external_exports.string(),
      higherLevels: external_exports.string().optional(),
      // Description for upcasting
      classes: external_exports.array(SpellcastingClassSchema),
      targetType: SpellTargetTypeSchema,
      areaOfEffect: external_exports.object({
        shape: AreaShapeSchema,
        size: external_exports.number().int()
        // Size in feet
      }).optional(),
      effects: external_exports.array(SpellEffectSchema),
      autoHit: external_exports.boolean().default(false)
      // e.g., Magic Missile
    });
    SpellSlotSchema = external_exports.object({
      current: external_exports.number().int().min(0),
      max: external_exports.number().int().min(0)
    });
    SpellSlotsSchema = external_exports.object({
      level1: SpellSlotSchema.default({ current: 0, max: 0 }),
      level2: SpellSlotSchema.default({ current: 0, max: 0 }),
      level3: SpellSlotSchema.default({ current: 0, max: 0 }),
      level4: SpellSlotSchema.default({ current: 0, max: 0 }),
      level5: SpellSlotSchema.default({ current: 0, max: 0 }),
      level6: SpellSlotSchema.default({ current: 0, max: 0 }),
      level7: SpellSlotSchema.default({ current: 0, max: 0 }),
      level8: SpellSlotSchema.default({ current: 0, max: 0 }),
      level9: SpellSlotSchema.default({ current: 0, max: 0 })
    });
    PactMagicSlotsSchema = external_exports.object({
      current: external_exports.number().int().min(0),
      max: external_exports.number().int().min(0),
      slotLevel: external_exports.number().int().min(1).max(5)
      // Warlock slots max at 5th level
    });
    SpellcastingAbilitySchema = external_exports.enum([
      "intelligence",
      "wisdom",
      "charisma"
    ]);
    CharacterClassSchema = external_exports.enum([
      "barbarian",
      "bard",
      "cleric",
      "druid",
      "fighter",
      "monk",
      "paladin",
      "ranger",
      "rogue",
      "sorcerer",
      "warlock",
      "wizard",
      "artificer"
    ]);
    SubclassSchema = external_exports.enum([
      "eldritch_knight",
      // Fighter
      "arcane_trickster",
      // Rogue
      "champion",
      // Fighter (non-caster)
      "assassin",
      // Rogue (non-caster)
      "none"
    ]).default("none");
    CastSpellRequestSchema = external_exports.object({
      characterId: external_exports.string(),
      spellName: external_exports.string().min(1, "Spell name is required"),
      slotLevel: external_exports.number().int().min(1).max(9).optional(),
      targetId: external_exports.string().optional(),
      targetPoint: external_exports.object({
        x: external_exports.number(),
        y: external_exports.number()
      }).optional(),
      asReaction: external_exports.boolean().optional(),
      metamagic: external_exports.array(external_exports.string()).optional()
    });
    SpellCastResultSchema = external_exports.object({
      success: external_exports.boolean(),
      spellName: external_exports.string(),
      slotUsed: external_exports.number().int().optional(),
      // undefined for cantrips
      damage: external_exports.number().int().optional(),
      damageType: DamageTypeSchema.optional(),
      healing: external_exports.number().int().optional(),
      diceRolled: external_exports.string().optional(),
      saveResult: external_exports.enum(["passed", "failed", "none"]).optional(),
      damageRolled: external_exports.number().int().optional(),
      damageApplied: external_exports.number().int().optional(),
      autoHit: external_exports.boolean().optional(),
      attackRoll: external_exports.number().int().optional(),
      acBonus: external_exports.number().int().optional(),
      // For Shield
      dartCount: external_exports.number().int().optional(),
      // For Magic Missile
      concentration: external_exports.boolean().optional(),
      error: external_exports.string().optional()
    });
  }
});

// dist/schema/character.js
var CharacterSchema, NPCSchema;
var init_character = __esm({
  "dist/schema/character.js"() {
    "use strict";
    init_zod();
    init_party();
    init_spell();
    CharacterSchema = external_exports.object({
      id: external_exports.string(),
      name: external_exports.string().min(1, "Character name cannot be empty").max(100, "Character name cannot exceed 100 characters"),
      stats: external_exports.object({
        str: external_exports.number().int().min(0),
        dex: external_exports.number().int().min(0),
        con: external_exports.number().int().min(0),
        int: external_exports.number().int().min(0),
        wis: external_exports.number().int().min(0),
        cha: external_exports.number().int().min(0)
      }),
      hp: external_exports.number().int().min(0),
      maxHp: external_exports.number().int().min(0),
      ac: external_exports.number().int().min(0),
      level: external_exports.number().int().min(1),
      xp: external_exports.number().int().min(0).default(0).describe("Current experience points"),
      characterType: CharacterTypeSchema.optional().default("pc"),
      // PHASE-2: Social Hearing Mechanics - skill bonuses for opposed rolls
      perceptionBonus: external_exports.number().int().optional().default(0).describe("Proficiency bonus for Perception checks (WIS-based)"),
      stealthBonus: external_exports.number().int().optional().default(0).describe("Proficiency bonus for Stealth checks (DEX-based)"),
      // Spellcasting fields (CRIT-002/006)
      // Flexible character class - allows any string (standard D&D classes or custom like "Chronomancer")
      characterClass: external_exports.string().optional().default("fighter"),
      race: external_exports.string().optional().default("Human").describe("Character race - any string allowed (Human, Elf, Dragonborn, Mousefolk...)"),
      subclass: SubclassSchema.optional(),
      spellSlots: SpellSlotsSchema.optional(),
      pactMagicSlots: PactMagicSlotsSchema.optional(),
      // Warlock only
      knownSpells: external_exports.array(external_exports.string()).optional().default([]),
      preparedSpells: external_exports.array(external_exports.string()).optional().default([]),
      cantripsKnown: external_exports.array(external_exports.string()).optional().default([]),
      maxSpellLevel: external_exports.number().int().min(0).max(9).optional().default(0),
      spellcastingAbility: SpellcastingAbilitySchema.optional(),
      spellSaveDC: external_exports.number().int().optional(),
      spellAttackBonus: external_exports.number().int().optional(),
      concentratingOn: external_exports.string().nullable().optional().default(null),
      activeSpells: external_exports.array(external_exports.string()).optional().default([]),
      conditions: external_exports.array(external_exports.object({
        name: external_exports.string().describe("Condition name (e.g., Poisoned, Frightened)"),
        duration: external_exports.number().int().optional().describe("Duration in rounds"),
        source: external_exports.string().optional().describe("Source of the condition")
      })).optional().default([]),
      position: external_exports.object({
        x: external_exports.number(),
        y: external_exports.number()
      }).optional(),
      // PHASE-1: Spatial Graph System - current room for spatial awareness
      currentRoomId: external_exports.string().uuid().optional().describe("ID of the room the character is currently in"),
      // HIGH-007: Legendary creature fields
      legendaryActions: external_exports.number().int().min(0).optional().describe("Total legendary actions per round (usually 3)"),
      legendaryActionsRemaining: external_exports.number().int().min(0).optional().describe("Remaining legendary actions this round"),
      legendaryResistances: external_exports.number().int().min(0).optional().describe("Total legendary resistances per day (usually 3)"),
      legendaryResistancesRemaining: external_exports.number().int().min(0).optional().describe("Remaining legendary resistances"),
      hasLairActions: external_exports.boolean().optional().default(false).describe("Whether this creature can use lair actions on initiative 20"),
      // HIGH-002: Damage modifiers
      resistances: external_exports.array(external_exports.string()).optional().default([]).describe('Damage types that deal half damage (e.g., ["fire", "cold"])'),
      vulnerabilities: external_exports.array(external_exports.string()).optional().default([]).describe("Damage types that deal double damage"),
      immunities: external_exports.array(external_exports.string()).optional().default([]).describe("Damage types that deal no damage"),
      // Skill and Save Proficiencies
      skillProficiencies: external_exports.array(external_exports.enum([
        "acrobatics",
        "animal_handling",
        "arcana",
        "athletics",
        "deception",
        "history",
        "insight",
        "intimidation",
        "investigation",
        "medicine",
        "nature",
        "perception",
        "performance",
        "persuasion",
        "religion",
        "sleight_of_hand",
        "stealth",
        "survival"
      ])).optional().default([]).describe("Skills the character is proficient in"),
      saveProficiencies: external_exports.array(external_exports.enum(["str", "dex", "con", "int", "wis", "cha"])).optional().default([]).describe("Saving throws the character is proficient in"),
      expertise: external_exports.array(external_exports.string()).optional().default([]).describe("Skills with double proficiency bonus (rogues, bards)"),
      createdAt: external_exports.string().datetime(),
      updatedAt: external_exports.string().datetime()
    });
    NPCSchema = CharacterSchema.extend({
      factionId: external_exports.string().optional(),
      behavior: external_exports.string().optional()
    });
  }
});

// dist/storage/repos/character.repo.js
var character_repo_exports = {};
__export(character_repo_exports, {
  CharacterRepository: () => CharacterRepository
});
var CharacterRepository;
var init_character_repo = __esm({
  "dist/storage/repos/character.repo.js"() {
    "use strict";
    init_character();
    CharacterRepository = class {
      db;
      constructor(db) {
        this.db = db;
      }
      create(character) {
        const isNPC = "factionId" in character || "behavior" in character;
        const validChar = isNPC ? NPCSchema.parse(character) : CharacterSchema.parse(character);
        const stmt = this.db.prepare(`
      INSERT INTO characters (id, name, stats, hp, max_hp, ac, level, faction_id, behavior, character_type,
                              character_class, race, spell_slots, pact_magic_slots, known_spells, prepared_spells,
                              cantrips_known, max_spell_level, concentrating_on, conditions,
                              legendary_actions, legendary_actions_remaining, legendary_resistances,
                              legendary_resistances_remaining, has_lair_actions, resistances, vulnerabilities, immunities,
                              current_room_id, perception_bonus, stealth_bonus, created_at, updated_at)
      VALUES (@id, @name, @stats, @hp, @maxHp, @ac, @level, @factionId, @behavior, @characterType,
              @characterClass, @race, @spellSlots, @pactMagicSlots, @knownSpells, @preparedSpells,
              @cantripsKnown, @maxSpellLevel, @concentratingOn, @conditions,
              @legendaryActions, @legendaryActionsRemaining, @legendaryResistances,
              @legendaryResistancesRemaining, @hasLairActions, @resistances, @vulnerabilities, @immunities,
              @currentRoomId, @perceptionBonus, @stealthBonus, @createdAt, @updatedAt)
    `);
        stmt.run({
          id: validChar.id,
          name: validChar.name,
          stats: JSON.stringify(validChar.stats),
          hp: validChar.hp,
          maxHp: validChar.maxHp,
          ac: validChar.ac,
          level: validChar.level,
          factionId: validChar.factionId || null,
          behavior: validChar.behavior || null,
          characterType: validChar.characterType || "pc",
          // CRIT-002/006: Spellcasting fields
          characterClass: validChar.characterClass || "fighter",
          race: validChar.race || "Human",
          spellSlots: validChar.spellSlots ? JSON.stringify(validChar.spellSlots) : null,
          pactMagicSlots: validChar.pactMagicSlots ? JSON.stringify(validChar.pactMagicSlots) : null,
          knownSpells: JSON.stringify(validChar.knownSpells || []),
          preparedSpells: JSON.stringify(validChar.preparedSpells || []),
          cantripsKnown: JSON.stringify(validChar.cantripsKnown || []),
          maxSpellLevel: validChar.maxSpellLevel || 0,
          concentratingOn: validChar.concentratingOn || null,
          conditions: JSON.stringify(validChar.conditions || []),
          // HIGH-007: Legendary creature fields
          legendaryActions: validChar.legendaryActions ?? null,
          legendaryActionsRemaining: validChar.legendaryActionsRemaining ?? null,
          legendaryResistances: validChar.legendaryResistances ?? null,
          legendaryResistancesRemaining: validChar.legendaryResistancesRemaining ?? null,
          hasLairActions: validChar.hasLairActions ? 1 : 0,
          resistances: JSON.stringify(validChar.resistances || []),
          vulnerabilities: JSON.stringify(validChar.vulnerabilities || []),
          immunities: JSON.stringify(validChar.immunities || []),
          // PHASE-1: Spatial awareness
          currentRoomId: validChar.currentRoomId || null,
          // PHASE-2: Social hearing mechanics skill bonuses
          perceptionBonus: validChar.perceptionBonus || 0,
          stealthBonus: validChar.stealthBonus || 0,
          createdAt: validChar.createdAt,
          updatedAt: validChar.updatedAt
        });
      }
      findById(id) {
        const stmt = this.db.prepare("SELECT * FROM characters WHERE id = ?");
        const row = stmt.get(id);
        if (!row)
          return null;
        return this.rowToCharacter(row);
      }
      findAll(filters) {
        let query = "SELECT * FROM characters";
        const params = [];
        if (filters?.characterType) {
          query += " WHERE character_type = ?";
          params.push(filters.characterType);
        }
        const stmt = this.db.prepare(query);
        const rows = stmt.all(...params);
        return rows.map((row) => this.rowToCharacter(row));
      }
      findByType(characterType) {
        const stmt = this.db.prepare("SELECT * FROM characters WHERE character_type = ?");
        const rows = stmt.all(characterType);
        return rows.map((row) => this.rowToCharacter(row));
      }
      update(id, updates) {
        const existing = this.findById(id);
        if (!existing)
          return null;
        const updated = {
          ...existing,
          ...updates,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        };
        const isNPC = "factionId" in updated || "behavior" in updated;
        const validChar = isNPC ? NPCSchema.parse(updated) : CharacterSchema.parse(updated);
        const stmt = this.db.prepare(`
            UPDATE characters
            SET name = ?, stats = ?, hp = ?, max_hp = ?, ac = ?, level = ?,
                faction_id = ?, behavior = ?, character_type = ?,
                character_class = ?, race = ?, spell_slots = ?, pact_magic_slots = ?,
                known_spells = ?, prepared_spells = ?, cantrips_known = ?,
                max_spell_level = ?, concentrating_on = ?, conditions = ?,
                legendary_actions = ?, legendary_actions_remaining = ?,
                legendary_resistances = ?, legendary_resistances_remaining = ?,
                has_lair_actions = ?, resistances = ?, vulnerabilities = ?, immunities = ?,
                current_room_id = ?, perception_bonus = ?, stealth_bonus = ?, updated_at = ?
            WHERE id = ?
        `);
        stmt.run(
          validChar.name,
          JSON.stringify(validChar.stats),
          validChar.hp,
          validChar.maxHp,
          validChar.ac,
          validChar.level,
          validChar.factionId || null,
          validChar.behavior || null,
          validChar.characterType || "pc",
          // CRIT-002/006: Spellcasting fields
          validChar.characterClass || "fighter",
          validChar.race || "Human",
          validChar.spellSlots ? JSON.stringify(validChar.spellSlots) : null,
          validChar.pactMagicSlots ? JSON.stringify(validChar.pactMagicSlots) : null,
          JSON.stringify(validChar.knownSpells || []),
          JSON.stringify(validChar.preparedSpells || []),
          JSON.stringify(validChar.cantripsKnown || []),
          validChar.maxSpellLevel || 0,
          validChar.concentratingOn || null,
          JSON.stringify(validChar.conditions || []),
          // HIGH-007: Legendary creature fields
          validChar.legendaryActions ?? null,
          validChar.legendaryActionsRemaining ?? null,
          validChar.legendaryResistances ?? null,
          validChar.legendaryResistancesRemaining ?? null,
          validChar.hasLairActions ? 1 : 0,
          JSON.stringify(validChar.resistances || []),
          JSON.stringify(validChar.vulnerabilities || []),
          JSON.stringify(validChar.immunities || []),
          // PHASE-1: Spatial awareness
          validChar.currentRoomId || null,
          // PHASE-2: Social hearing mechanics skill bonuses
          validChar.perceptionBonus || 0,
          validChar.stealthBonus || 0,
          validChar.updatedAt,
          id
        );
        return validChar;
      }
      delete(id) {
        const stmt = this.db.prepare("DELETE FROM characters WHERE id = ?");
        const result = stmt.run(id);
        return result.changes > 0;
      }
      rowToCharacter(row) {
        const base = {
          id: row.id,
          name: row.name,
          stats: JSON.parse(row.stats),
          hp: row.hp,
          maxHp: row.max_hp,
          ac: row.ac,
          level: row.level,
          characterType: row.character_type || "pc",
          // CRIT-002/006: Spellcasting fields
          characterClass: row.character_class || "fighter",
          race: row.race || "Human",
          spellSlots: row.spell_slots ? JSON.parse(row.spell_slots) : void 0,
          pactMagicSlots: row.pact_magic_slots ? JSON.parse(row.pact_magic_slots) : void 0,
          knownSpells: row.known_spells ? JSON.parse(row.known_spells) : [],
          preparedSpells: row.prepared_spells ? JSON.parse(row.prepared_spells) : [],
          cantripsKnown: row.cantrips_known ? JSON.parse(row.cantrips_known) : [],
          maxSpellLevel: row.max_spell_level || 0,
          concentratingOn: row.concentrating_on || null,
          conditions: row.conditions ? JSON.parse(row.conditions) : [],
          // HIGH-007: Legendary creature fields
          legendaryActions: row.legendary_actions ?? void 0,
          legendaryActionsRemaining: row.legendary_actions_remaining ?? void 0,
          legendaryResistances: row.legendary_resistances ?? void 0,
          legendaryResistancesRemaining: row.legendary_resistances_remaining ?? void 0,
          hasLairActions: row.has_lair_actions === 1,
          resistances: row.resistances ? JSON.parse(row.resistances) : [],
          vulnerabilities: row.vulnerabilities ? JSON.parse(row.vulnerabilities) : [],
          immunities: row.immunities ? JSON.parse(row.immunities) : [],
          // PHASE-1: Spatial awareness
          currentRoomId: row.current_room_id || void 0,
          // PHASE-2: Social hearing mechanics skill bonuses
          perceptionBonus: row.perception_bonus ?? 0,
          stealthBonus: row.stealth_bonus ?? 0,
          createdAt: row.created_at,
          updatedAt: row.updated_at
        };
        if (row.faction_id || row.behavior) {
          return NPCSchema.parse({
            ...base,
            factionId: row.faction_id || void 0,
            behavior: row.behavior || void 0
          });
        }
        return CharacterSchema.parse(base);
      }
    };
  }
});

// node_modules/nerdamer/nerdamer.core.js
var require_nerdamer_core = __commonJS({
  "node_modules/nerdamer/nerdamer.core.js"(exports2, module2) {
    var nerdamer3 = (function(imports) {
      "use strict";
      var version2 = "1.1.13";
      var _ = new Parser();
      var bigInt = imports.bigInt;
      var bigDec = imports.bigDec;
      bigDec.set({
        precision: 250
      });
      var Groups = {};
      var PRIMES = [
        2,
        3,
        5,
        7,
        11,
        13,
        17,
        19,
        23,
        29,
        31,
        37,
        41,
        43,
        47,
        53,
        59,
        61,
        67,
        71,
        73,
        79,
        83,
        89,
        97,
        101,
        103,
        107,
        109,
        113,
        127,
        131,
        137,
        139,
        149,
        151,
        157,
        163,
        167,
        173,
        179,
        181,
        191,
        193,
        197,
        199,
        211,
        223,
        227,
        229,
        233,
        239,
        241,
        251,
        257,
        263,
        269,
        271,
        277,
        281,
        283,
        293,
        307,
        311,
        313,
        317,
        331,
        337,
        347,
        349,
        353,
        359,
        367,
        373,
        379,
        383,
        389,
        397,
        401,
        409,
        419,
        421,
        431,
        433,
        439,
        443,
        449,
        457,
        461,
        463,
        467,
        479,
        487,
        491,
        499,
        503,
        509,
        521,
        523,
        541,
        547,
        557,
        563,
        569,
        571,
        577,
        587,
        593,
        599,
        601,
        607,
        613,
        617,
        619,
        631,
        641,
        643,
        647,
        653,
        659,
        661,
        673,
        677,
        683,
        691,
        701,
        709,
        719,
        727,
        733,
        739,
        743,
        751,
        757,
        761,
        769,
        773,
        787,
        797,
        809,
        811,
        821,
        823,
        827,
        829,
        839,
        853,
        857,
        859,
        863,
        877,
        881,
        883,
        887,
        907,
        911,
        919,
        929,
        937,
        941,
        947,
        953,
        967,
        971,
        977,
        983,
        991,
        997,
        1009,
        1013,
        1019,
        1021,
        1031,
        1033,
        1039,
        1049,
        1051,
        1061,
        1063,
        1069,
        1087,
        1091,
        1093,
        1097,
        1103,
        1109,
        1117,
        1123,
        1129,
        1151,
        1153,
        1163,
        1171,
        1181,
        1187,
        1193,
        1201,
        1213,
        1217,
        1223,
        1229,
        1231,
        1237,
        1249,
        1259,
        1277,
        1279,
        1283,
        1289,
        1291,
        1297,
        1301,
        1303,
        1307,
        1319,
        1321,
        1327,
        1361,
        1367,
        1373,
        1381,
        1399,
        1409,
        1423,
        1427,
        1429,
        1433,
        1439,
        1447,
        1451,
        1453,
        1459,
        1471,
        1481,
        1483,
        1487,
        1489,
        1493,
        1499,
        1511,
        1523,
        1531,
        1543,
        1549,
        1553,
        1559,
        1567,
        1571,
        1579,
        1583,
        1597,
        1601,
        1607,
        1609,
        1613,
        1619,
        1621,
        1627,
        1637,
        1657,
        1663,
        1667,
        1669,
        1693,
        1697,
        1699,
        1709,
        1721,
        1723,
        1733,
        1741,
        1747,
        1753,
        1759,
        1777,
        1783,
        1787,
        1789,
        1801,
        1811,
        1823,
        1831,
        1847,
        1861,
        1867,
        1871,
        1873,
        1877,
        1879,
        1889,
        1901,
        1907,
        1913,
        1931,
        1933,
        1949,
        1951,
        1973,
        1979,
        1987,
        1993,
        1997,
        1999,
        2003,
        2011,
        2017,
        2027,
        2029,
        2039,
        2053,
        2063,
        2069,
        2081,
        2083
      ];
      var CUSTOM_OPERATORS = {};
      var Settings = {
        //Enables/Disables call peekers. False means callPeekers are disabled and true means callPeekers are enabled.
        callPeekers: false,
        //the max number up to which to cache primes. Making this too high causes performance issues
        init_primes: 1e3,
        exclude: [],
        //If you don't care about division by zero for example then this can be set to true.
        //Has some nasty side effects so choose carefully.
        suppress_errors: false,
        //the global used to invoke the libary to parse to a number. Normally cos(9) for example returns
        //cos(9) for convenience but parse to number will always try to return a number if set to true.
        PARSE2NUMBER: false,
        //this flag forces the a clone to be returned when add, subtract, etc... is called
        SAFE: false,
        //the symbol to use for imaginary symbols
        IMAGINARY: "i",
        //the modules used to link numeric function holders
        FUNCTION_MODULES: [Math],
        //Allow certain characters
        ALLOW_CHARS: ["\u03C0"],
        //Allow nerdamer to convert multi-character variables
        USE_MULTICHARACTER_VARS: true,
        //Allow changing of power operator
        POWER_OPERATOR: "^",
        //The variable validation regex
        //VALIDATION_REGEX: /^[a-z_][a-z\d\_]*$/i
        VALIDATION_REGEX: /^[a-z_ABEZHIKMNoOPTX][0-9a-z_ABEZHIKMNoOPTX]*$/i,
        // The regex used to determine which characters should be included in implied multiplication
        IMPLIED_MULTIPLICATION_REGEX: /([\+\-\/\*]*[0-9]+)([a-z_ABEZHIKMNoOPTX]+[\+\-\/\*]*)/gi,
        //Aliases
        ALIASES: {
          "\u03C0": "pi",
          "\u221E": "Infinity"
        },
        POSITIVE_MULTIPLIERS: false,
        //Cached items
        CACHE: {},
        //Print out warnings or not
        SILENCE_WARNINGS: false,
        // Precision
        PRECISION: 21,
        // The Expression defaults to this value for decimal places
        EXPRESSION_DECP: 19,
        // The text function defaults to this value for decimal places
        DEFAULT_DECP: 16,
        //function mappings
        VECTOR: "vector",
        PARENTHESIS: "parens",
        SQRT: "sqrt",
        ABS: "abs",
        FACTORIAL: "factorial",
        DOUBLEFACTORIAL: "dfactorial",
        //reference pi and e
        LONG_PI: "3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196",
        LONG_E: "2.71828182845904523536028747135266249775724709369995957496696762772407663035354759457138217852516642742746639193200305992181741359662904357290033429526059563073813232862794349076323382988075319525101901",
        PI: Math.PI,
        E: Math.E,
        LOG: "log",
        LOG10: "log10",
        LOG10_LATEX: "log_{10}",
        MAX_EXP: 2e5,
        //The number of scientific place to round to
        SCIENTIFIC_MAX_DECIMAL_PLACES: 14,
        //True if ints should not be converted to
        SCIENTIFIC_IGNORE_ZERO_EXPONENTS: true
      };
      (function() {
        Settings.CACHE.roots = {};
        var x = 40, y = 40;
        for (var i = 2; i <= x; i++) {
          for (var j = 2; j <= y; j++) {
            var nthpow = bigInt(i).pow(j);
            Settings.CACHE.roots[nthpow + "-" + j] = i;
          }
        }
      })();
      var N = Groups.N = 1, P = Groups.P = 2, S = Groups.S = 3, EX = Groups.EX = 4, FN = Groups.FN = 5, PL = Groups.PL = 6, CB = Groups.CB = 7, CP = Groups.CP = 8;
      var CONST_HASH = Settings.CONST_HASH = "#";
      var PARENTHESIS = Settings.PARENTHESIS;
      var SQRT = Settings.SQRT;
      var ABS = Settings.ABS;
      var FACTORIAL = Settings.FACTORIAL;
      var DOUBLEFACTORIAL = Settings.DOUBLEFACTORIAL;
      var EXPRESSIONS = [];
      var VARS = {};
      var RESERVED = [];
      var WARNINGS = [];
      var err = function(msg, ErrorObj) {
        if (!Settings.suppress_errors) {
          if (ErrorObj)
            throw new ErrorObj(msg);
          else
            throw new Error(msg);
        }
      };
      var customError = function(name) {
        var E = function(message) {
          this.name = name;
          this.message = message !== void 0 ? message : "";
          var error = new Error(this.message);
          error.name = this.name;
          this.stack = error.stack;
        };
        E.prototype = Object.create(Error.prototype);
        return E;
      };
      var isReserved = function(value) {
        return RESERVED.indexOf(value) !== -1;
      };
      var allSame = function(arr) {
        var last = arr[0];
        for (var i = 1, l = arr.length; i < l; i++)
          if (!arr[i].equals(last))
            return false;
        return true;
      };
      var warn = function(msg) {
        WARNINGS.push(msg);
        if (Settings.SHOW_WARNINGS && console && console.warn) {
          console.warn(msg);
        }
      };
      var validateName = function(name, typ) {
        typ = typ || "variable";
        if (Settings.ALLOW_CHARS.indexOf(name) !== -1)
          return;
        var regex = Settings.VALIDATION_REGEX;
        if (!regex.test(name)) {
          throw new InvalidVariableNameError(name + " is not a valid " + typ + " name");
        }
      };
      var scientificToDecimal = function(num) {
        var nsign = Math.sign(num);
        num = Math.abs(num);
        if (/\d+\.?\d*e[\+\-]*\d+/i.test(num)) {
          var zero = "0", parts = String(num).toLowerCase().split("e"), e = parts.pop(), l = Math.abs(e), sign = e / l, coeff_array = parts[0].split(".");
          if (sign === -1) {
            l = l - coeff_array[0].length;
            if (l < 0) {
              num = coeff_array[0].slice(0, l) + "." + coeff_array[0].slice(l) + (coeff_array.length === 2 ? coeff_array[1] : "");
            } else {
              num = zero + "." + new Array(l + 1).join(zero) + coeff_array.join("");
            }
          } else {
            var dec = coeff_array[1];
            if (dec)
              l = l - dec.length;
            if (l < 0) {
              num = coeff_array[0] + dec.slice(0, l) + "." + dec.slice(l);
            } else {
              num = coeff_array.join("") + new Array(l + 1).join(zero);
            }
          }
        }
        return nsign < 0 ? "-" + num : num;
      };
      var isPrime = function(n2) {
        var q = Math.floor(Math.sqrt(n2));
        for (var i = 2; i <= q; i++) {
          if (n2 % i === 0)
            return false;
        }
        return true;
      };
      var knownVariable = function(variable, value) {
        var o = {};
        o[variable] = value;
        return o;
      };
      var isNumber = function(n2) {
        return /^\d+\.?\d*$/.test(n2);
      };
      var allNumeric = function(arr) {
        for (var i = 0; i < arr.length; i++)
          if (!isNumber(arr[i]))
            return false;
        return true;
      };
      var isFraction = function(num) {
        if (isSymbol(num))
          return isFraction(num.multiplier.toDecimal());
        return num % 1 !== 0;
      };
      var isSymbol = function(obj) {
        return obj instanceof Symbol2;
      };
      var isExpression = function(obj) {
        return obj instanceof Expression;
      };
      var variables = function(obj, poly, vars) {
        vars = vars || {
          c: [],
          add: function(value) {
            if (this.c.indexOf(value) === -1 && isNaN(value))
              this.c.push(value);
          }
        };
        if (isSymbol(obj)) {
          var group = obj.group, prevgroup = obj.previousGroup;
          if (group === EX)
            variables(obj.power, poly, vars);
          if (group === CP || group === CB || prevgroup === CP || prevgroup === CB) {
            for (var x in obj.symbols) {
              variables(obj.symbols[x], poly, vars);
            }
          } else if (group === S || prevgroup === S) {
            if (!(obj.value === "e" || obj.value === "pi" || obj.value === Settings.IMAGINARY))
              vars.add(obj.value);
          } else if (group === PL || prevgroup === PL) {
            variables(firstObject(obj.symbols), poly, vars);
          } else if (group === EX) {
            if (!isNaN(obj.value))
              vars.add(obj.value);
            variables(obj.power, poly, vars);
          } else if (group === FN && !poly) {
            for (var i = 0; i < obj.args.length; i++) {
              variables(obj.args[i], poly, vars);
            }
          }
        }
        return vars.c.sort();
      };
      var arraySum = function(arr, toNumber) {
        var sum = new Symbol2(0);
        for (var i = 0; i < arr.length; i++) {
          var x = arr[i];
          sum = _.add(sum, !isSymbol(x) ? _.parse(x) : x);
        }
        return toNumber ? Number(sum) : sum;
      };
      var separate = function(symbol, o) {
        symbol = _.expand(symbol);
        o = o || {};
        var insert = function(key, sym) {
          if (!o[key])
            o[key] = new Symbol2(0);
          o[key] = _.add(o[key], sym.clone());
        };
        symbol.each(function(x) {
          if (x.isConstant("all")) {
            insert("constants", x);
          } else if (x.group === S) {
            insert(x.value, x);
          } else if (x.group === FN && (x.fname === ABS || x.fname === "")) {
            separate(x.args[0]);
          } else if (x.group === EX || x.group === FN) {
            throw new Error("Unable to separate. Term cannot be a function!");
          } else {
            insert(variables(x).join(" "), x);
          }
        });
        return o;
      };
      var fillHoles = function(arr, n2) {
        n2 = n2 || arr.length;
        for (var i = 0; i < n2; i++) {
          var sym = arr[i];
          if (!sym)
            arr[i] = new Symbol2(0);
        }
        return arr;
      };
      var isVector = function(obj) {
        return obj instanceof Vector;
      };
      var isMatrix = function(obj) {
        return obj instanceof Matrix;
      };
      var isSet = function(obj) {
        return obj instanceof Set2;
      };
      var isNumericSymbol = function(symbol) {
        return symbol.group === N || symbol.group === P;
      };
      var isVariableSymbol = function(symbol) {
        return symbol.group === S && symbol.multiplier.equals(1) && symbol.power.equals(1);
      };
      var isArray = function(arr) {
        return Array.isArray(arr);
      };
      var isInt = function(num) {
        return /^[-+]?\d+e?\+?\d*$/gim.test(num.toString());
      };
      var isNegative = function(obj) {
        if (isSymbol(obj)) {
          obj = obj.multiplier;
        }
        return obj.lessThan(0);
      };
      var stringify = function(o) {
        if (!o)
          return o;
        return String(o);
      };
      var inBrackets = function(str) {
        return "(" + str + ")";
      };
      var stringReplace = function(str, from, to, with_str) {
        return str.substr(0, from) + with_str + str.substr(to, str.length);
      };
      var customType = function(obj) {
        return obj !== void 0 && obj.custom;
      };
      var sameSign = function(a, b) {
        return a < 0 === b < 0;
      };
      var format = function() {
        var args = [].slice.call(arguments), str = args.shift();
        var new_str = str.replace(/{(\d+)}/g, function(match, index) {
          var arg = args[index];
          return typeof arg === "function" ? arg() : arg;
        });
        return new_str;
      };
      var range = function(start, end, step) {
        var arr = [];
        step = step || 1;
        for (var i = start; i <= end; i++)
          arr.push(i * step);
        return arr;
      };
      var keys = Object.keys;
      var firstObject = function(obj, key, both) {
        for (var x in obj)
          break;
        if (key)
          return x;
        if (both)
          return {
            key: x,
            obj: obj[x]
          };
        return obj[x];
      };
      var compare = function(sym1, sym2, vars) {
        var n2 = 5;
        var scope = {};
        var comparison;
        for (var i = 0; i < vars.length; i++)
          scope[vars[i]] = new Symbol2(Math.floor(Math.random() * n2) + 1);
        block("PARSE2NUMBER", function() {
          comparison = _.parse(sym1, scope).equals(_.parse(sym2, scope));
        });
        return comparison;
      };
      var setFunction = function(name, params_array, body) {
        validateName(name);
        if (!isReserved(name)) {
          params_array = params_array || variables(_.parse(body));
          _.functions[name] = [_.mapped_function, params_array.length, {
            name,
            params: params_array,
            body
          }];
          return body;
        }
        return null;
      };
      var arrayMax = function(arr) {
        return Math.max.apply(void 0, arr);
      };
      var arrayMin = function(arr) {
        return Math.min.apply(void 0, arr);
      };
      var arrayEqual = function(arr1, arr2) {
        arr1.sort();
        arr2.sort();
        if (arr1.length === arr2.length) {
          for (var i = 0; i < arr1.length; i++) {
            if (arr1[i] !== arr2[i]) {
              return false;
            }
          }
          return true;
        }
        return false;
      };
      var arrayClone = function(arr) {
        var new_array = [], l = arr.length;
        for (var i = 0; i < l; i++)
          new_array[i] = arr[i].clone();
        return new_array;
      };
      var arrayAddSlices = function(arr, slices) {
        slices = slices || 20;
        var retval = [];
        var c, delta, e;
        retval.push(arr[0]);
        for (var i = 0; i < arr.length - 1; i++) {
          c = arr[i];
          delta = arr[i + 1] - c;
          e = delta / slices;
          for (var j = 0; j < slices; j++) {
            c += e;
            retval.push(c);
          }
        }
        return retval;
      };
      var nroots = function(symbol) {
        var a, b;
        if (symbol.group === FN && symbol.fname === "") {
          a = Symbol2.unwrapPARENS(_.parse(symbol).toLinear());
          b = _.parse(symbol.power);
        } else if (symbol.group === P) {
          a = _.parse(symbol.value);
          b = _.parse(symbol.power);
        }
        if (a && b && a.group === N && b.group === N && a.multiplier.isNegative()) {
          var _roots = [];
          var parts = Symbol2.toPolarFormArray(evaluate(symbol));
          var r = parts[0];
          var x = _.arg(a);
          var n2 = b.multiplier.den.toString();
          var p = b.multiplier.num.toString();
          var formula = "(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})";
          for (var i = 0; i < n2; i++) {
            var t = evaluate(_.parse(format("(({0})+2*pi*({1}))/({2})", x, i, n2))).multiplier.toDecimal();
            _roots.push(evaluate(_.parse(format(formula, r, n2, Settings.IMAGINARY, t, p))));
          }
          return Vector.fromArray(_roots);
        } else if (symbol.isConstant(true, true)) {
          var sign = symbol.sign();
          var x = evaluate(symbol.abs());
          var root = _.sqrt(x);
          var _roots = [root.clone(), root.negate()];
          if (sign < 0)
            _roots = _roots.map(function(x2) {
              return _.multiply(x2, Symbol2.imaginary());
            });
        } else {
          _roots = [_.parse(symbol)];
        }
        return Vector.fromArray(_roots);
      };
      var comboSort = function(a, b) {
        var l = a.length, combined = [];
        for (var i = 0; i < a.length; i++) {
          combined.push([a[i], b[i]]);
        }
        combined.sort(function(x, y) {
          return x[0] - y[0];
        });
        var na = [], nb = [];
        for (i = 0; i < l; i++) {
          na.push(combined[i][0]);
          nb.push(combined[i][1]);
        }
        return [na, nb];
      };
      var decompose_fn = function(fn, wrt, as_obj) {
        wrt = String(wrt);
        var ax, a, x, b;
        if (fn.group === CP) {
          var t = _.expand(fn.clone()).stripVar(wrt);
          ax = _.subtract(fn.clone(), t.clone());
          b = t;
        } else
          ax = fn.clone();
        a = ax.stripVar(wrt);
        x = _.divide(ax.clone(), a.clone());
        b = b || new Symbol2(0);
        if (as_obj)
          return {
            a,
            x,
            ax,
            b
          };
        return [a, x, ax, b];
      };
      var nround = function(x, s) {
        if (isInt(x)) {
          if (x >= Number.MAX_VALUE)
            return x.toString();
          return Number(x);
        }
        s = typeof s === "undefined" ? 14 : s;
        return Math.round(x * Math.pow(10, s)) / Math.pow(10, s);
      };
      var getU = function(symbol) {
        var u = "u", v = u, c = 0, vars = variables(symbol);
        while (!(RESERVED.indexOf(v) === -1 && vars.indexOf(v) === -1))
          v = u + c++;
        for (var i = 0, l = RESERVED.length; i <= l; i++)
          if (!RESERVED[i]) {
            RESERVED[i] = v;
            break;
          }
        return v;
      };
      var clearU = function(u) {
        var indx = RESERVED.indexOf(u);
        if (indx !== -1)
          RESERVED[indx] = void 0;
      };
      var each = function(obj, fn) {
        if (isArray(obj)) {
          var l = obj.length;
          for (var i = 0; i < l; i++)
            fn.call(obj, i);
        } else {
          for (var x in obj)
            if (obj.hasOwnProperty(x))
              fn.call(obj, x);
        }
      };
      var even = function(num) {
        return num % 2 === 0;
      };
      var evenFraction = function(num) {
        return 1 / (num % 1) % 2 === 0;
      };
      var arrayUnique = function(arr) {
        var l = arr.length, a = [];
        for (var i = 0; i < l; i++) {
          var item = arr[i];
          if (a.indexOf(item) === -1)
            a.push(item);
        }
        return a;
      };
      var arrayGetVariables = function(arr) {
        var vars = variables(arr[0], null, null, true);
        for (var i = 1, l = arr.length; i < l; i++)
          vars = vars.concat(variables(arr[i]));
        vars = arrayUnique(vars).sort();
        return vars;
      };
      var removeDuplicates = function(arr, condition) {
        var conditionType = typeof condition;
        if (conditionType !== "function" || conditionType === "undefined") {
          condition = function(a2, b2) {
            return a2 === b2;
          };
        }
        var seen = [];
        while (arr.length) {
          var a = arr[0];
          if (arr.length === 1) {
            seen.push(a);
            break;
          }
          var temp = [];
          seen.push(a);
          for (var i = 1; i < arr.length; i++) {
            var b = arr[i];
            if (!condition(a, b))
              temp.push(b);
          }
          arr = temp;
        }
        return seen;
      };
      var reserveNames = function(obj) {
        var add = function(item) {
          if (RESERVED.indexOf(item) === -1)
            RESERVED.push(item);
        };
        if (typeof obj === "string")
          add(obj);
        else {
          each(obj, function(x) {
            add(x);
          });
        }
      };
      var remove = function(obj, indexOrKey) {
        var result;
        if (isArray(obj)) {
          result = obj.splice(indexOrKey, 1)[0];
        } else {
          result = obj[indexOrKey];
          delete obj[indexOrKey];
        }
        return result;
      };
      var block = function(setting, f, opt, obj) {
        var current_setting = Settings[setting];
        Settings[setting] = opt === void 0 ? true : !!opt;
        var retval = f.call(obj);
        Settings[setting] = current_setting;
        return retval;
      };
      var importFunctions = function() {
        var o = {};
        for (var x in _.functions)
          o[x] = _.functions[x][0];
        return o;
      };
      var arguments2Array = function(obj) {
        return [].slice.call(obj);
      };
      var getCoeffs = function(symbol, wrt, info) {
        var coeffs = [];
        symbol.each(function(term) {
          if (term.contains(wrt)) {
            var coeff = term.stripVar(wrt), x = _.divide(term.clone(), coeff.clone()), p = x.power.toDecimal();
          } else {
            coeff = term;
            p = 0;
          }
          var e = coeffs[p];
          coeffs[p] = e ? _.add(e, coeff) : coeff;
        }, true);
        for (var i = 0; i < coeffs.length; i++)
          if (!coeffs[i])
            coeffs[i] = new Symbol2(0);
        return coeffs;
      };
      var evaluate = function(symbol, o) {
        return block("PARSE2NUMBER", function() {
          return _.parse(symbol, o);
        }, true);
      };
      var convertToVector = function(x) {
        if (isArray(x)) {
          var vector = new Vector([]);
          for (var i = 0; i < x.length; i++)
            vector.elements.push(convertToVector(x[i]));
          return vector;
        }
        if (!isSymbol(x))
          return _.parse(x);
        return x;
      };
      var generatePrimes = function(upto) {
        var last_prime = PRIMES[PRIMES.length - 1] || 2;
        for (var i = last_prime; i < upto; i++) {
          if (isPrime(i))
            PRIMES.push(i);
        }
      };
      var allNumbers = function(args) {
        for (var i = 0; i < args.length; i++)
          if (args[i].group !== N)
            return false;
        return true;
      };
      var allConstants = function(args) {
        for (var i = 0; i < args.length; i++) {
          if (args[i].isPi() || args[i].isE())
            continue;
          if (!args[i].isConstant(true))
            return false;
        }
        return true;
      };
      var mix = function(a, b, opt) {
        if (b.isComposite() && !a.isComposite() || b.isLinear() && !a.isLinear()) {
          [a, b] = [b, a];
        }
        var t = new Symbol2(0);
        if (a.isLinear()) {
          a.each(function(x) {
            if (!b.isComposite()) {
              var term = _.multiply(_.parse(x), _.parse(b));
              t = _.add(t, _.expand(term, opt));
            } else if (b.isLinear()) {
              b.each(function(y) {
                var term2 = _.multiply(_.parse(x), _.parse(y));
                var expanded = _.expand(_.parse(term2), opt);
                t = _.add(t, expanded);
              }, true);
            } else {
              t = _.add(t, _.multiply(x, _.parse(b)));
            }
          }, true);
        } else {
          t = _.multiply(a, b);
        }
        return t;
      };
      var DivisionByZero = customError("DivisionByZero");
      var ParseError = customError("ParseError");
      var UndefinedError = customError("UndefinedError");
      var OutOfFunctionDomainError = customError("OutOfFunctionDomainError");
      var MaximumIterationsReached = customError("MaximumIterationsReached");
      var NerdamerTypeError = customError("NerdamerTypeError");
      var ParityError = customError("ParityError");
      var OperatorError = customError("OperatorError");
      var OutOfRangeError = customError("OutOfRangeError");
      var DimensionError = customError("DimensionError");
      var InvalidVariableNameError = customError("InvalidVariableNameError");
      var ValueLimitExceededError = customError("ValueLimitExceededError");
      var NerdamerValueError = customError("NerdamerValueError");
      var SolveError = customError("SolveError");
      var InfiniteLoopError = customError("InfiniteLoopError");
      var UnexpectedTokenError = customError("UnexpectedTokenError");
      var exceptions = {
        DivisionByZero,
        ParseError,
        OutOfFunctionDomainError,
        UndefinedError,
        MaximumIterationsReached,
        NerdamerTypeError,
        ParityError,
        OperatorError,
        OutOfRangeError,
        DimensionError,
        InvalidVariableNameError,
        ValueLimitExceededError,
        NerdamerValueError,
        SolveError,
        InfiniteLoopError,
        UnexpectedTokenError
      };
      var Math2 = {
        csc: function(x) {
          return 1 / Math.sin(x);
        },
        sec: function(x) {
          return 1 / Math.cos(x);
        },
        cot: function(x) {
          return 1 / Math.tan(x);
        },
        acsc: function(x) {
          return Math.asin(1 / x);
        },
        asec: function(x) {
          return Math.acos(1 / x);
        },
        acot: function(x) {
          return Math.PI / 2 - Math.atan(x);
        },
        // https://gist.github.com/jiggzson/df0e9ae8b3b06ff3d8dc2aa062853bd8
        erf: function(x) {
          var t = 1 / (1 + 0.5 * Math.abs(x));
          var result = 1 - t * Math.exp(
            -x * x - 1.26551223 + t * (1.00002368 + t * (0.37409196 + t * (0.09678418 + t * (-0.18628806 + t * (0.27886807 + t * (-1.13520398 + t * (1.48851587 + t * (-0.82215223 + t * 0.17087277))))))))
          );
          return x >= 0 ? result : -result;
        },
        diff: function(f) {
          var h = 1e-3;
          var derivative = function(x) {
            return (f(x + h) - f(x - h)) / (2 * h);
          };
          return derivative;
        },
        median: function(...values) {
          values.sort(function(a, b) {
            return a - b;
          });
          var half = Math.floor(values.length / 2);
          if (values.length % 2)
            return values[half];
          return (values[half - 1] + values[half]) / 2;
        },
        /*
         * Reverses continued fraction calculation
         * @param {obj} contd
         * @returns {Number}
         */
        fromContinued: function(contd) {
          var arr = contd.fractions.slice();
          var e = 1 / arr.pop();
          for (var i = 0, l = arr.length; i < l; i++) {
            e = 1 / (arr.pop() + e);
          }
          return contd.sign * (contd.whole + e);
        },
        /*
         * Calculates continued fractions
         * @param {Number} n
         * @param {Number} x The number of places
         * @returns {Number}
         */
        continuedFraction: function(n2, x) {
          x = x || 20;
          var sign = Math.sign(n2);
          var absn = Math.abs(n2);
          var whole = Math.floor(absn);
          var ni = absn - whole;
          var c = 0;
          var done = false;
          var epsilon = 1e-14;
          var max = 1e7;
          var e, w;
          var retval = {
            whole,
            sign,
            fractions: []
          };
          while (!done && ni !== 0) {
            e = 1 / ni;
            w = Math.floor(e);
            if (w > max) {
              var d = Math2.fromContinued(retval) - n2;
              if (d <= Number.EPSILON)
                break;
            }
            retval.fractions.push(w);
            ni = e - w;
            if (ni <= epsilon || c >= x - 1)
              done = true;
            c++;
          }
          var idx = retval.fractions.length - 1;
          if (retval.fractions[idx] === 1) {
            retval.fractions.pop();
            retval.fractions[--idx]++;
          }
          return retval;
        },
        bigpow: function(n2, p) {
          if (!(n2 instanceof Frac))
            n2 = Frac.create(n2);
          if (!(p instanceof Frac))
            p = Frac.create(p);
          var retval = new Frac(0);
          if (p.isInteger()) {
            retval.num = n2.num.pow(p.toString());
            retval.den = n2.den.pow(p.toString());
          } else {
            var num = Frac.create(Math.pow(n2.num, p.num));
            var den = Frac.create(Math.pow(n2.den, p.num));
            retval.num = Math2.nthroot(num, p.den.toString());
            retval.den = Math2.nthroot(den, p.den);
          }
          return retval;
        },
        //http://stackoverflow.com/questions/15454183/how-to-make-a-function-that-computes-the-factorial-for-numbers-with-decimals
        gamma: function(z) {
          var g = 7;
          var C2 = [
            0.9999999999998099,
            676.5203681218851,
            -1259.1392167224028,
            771.3234287776531,
            -176.6150291621406,
            12.507343278686905,
            -0.13857109526572012,
            9984369578019572e-21,
            15056327351493116e-23
          ];
          if (z < 0.5)
            return Math.PI / (Math.sin(Math.PI * z) * Math2.gamma(1 - z));
          else {
            z -= 1;
            var x = C2[0];
            for (var i = 1; i < g + 2; i++)
              x += C2[i] / (z + i);
            var t = z + g + 0.5;
            return Math.sqrt(2 * Math.PI) * Math.pow(t, z + 0.5) * Math.exp(-t) * x;
          }
        },
        //factorial
        bigfactorial: function(x) {
          var retval = new bigInt(1);
          for (var i = 2; i <= x; i++)
            retval = retval.times(i);
          return new Frac(retval);
        },
        //https://en.wikipedia.org/wiki/Logarithm#Calculation
        bigLog: function(x) {
          var CACHE = ["-253631954333118718762629409109262279926288908775918712466601196032/39970093576053625963957478139049824030906352922262642968060706375", "0", "24553090145869607172412918483124184864289170814122579923404694986469653261608528681589949629750677407356463601998534945057511664951799678336/35422621391945757431676178435630229283255250779216421054188228659061954317501699707236864189383591478024245495110561124597124995986978302375", "369017335340917140706044240090243368728616279239227943871048759140274862131699550043150713059889196223917527172547/335894053932612728969975338549993764554481173661218585876475837409922537622385232776657791604345125227005476864000", "24606853025626737903121303930100462245506322607985779603220820323211395607931699126390918477501325805513849611930008427268176602460462988972957593458726734897129954728102144/17750092415977639787139561330326170936321452137635322313122938207611787444311735251389066106937796085669460151963285086542745859461943369606018450213014148175716400146484375", "399073568781976806715759409052286641738926636328983929439450824555613704676637191564699164303012247386095942144825603522401740680808466858044/247958349743620302021733249049411604982786755454514947379317600613433680222511897950658049325685140346169718465773927872179874971908848116625", "1468102989495846944084741146947295378041808701256909016224309866143294556551407470861354311593351276612463858816796714569499021375899793849136855085849133702029337910502448189055357182595424959360/819363879309286303497217527375463120404739098260200279520788950777458900438307356738082930586032462601215802636320993648007907724899611296693997216938989854861043298494990214825163523387600982777", "5896704855274661767824574093605344871722790278354431422729640950821239030785642943033153793245906863203822369276271050164634206965056233097479117980782641839669/3030306850569309344013726745100070601277982132543905537366562638553198167007159067544789592089960911065181606283478843359856123992707598685058297067179343872000", "76631772943534985713873427262830314617912556928476573358548256872141516989538374761909611879922349479420014771499018155447198112155515453671128814488139633810493264352294560043912066253026059140653027326566801398784/36852092933388988649396042883218509607503204211148493545892849595498822817623842579026942621098851631842754395231561679671400197056377380063233740202370686144673585955581403046886083948450136247134308381940165804875", "3159076083816399509754948610929467278257473888282947311280653574634802580912280940686954763313882823327077171624015737719617373932318151594325834524000275847475866299387913048/1437757485694188822758304467756419845842037623148461107362957994816554782989250555362514354661961482939226272309026092009962414616417412938087494467254146002233028411865234375", "22266067259907364984531611601870291368272674573653403965630628996687370994139884833897773468149149664829922302484782423514167405397665098388400450149078982462318781750661005833037235183394221496186539779712428265837926417581952/9670030144664428565128962309657100138096047028794689249320859276197340398920725569428532293373676415359965773460364494998334259893079003125373872108770534788283842907318071170285038777091588292539102269617376180390982915567375", "14604654564989239958569331443385369522850975185358647132770022716433280072271007767111036877803328768910274400515590151934676819262085211828028638417329558229123989556376108454497813055/6090614019162516693013973409650613208227889078878781039105047015752493519149314227721984436973374032279421344818329285207124280297611253861173835238379831004010748379874393292231671808", "1901241885407696031217292877862925220917660047127261026827869027159993239567933534052663335498281439239753018507182016153657409777749792228538380379703411298411623469292891476969894084838876001545818141543890273256985768690847587711270930688/765116019778838839812655402103512685695769161212360553099732689795578904762091216998790589926057819838537805856579109910198553330075924857419395160755642371550113347465300208422126945265887065434116781678702741657275181694851670325469434625", "139459806786604751793737926146840623607010208216289543036026206208962059593900745886202214788747453279179283344350478734275973878932538430194363355795823581315329311220701640235653288975569812161436/54371368534412517053056101353618694718215711767266376573138772968257303578467926450212293233332401067673270853953399269852376592855992724934941173346260129257754416412476202526978443681584633116375", "1045669091124493070709683241190022970908640501171378776604126771144008324358233819560649021940145166254659028524319517244711645162132513416238958170819347361185944945680269442845829390112062101255500836072082817820950448463314034677353723256969344/396228259004446234921310936915931611736815598535963504660076315228798989932959459406702091180060429080345146735173591749448509810270759531977278642135591672189002006272326131885315743181289970885337574780897529347356567086535505950450897216796875", "9912919238915437302006264477931031611447467070103973106567538528951878797932559935860738745374437522819124347510590800370471910492338584284092534264608801221235029062881964101996762011296996851893455828946521/3660537472668264151218961634689665210933936249986285290553357254224360417386515311493310199319523687171757653216994741150377508234317025158302057758196429623723072084157928224798322861732880034847243894784000", "9263710175433181746575186369318246002919895649622127410824041370079225200282403368319370743363303164313395723904510539050157032684710468364067204876434546848634842333436957245275217583248805993142227630297924119330553308466662488683624783307023014909360640/3341177182697517248552428837661919299725031035849865632511882688786226888137634168024976033652753689210700218163621739078534353578510364301481093730054725078138658805025014615651043313990684347632166030359086885561104034510990826655289288319840595753002771", "5116082230713622171832327542439052727465114322479570603905499496221224653983960598946033081212909066917137546065542953865612718836914393275681318667667521726785633638189373998191090501201427906618075889744489190209584/1805752553736060443820406101277706970767657006346276183748749630179442318063568286372320188433843729960294965366346522303898609655762491623098453269916163621089005711823488749297418113474056676109581110715068124438875", "246569125619713282434448566970352231845414317018379160824176638351574938993535464763890962336882760882398479702237564384291290459961036068916857265499633061660562532011248501476114401629839742058389195725393702000011860799793778295606988057303225493814005789533570432/85307063020836305797178273029353623060860009152114361453434032434699636078115114412588719432277441055049132559782203988387794711585368296817222565434951256788867244687081233632650953850383220864394261763844194948389861147622944651546912394593164406926489862036343375", "133672026303452911046163998480860917119290576658330909785707604886881155606725822685088929236266583416708668502760907677019598002175122453170574729028452721476464728566191464897928696630979863154661704374206171469014225143/45398130975270785045482567762871405072140548998125471025451666500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "6041693953360002800224091673336562508913199995987479264605216252220579740134601435770085920869376641180763419907442721705887169884230643795126568815123647603047739799302562095542459344811429882053086550900803768964612193941424128649976704727183797495759082741166938351872/2016766992122395667828553277997478570503475626107286343497917705446132017125079612756035254750822860815515899557855166824523851779156336235294914777307802256439645525835223691751931866188957324792276149549076500784191791380803500156776088683900346065830066370370083309875", "705868391597244582764749229356331441978820024796066870551110486625729826111158236686696326058778874201639006234449557592353247542995871491078308187261304930042019640830629526023972693107193897009168955674240659026247094657679060/231848642748474339277532000336338632910990823562381469441716922006107433404523316252618490265927265734670539384485699132080062215196462178933963957679882342083893417545858074378754089719547920901917516016346211301054206383643383", "101832160604157943093944673541651013907278188571533075311673249923948856034633446617630054761681006062910980371900782781226979391765818325065031889334563981235894369036439929651260587335544056975715076598739977065390678221999918899003881778449092038750712969437519295878491018112/32944277910571666002449086492515464541550138004002141571670657643770713783329063548790202120805341989608877739811787937782240802963962520261844114327432160788193314874913687387269408387417806176202979244637915812905426565263196954203487934225589622864145960079736633434831996625", "10655703119271468913597640479490594180964700448340778168715956712130636958373270202484276402718566314881119559090842449610957974112230306343486091910217340665146602598568991520563987490686996746558858366002301982443029430290679385551/3398412687366638541233365137084722368200311117891192348532156645374786104142009695796409107380345795998400850838706661851176885183144928701608654514812261697598380070746520197171576610572921007069104300695592751543563472456384512000", "1903039332876763837419920240543738799531131775028971323439870868730321221615515008394327723508670975623498588291298064320786970626232668956372004004897872810230178526101184611242511193415796638694370503100219710864543168952682617801833318493436174387568067811938490953495819438108686336/598806534367503338307287246320963280558134937382149405305466709787179429317914803617527827862441615350396864359976273212272586892074799651088317544101755361439294687323233086696182687664637422796995789967075271448560870681210580691574924544896656175563265378514188341796398162841796875", "525573915563826130963525826191411949262846916750432019596028344808298471293378917508549164993368392834023782480702893643486699787870059946429810070222126260200026332874480239090370088123833491499400991181659445914352500247596757005142623368/163278727324937389095822405034435687776345799835442022795533783889356344755225815267819508608559076191292900367982490827396869405536484846115955581043091229202052407483776587687967125885665493681707461345895999542381476164157058393971431375", "9263815657177858787273494705338516861045771674838057329170239610953039987023429736752079544014780707408666628475997291124805562998227296677616204140605356257712022384368492575381355563976330347792504605666631512343447560301417325154003481040250148561839861837778597346623630046623751094400/2843321709948499955095590862256744532227698001408929142548057792217790532624003190447363578048562448168721539177458065482170148482375585867230123873178100117094533143052886527452665480614620123764036974180917207421482431983407742154634391264619615289225747664532332469783301704643254076601", "407959339726114455622180187758753007349209016396248763075759257357925636039752474207685682218422721827857994768023399625060206708378433960993946156803948655098667156937949174400873748557248801874735834957795040139401560494087476967548060208243867/123780218751812156744401121690996305978134694678934447237402511116731459214498784497436358160964198336874043702652746834763131444030185151143987331404604087778514863973633941401826334750268416015224906056576641018962863645043976537664227639296000", "2547676391598917379516698439971914695230548782904479778605691338364453606537643088857116141939170899135026552016969320061900926954008522781162186995856580955090548471448276736878300717869625651893741316530109438876067419826217901657017506157997588944233677467357220316084583383623602865379325184/764562034757392298786420374672266498815021229519853724850874576419885380830752931701831256959159800764672605004880389358601658343203513177084389490286723240185146570925957286083025676875197029662038213216541352875570101363668917766225709569356861275434470568767077844675593176178611021135573625", "186545352286463730559933346565311535598243666022232037054735807289501173444103692309735768703898330430135399033529355360391658728987379385732098960609744313878477967971557204207043802935782878745271859468248704012618254203101767841517569443555143252/55399179641621656233589820996143825959365789093262978988289445625153099592463372579496245442338653053662134699646413817866770218574795378644415019944304868289119443774932782235638737888469746745621382139263856603239588594078668393194675445556640625", "664884440164786473344854955309049113269357314957985265728106924238588705533437169796551912202931185746193155801905841712503407258166135075966280435780812714252670362202091663287095423712596462690753468682634261029392794173636943978404002804413009590005984736612421172979101972556772005594499779860608/195485517776407145286424460448995460754674039560651791192647586550615878988380153730602665795647187884543361218962125172808792176382956599256188706636727418572541254480798303566840010217729386905041217793614214518363859058348249961790104618910877813067510758225302884815410347238200133693756493703875", "2614957283934314904315471338485451166053664494383241929385424599389309215073267052860464009981063483440201193771607520572077231889699858482582363845275452280606276949653970992719332472370351170732899676316967244504534154616036371979031399425846100527685/761493664432749089312665480773496290658029971027686543404885407644062485746072719559288231362060149626237939029641098328278650939665665969011529293869562636656650999759724704272743235210867676873525147820749560155294022488994426729939894753293900972032", "124843380518493746761140367283007507854364503961156704095198010255465940085534099747297600085903814014415830785663764373057896014399822131175202342399536439284123918855893825207202244831315575594886675813256448846863723093240955901916229136393454605455444105444987028391748121054399538064686074523506176/36022228212051654395480210378626648518430280334458144892889271272122662467638331091863215146548048144675657239846337165813938424387499358852301016926312083940212100001220180762189978024821166744964908871443681332664798940660421469519997746775275873085770018269706847741064037876137315001228315806659875", "827992369063043155578730871896750570951766628472810506926098505028264552046829097082095665194000002802661600196840639204300804225352337632259980703832713031790922485730615305441309917696044954289187837653933158950774246017223571461858939407386087081525130831392/236805932823686534991153393869288530368011574665859226704279685567723830696754821658770176385138917722808377962346690757191122309876922069867472518117628639913077442806147910884267694879089753138429767401700283014143248445966474839193628309668702223994071394625", "17347276886878323736540051321582548724378497839789943634071026331001588645519865992773157565595886250230140452154269197770615097377486013097979087647774513500701793885978192218455687078883766086309728287172567466406449372659680040183273634701092561727514713494914793425407149186041796935055187281744386432/4919325621804683623339606849970832094714371903709195539440424738973575902329797546592497378000858196173718145883783709223158260700365224756081275272021856393735663399552166737690038832550853145831185979094979556715294990257315369124065787473707136464772247917156232366320267601622617803514003753662109375", "137984231830526866236186357461458917020538108058615632801298091031540729111527734872044790487396302545910108285921421417358113055522725197998483383380192391312304647004240060970929072498293210057120617332323445379424867965764749534125081131327565507524502163460761/38810445792642817561168950890315210470940006613819790543653745327778579787694809782601777514116858514049585074667085399925278459138508514838268321349069481334967221455722811414399738756151414906092225265355449011152267068726417045644222323488445626292574879744000", "746567120547823334914136339633766098626636643449144032626270358619125402826113269699709721071135471625588981126637674402048519990010499180844665151971356149292818375448504122545400227696621572263621729512461528550588108384619064912224884465737417596190735966915167530332762203074440688676123756162572829692160/208334337057923929636884170505570363171441147899816815785150954417598643614152856767186132467069365605496210036171429712485182162940460120834349006784956522600679357307849981862006710239311750261522832996877712350330290831638640913932265004107623954913155144975252743257846945609734368518424172846119306643431", "64649371728330695076928013661001819989330953381731372450140483779536126948957993261299287753791770622512248630224724990234903928056275080682537641377393210728546364176267034339221558641084730052304770498929958838997239635790469536857863963589118888238069738647239076/17903951498200212327802847425913723358452100686246224008745414214690047078122925247086521362329833307849817944645647750649290248110509395628305970523384831671737569872597295947593410067364379687588919135621621162007748635920864926867870502568935739725312687094047375", "2454918942158003099688922026016393688092399295166304634317616773083386087532869193458590448918958337530406410803840837646465522656670050113548208618655070231274778592766244282964463702354872753657766121825196898916725498553882689210280080206627916046484942827487726300822318764058084323314109595329304407466188383616/674880185931325925966586583820010578979699141814417326552629206140252348822939845006845669570885271576698771404162512001549922909048916000017837898649100825976232784446638776021483802989797501705685620612986771521390439936066527738682396560462899753657942715306792783283782238662155922082005591512296007820682995125", "74018558041066162916454010680594042518462756234254788158141115244349044958441521749277686851928706433556285971088455226217644009628399441967508838553345152310730562224910795446341601049647392069373970101491741830623078126344928804029524181578945586663110848142571149861/20204153620006780689923328634586091101021423979622170579036140596085566172775051595588438592742563923428900864000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "2127032036758045513335690185608563023954009095206088224487365541995326714285119384743928987635752931664240752323937321097955456543854943206092931247498833001499955456190701695430459583885125382086777607021670447795321669948733328973350279846928613949120929250312666393359442423066212311060931469017737106028339882830848/576612418511902928757340062840968526862381326698309578771238715462180282212422302261044980131594522407066369222998903808960617461164985318633518680304995784614308979881735537678182134128319596636920719106506829571072447362052319438091347699720147003209417806230149598345068078717948025207635448205253184540936478445125", "35289653975561083576641954928762116897061274899517309102784750384002335187117263273488751066569234386120759866204372398611196356888479036949053282301027789530999737306501029700128744408015642211359442183943916106790666114870974212159410284751571905275610921784716184508440/9503006066880728386808143045924119024212377150217533250562188228062174064693375135306438120385877320162710918716613546077156389583384656340709638430674364232343609717735574035535102953482366914421205216675248471695111720986346092738728929878538430662191272737183832556131", "102633551023964794485575491065909467125458972250222581133681080524371507544152979467328048718122409841060527545925136196267751819689935599599321090571687632103850847605493223603751038996548520557330016046032671961857623066292962260173840972332108111505971231021442896036760967107060309991355545554631003681544611731245475968/27459658121882266328752886605529964804078316737648012166874496015808620265471203512606463219297059547428855195782384236337998738233668399173746663289852416697917397644234441300570212555870401420579737973722145663287124151049692290432756231390864184491891697469874600345958989433125942336757049639797225309327019275689074625", "10034393558388390065766795008210457368713365491566387292163814915435906649268119060550511145023450790393353937124495488860451123302412204483570913557762460385297770427946219119911920640306914453207097103853766023934602534502476962159682750262143380527529536498215384467975023/2667919902603322771586358077760621955455470781865624844984169443739075976572061827709528710108877015489050369589117491611045518221354793418884447632063538994046714401229510497599783726376490260140723032102883617341970952663947646017489439179953454964374887388652792446976000", "248528145263843375390386172800048509380966183384567983242213959113927668429802237067505890436957693495616107089384741585283620097982859345081736730899912519273262934785992235852866637878831878448348444611412764161078458068549719800733237024285525816723480868704742804077255242682077291713092790250511567621735004237450946304/65676865669148624809340872151906045781446981664561196686217551358486802274698228825404698950974939545099727242259547145392352658637333562345477931951890984276718673618736565926663528625796412420753961231404680876558659735251469326707567479071881966875336951133475135427640218972722939427821842173216282390058040618896484375", "7805448718805635696495809414501206964843262114470109146341305656318015059743127114324245035489577134938579856003956861881125856595981500593426840968087618241785931128978516340812066502964561231235073012672356530509663384739132686548934288703179479011016719045530855033205271548/2050525178024039744126592505352202216905491833360272553169520915020715464206141942151086176509423406413311520838568324134077402841030113427309725873344806030836314500267104070131451720947531994814710189000076651895520222646974590481497382830325485174899169093049299764813276375", "3355325071293197839434119105039673324264765809771192815982246040415580387729382404624613875653005261578877047405365032178619450963731719777167015959920645055600439987161800547901539269321100559393048973255388860193948274255340335876890491746900991668165565729269698196233805991206691196045182214641935483083662356666996922240/876402579119117579582569839757462461050855174353108858954282915644790659429341853404829661899850841645529640454766173209897510988090318303454542547519850473808789222552969933222203420847859171250332350076509996295844203965564448154484566493395403967626596213792922784509892086361572955175655987334882030766001799867659814117", "218871061991045868372866381545267589365410350294028138778572466235486397478028823720846191998825628156716190463263492304639890659254282445466806224943413446008645087186307985343574807361972238230520975439736199291019544576443791916302825193643774360055545186783819367378492631806297/56849560726416896431557940314760680962653658127458002233782028041537121216487790008085876994020812492987733987414743604239935223783349870516284048368761617736127892160849065895223288023531930411718807065209903593668117085505482007061969339237404945180379460053180570404846043136000", "5008685108365226931582937964451700746853986170633433728409171904803795018146152804690759530990140552460596075588463394200510044617816085275660078502126507209302951286606953039953843685800941558212440519542602092919776366067720586295390886070120828199562643208637974347390938772070049344991272621102622931576339988103674070876518912/1293888539680354282541277646947380627241979967611883341823378331667976045287311988103163380651334828012840330710760757271860219584371109472132211215957402251594055009937397184768184517621978947384029376766290498101728971145633139541827544539988344772578184316843734267915665730981857376872622787627370859411909330227080697966353375", "15388340113525711660227566446101909585796746979396093776960989868457211684028149502578116456785221720682202816140911944661051001675127262774824593420825587319436537346311831003212424497488485098543512314062112948777572038731823948224734505930748371522309451168088057190162878224801232/3954220582960831691377435160890656173654063611768428458807273708040518769541211737927975894584024448193835165167801976423275767590502552964407494549049777006346189436817215329891530811451811864579644894987864267389290848598289794977382504890216219362031324635609053075313568115234375", "5099039333987561374222193551155323470675617979816941646196895589439391685938046865391119484510329634015275893520725135141878751153360264368353595348921951280561029028912953500944814771064409611917475818956659775131751121312316084465321917769679881052144364834485866477379437705913911371481828140817759401117780199246301705600020671104/1303503600297679371136943454060319958680553228879031326679449263682048703103464872914972900105569835004878963701599765030590097739639045890060548760692125546754294514068052902543220382104483822438283040090444827980927544440984823535260277595466339403795403200720622852069244768910603820007632395190204569927612348189089161551951106625", "4902837141334073026145827027361937996261324349722726869116185158777439337041263482852376194988371853413467559557923410949898048139830183335197992754748294810838187068126867611615800383834975563313220497573778480109264178673389149671194149749735833378557143135481387904961537942569904075/1247045310545991266291285730016853118981099516935251861146038369985109288084420528171217942065832292739130145780833406014673689119563698528225048800794718789218267628507713621235056538202070171596177775095071513194885568843375526804796016261173388452184505503341132236719484809714335744", "38114743522716832107917466438257616720476488812538316101658139632867788464381862291240727309611460187159930652186486096300862388591521625093237019662273764387591494074792574929490381910446287947994150655077877204446864004067956087975012773988833339521775463977233068498404144221045837190392670308437391686081418318624745039402145439223552/9647001083383999453668111809775451078976046488746916070976218645431946648087171586252172936600115032316383427265217993193444199863138429602138841976586190525451324093772097241349417938578878934577091671046050326087898259692917931230974174799815198493279413438192301437068820185757869608523761456160341754512329264442115351926967120404125", "573695055225225727008803730767518906490704995929177617646275646884555707960986625481944101622708415415988844740028718027554452662358957933526173824325955904005404113684003841990198157072540659184995738719040024647370869010473254071681533880576462368600901824622431045529064651675640055917092/144509482511118816399089096021290587489594541280398871255876563615464628718527634679330291741479135415168539765887291789615790513527330600394937614433502341116068305347468133950204152174094704092402978083370792135432486240914953928188835819767755172666693219213868545854371103120604946200875", "23876960329653589647925126180903391687666378233201794403339630995420215267415575142266707357255726330536094448314199602616026935251126469221925945960901748679919435908556550271504767784553484434363646489174587463466333864577705745452492395785557425904735048180164697040313528831173448025400634629163795223739061661461986923675833880378496/5986312408594306954013526197465608559068621248896320652512228238115589875514604632230098997609482248000888567135685167138762172475788060284232459813998201719590208742091697294562538265829954186149162974972471533202880368317237508987477069872431064075005305838801862900501819963793062041081601844759452202282545840716920793056488037109375", "58168289917567723171226992383559866214094157894992327555495441698028867727845766488121900626912848698952863438654895252811583144479300382761129433911280049009362667380001406579175563745824368613319103673817094498117944856004415812877213722455299491145649879676787079744410765053845551958756701/14517067289347903655500020160671113450349743650636953726251191692074385521975132268313263723831804150872238173602847065423463131917373356798750100313145228608894881457107689499956903046984443545789053438946050974567665049237414588435796381674590098629779384355275820782532479708807512981504000", "728621890568281859295409481422447012528302594365693410763821707074444799793690738137592101239862736313347273167450056625929591960610208335290882047413011571781161008296084630072829079783328937418641417642857196346026366370059522990813537731394823630207433267854616768658990289454635793326766697884798538576055949457122067828153655416688640/181030730759516991863708593747964787874073354051675597050399087612142539517308720603687322924426591889179726492403913356461908748733972707460063017057809060190437917851790767968877215795679844983288935075688219234885360839984681619084834228226744165610073685719017596630302462070188937998558312507638434329299017584329479516410907786681093", "86855946923438322218622470067224691860808273886184997065663554841573982963995340977083049132518812923329423480393306918856650577072525633920456721265953575424233701929892019410099166322511413146891121248381648145391642571638857576890568882512129960291171866772665863159474602604647289052079991768/21485753507365901947528588896402264670781310878547726104482740647554738151100954835784115119035980523529677083504495839730499664052882400915208251594384038810917282207449860876251558307288700200910747338758723324686939379138206117634546981163355060740270734146780942696291669461182599512320099625", "2158989152301022938148680102142188531448821359505188055264665167313418619665693092337665573150374231484840948447637297247277576415460889296724813940128955070240137590073233263168835678714131062764247434144994737610229909964847568491446606012581370840699582055341626266533733744293929658949697805855362114229666626620766245630122333733703618176/531794915405164005613733454597931482878479882704956110685223892325074211694837836221759995948610212818642789132749082430059593652854659130217225506942675608692701447738732031302987802196501895840510235161825501235133794449421919927396142470196961877376701957829921152848178076410141813926924749057304222282687697297216661687583257901415465125", "139432548574396829074586704387656697097760057897628994548358619815052936481650396157428747411173567801047221928593253479330480454469358220685854351236980383914223693722868233819483137401339800304943891968050399345430243790898955416907228948287367356990263740207046902209563417267686591994743547621/34201151688775214071963206765436083445901621442002061707492082843232231754829227303539041286301398668437202547003300396162741375435703188500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "11008517174872833286150985180322584448162884832099344969609291070844193524816852920942383850580217443209402836100467940651581092350600329145627967515818684442171571156446321228596914355704205623857871497315955269266498229823278800717909321269179839084452384509142712677235552103459737790674103994445173074670347080506698168482564009465276165824768/2689223396936080856855299215659204161946704205931885125148201643087176556822542895325191478283706585400237901215485150928036895428721912118467760766508162631903585126377676412573187912443878232521444786090510891599171741773242011017926658231638022943018461086517502584854390836347781674626615709751386455292026775663545470794167629144456268750125", "16108638074211260588800537540680707641986073914251424878121255234668558067988171568946079848860335948991834525552515669040163026131919804987340113244760738846884911038097907756220945883750502673899084880578229601870882631165510396775126850307838505063922101682333806284668762825609556049426829531780/3919363961344261777100658318137884299575193089462944554282218278496298610828757650104922583359642384253066896538203596057302203635134833545580869871333892935330950583664400555463557735723364497947986885146043017010159347046389604172186788902608216894094289769850517098027486468084407618748895626853", "34420755849180279597302103726180110022640946692592540634353734157479505420320000324260530767186132260970572450489530034440214259559325114511265075416512316229177952140217732655405289808326341696986755141965043719344169685611217958619102774617224847284122901023774956887687026904767714958090256282893003000752947427857703259704682455375442735857024/8342030311716679826889917494957593165464748884572298173556257652389845294530325764837124998293398445804458613956489096007564811101361266196542129764287084823604897187311540561857741285793447174119667215803837719660675298308873496219385226998078648428368061868944322478384684509466965129972030932418920415308276430355882329457342937549162000252625", "345888075261020004071220843714060353763382280664960929903544964118831237876694384053904571498830068831026644303797377762345709976595360421502594656308937649239978525713471393570536680412814805076323426256584504251728507416368609420882442293831684681071553766603478479006495757222912500012444787804577811/83505703731469734628961395063481893801938371516752417759131774530720075262459158384433785006689548434701904106312038822969658455364219435022841597243178757423598248565463985786213156556523685666430799283870548238467817226915680747412191245046634279766450629886904716776719219698922088211154187845632000", "1061717830619177527082296723099890392273896386613997004874669053445943252046748251883532634529759169500795452576392700472771365240996842610207274128102329096619028487369622001737128463631016494371635687841733644339636164570819431573829173533941056258744442930643735587780907310433371453992062647737259587563398111688659657406089003293576961475848704/255359631537215747979895955806995352799574790340218399351168178555478073997876110889483456972687438702262017800167048243754141722496276537685853311434069991222324039005160057724073156957530106623908696241268268096879569794431919729620178375212905203484165745866913773304319069321426245521467122472046370356725530914587807274074293673038482666015625", "274122944106300296738399632684955400761495830361663966466225652918683099779465438024846903286816813856490888796372134557295699980528187779624865098445756013563535339056233912394908544185885547842235097677765325396255649207317018754967666450708249125316192200151505568416495274671679500594656671785202496/65687592621976546250581560102201535533608158256953087745856906437400149205693427285162333502528793675585022025602144243543064185647792948495372442630333800126269123531636800213405254045262127593759539706750242430153456891792533267948231185296091297979933562727112487057234422009426868531651634706262125", "7842680480716516803148821198697967237136721860017131244266974996267074742248599085253569637183007740566941125452215834642683053334607896723447140851344501084122965014242091312411884985569341166545074688756440728922408743841592658677792796881188604773469108807869960161395759837407978596679911066586626885830991556090978327508459276025943279064965688960/1872528612245648675720382138045071131304652050696842872529163720558126655075937845539792108048310219395746259570506175902206215101518698490144716531697689534559827422735649881381597761684154409796315455445459537515308174919488497154409643876490472215352056502193150125644288086294418253309947229151074464928874881827227706992859640236086417889990541889", "5300824422251242070074569186825929119848111723012841627275830216301188228660779008353049603527567784119877706984722171178137272986345560485784907345500893648715341273841147320288851034078863843374665850852481747000237834238703248634174397792745914847774297223176674917912406659831206869442510948965571661/1261140476013707338477604677428573831791396352814802149994640617701773078174882455512668089072441176857892331468691160991310474734143842336092636848492066592397892638052212250229129355009939118431643425836944282456647571558383755315238500832868535816144280088644939696339160092963629012001958205063168000", "2220223718762215584659309059880106334425515875615107369399767892051551634000614327272260081056973863669004224981561870246078120862256383581012183852291444462730018546753183156982897386563561418424093883164027305254176874653780425452987066512563140531367766900610414277825262239199580925879453806414860409441845631158680721091621460775043562065815179617536/526383206607841251253861841374779803798480623722760367843070466043030228662340154304405180907941079883976168609082254331465595267209149963786388600028701073430773581228212441424400748220833542964971495005714483235359479470452593264280645360131482713147116366500300066771223383007216182988263355451923333319170174755334598973202740108032097242475554128875", "521891797109626296684891455959263713257353500867652268541535940159815152120871142196535233326890353914761242025931373491906127275561002910157909306979093246574207104081108188995072105948138299097848175016082947174156278439986705241571619793059501724269644447572323501261424770743329858038040685313621446524/123310256826873923765604825413207481739886340225713108649758575106598510022338480189649787216845041382860899099250547657534972156328080736149239332330143771138115695598493059325064119176038137294863053148618656356436332991079150723235214278848602671333076219529535123842212129829931654967367649078369140625", "66086044538329677372986118727999622900471937619891337714357792768200341519193500393739322894033303245376225584865369486696276607060432449792893028061817203932068085863800494054274423512956136695211796751845295921015953538329385253280866669403169919614982155350899648626481405781514434761541281229159396787287553493046927448595964103589100429722948913403008/15562137339474350565671240515273666798063901504051979980452491653975250630723677279081058884163396938548780856293034775459223871281049026140999055923743471466471830572672766633086347312178711643724485955576579988182546105048041649947277672869613992334541438784737993706482731696809943027528882927942967419447250586964258807454003775693567366165507144866375", "335377615394100148751647837967017467711612297170079949298328061159559939969228226474615711044891085626519877634842694983669611974807129333052471799687426665556738316626171408219730853872410792831871526174987402129691897433888027072807302411474690613948951673562473758814664346259109886876538510453475290967835/78715592752271462306588358880337347638000605031000575876214116610339827495261512281635361568951675037834544811575026718101166562072917855004822606752296233435017284127594847656529606648345533195437635894948829857913798336356647286032372695130461573940500785137424365840081503133157308796505622439791698116608", "20090879701618729602554170716780970848925039917987945471322994867171660307998603515745066411687983450400412739285577269751603921163835619296822801840348319742203974023505186187060251544248644338412667631232247108675504629538319425769464277309915502144443973397371136256151336255138506001292355330875114245901820438821732843540725116728866301271466614762497024/4700223519410528857298732096729483544820841497820611795617923063440946097326817340637303431283005509904481323205480729806879570430868897342398783028649633951362398196137429076844504529051072393709154483678349272930361110568616112723747726853614661953537957117231900032044221535502745676310313569997665352252492568100075191900969170979460298189170486601502625", "2904778979985524171206573028445379872240558084236464200857594814631031581387804621371822074061289363372523364167184697785570324832815972970658633551879143187709707164796663015180877412717910872234647704536817108676736661804878068078543241390828229923424191204586313620612539678930999769543756218765870513049986792/677408099044823641581658869221044375312077929976719183424865834811543737800956896926637625166844372424044003929341361734886232742770909683021563822987505236295727478159938135467975522336774471915167606673489722102077041330652185811196423400701795791669780695158730756241178262962515917389382302757366325768069625", "31270155809329751863885224732454397292230969002004953832354065319735530624996254695453061851449600345977646455072512400760539747054003851289540339425848681804190284451253462663731135337775088379954403740058084949675460445909826322297817535400604180338201322667139062500269285493417563095365899631360901732684124930296643108551710704785906431324876072470231424/7269578038000504017073007978844992319987411732848567116655821196644382777088703228960020894756722675887473977480537577509061256138261063926845643360849217556370868752909531088361229374467207196928745673402380473721018157327193509586295879051411183657185176812738231456253321187419224704301236205478184115996135940848503487199394612616742961108684539794921875", "432538822079707760382094121020421735679118830363764570640789368235407853152380328891350816400541189148550353337874309885334920995713154225799660601389784410911658967499100610376065640785585342035058364676314084595283850213942576431310823836792440218271879354669291052589804956435743500204185107215929849054782893113/100246574739326291035824954677502591279343311051719151327066341370995390423713403739043396503785261917771859220535505691760472395306543276314938287868734009582906895763073519374099272340577921671298878837400921045252035507925021904954445172372479744465666760762909731237634082051855588025732494461939980856983552000", "1914333673689206389116942789116917579088664511118582610293383428712902211612554212779880638065888518488492298586641997844141510832940409501694726851666478650414191249534733087933879981733561565249818572204932715347752949087800778646065986244657260832234479202201129845117955957242616947361016603702640821256099895469088229339240402478576285854783063612307200/442333801076281757298117784528962837115323835962460661601905131618341609371649347131724700192551574625400701487125984359494804828935577124602622582550626336986871791407398609915208114339012374456785705161994343348351473385887949809051796407340988735853810174589261300681030826392672282630613354461927208579993042968520650313621522933214063366558703422757071", "5704691626402072213006354545292364761246893919997531024861408248746241619817955824682639582830486790618668221530365426203424888737658778881721063941495350237419723855000515747725926735319471480027293210991869255971365522170749568996651406002311020883635577590045650037569906001924971041810547543163363976464780729932/1314240362076792592671773873754757443276256223533339004339330559325754574023619698171225777585408160438834449576526997055649849875516310105297894855264038450585295422343454458568152668980131977005808840141079502436391909349182185596381509091427752151860204235071122788499996991078935216686010888734471173124487937875", "451219364084386208718456142329444023337343409261545444643031014769484085278440612677813682892926852469540118625738238137458321112005189595703619178533263706811689687213128887082197330137502064260105387500552856851972124172206996205919556553246133218441769325133725631665593372188755090094541462474970525820334385058333756591222492801647110594428922046641945259392/103648250172203340865458115839764297558925693061798169434516001775068769911768281084188883278842546791612199025413573394167639925287068809631958006622842716869211374513136766899877504136929177267362862319748507372147243911522667591375015611312165464514308451222180272935398828092646393830572838772085366567154646425598388620105539619174837489536378605144891769625", "1591076564577634575701791393842535460875733974464805197283632670013516183281542903377750304419996681222758401497321278555686661981435637461350320471258386388843198706277657208526372100698700615835733712519332548607115875288787602084336341594576426630670911478276101702119972195558314357975365863803265163991961173/364433108410193393847203348728981296285742202617988970384277162225847256295865554341611171460436362780497179090329831885853324392923449579538286804729856000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "5307507148709435807261229345132535134848030343901300324623409721698217134932866488937772986386501538026693956121121771089740095760486362654754229904633476234090792827930433598453200536551779789049352131005222659995845427680686677324963223653949277037520711609343166926627713758990384011274777087968799793410506391884872456420041494598273703914689586637995139580794368/1212244290381524115082005575105703496583315188540177702780216570265159923654197746388568151706509243638302707511238539845531608313334248788980188054651601536067740709977678222790481348003085034888244447626347312094586389347535167903408519024105748523384932942441843118813819781347089702286481924493361058339731949844620763272778960860509570622673048786968660129650125", "3046577098843580578619955603029073328361298436129791931304665777036152915858575282362742008136721284817899542475666054101957899858138590963789072530710775790433466847100422875906866496318804986202089528198912098377828580031852152997907433335176267300286466072997014023120087988748396598176622765923059385876855303940720/693911859077752895978833241338902695755528613729508555938416419864772385336777924892434701804078893822446727762077537955240605927550548046309823051841326355655848406646248595628715185413852040295631448250459076043816328082561248420925930431777502622148019371383254316636979070731427737764160145097293260938978413488819", "155310926743873343426312607182060072939030765297630534544899230213054714482456829198485999782086944271490229412707980997432528653509945301574794242118433868747172279224118534460563400440670015323324602117517342201640016853927923976796453577048995243600967202462466681112804476672348206491490513419336308575442086511015101999847896197546900512764233674747415844045184/35278162986589659300679088538176070649273991865663041616088851923111175518405117391134863644540911005782372831496121355954470744169969774540892096320978686548284501139861783292226140413769665461494668479430833892857992401391262903582109993838728281915806394747833588629467613308837196269424421131934859079260185052081536487462257809987002198437182539441349474426375", "46729591025621874782758519074451728476386657576036360734358719976400940301493939192083339293779149127132651616972817165172116269307276487158069293114860391502484125554406945249728802484128756924044633825692779783425628292959170597009935305429239702926898931975023598456207165067568919757902764815108751735753431153581849/10585868084079030838651390738371141142245086465033459640458366146849314274285871375459898014414833295804139979016362796357043372316321872357817727821559232353993714062535883074661734509440994664726425399880995133711038483607773782532430879196405793694658185175583691180757783597895616920432527125993118171361116684288000", "3736372348124144720852190769710129461145889011598636925228657393934132828633132357232883470466940330848177425542748100211498184494252714616379450272611850068867816250209867530921278645286769418080018709947826876461419654782341309127709703626401211996255743831998918894661053669189312375159058718767082163156988766821194002596331826150321864927832618126580509732359424/844176851007504003627016945212023239308348428094023437269532743221937069345682900884618378849283002998220513307273333096775669556093005637615012750733216460458689282791632437851364674879152695438589692227159038555722539345972833161146108367329370564838671791241431125003401861887477969954740544092178721327724620450947646209914621007186497081420384347438812255859375", "1258774755828991281578968023382624723772927642002016270484090409043454336040857926581316994594109169123354553321469500848146015719851609220423736153365139804086413284787598253618361769125996755159571523632747129480387254164008968993734442164892486441152227433281625391753702577143985047832519062595123255569172968685060844/283659859661671181526547833415653453506477950678651675193210969173130116121017723360258249430884213011988678011357458727603413521688184521573094783291496368005697481333739504490647194454695504722542014845706216224432373442438242355188461951883454664693262684873988061018976711201351382163527093784753398257094429403691625", "84932063355292829988908961192574710493098897148701473172754949846455626381329456661808566365329266898990829247446356970454502007127269708487563279536825277374133681167235811080298134899629580318813382668399644553111080625918213250223197440426147821225593304993621451053135332451997633132772608233430131400186571793929377129211228689703376067763625568623535588709576320/19089978133324852910950469658566458037096027722326716800113107848115231563787455584278193954518442601810776347091253561956877155673550458955562102935555510392954425196165785410319126098393353878286400877305164869548380670204577544630353859009177051698096136470072137579698473017257397949994722015089768745013713383769765609613514021200888647472804720456494757423299627", "802638881530832431828249604040579750916118423833791608589560402449036920165704012070349537114920882938466635598602387718300074733476150548724726460209016834416094317724261857969955414000155807312852092720310159572547644569797512233899495300028159721348599816083166712365215075728968005941610056018023633235372936903015771583/179951197386119079732438617407921535065140503043429174394605652913879982486051627760652197484142547447000508189455126493868229565647284332735552462525598465192073558793335913005459266977086104359621022691931002488052727597513413492393525660272900161375677499228252863529934576881596384036401784035248649026076581302370304000", "25208742399375362881099811032135575360109715964024747212026245529087599633280142314962581193303683759605084995818253124445773115574470717199218828756449187055537877478033129862600982068782249943150019637186466260707552416433010545437321814115233841687700051830170191107127799355485920046505591193770164750886037885397478191534797655616745528343172318318678405576430544896/5637713398995569614196397857525646325234056219513202928587580534159596897880731043336790273040813044077153051260989730372846713618900145444802234629922717464041261370803598799826604841654608724727320798324006129524610666235998113655193642594744544226880944882342204407750193512869672849910003246504052298022468012594459974209940607450480609190841893267203392880360823875", "732332637178584560220688900268566130246820235956768724845747830959547501950765063982943061181526237061809052444110437930100210105274824607344902764184151030827266142225894655531497849161692760385938786736436977268616029862577293984376170905024712952813234949508186306774257035535805330366742322777611063402455261391021097128/163377988152179636922409938163005948596822656868040662831003991395905185823836089887990201522673196719628247106777881741843786365701135555917263285268753605514812568258179391272113405920369587922702002732667842511108732068683407168090725712401954314293193572654347237716691784386690948494003094992876867763698101043701171875", "22391374854299462107923583267570593886002658786775211597896252879708753450794332301142909715845151746786016535157797023153041007263258732991465037648536702217273897876864351559736449481285518249846264600935543582562018874574655740660800634883403597181876364712521253650744197321080655028374602772696770227741610874399454362583980465225235674816785988164157351243193265401728/4983275997188967758382167867656806681565521964135131710678447245984239733544941881418957694612909599261843693554043504855207170782744518943778096768859337980470219783210191765678908537645270392500777411134164918803949155037581108678968701961544979451081836872425574123683574475790997414488641534074873248802450108535183413970057319247033379016606809226547805269752123746375", "21252344995592269775107236774689012760750850598567799560343535731251766780016530978663079386453430272698006977668063208502408607227544322945446079708000304179073184745623740466334127867464883762843346619853325415963062181018736410570113171387891518398846617197097407612852037905687899800932343156979591740310928257766081697645/4718515378484509142377558412184183991357747235892194234377932213613746008373918923611236346330189287336493794499188640380975364991548794341177060325509698404571318037298112293926833877103554546466055612498927474225619680186119313129604319096374924037870803554153458104225741255753314955115645304948564151765516183663634546688", "76703085666560609319365659209445044957052359500745196718269665234646121134787807938680787341023203786904308047981099228357850016602203539979246579454229078497537148799349353250167621935384193502383187510928609818011142642954550330069991570983902841318203794113898871515702445720207144863877026526025447819537396146822201819435536435835285098485990260677737192230985069824/16989892821104122916312992616665764943723222199277412857053896319814438961475117951904867066845412639236790762432996309717924037467863024360211163971190006272168845197000304328480920483651558672879967350982199768255256753110375467976246339260326422891913564151453729285191351273342206198366624882195135056176502724912849575385576554208844814085228696838834665339811027625", "40153831166521391225489894857551838468150576827129133168972859441122728710165233865309084872159583787083130713473702296122465319276461991457173085312407612757280915853584698420083436946976844240063731333638150599017886937783470942007376523947840104246927580254612991191040951001539641947153847776050138532219595746056076776809812/8873576113581065493273519627544307418139908640325227196912114520903505426722086265723900326735989771660987609604507503750212298754414472822477243293638486047313990878348820573874809636084574108909615044524663712495422565151340037564156235745628465172219286664653343193162657374410926171153516871765680561505768223660055617934625", "200736374277835272485186523480177159453030082779872429648449412313247640312479214261681899286513818912991945046297334418102711629933437654377760028476767482162031641781499114859553677502002901248124750539270235098492377826240319766677856465093871367817683734079621359186477306173620331748496369122143019303740252461824523590096923561928354020960176605008889579578495073283712/44259440065125442964014453739391594153290923937737136823355312892557975399035370631521014554980129291582486968083228888083079118116286312583989433037097397252506140224404130371160608365777625538148303917306340620019882928744151294738308047800711028158277500317134537540772759486365658024194428796846364486187105343266398338060080611643110071184992193593643605709075927734375", "488459049325494693259159444507437983381645757291858092983371672334043029615965882574409808932509285079401239403272414271652617474184321852388397021836909585659327974611273820676128650810907598106588433939541654215766888212287311943387232664417347883717203611092450971786083806323404432266197250919880225892099146722474124874256523/107455855466267410923480140898552598306699341366032095904938430084768624148829473848763761936703072253841751966906142283640379336131083461646777390874405323298406517250231389493084918065243079819898691146841695350589992171102939046740169198394671965069747042621265775948217054519855346617967866614303497258042439052681849864192000", "8430374068596413768975326329313648683222744787097373111477788794692418932056901235174019333392845529821722488982447683794746518712070635063397464904489452840169472596494433874412726723065560358405027764015273789053064830528919091414531400589850704395887250756457780868677553068164933299802944396576360356896758745030955907258232257358056931680617626606715393885378887657377280/1850480358582748412767893656294669486390769246349349706200869446679212812264400876685764762211659843658541567071977813110496329850010288179702589501255367345935389050373021591572539260951149696801665953123597521983257852207280970577287472932167362521740230973547070264273850381896786822127290397075758780174083415923482640313277341120938690594859118603017930500014640169211239", "58273615882491925540881784328370957720539797010816130007322211512070634295154626813477498607761260613353633996451797686143131893884559909668805628269959901044961666535533876340116728982072626875010391195372759135469446048394835148654407846242721443845351855234347422256700864370273092971804207514736924787577569355949601385705517152/12763172138328432984573837529764902730448666594097466544652830703737195804747682450548488162227364538052585484418491914323658215406327363805353540266048943197822838925184942600367647278764952826664684839953902567694832690683467635727409976388280092262839126779730168889686628630302519063225007497707028600865624133968363921915016625", "2685278694947152969468407055109959900160804835228466214479525891103128459065131221736713585038130737099067040196326815283171857977706979990467444622550497565521863441617001097354649972660183038850033950647594754644997436624623325003537308428828750008305464174443210079059253920383411910911594636045517662796811001285984447671371943267419151220518726940455756833040934506414133888/586864816044968996825907488721678304211296267371936463272955488077666796280028127333229453342355554450708284934221461946991556216095213627059047984199091625921432110913096253352065238765240063555347292393427726758010888546427415276046238297382474708612526770055488323003698641493939145624184943388159614111350839555141202024991876221874110644879676602924730506882384603409121625", "27700345710264347957758638741952394530538598225904772664391173119594616680996031886665218221392453628824570256438960349220263575741495285780845399187013582169907518462437966962923592601721119258663490655013419675469864809004562272799012227293974254329929404036071055528766397079743200179924243479370594973626764330855493789112414191/6040997839051213541001279276287478343874107660287651711609067205111574718442229224212245187655300348484144001298428958025052162253854676210451657425437588244676589965820312500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "80160269787574270953020489212619791839643207793889009503234879683494928396231769167082355143564723274576166638869430572977442020236299319718643894871736539109822173538266278165276591962215927816541165548699380129014840956895931285215480350321259054359835472320394089646764361802445068798451796525897304221529850133401768027469126408090577121172238802281079916258951770135485696/17444957084936455555074876721808241311651668802091828589911310253709517226715880722948267977560381436307152342821304525073651379763144281678911047276389231713860392794975453518107055568765009486973017341479560154792340888780337029481646046233967923289468141293699236815196553819373828280398488966665994092877680860643266914861837639322607761804740256920429518434353839878280875", "2352816897072623416220002134476921108405735955266703519252095150412419264317091785317803024028565851487861978477208755211589867803009700996828082850796103789009194767813611798769297617674631277847910238088040257037678126316866517601388289837575778165301828137259948173292658462765645645868094197736382683775415645307647043205988394700/510973411316690313485681833991645423802776865720580280058344111363363091616558230182669376841383375321912553771027107891991318313938505988903735114191313214327683449514676737796942389784957658395806951715454372568523597420866050825822028817422805046287798054682484158011143949412956697442991898914560191411624040490122951328364833797", "6403295584873165688372907494046202150046769667837790834896334486679541887567517050446119511695248926941383207478170182650927368177009669717288184903306689332746127845953193587519575304974203099873732502605739219028995266139383163062837007982999189114810534856227848568800302527760100163350814120545587074865568436789021082619398126713943637898657861949091545516403987546145915409024/1387794272010111535893205703999712437783041553900341112488641528986385462810448493444968969845352401058333929711237978223214186693177251566069419805757440174840170213159651962686467523533938145629444468366235554597245713128812532716616087753947246800626006504878203666972651384731498770435755225220796872155249202960801768048854869001310722927230237083418017482134588865244642658875", "82993247683514419570466529457059660634483860665557779709153549045427987672829778520201315148149878525274005978368939092115193636113741972236218502664881450367443614971109677363668874484696543982239492409231870942414193419634675024621942196087473557914167832058111113476295926250739099284241826553737074679953551191767148712684157318697/17950946423927357725787689855263532224005643859095168852729513034456208872420513601894508438640531171097082516559962755244698695622824386001219435651555513795509616906355363573638916895074349491513539093024980575852693293474288638209680085037286354050958859425647536735341886663074581909148323105020337857959651624760873736590065664000", "584891611376763781852144397260140844977346305541197362434227194779766612939978629636198589818106137319267243431810481928639442343946346034433828599323416877248326356345631611148749005937144684862502198147087702668524450709118588741606955966569427636630159793409544653944608958808602551061186799401212712216156799273254257486955348236914237644151956226336750212957092204830385441792/126256710861549838395499078249922986417488985866522660521294610280820007499099176190820291214370699289977888813109514854178180265382471972583921477022411657285850911270389720508719377071949050253246021921916685716353393018411683757067093259101151481189635423399611625009617884983318141463140199839724797412514785751549277231259345923662499623640886881048572831787168979644775390625", "4743054867460856425399742072925732465660626340183690464743217147109403130730445842673866624947360862438925194786600531200056131309608642363389833474026007798643235346104937733349791667694862514383520689594596660275306247615314272223660862212527346572811422915223417783887717426641317921972456913534338708745549252254865615725859881457906376/1021840037832289788284691535543138164288462770384961802287250236519983887262771944174557087207566030730743075334169628971336358708580124427857321953981475719503574867471090607795242192417162791762511940848493176847925838738242153177311649130718886794249673254183907621449520415060660496225939963471753122766421338241291756892571824984344625", "3784664074155769467702999785016514468281913375341134899878893061325465790589101335015569840325786070795267055386681356241209412947116340524588831510768864231937929260236754881829005065056310226407358204278658699999612596866156294195316867934035877283950841910726224355461522065773816109849107487214275801829843762482082803559183694631856772777313673086715631547326400170962722842240/813783281473223559981291694175087508812520505931454895884442580280342455516154674683217348039336712901850738745276445107477919518905155156380620466135946654952837573797479076027688866326359448543065305071605591497778941561986579230698384305536224430794233462949056326864499827444363206162251104552740175503996670997705423888382328014210171324376593090187604268086334796245552762333", "1946671258536842642381655747294621776070051525209940130115769153666368932042152311477746728678182920842238801763565726086459485050237860693394471644023999467670017470376746609892484192072297938254898880354014176373253875722410186683852253828299669530022166361304397631667133689128358365296701757782382475692465977794960109690362462330857/417774039698408581013003883929127512062321623871486379101498968145670269174833505080260389860863417408848209525427705249526516766731427603641806256289098209429110794311660844125377702016056984573671024035213045475132134896835814746425864304907974005950155657789157496389234919107772201305672421982198984613601511388413381215220924416000", "328578487723377153600821813410631465225159589727320893988991729306688663770697528156625398176929288628930496338036815910669579019719633124832162035588583242320537435554101841406566009219059042888412893352417446437227440076869427577701706713564212185163005644118869496869980925214424591264870388237079776503547314587137721633918824664946974571838634860386893404364499977966899068777016064/70382695927096628347637455030970644630942872888311870124896575877585692281624151103204551947776906510366521972834357031777287506848887607457751667816514216907338309372900327919413372044625602555866294337672022362865161523684052940126509854895320132828009551012639156341878073682501185688461720664801829933689280752623773789373199210473995823367199793407048741191786377993390965297664875", "2617201476921368517857942326432090876874414269689140439151907982631768946799200744678055980827789859579196832718849393046147656447672531861353456343821196812881882023188898815179947651274131166835133965629115749368441605680383605331300030886676081418867305170012032824011912531673468215561506423833911621270680104083533917562622600478548/559567121085534865189976875600841717161617153776904752351231210970240323460800785728739412474960421770806162360125774000625035522428160837855944215417821324758873127567654244465281354654299068546570789547691342609793050301258532586131013585959164719533123826201937801986942606844854123769532447570107525081084531848318874835968017578125", "636225736038986537559880265988431731529837451289737542395494683393492040808565905376235074534207026537145408562785279823547657299565440309510931336394031904920056464959974743525662459433889398003683078967642651812081450227654478095420306880762753401111260630654049389197602389949892636943971690212484981672010398108426002137114819838399222096538921225458913266993881960732663394566024064/135776510176793971074115131648637508758953050390591773574951317807919051619690313331192027871176160424663811116849856489187562728496099757910540362703888937768555824513740118941387831822900198029266206334350448626733139136083404404120210893986654422850183837974770675600952078956326317698998103770833069712616832650406225828969036781514645731022616236082175582937900731419575337473384125", "266695771933124633677367149389643417608461366874310588884377151539325854547826373711099517873721616543570605935954334944030816383858485296542260152894035979141266909050267414072982042090341712035518685997484257326212454742816979806460287972757626105526907510197321350895873473656215941034605746494172316089636216915825022339855304925515685/56811706665210352283362623728191218698295056176625217939528332247537278605113496147630185544004654583441448319260578659922931798845493756189402805173037491645434052737405379674607517658118427614090338938517963215812444779184193933749520313676564187507594274551791388039139409235056119788261689087831209441779870873305232021728002651979776", "3511806683161697708497547617957719390189982761002154386881580160856792742952365159764830433511949678304281539875366378131195670004345568047690216126001067194904446295336734931691743477531830892015690816210752795806120303198745685394015161323982229908105397857791180342330098240702332072396030780386362735967021055250450666535422528637737695053315137238368787607412459874094164027214953984/746741569878639983491390741637813989978804202898438708743258000150996080386381281307609038830698579358879333079215327202911977568726258527646560497079622703052765164031089590965199628534477381843079892123440214378949632707668935001371616475282883095939750704292616758568964786737752325652839226013335092148777788733453702438432279149298482004122593243860829060557386699231448957232420125", "499543951252504651717279461487337168721376180441322735807713499521878076780205427598086756686061009718016175215146305489885835839673419698751530207404115002383180054704927695269921072232395828258826213554806570423602966743337801741633869267620843626804016742412046844770601322513184123515405692795346790813502805238635003099976693786012816/106032986203682550514602969462803214831559442358811656484036951559991322084935692953211120289352600484987931812632505499612220494311324679562152078883141464406938524087376964935494245010636163705698220308243980789514815579319533341929989455211613890905485981353837321342730307819060825125980500975023479813757024395422041501208805339176375", "8540849722242122835873311629952985285477986765819584558233324868363310302206006773828897816547299245727087876984857726652932481899766510637403577175623031467933486823994040576431755172220921921877192006685053572215922347418846423419683723609799729359551828522978186208983138345476801247634773975311405913274552616037005854836040162212761099347518242200807692224460514057530656658616850816/1809694575992816440924165741094996511361288430727981159314194000585536832192004274726651828760263522962868944612215633976203596150606503849595633388319338251977160257979846235995654357082321611719654136058257458753105122024859078420173515189641515736029725847315662215778251370398007468665986604529263071981040014321717598469319370651877296085250322599247141397427185438573360443115234375", "51377057693118720457387330519321684810411289582445982078756989158447711080414032055843805733348558621949380554029375294451303430269197115810494758213980833379214402452992657502777067850631862453239349835215260705131864911194740832694498014048717871429797341104227759557199716944554347879767916801106279081864127192611546757627038037780244683/10867246748205139797826516105458406878398263495890048637741584969144406206902037615496936724683237700974333817527350121106320991054058406504571347680049945745432432384570515723033245430148177097144850158758462968940525568041926860856763884474605057056550146491001458649244094211354153171337463406192651150028767064600270112838159624568832000", "2517199821548153657910904242290029026229621935918771922146425373057248090467388430999870036608278542449661971830076845113363443421757278612394167195431759807908413353743377586893872930828548256216510734912027450642648789925142482023713336937258932978503310551945630359646777080073329099268529064437120002567758664419443374110941824106727218341795100740316967386497091058915066147604481280/531524260324016969370728057738851340792702640911631807178654723224511108065633433027773388768889035083734041289308124943130099580765995149865288328550751289346866467755881013217287175392101334538392596956248952430438673292186779006015549928829953979591250274457658042926539541422697852390294886719770034058916886894408015624288115732154492554105512936468520265305162358665491880968652687", "937159485027553069020805864547349554547661693803137696125140510201297417077233061462068930061915381468160677500445535971818609631674361074587732183297775728389124966713749450996643183965795829780345678634356741756033039293590264355732129789110416943789326482663579413229893878422643110852069225671783017610387570935863228248464396615988222968188/197552642195166614912991396771845374656891854357948006221100585931656016640982345159207601253599235265353060942313995345483862152489766993442419668492877390774016299878943454249209917002169480134131612530977452579520564400124908392339263545911443803619972765231094502745980083350567509014991735227390978850048088378721210219321877150756855372125", "5119346675109082499980756672052066247676641510661024682574296075659671743397880591881419516307292610449161239233139088348510165442597278965718490070997173182184417648987611422446347235659085092530927312760229499083348217392125906851921500360553758600756698605047197529446594606336369425040236883171542367713951500007600355406492128741649090501989105696576697387613035366083536629358444229248/1077349190930018641197987339365056771667455373500846354778079878558146320193384166982231171317419356136237346389570422332278447217033773023556383420372685049620361481309067017697564760747047839930422553324681218253359586320952896352245366885171583221864112040038531116947187482413031483309534553461613717398523132176948321964066833901215878133594739833910960843185464241840039390204295097875", "58469980853327028628854378052548435225264353747414624620847476036979290604604988637469977624105451959796142112200285366199247075503424204044884512269071061176877225315884188402954249683107639777479663275428465242905314418930053869461904934138752031124685541853599407727446896558064252696813370692668496452783003306386669962110734257851955001481/12284458784412533668960387046583440199646081362484321078872891438551639470826582933879934711861551014258493898870867541349962531447724393381011633785884743889445407749238183080941846528000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "632694338036291086868292541736272151517212971647680989553388199374739841494700315711180961760384484042159533979873604395621016272772109619401112452105475906812313548587880899058905419220497456502543971131226430775692744506047039958551641270070996110661036371362526401525207493270590999387476275629412687473362310414634469788979236895300129227082421021999210841384596617452097273320509348159488/132710874087075221626157136110978536488168313127228703025408943153782802265472978945703742152954881438058373686972477195846162708986982742647038014147903817539418442869011995988024638278746664230046452545499722614320284478925059527086663455478374200352375121910000967044366831275681254530914306064535110528723482282501358749001657608122307686482720926189537227492041135055090784059994118192625", "2022422468242151190347511883185841333968390991430363660248687284021524206079162212007263606819387821055183192871951076644707111802972354128011904720586729919826758651167984507804867954970064938022106484656560866447290934136610214175516487579122328055482392137619829739560923807880779865442016530712986750711199998190148885726144596663143651240/423528009127070458603837580844559347493775236970253513203186912091140251858605354218715508091394564000304400858761758838182654201653901408046974668599216804223721114331085507752600832390227068985693006017591304916519540245902645712532993889000048992026931475754508248265356181099817467608863068068953756055334213584649136541490530849577363647", "150542201776735231618709653388506394887777837646651406023174643241783006776019388336318216053045300417086929061565868663031237502137150880313922488106751241006715449458736723129545400133450376339156062387859536289694727635468338235084533552501618659272047966040838509286942825414463511175531001410923014751124732748099355476332649458471135027773371541572374016038525336728276024676601778299264/31475618522527975728853391146702172347290819252268551219771201846701658848754300838383637247014705706066050673096278897933831272607774110183488615338021656923433335661890414740664480671162459271850877855521869741833030384682549648626038314686632195158507693321505500888988183270276134667071014075017317692121986144742473139078857816578133693776368882596780120407949076129685719314703426278875", "162664351499283182546788129866259011542529017155637405328005084357078048074065548349602626724265307733005745244338982661090506394708170105916177679714664432754153795772811389612700051002336719842784098507498286260450939289109123759859710248621544296008356071415713931721102824434964336667980062728653562369697289761913925215639430496443820411811651/33956433298509232632327667206936379248172049619640091186698677954874297837764235300806836350019565970550533206216590639008637925266405524715041372407701947953283803854153876844320283735281209725651036513491246238622967031979233265136280687995181375582844780830517825595245506321879177965868747546127685256867456319112247572348416655367667187712000", "27228583713734183629451808889147559240254570554044667607519238865891084165382075658707675405673276615039702916443152954157535195508033284355580742761569101934821088036084480297442018005972653124248838420021440899368869744141698556359295489470499243402799483082406238128875386939389123336303631993557844565927960009744780823166462314116039469622216263221278402673028225214534859076857413557466368/5675134787340359276387085910732530678163604187009567576895331134521132071092293139167824957253050637085885426100206370974479279292804959049999647539684766632278449357893560561608633329561385765035738071726214510832066885156767060324427330401967034889966727638276371320401053302413136551142103678412692111973028587922399670456670380189570979581674699102934733563330382821732200682163238525390625", "1340937726818688387636018677960518622106989311577445614347061615417831160296369500704524022869612973331444242000788110133157689786976834913297544087249593601420972111789552905846168933014570399562460789075871112224533723259660967481288525220689577290386781169316008987012566216235876842757183233207943071523447855623001920854571597886491163165150556/279054368814522483241446594911968519760869180429079780837994812436395792594449929617293503975169489945136244602350941695478861584261665582123038340824700224583170270427163469762789603657025958695551448477050958557681299495041994050951692916032501884523150972841782658389836059236040091605838583126400660344344601879969354053137568588338096589095875", "8910951660339249479517731530773509037034977353457185453617569046885132434552771722727442649095007828468878374139001808825741829728375370140505088133244952288239619141544661695065318568074863317054989982620944602245967155400712702259180443238473885690297281525960618905625084639870407113029712510345262279507055197024677292523214467306898573956604928730377318210588837126450942086527893437954864000/1851573255256476362977604759655284263358595254392797078730401113550522214182030016660458780180636930591149034499142464357511158868625309442843792189394292787657774627425816694628839987456477799348874853555586931850788645677998004186437300173080088839930384424797706381282430208961565555953254145002318893188197561315855286173276564036402546798318351229978103276843822345004757661005876638005274037", "84997663352987536417038496128111159210386455419431137931308301989414462311135708114322046234708053448098538629166672456703651524480738219822858469100454933583774404032968304328859365484249897913676382909050450855222567147661842184538302991526635974158862033287154321908483007506326807469239745851379559259262425675035790574846229470041596801343087041/17634687575122715507915388096857069366146981156897230620371714518707518105157483283253374797127075689236298114335734874553183291806268149747826050838089931351158483980735336772879045027213982661634865556129548356487722537193914986994283729746578044621115589195066212043187229606921062007047940293972381121200723292297716621231320254309060321476608000", "1648849257486312935416274009474520589799750757877252390543329851029437452988499485179026845292068377957697884739052491455807688429630524210823560524122596610276957537756142278585091315141096146341773982302888007751632401090642472506538817998043326415693840862261701364114923327286462650797963969289743571514890723145251583881752876340628073395708716735192690808352188867334842743895738955762067968/341580411902962140529547622267381834425264893226447658723654120920549166416114849731588552578626041597847002946105459812230979900480135423787717825697955152193526724029890829615845314765605770060975538542976523177976182401820926854406945392167140347444433885786340415437006775075196031433365827874254477351374236932624514469241634422312990555534789607377023339236417434574755566856489013828206625", "4899626659231633406569362199187192352933567344960498139854460545644210119722856870634652562532083546344965166340063297647520613455037240144734014575196764021102614748218834054157165781057405100578668000290493431869797883155764963238760612333048336953434663867580862692267574574465371615023999531030446250351305046572267686566999209229202587258144318592/1013522377571209303732207048597964555261512342860326827024786500686692475697570284120359840724596444209277948648863014479460188496587721578075151793081823795161404110811480269106846359964436993190293615381593756076515012514100289406862487971220020752628653845345780766244842386136740768474703009091552043945843632199999007070800871588289737701416015625", "362903847358088423032098939589019598036593525722040887883164115981767777873860799955715587436566233010543937498922435963385091400670303956612881974450548904906949032005878241638546734597308786514086678561900713741746905742866635779432216761799371793260025549698865319760786921444505323758235164807966277024031605673481480590193724980659448692487108892154809490199414370023696404259691299614147712/74959603173756091922435708504751461448318819548943586676159545028063979695880930926805574951275602951047845904770828900645717477098988124553474616764040938121171776556999069351772286262529729056288451037717198273521810585868307402693261479298923209587143468206907278220909447483738730657438961435587752873879244136801168836767273934997417156543866722171766794171623224855358640156858606843576125", "8521348154958613550574095745596657249924328336262127244827955886474742319277424381360677655239017583606851483318951440691757875270001283229585075137091617073509041644097526047127618954293881264113694362598157456878784814696577083997902588926421675843291157049153701100218784481406086810264243143337016042301806376864424632290226377881206765051896745/1757584673254145109614914862134217345456065873908262753169404848658913774363650863904627183104777337461445063704655164325930891269843669860409763569362863600932267319335889540453302785099532688264425988677082044905948179153286276609910158854349711054144968131934713419772852663860893241364433872853338630216232313607969790083448433666334742108176384", "1802461420562646993856730082999823508145602238125054717836501201545920604020389361370931345491160549787411668288359013059160331370751496329806488246135100776263777863399096485894306306621852596694700845918608199329091852956315870664531614358379176680326508877329862713333336188556181470928613423972314983964578645688876556351433429494008513812136152576866650152623510296911708111085518974142728903424/371238439252064016214448115231139360835481920731625321084601566992497057371416121407293286027832357816257507287295719261141426130159269433199862002841433235955835172774430690352481806933860390015899973299268361513643524088242973968537595085600335021120523852420135081643310663869327371821064862449426404044951571585406092523478861879148545678639697679215289523234342337347529225543852787599016265125", "88795280670112240977945082069219541902481768504536167808816453021962616596410396813316064685579412429940019071114917828928080181638058444302439626425155946562362550070187433083541414569447612195370911498321149367969974762244140788494955146280201020345849385865084095189982291190135293114489407801749533448443222584092575861096946605418438181411489276/18262596223069549313969288693970246663726147886364354584825624311486557881239003216971630599389642752648815377795018130449384513824927138566203714891090017787258920529990523519479383032564209629983810866231367438270859421572641494420831435563580050954867101292568399107965982704216434467243223964964535464624988344342084084237484262612100980519602625", "752911409358158070688133336918078236438086521781731735123294741731669530734909563155732092406099003582749182967246236657021875488130304108082404134004381196925042617909108654109138702993903561036987511410396567636331465803949049946947888490287210013788802287247422993384874670368649616782837096233384279817294778916419067404863458318451722971117669642134894906235066332205740872938406767767019265664/154635332883086377656813458754577288834216641577439356891585125701020579768315520324293435008561626926046988056302745604248220408154454267643222328696606367409715369481567213640103076112146615938180089303294709009813772509602954514391675152597458428326644988225555987883250642389550531163153338541870029415077982539614784206119074702022117790679351778993541426110436276530890609137713909149169921875", "15286089077439918584953144558775765002061832952090847117286473868694909713791678395221438112006475047633028543501632631679316850512797978594476229228325228403849089079675681042224057234415951253954044235099139983386056610384489202589484570852048157272551098909455253037561994944665563291526597323199530997923272894119350512727802414680772513760081360291/3135161418037836259442831302977219750614726139657718770206960776514822107155928800694375522572523712277389679035632531727155957120566617736817225541673148354829212969778664144907503411589126111888917929495106029890532891919001138770210977012708107496187227751496980000137223047079127096028939624830654227758737339725345681745847598157538483308068864000", "17723482381737693269787076798246423310802126092500438681864673375704464394105734049099094818738115345706100191580982712146882034618103161268453808819471603805345990162762722549964406042295355916458624836894291267553138041035528315839108252422478610879301656207772491548742981990469454529537049123948604931661837539943536878260665617524824604291547373872716194154198824107266275716083848262625068958720/3630091565725887087605600771358216927099748013831912080380983545872077197366172619225751217619097657405660172801849926220948413919823038425519006413005998509677472226729295278652284861834178791332630676772284971762683579047508016687969040658592436230062049051143001484384767836353233324570686249824980508520186643477313941054900197268584495128610811273834192099099592687485176400539748616360799518357", "39160514032490258389003214587901781721548011632821053230881239001436341012396166857515197251499460842954863342641015306304854226194551189224721257664420778416733889030680295206179109679627522113592373938602737416822981698362363553492610842201005420727750505681358595340127099855823746410663750133019743170700888375554918213182862789028531284364877435896/8009919337434786244380818390213546866794958389603666737562053423775386173149395943310276429895991903753441584557917565343673605019989336264748588735390182130334278887642569515202100870042209261561001627386525182096090194076839370589780431326097965428311786635366819094633651297179987340498215947144870164066409654464551017761658775207392803825996394875", "18188388167811476762477659006849121912679763597132233588170406666718758511478154418948855160838212151370453213943784067796172102916618102024199200086478021533171984254799008541948973652219533819511807681148179806051835318645591102296256347927018942348574774821478499092054497390790734798143983945096982240517058861467440217558586822663985584775920517755909444876443211404222400335500608733284461685888/3715278241795087610941547133490827711133909145414878217965273061493740719983191775105550559905283733134189195190321643965858771461560130864714477448011225816210219450040558581571206711791272284197614810026220745160693898421068168630870850392739817340370146186703867097982858560347971281142766235850971837330222970900661653800041795020382847588362774677568059355238174402415384788280852059532958121625", "46353430636874284402376008361176880938798775506236714098123916668545331718677407145199311191108199195405139575147933283523305343027297808443653460575141799729554209181454676876263582758919969948546918471128299522715691694855904535448703118221685887195383025133924852224568922999317583667985459047407473419196367812949579858081181660610155317911318937349/9455890179897829052705408931064120820559254220394152447502395298827357144081378513080398823188243663943177539817982481713456798757563952162598464929784370305696420245648035222083207596797327498500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "13607414211126412689435920170832779523235279308039712294681570127241403406455725064605210473923965685858012114332021572088551127762628892611459785625407107300355287623761046438724706918300976102581928643740596336865698485838431972050267114940079353996100620311097561405192365496385584164725035842307146351211183443267583872067352881387294766804298681841402861626441205037637282007810811602289501477350144/2772205947240095684743358245950494400934136973845543049938212403703005150954425087866758842625041409060217562878157900197951382737615822655863548356735553650755342108183641353142157728364469706919993519071329069805875834057743793434164720370026073143626055293058601124362130539040404491770346043977106988100969901297669523170508321703496903672333781306743488573086901583022550356345156457496396749797875", "23264350093315690507131500726914401771633259602904894387312742275462601574788485574913195967854009886824436237740789910851843045306673524324611130536719802717912615609109285261163220007241492964833933975789257681755002054890453747803418465119567389315754801791950553304034666399677630030683759466627797123971742061866928213780452325847848901682792886840980/4733430508316851445525799359992627142007028326865116523033957869609125212251136452396410236930025876982265915963089597825393317909648054808274488356887197933393799241941120691826916741647173843634076299630884655997401370400734954098249519111198509015387869462198674657171808841005212058822254513429836457539629035675822719720295352508916898476137111981397", "538960934807826161927564251064896730663918579817797131801326848839524373936888402762331254883505157846659830555799909822861853145306547699817986010353774500545305596630924815657016569444824389893996399550343022444937690798126189162954188680257730893424775303801562327757655350002001080811866451425665301674688928515041429654624970707803336800125648742168380676815769457467038849213225206824671025803392/109517448833211208909213522579666376007937648875042608355810687327424621469323788799169718267715808580775296460944943658428295481347915131091297305260674731651980547668762317138753250458639043477453950774629862540017034566407286963562574188172753764978963685535201028286359818524519980885827473904574840285411260037264057197155527809916623487144493019982419606308144576939532055057697567269576800542875", "24451481554350251656598350124163983489544445991992661049829014268366250968046589127810466483349378560701491445658725080497078590986743512397927747885285095846398852574219367580068049729894667374214861939897557930527646930793431512683750733092448862551580494245486308114129295467976874843852138144539250235632985676953662288536669286915983261820949386845806781/4962240683851186225340479316959605207278948397833849899236383273145853045488131674290332609876751222112917095096150531825255611911377071887145019702433883343849119017643117746273523770961304609989779231048095665388209125939879595509516490230961558353074751312876252070889983946768175488341370453053495319823381943793679003096504200440997908071027962806272000", "166591964685609920525429719961758335887941461052357297159523350448241484106515158310298216150030768812873781356326923214637847449893575074813991141092681107583183275003570804134461187213143832123628701876041315736048451374824101256980832991214945762266748755723551899001458245164317581617731332466039757786839492869211248064662857987111284518155462148044812626055842061283907063784492325693994911811072/33765943466859756347231737285768516240749714264564410814839966011490233598006227246396923594069488496368994857718734549787000213944990695920130591750377483911116845697231074543526982580529937081378303555262933800375576494067959129682770065443667091668104132884375840812635624862495548888467575848428463895756394050252457592540570490061561616914443009224917652440212112452400106121785938739776611328125", "142464729519206642943985715465196065680101634264787375740459792619754842396453535646509170066091478069799080172299369994438836484938378991283020978342879057271045033903518255546705211647900945143546293360496661466657600494787228476009216508124736254967761901224547269496682078470378676865981855568197705507111970901389105723589666709580851611656838285777566736/28839643075889294346635430272525349651555039807615358795334663734940126053968249608601725991946342449660829847322517564370606746964714098508298705743689729306507554363954348780144675937510900983622836770223945538844314468550644543502501484521561567788992156632892028591678742014134130878101553633195551605796158103033794695984958987367799607407626319024034625", "380457154857422076784416625436182734840012277442496600178664323821064977485271288502806124740204295811759917468598315932331219906040253463960961995849761235911145436552991677050565022181516596464968316292789048809559129516930574340710998611088996508613850407294743457197519091160170604426002924022923388338999324182261954685794522778833029950214443271526469607532589775916381786492089432407550224137344640/76922142291839859196033215395526448408989799722090330866256930898223012427332209054699494033511478050536463051459450844520020426942553107946282832072826069342120835351421637970462054707566481086202287686453371483126873188020538661871147778312986131920021929455276187425940666580158173676284545586944833678819622895550345083175685846944633982680908505900099388037050135210936852210263717185637166725605577", "79999800708369666670693340813609265988600461251844239982904928629083975986385235816587497657678297663151298709076884516168798694292862559083730259839524968813932151813233366175091317046758260934357096757322369138747731224414176608247605314668045838769433811781490030635374856042786947109101585097035794969502111354126773165391577217071956928171336060247633607/16154850265413610119312596299635391433380319311682208755390341659152160578366244774029302281068833963848811596545791104919556346810193385001196395489740571188884873246131813864782581356887110499639544662322008824704830818136660544673293865921754569356583698951612797219776290835161780326945625621758204931298948625885081325268123344406261740843197232316416000", "26517014004241498798848003208133111307300592620947908933072661812816683085261359696887064436611747292468717739609776825664344064024535028242737616786238200200498291226984541942836459188328346609549239724653950302145388877472274074665166631509490297630344351573245265440164082334092997307729007429218385933622623935704482371360985836659823269511115937443161532987660855490906546130131716829909388620539153152/5348257529530073524280989257577050878033239486885664777340947102417077875628238501791711336803418503616042922880218860266611595594400020206192599559925169589023339295256084579966533260861249529670141854632965231468533448709363477120437277477668173149958267956654411822360053335695956270719680086524322530514249891157439878407417971839744392044064720476417844056346174795601710447583861127956455406902139625", "71197348290771978405602732839537012310626009318133570890482364371056186523989330157966045289127980687764218363064941391483781008265266963537623770685390148810455244349859354857421474277963009857011653865476081389968122418691934354122230780300833008753686234433642072919923583176333668289998661499146617277981691372057042930131717336250309680764289256080895092/14342680993892886303954853579883363225921109635079605392320944523109187641283117181461662846411912306480691901515655220490850586434947504504317080144378185989596578890875561336496479576651516902048606328604696610314441229321219627021610788398730173161473456954861916116391687748151443335513249810808309201830214153565966339609616397865465842187404632568359375", "342401018754023891059352629509715357053454506037284788725127073168445189422181540408896452651232759821766616850264122591225331120588918865882061344322996688880669665450231982002597398732201789017495427566260651180470635467002453249479483900268320570004293679361696197905823690145326531180324429318916092471863347575533714871355651558610515931373080997536792242278529575700808878786732127630024064418468916608/68894647682461956089382461406499759613691148650738957016015844830333168307020284281532026442272618372290646283794122772122665531108484704223311663270836645399554940741928358317884620420886609705267248656765357348477857852684140561714900614303731786621656041881975328169543884661780531057279582784036689401206706069028229798913082362331334839997133771880514515972024899408556517159759907883793675672065360125", "190286571838805495686895463752492174798162827967490343625540320679760700551286395956241059969689020885714190883323266375067607282890063444652926151862650426323339187596278760962390404656342309737428214493422028545912504503974763216230927196187743439226243880933947417760147785405444976177822143722569696182520826218120595298059020305548681823408268556482981325/38242608291912408815838081993045123864617058390583394828737640036167893859507494091864963383596867701436244007905770284939991912884465101575490548813894148831966132970730263562113961685364216989999844961688441914455435934703797359360780356482629495214859917249465567846934284121032247250332634283689409883499295469118485912489058982596725212975311140618764288", "15345379701153714436938289567639102307887273898834051456693981514956329731572600026866162286097662958712922836383881840211072389867463987895894067288699955858337488812343674818565432780224654423872618380928462939482247900055572079914753652915184313685270722583926261499687728814560680092231526501970431280783177357735398580700300402036873780385926225005561766822479878280891130232036389707452005183370152749056/3080426623087819678602049171756961824196425548529619576972793653585089380165862889092832375934535464160425580449193072125955685099151500755278763306599307218302635233595329082702148677300945556130106197481236122437978375963261172524503625593066102601042060541617791008722569799735202779005407381267021641545644264334109052258081225159748043792288699674153722046659880085850980843460715080965607434114275256125", "36443601662144279337033484452272105547257065463167427418525882851507989449375452076227652634440476502702584889057376829320548464677623038648843251719168810701744338735202853412651160681259533015293997501525430222870696235141468274274064390273214484922080219643095978640300874086585386991338440415203863901714217818222666715642467237183267303214471854472286478344/7307237990148312451155090506264642657872224684879860008436735430879314349554023096366846856470375025555139219961666754780864835035902856314981482268319886395881809659368275720375576152008289949085453326722156553603358879420820012964006978808113307340321824660484441618487292138631579616351777191144073820686595597986548374588839763719082323114663844043046087375", "1575294930860663922843149113097927168024893739962464327016763741314068438447271326302129681931564068796631337571133444163024224071270063174829664848259482066723104251718808936762938249028582992557822551950212098797718627418782376027133576209718376784834456568694813577764300716139817031545408608110880973380162736536313173329973171844528083756524804574267826691156368696436273087171467254161930265910972517504/315498546654512047637461608750018349421492986465373840347519942494904200733840189483934245529561231604050629653992944140351106887747105945984325466452136415067807666316202346895657914393512001212656936450425268507235863153258769360296536050028695266363553141327896064944506216017933135251875087069031098099192325817395958019524956320840925176589616439477134480262100237057953933117460110224783420562744140625", "7692057599553133417225997786980128299372439542315125030077404519679450372805989755158000864378924877036225189784045171045139667691524763609840822628706422918926410377185494048355128046783294954373197082851501927410350313585640237550107070936498164597231431242858771457898152684298047446530220873884022213114819556822050178579707210264243087257050468000092842761/1538814487241112760739561704846381585063002784795057066438330325566843108114787083741788078680861495340026117682606689156065008672344707615420501964123121620401073675430690541617930520947170306763541251152854304975131871537939618684186766168376514664494488691311397307418298556185724993104760692216619178358268934740746932420562664234738576394742559349407744000", "15190836470550557926140012263310230378455340797095100474720776113765300081463960235506950799869073894127884189857505951314428810423734978025409205413789025720642609035117121385453856877706229778165533034683130064865256448444765902482146676668197546098809055341050873494446231793312407516463576380102073171090898973046611572020564659042146465345334273595086941562425006763960197801018796906114925005810069684480/3035556598829526968124942916297025416522606357010637652635799096498208643970273828496655227572100159414352020909846298817521082538898702393916708804775798552206401718323929157863173504795127180177622667376867235806208021329981136637175570409791442328468473111768140746895005561471574356889047981458002257872092408771959478275534098789982899056118498417649167444480913552548249005268380838457505944462494874581", "2923754549090941424546974281011770689534961442264350984393235983189168024079617848190236639328676436485460311093391982825027512234467853098757486086492333410753919927528867817406389678461354257841007722472106464785557179844602277350411593959136520732862935740433163383885526249897183805981219416420390137516812715245569037561966929572448247077578419534651990827044/583599691615378545100950777601104007812792435102945248411439102112424251478512952087517463400054567832353967731887062349496616445419782499817548928078665212077449420216892583997505908858360011413290038645573504472422610780073975450391707084016931661068694024023083417126286468909117254531307085545768412513447197205482285022417611018126886491416133665625891075125", "441922815213568908489589193556560586318864326425397702047965372289295962228254658331201274291697626694859414786292266008476137667843874780506886929181835469302142365772763129838217316953835831059616268288399119642314758261677639945004547833810080700127847214666763863338091523753898362699222880772298183760217731228628442782431573977490761665091005756534420789258276075174436091798475838370152192077494553263232/88113527373573049332749294663402406454524640221866407165839162576979477138694653404281889227416977618913249275712917582743426231744980461918772793673202077716234026090308791893409200158969108910565467273725064769890443408324386897017825489615600787634985397885230455168591240328585041836771921929567914891379235573982442311269392541694564675053636078990836491104116280492254795616055818375774141667319774630875", "91197133767962483852278456285591810579974783077874307589555559715577599604626819245000672929518645004771085106770784762994476973842713035791487204122653245797126906189270204029735872508462106527240320932458036231707311992868347221176460407003487373754014365881209649632547685657666691589606571865740595829983849941049450471212387808617247938941417000965198123059467/18163679611214677813643455199979098261849405189805364986036911945012016248297645596270602508015864371788974684317239728239847888960155365342460843559658233069613218442910226128113196984801126248862273503232000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "733396724434554481470656964167233690851279923085197144879644750437402627936723531635898542414136943003236478432848965516925891956615111678444586384493883113385335463639674699443808084827715994137410743992130712903997815471369201406683862985677774155704267039224546352414417632475628136460919900347977754644214725932476856018335195927604771408949980634142255497812566866795799230501026066145434755838336990365184/145912495644159810313026420025053989609942265686388630266226856650796088768164358961644113076809511566125145395699271530802891523741636707532676065833327082092521989958971154798465784847092870457944857590623097781956884297103961713362268264159015928554707158239398721416218953003215109202771651993622244788505649098445109438104466256408060944298437033058380804126574878377874459371251056800895394904459469832875", "167606423853658713615749101123336326908381619586838606922565378505211386185130407423587264776519589295420758009764678759213587906216543160801059029133457062067529468464636376639307690657945597847080706144898920305379653754920571797771178341550808041652360635584401789901525709166172283390177673009483341826911179861584213314395893323035527116283758445038413646757280/33310364848744488727470761889861069993071965180756187311178124887286133554324042422503263994717993129539448310743598138364172889305532401505890384806078790034557049074169245078416704866867380089103064821732673967120808611636618526737138435792818828990403374766228037003927569643972203993263329403469747342204808360947840103843317533210523853631711601450617095736473", "22466735478643771803624909352181817912387732117378538284107485621001246177152644141853604633676939694208131243081227668237716194316732125445041260568403752325416203858329469477774720998849334961751541191761521224644520742691981372782009394826739249604257098248751626957528543558542443122470657230835176462612530464044652140581367666271771882198747182114685116336512604038833327707163107207664705120728068987996560512/4460342260599110071819142535903990817893424192972341872394014748315090430999224107274777695306032783105944721337053156074851240201179902835353097683269298594190456286888326067932777720561181760369783486872666974623910515795208353605697065447942804414120030678603538761538385793829787734830129764152263691296719726909633580318897787729004972323599773548689272008712427926734258913271101899780538635213826239542884125", "1972862002066252798837977155272535342727415329632252213508267781390870646909686724955861608046325765650407340102472833428905279473185818898693854344138403744757857928883601637909604082588338869612221777263582365745419719805587946558326048087138197694016224613118304623864709183681172362693106460535117459192992832969130895829916210933710820035479169562970982784580861/391262854245936198649509275719624152305206807261382621390946060636032376057385723427601113233050260359684153963520782285097664628279596618521963444574543409076428660874564026651742234728997339844161514273669735686516761239076529088145208958938384732800586298943281728435207452253170935715239392534815683367114290676180839217919539381651841151674859715992309727232000", "25408691426286653276004556426513401767718328640048945917745783225459709487487356095164164652218100925888847689099153320777389381851598236046402124684511968385325107497047025485302333503075085562533472482645023963717347867696861885363417595298751490212495932766872748125111115039311507374363000062513977436921772096443948159289707996749061007112458126301618769295162649600673247799961118662602756889448152517364992/5033870770817104909025512331238419776407331281944565644457345507262881100618908405924951559853352841154730802006750688581603270849880756026262217651685813584900300357685874044482329601894134443542753690048962260914642678445058891387041919581376195543193199307524572671344323361282633828144708683536721118910549933336800461248338059209853766305058943888965279863852107507075916981165164543199352920055389404296875", "616565940481577765011174617619124841631603944267256178093555235591208387588894068005162766513720546626399308168923904625210748051788652328072241494243040185611373035059619136712559505023703153194815611268503291295059648269772663939137446253437248541496631852986499688052678961495116210133458596866684413931188348798244969797973846568160999564540652111599082181871436/122025682149627484528651507368051367620578469392233875493556828623437869650284356703295836998178256875766319508797903923638967073687991229708051285605187358616531926112736402511567721889845693991963610192161413692928378708223712791930113386840109729368772998347036090902364801014045328348830748307179590755723160142468563977011700764517880467116766150322736003147125", "979882056834583241477188686550561625289337025747787132773853690143359657519481397575561812727394470125172272246774578404543257210124412718725081536309818383310896102958167337333430555168671327992395916735022711297435263157670501117734412587691271084981140167017421900852550822579410636184333142944411060788723653596377015359036101170054828623669169047118551010102258802465554033173968468183492058271365801755986560/193732066620504775981759812703028757608600125742477178751189607602983198559778039141192492589734277739017909889924488699372940787977794555519474807920198944109549023547259912324279741006975129518191081373554817584214941629021088206977532599055014150433581544599721903881284581257812850697423350805715586436114842183295730680490110793225514602133304729484547181740290534056445482186430729398701311563285494964645419", "1138059441890428903336718712159907364975959482163004276901676063186939296217569849990951930955270849692775077813359573394435924934540269310629731801376134549169322946310756738187834128956671195358413024062230774111935109203207768898525882417078119314003162592087920755572050993355843681931139257303484526223461840939880759908449181135029327442039666513325916729112853/224777393704985303260433439401503507705148576727364388720387174977154204629336985298082893443205223017966145098064861566754244624732671470935725326043491911142467178027013112527668183783450932992534517827863293825061296257420183669383719043873666284378647952385401303733274771042385666436214517205678674213118374889121542369996042313879258622144464565403138392064000", "614262617634904509410555695398092190166323289787703954329113412647342230855826568873946233136303566178604275296873234926652080462259552775254755109931312516616838091852915397846984381183732773411263828600108443070778861986849272794442105107285234729077818614332155890946804257724112143631642663084660012362691100872465148864413343598067567142977134846266425075195546265101720326272502009234689388355365794889444257557504/121200854655310345878069155190734381476914416893031941761756379148622591310152793328910334357724762079139509813381997287954319983165971628429295803162563856219211627796200599196263868781937234015821367575512548522790158101892507996780675863234181700253545912643548466256938936835469646114659598727592390628209362096738343417775009361678599075671154405137663077798419897932404104579113056038271753988669813988076515476125", "106893445531995430131837569895703697604978445859412739331042151546083234373443601923983714252801103551874986033841637079479794895452077803182698291822629713500021995241940133037200268381793282318691568234728329378829301282121562652452936297422136961147432559766896143081059518238234777055931999714973999553456547746825617168005650221542417216291412324174772893635832/21070287546583154895102927029203125577385528350171457634203261197137238923923245382493868134869009844094435068284335909266152042903157700510534904847257436666980671067329084409346149729385625108233234542133838924281113454526471855573271066865534480974484196644173270141056470857666632902827625475719738076524047736123182255306429677688129231682978570461273193359375", "1112742798776748551928744983308584493817112400536084744850969025063360679785378789764875076529575583792571198510306186417773101346425704969671256564494135750783642910394213727189639661184379341961737135764570942961692159177189753139209638929302928699705042832922774012622017270172331722295881412111812933593370743210214549038212395941675257558442878012136484052827439007483777859391215222647499741572327725689840850048/219121905514652575155579185322367175400669386131891843382447432851122462422992147756333729893028362013318264155489537138133372703295804002840920402482110260590055749843170064921843460498824128274420925357547023876488939786863662801268798987685503391058250902634999352652063668663245829496836853509616873246554292796823779397317819134891873583857621623143253788854530146303641400986028503534408870194989478421253057625", "983995170259637497940121707857673268620603982844439610076334749792119502557380361624096960070148627663305171311646851566811683351232268240169848810658089698606409195744471343416197434926513684882439596141368794175162315633192028977211909698595778839497844847281262559899914504080092844816319298286511436690429175757804604673752838786852277255064434365401871903307643705/193579499709739777577893639665643417521924510242119561765932078835121983190401762561436208758210519231103767232899529457440602166918701550386152070813526760823513884391055054076485295945972185402977095815609448651316824455250005505410192101148149284756928250258632031981439345164037318129987999546683113483700660879431801728391911161900686707231543216283304182063038464", "30691013076836380319652884848585431917439358375118437035944950498156836885409110087616602043242747413728866747975631727566613593257623099549583001362246649928075859944695060947434885707102684568632559339383409378997568182445019183928058902445738702610436187907199482604867148445903921474846103586253320950728989228898324829144701782792767763794895137313050381112872972806712570559942583906619373159053654481250809168128/6031936190594376585238407905469035598668211679521553144958053099463931217856780171872253258738635531385711702176347575597387389685526098889278278029314982721284691198967204664771178761416891317672705719303088746953644978471289001577698554025410820041497108311270431130911021653860874238212040640737171103823631718483572464361276703378587106311153455557896527384426327053165214814954154328483257657424873929502112904625", "33633002641218571027682690377239300567277297301791434890431645909447040830457253186262970747405514897340315490970846553666201190386457221846694126637998462873786334837901001833771510353365825087187582807843940479192544772559118293851131234910638705258664901225494129023244916125545283621607920983287799648992632814461828998517949449887522866259724675318233522060729654796/6603800575190864815125307817934327053530311915572323544225173935830559756077637251538096164499112411672913910767032482188570876526606118068929913515497400397562722669603861813453418621246538114872330536044519242663538662076583511078523573320035084744399535581216815034837553165853576616422592790103728141443697362408727056813977234078214386771115586436985105038873998875", "9090550743395453237608373761422705922989356346696677314277463900103283296889488490217663400349361962695279888433677856471792856853109469433355422802663947305503479561493033851081993247556828544308258821557994512133708656174864544457143793106703578476914924328960109390350040954158797845288786321215010324565010420734044059968931558099077932776525974187717655105951506223649947806568984848883258144616897526257038550656/1783219994432430133950472014582130883873515063182143523712063859964133099770763874744121895885645346884371273930727450069430704145915261127061538288702855011220545530326588799412076879985026006593893648911637986337776174555198865379578424838210466703683642106934154603710587408512357351455891557594977191641529451749437270208258072920514602243985184744955476557012910446023911358037761232253615162335336208343505859375", "396226087129511787616470716244996965529391571019620342657409150252952330537366537352182763477820160355931003174946109480036915624974500187179367618457008802667089004678925595775249725629495848146669773574395699032785024522882892752987825063933573399691764866816284097232869198405981830106568826923407996367321353003569052419999880089180418759265274331299787468134974811/77651132902382550540201641628906752945078964002822585000619340261128555048628863996784740469908853602590877726845475670110127527874088625214912598995012971630852593597027649154487264595100300180591016581254965295280089902497540043916128232871685159131211213497239568483141031137909208031392464815187505714066235868748950184065923236670418822911614780061752905170944000", "1288523130900767412477856952035690867153496584747510253984686336382980221603917538996138294311274357713893956725672062832264871415025750136690143411884111580335458539824573239771267043414225271729141508235839982033182605445173050590151912297720800168687369852280323356691345317649445843078291369394324862039143247087442309135074453265658730028145500871559458519282433012494054724678302957276371418936282902434203225600/252284450515080370603949213084529993395050575951188044032908270470514999880554862449223347761507020354321422785760279154913310488296485989979706208254206974075438570521939826124860483842758137231373182496438568202110337751291106165654945352183167578675508602832478752400011567482434301614269579368882858973850914513870297071866544875650189106576672289734326492492059816669288907018095832842249738081022227281715919357", "559506782175368748187145067236900803925823792088293851453005882621173124590368101213652371965740365119375069053747415415684193092607523211636912074219215053809881814859129515591479780669511533619258835199715146655774919418434080807837587396115955105126806762961292429904380132116986984435528307613054828929294602185927322238461491059740342387266084431988727321711184308176/109446188216864405154936682374609448082436347600301765944233278303643744736544109262794383069197271409398615846380701459882784547857821831816863216080069944818453908760476475874319791512782445408136169878207358663250499628002971644430164185578966399908622640732411885568638054229180673755690889471388585521113862492432946110902070139679164884208988489955874131206343597375", "365842109776085256207829452385781129402656684569922320812625438296958174120084800064669048017227033185969596458778213306152397766619692644694641677223213185977626940193107608138827771259334379895020377700759789774994800008933137569543592829220611543060189849601828342989023692876182148818363689293009174358168826340010491728715549904988196347316703985894355217235339548078187164176255405596310602921647203428200269666176/71497266937783826306774367225149833789788300609530680399994804704196212252148324552193149332755057982662844988588678159610516634667597707204818296457616315484973288944637139939912166034691155272078609876888919170894915224022982785138928008133003473320018151370486895637936102520353951511525996197267572355782608352075229547764732602557133494648237258900273354364050662921889937355682486287799239363976556848320046933875", "59378684894605773397070783936113244261297966863668546282887298999811950599772732377979382620766180662159460666220894896896564357533604962977968843474062092083279165837424210591042655271577974272394203253875965589611493384384257117088518521598379301169916060951350650621757237206805037261878212424267780312614942173870651684587166691539909068452932891649554575072205080763/11593916877920131260484148322810317629326850763057953025674154928920977965095141485536566217873796019006709247938019404840440511433467040918770165456925609124166970862430104329357419669175323763143377917913760028500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "440706629842402075137926797732405268015915199334341565218443748798479563505125605478061664327658137598204192554352688830679475840386882350034150077506804799859586772904929402683276898098601814091430598259347980573084686932949502809068565420937301632494387691284902026088950093888426872222813857928092871267130505744095697172494119689779474840037266295586359244899477781345249657455186847452249040895151288114085352974933708544/85971876318334010542313048056773419567285701852816309711738644074302467763075671531248793080425349570584102078764464196653843973936119037322000695949209283327606280423406302517302874806092835694196353778161663338667091195199032831587897410329509487165187753418615356836636352319310103639079123698118997500068644500893282438137614420288839230827096109835206605385673197123994357393257304049093683934224826006704198171592304125", "13220371178312284248107863849287558696210741535280184003301555188086761767176560823174196915070378763091889333203635784037294769747641959860810039816533609140662043493962707445564057197150603226797446933532133956054671103942520142568674339411250001585991743608723150284270101326419464088290151483823061613403673956918458456165552482913079283537536214967294211244361353060/2576683013797055224377707713704899315377379548630511095136568220145808780162671473907260623503552385384482723173913562423316997528913651044277418227616447815609873991028073011738113927961824632868956802271260292075825561646156680740323686126811928372672670917332613490241615850953660246271541592056143611581223295045062157404996958100136358649109693659623847024011265147", "1538372578072246705266078247950089219881197139399081643650271348770110178217959856819170325400476655944115553238940541695152110949081675985299189913515975242840473616169775880272489805123124548256666658584129873597192213080038937409046114908719298170078476325423466734429870048697383304265342125425087105698152643145531760853127801123272389134514333752173173161562273487752064850461823726948588221913540799816489566883798912/299566102446745552813544808169323270315327122249327394279467999308669285416179486075255023523726449428151807672528368606071047812907935426406886253284580296349349558797128593446316786243666290649442956134448480598303527795996222703837663605600624271807461605295956674925277658331760000117761013381199880905748188151556184620779667670278558839116983636972680749836497346863752662521197700717702790359162307617024566689271625", "281696937222363685333688097915539146272117417024070728031063821781398985795813333650547982965341298894634762289669256129805545549280355643122501181852136332529515756074502902204877664395456278205770206019663082511098956468724829475220996427130295010430751942126263620206886404244432409164651524408198286831329682605959881993845189585640874220032515465014097345759490750307207/54806274927935495596891312029173862473687610099325998583092091915101265393157631244775387832621032230434007486602816972765210205596482942091518459849775458089575743699797096697542306049628939919466378189656065461708686421130956996965004776108499273871055615413566043083634090083096967567965373203683231171594922347812966905149873265654962896456451681332216735396249206784000", "228506238533410805238253122961471637501498406104430046727793420497895852412513560203475440156216063574654372726194215013407325207763369075250819386897086702757125418327084312933061738392406321003231853349865003322697360659712771167066453430309997639548320673279964210730701373707765051246595806673865646607841876463608039111252607452843372970797479959213447237540830563469297144446069689149549515457318899981763489792/44418759813188470246596822974281932219088697005123285598909329328419879212164564561558656547678211265529803086702843380128457744445765859393426675396393053094588240457569380155526179040891009717323059641035189017918495485630657360525410506453554255734005459614858972904374739673834145083512160883402151636664208253116362089211658645312778404886460203600762546810897889629330022309705583438699250109493732452392578125", "2396110297187570506257836426251930521245117960980667897194680897478996322590925380310917400763581787981992131769075961259393685331523600287377841990678117113566991100720996059187144934569703045966210306282348527729533806882408323961336166190162075154579344185244957673138372347997134388801085788353482276257401005734929059700346687783400772331280644647089520646562669857652648/465370154262863030800729180763091967573522779260407615567563274096037297593764955820626213827962697601334935773802201919483657310282236100250543992334865461800976838791035335861420892967699843608855185710753433852279737724446294443337363478679601049432404435672469098850676302728116369979460222148206944323730586138087862719386327396334468302608499235112520318322763857676375", "1188272888075247520453568790651819187486389546755745961952033150576243575862120569399808467067800830890874391487822723879717525264875722720416173276963170672622214121308038530968291758445510982186014289745026439477197148445087614813262170975056866881909056450023324743409114115141145340480846088869807540798073417035168139476153897066325127540609756310068558610112731607522096096821938163134080426356894899245575410494080/230586762395914863625709048789913840511134004337945700368117795195769576856434588144361459740833007125516905017415184787078710001969815416281381427387949263792200577791644278234661952852149216540491852757174842146376788280677956350901082838474705227642420261641783722891948710833898248566893322144435457967452449965772543077421407816225704952270697016152452032506898311260979594550143344971416786595888053149375287120733", "1072184299258468249004114536023934869518152618369895613271618698908405514630154819453979477077738526673716264830106745031385951736108376866253955319711026042389282009348594845497252059906901748860111986811345742998968284077119165082435598381810306691078037018432766116865792677955520465319184311529667642995217214507658693259694586107847099911341219913576038605872218680562047/207882129535607118520818565811162643811811563516006836924341123976848022970024793004700710992938987476728640943834012473687892481059618823520721737479364352887178017866425027953255856440099446112508663603319745066750522936408781591578321031173620445865113295407603090322283539974563690157418931060565698315406021569491751612761888641141446406531645379264720684248398299136000", "158094023904374464057702010126993231151433474361820266584020400101533651587072432728050776506672527718975042616651177034635188178967462982926261516748842073587981953038445977514446838733557926696939591069712397947055261777416704028506441173540338327591514650398349069348381309688677335132100441905603664282735310299686268721634369502296867409514777359935022301425165750780988231639828675424239931533849896744198012747670272/30626384366513923671063955469537776291182594080083494737341604579575446319190916924682809546024369330706012653799783122328775875399363759308193432327358837772825609356553955350401725689682838701996446404559005896479618311357573203081153855961484398360670837599853294627153740224543175497655414585918231215639906924313779933211774291565425360415684556655021031131349317390382320286092667852173815259422737956767922154798375", "12216278924286401897470540169822542417611356797676160128176706721343511598951866107858729405615631246003458062949723290192242594609994613705183460814797527214549142043573863947658832694800184691222426521703728394203722420336773310908687071670107794543022567943478843065246011544888390757810534211554666736239506503613750756246364621509359804902243487113673014588325806249988332/2364584127734680580481708368927921125934330000162935118371174269642831409084634375654239735054363928748162229294829526339927907778510530444646754603322373712788147193691037688552857183116332292048731726305451516954679277320777955342295564000586923227775208580772868590742136150431152495718132142742153643081187691849828217592954519485869135930755646768375299870967864990234375", "578939195017447864385837341975558679292903716580114421030538728778491606282153588930983966100514147976321305616196463174070345884292672842497715966933722088536619333912687108737657068701352918582656105418491672377271304970407730786932913490869797471081081431072836814581099271832696990064828717287258860166842791984158634684078346453202928137987930328826212011774670396356151265781053547412633310327737900786639842674288716416/111966291649651600701875186827360807558960817589719096407887999108024557254221008849510152469119211567152616745769256123968832250104006560061907741567034087109512483357851919402017950812795426393415409198268246337542639470834168040295134130657073201020340432236723824670803498949071870597039309004562024033656488150406105175401372709011082725359382691270659245312133919518760328422827067578306005644825927050994860723405473375", "8041514821545833865350873212853873042112343327573364523948780030849543753072688526717886590013028227714585965095216381829914996539132359247488639692828639170075726301411777307168737667077730792892326979446426349813642680537699905651125068091362135055902152994216233622733424128982011248923051410141033146604688083721413402395290842738021365861670415833356403364696759583009635/1553937833499559104910551811592138833189892464446761247731330672284191313590708439680460540329836344767557599746234213006493842842879398684745864919973051635127080738612248150108793397855113122368507483429209127035263504194847798809612278864438287815470711036548695032421148125849669175729331459149833945183228413961985381338162155596008680906676498435954178226973272371625984", "12059659399309169167301353842123191409306995788633965680414620302285606896146667751472818541537183787935352700725982053536032930866708413010971856856768384974849695774437178790890015242323873769697407411558706626105140596160049735605389301414460825674631122462760014451298494875244754354054447697502521388381253293175367558014453865905104467382184997528879171136492277222127399012368677604910497789360212571238146627048080568400384/2328494054002703067219004484782931471919751585969487160602269605916676223315055450845942763690581877771159615428854802721943114463834992106300185328876910271612375509166975628540839858771078495267566008071532876816826751069408153323840515037497664871689085370699991860738368371510578076683395101062439493831773194498579620513073693022191702398601471237166387045790480861932005012807234071429628725981935147069738988682858417182625", "683009426705008850682549700382901603742691705123356866338951397347368059105140826655486518416578697931244347554322654428162554903861783227680935341690740579867651545205562690172425016836559678937794312287639193745517811234257062356826622207475918293015140472942579713388671782202262396642735640315948612572908444501108579457520714632371056288874351015666995549139003946314085696/131769214246522869780429817236150406548549044658474416909806179734873399109656411633488099249198882165279745627038984487365589625562901914030850178330133080409420340227179447548044572594184601425691821617928130423410997853384425373999967759499571890326740433081063424903098252502791477854302204200941376983295622430177445507316706609802292121282957519571162158620971952084486375", "1418116259749091420309271913909337143756589314597557128553117870573928055109322864794169592355058370891251425125187770724828108988587888087023982451205475980371440423992838481547236638456717520835668859093413956339261802305597694403381021863258753441889536361061407579332570493634254542013337999844407181346815549594836374497512447969751514466481466717590255369810506813543577735080228718660747940956248427356785784199073569408/273368882980516556922532339653303822104510203916024760371844491705599093435133738774975538364241630079468712981056336655766117378160822393876348755370711942273876284944422610974149712212944211513462921649872232656449940987552227525504529710373144228818606127541937831103642415534318303187393593236209298242574677293352798419428712873685798636474667204083938875672934235816396371477146089168375198141802684403955936431884765625", "546411077581845999248238069684194831621691193366466972898628141511422317954477211865167402284211971296286346492698354214043840080181702652132835681239302798339667835439189275457116051279366194551632712819028177402221815140045210690908631767786711675029194359998826252332434573121740830827417293557234891406021102083555472155479148332697839972702631641910213821827820374586459319/105246945889799140338072754365901705544530661781295362563214285953881890233987516230568663143342952799036341701952267011236663118111226623815975847494372076420199418712941018288738590264475520229651370015377608638075866459684692488079223686296541020897904588347083045723167762682959422858996673894180805702299907478685374065593161226849447131100462022089783265346597553176576000", "2398330640958841474772606439916070050977544535580605737383995160447105736276950196885906408317628083110923322157113892928963237845914017845444295040924101784423382681801754191301860383927129006953354739240926643562987838836997453985855576402628166875869041032631651591871962852884189548538272285387092843044669499688035134181859376665409767886188304314888753894905317929877238322615838524354191263502347881033855441181420399360/461588070868590122892265681879734295007029130965626060552783760068897000195207878227714842617470320231527222074701444349530952699708435668339712860464533455345665068841333232359698449088497137068713309811942968433868609329301082001752617420002377892756821532220676085014874112083615054550278903960627185675459015343606391094523511117705747842645927349130302549554534056269331809016770715819934970200483161548527932617036185253", "6041015879424725383006424536130409209607854044642113747266098198777011981328765528361630516108680392500990580908509403483891763219659726090675140672989657743882183951954294745396417829943469201306594018454995862321821016087416840247422350906412007336103086620396467456181771583200365740253389107968122850063607085957109965406634738740996318415514360956028575560979203447735121436/1161752799109428422288020947061281540989708937450568100764830251908850596717606701047413407636907934320789870175907792017513896999208892282137299070761467096211814586909598705615312819596495636017728313513520193786266452836805291464826226833593878504804389728477191170027729963773716267868284479768397603444919008915279522376004326398403851684761808785381609370767169521034383625", "13240077436443988749179508462267267187169441948722358165090554769250505713747934643200804819418670147225695324432684266924694524337920816452346599774452681831320005286326986675907899608537972384924882996757503264622991355949039882526389342174307168805166215838138277557052303430492669193939212362638263582899713198716541723383138016564027766560215944409353427176135895982596327685665844815618402881202645610620284792793420780517248/2544223084468158291883698813309541801455311468982232546872485444308211415529998472787377800559884210837213042932180479090277285630234238711851480232520137856848809986631784843528381778520727465146661792797924458540957133423665746229799675650290296217658444899605236550972043549278128087645211909479009099766619355677984218929672461506691980442071860591767266913041147587815452007726513853820116629482732060593116624596368806566625", "1953999166296955830935495158735359200362904181792947794529339487489730042568305997099959302322956898299616194932283060554261566410988618045107398092345476532371402134206635235570281738377188438407703089325315446371127042537576093536896282955524842632708645655481028161471313608974238110718242273935956977555610147714316158486553633871312187084618154014921190595222799283957140353/375191165084882521037046014569185165885459082629136124177286500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"];
          if (CACHE[x]) {
            return Frac.quick.apply(null, CACHE[x].split("/"));
          }
          x = new Frac(x);
          var n2 = 80;
          var retval = new Frac(0);
          var a = x.subtract(new Frac(1));
          var b = x.add(new Frac(1));
          for (var i = 0; i < n2; i++) {
            var t = new Frac(2 * i + 1);
            var k = Math2.bigpow(a.divide(b), t);
            var r = t.clone().invert().multiply(k);
            retval = retval.add(r);
          }
          return retval.multiply(new Frac(2));
        },
        //the factorial function but using the big library instead
        factorial: function(x) {
          var is_int = x % 1 === 0;
          if (is_int && x < 0)
            return NaN;
          if (!is_int)
            return Math2.gamma(x + 1);
          var retval = 1;
          for (var i = 2; i <= x; i++)
            retval = retval * i;
          return retval;
        },
        //double factorial
        //http://mathworld.wolfram.com/DoubleFactorial.html
        dfactorial: function(x) {
          if (isInt(x)) {
            var even2 = x % 2 === 0;
            var n2 = even2 ? x / 2 : (x + 1) / 2;
            var r = new Frac(1);
            if (even2)
              for (var i = 1; i <= n2; i++)
                r = r.multiply(new Frac(2).multiply(new Frac(i)));
            else
              for (var i = 1; i <= n2; i++)
                r = r.multiply(new Frac(2).multiply(new Frac(i)).subtract(new Frac(1)));
          } else {
            r = Math.pow(2, (1 + 2 * x - Math.cos(Math.PI * x)) / 4) * Math.pow(Math.PI, (Math.cos(Math.PI * x) - 1) / 4) * Math2.gamma(1 + x / 2);
          }
          return r;
        },
        GCD: function() {
          var args = arrayUnique([].slice.call(arguments).map(function(x) {
            return Math.abs(x);
          })).sort(), a = Math.abs(args.shift()), n2 = args.length;
          while (n2-- > 0) {
            var b = Math.abs(args.shift());
            while (true) {
              a %= b;
              if (a === 0) {
                a = b;
                break;
              }
              b %= a;
              if (b === 0)
                break;
              ;
            }
          }
          return a;
        },
        QGCD: function() {
          var args = [].slice.call(arguments);
          var a = args[0];
          for (var i = 1; i < args.length; i++) {
            var b = args[i];
            var sign = a.isNegative() && b.isNegative() ? -1 : 1;
            a = b.gcd(a);
            if (sign < 0)
              a.negate();
          }
          return a;
        },
        LCM: function(a, b) {
          return a * b / Math2.GCD(a, b);
        },
        //pow but with the handling of negative numbers
        //http://stackoverflow.com/questions/12810765/calculating-cubic-root-for-negative-number
        pow: function(b, e) {
          if (b < 0) {
            if (Math.abs(e) < 1) {
              if (1 / e % 2 === 0)
                return NaN;
              return -Math.pow(Math.abs(b), e);
            }
          }
          return Math.pow(b, e);
        },
        factor: function(n2) {
          n2 = Number(n2);
          var sign = Math.sign(n2);
          n2 = Math.abs(n2);
          var ifactors = Math2.ifactor(n2);
          var factors = new Symbol2();
          factors.symbols = {};
          factors.group = CB;
          for (var x in ifactors) {
            var factor = new Symbol2(1);
            factor.group = P;
            factor.value = x;
            factor.power = new Symbol2(ifactors[x]);
            factors.symbols[x] = factor;
          }
          factors.updateHash();
          if (n2 === 1) {
            factors = new Symbol2(n2);
          }
          if (sign < 0)
            factors.negate();
          return factors;
        },
        /**
         * Uses trial division
         * @param {Integer} n - the number being factored
         * @param {object} factors -  the factors object
         * @returns {object}
         */
        sfactor: function(n2, factors) {
          factors = factors || {};
          var r = Math.floor(Math.sqrt(n2));
          var lcprime = PRIMES[PRIMES.length - 1];
          if (r > lcprime && n2 < 1e6)
            generatePrimes(r);
          var l = PRIMES.length;
          for (var i = 0; i < l; i++) {
            var prime = PRIMES[i];
            while (n2 % prime === 0) {
              n2 = n2 / prime;
              factors[prime] = (factors[prime] || 0) + 1;
            }
          }
          if (n2 > 1)
            factors[n2] = 1;
          return factors;
        },
        /**
         * Pollard's rho
         * @param {Integer} n
         * @returns {object}
         */
        ifactor: function(n2) {
          var input = new bigInt(n2);
          n2 = String(n2);
          if (n2 === "0")
            return { "0": 1 };
          n2 = new bigInt(n2);
          var sign = n2.sign ? -1 : 1;
          n2 = n2.abs();
          var factors = {};
          if (n2.lt("65536")) {
            factors = Math2.sfactor(n2, factors);
          } else {
            var add = function(e) {
              if (!e.isPrime()) {
                factors = Math2.sfactor(e, factors);
              } else
                factors[e] = (factors[e] || 0) + 1;
            };
            try {
              var max = 1e3;
              var safety = 0;
              while (!n2.abs().equals(1)) {
                if (n2.isPrime()) {
                  add(n2);
                  break;
                } else {
                  let rho = function(c) {
                    var xf = new bigInt(c), cz = 2, x = new bigInt(c), factor2 = new bigInt(1);
                    while (factor2.equals(1)) {
                      for (var i = 0; i <= cz && factor2.equals(1); i++) {
                        if (safety++ > max)
                          throw new Error("stopping");
                        x = x.pow(2).add(1).mod(n2);
                        factor2 = bigInt.gcd(x.minus(xf).abs(), n2);
                      }
                      cz = cz * 2;
                      xf = x;
                    }
                    if (factor2.equals(n2)) {
                      return rho(c + 1);
                    }
                    return factor2;
                  };
                  var factor = rho(2);
                  add(factor);
                  n2 = n2.divide(factor);
                }
              }
            } catch (e) {
              factors = {};
              add(input);
            }
          }
          if (sign === -1) {
            var sm = arrayMin(keys(factors));
            factors["-" + sm] = factors[sm];
            delete factors[sm];
          }
          return factors;
        },
        //factors a number into rectangular box. If sides are primes that this will be
        //their prime factors. e.g. 21 -> (7)(3), 133 -> (7)(19)
        boxfactor: function(n2, max) {
          max = max || 200;
          var c, r, d = Math.floor(5 / 12 * n2), i = 0, safety = false;
          while (true) {
            c = Math.floor(n2 / d);
            r = n2 % d;
            if (r === 0)
              break;
            if (safety)
              return [n2, 1];
            d = Math.max(r, d - r);
            i++;
            safety = i > max;
          }
          return [c, d, i];
        },
        fib: function(n2) {
          var sign = Math.sign(n2);
          n2 = Math.abs(n2);
          sign = even(n2) ? sign : Math.abs(sign);
          var a = 0, b = 1, f = 1;
          for (var i = 2; i <= n2; i++) {
            f = a + b;
            a = b;
            b = f;
          }
          return f * sign;
        },
        mod: function(x, y) {
          return x % y;
        },
        //http://mathworld.wolfram.com/IntegerPart.html
        integer_part: function(x) {
          var sign = Math.sign(x);
          return sign * Math.floor(Math.abs(x));
        },
        simpson: function(f, a, b, step) {
          var get_value = function(f2, x, side) {
            var v = f2(x);
            var d = 1e-12;
            if (isNaN(v)) {
              v = f2(side === 1 ? x + d : x - d);
            }
            return v;
          };
          step = step || 1e-4;
          var n2 = Math.abs(Math.floor((b - a) / step));
          if (n2 % 2 !== 0)
            n2++;
          var dx = (b - a) / n2;
          var retval = get_value(f, a, 1);
          var even2 = false;
          var xi = a + dx;
          var c, k;
          for (var i = 1; i < n2; i++) {
            c = even2 ? 2 : 4;
            k = c * get_value(f, xi, 1);
            retval += k;
            even2 = !even2;
            xi += dx;
          }
          return (retval + get_value(f, xi, 2)) * (dx / 3);
        },
        /**
         * https://github.com/scijs/integrate-adaptive-simpson
         * @param {Function} f - the function being integrated
         * @param {Number} a - lower bound
         * @param {Number} b - upper bound
         * @param {Number} tol - step width
         * @param {Number} maxdepth
         * @returns {Number}
         */
        num_integrate: function(f, a, b, tol, maxdepth) {
          if (maxdepth < 0)
            throw new Error("max depth cannot be negative");
          function adsimp(f2, a2, b2, fa, fm, fb, V0, tol2, maxdepth2, depth, state) {
            if (state.nanEncountered) {
              return NaN;
            }
            var h, f1, f22, sl, sr, s2, m, V1, V2, err2;
            h = b2 - a2;
            f1 = f2(a2 + h * 0.25);
            f22 = f2(b2 - h * 0.25);
            if (isNaN(f1)) {
              state.nanEncountered = true;
              return;
            }
            if (isNaN(f22)) {
              state.nanEncountered = true;
              return;
            }
            sl = h * (fa + 4 * f1 + fm) / 12;
            sr = h * (fm + 4 * f22 + fb) / 12;
            s2 = sl + sr;
            err2 = (s2 - V0) / 15;
            if (state.maxDepthCount > 1e3 * maxdepth2) {
              return;
            }
            if (depth > maxdepth2) {
              state.maxDepthCount++;
              return s2 + err2;
            } else if (Math.abs(err2) < tol2) {
              return s2 + err2;
            } else {
              m = a2 + h * 0.5;
              V1 = adsimp(f2, a2, m, fa, f1, fm, sl, tol2 * 0.5, maxdepth2, depth + 1, state);
              if (isNaN(V1)) {
                state.nanEncountered = true;
                return NaN;
              }
              V2 = adsimp(f2, m, b2, fm, f22, fb, sr, tol2 * 0.5, maxdepth2, depth + 1, state);
              if (isNaN(V2)) {
                state.nanEncountered = true;
                return NaN;
              }
              return V1 + V2;
            }
          }
          function integrate(f2, a2, b2, tol2, maxdepth2) {
            var state = {
              maxDepthCount: 0,
              nanEncountered: false
            };
            if (tol2 === void 0) {
              tol2 = 1e-9;
            }
            if (maxdepth2 === void 0) {
              maxdepth2 = 45;
            }
            var fa = f2(a2);
            var fm = f2(0.5 * (a2 + b2));
            var fb = f2(b2);
            var V0 = (fa + 4 * fm + fb) * (b2 - a2) / 6;
            var result = adsimp(f2, a2, b2, fa, fm, fb, V0, tol2, maxdepth2, 1, state);
            if (state.maxDepthCount > 0) {
              warn("integrate-adaptive-simpson: Warning: maximum recursion depth (" + maxdepth2 + ") reached " + state.maxDepthCount + " times");
            }
            if (state.nanEncountered) {
              throw new Error("Function does not converge over interval!");
            }
            return result;
          }
          var retval;
          try {
            retval = integrate(f, a, b, tol, maxdepth);
          } catch (e) {
            return Math2.simpson(f, a, b);
          }
          return nround(retval, 12);
        },
        //https://en.wikipedia.org/wiki/Trigonometric_integral
        //CosineIntegral
        Ci: function(x) {
          var n2 = 20, g = 0.5772156649015329, sum = 0;
          for (var i = 1; i < n2; i++) {
            var n22 = 2 * i;
            sum += Math.pow(-1, i) * Math.pow(x, n22) / (n22 * Math2.factorial(n22));
          }
          return Math.log(x) + g + sum;
        },
        /*SineIntegral*/
        Si: function(x) {
          var n2 = 20, sum = 0;
          for (var i = 0; i < n2; i++) {
            var n22 = 2 * i;
            sum += Math.pow(-1, i) * Math.pow(x, n22 + 1) / ((n22 + 1) * Math2.factorial(n22 + 1));
          }
          return sum;
        },
        /*ExponentialIntegral*/
        Ei: function(x) {
          if (Number(x) === 0)
            return -Infinity;
          var n2 = 30, g = 0.5772156649015329, sum = 0;
          for (var i = 1; i < n2; i++) {
            sum += Math.pow(x, i) / (i * Math2.factorial(i));
          }
          return g + Math.abs(Math.log(x)) + sum;
        },
        /*Hyperbolic Sine Integral*/
        /*http://mathworld.wolfram.com/Shi.html*/
        Shi: function(x) {
          var n2 = 30, sum = 0, k, t;
          for (var i = 0; i < n2; i++) {
            k = 2 * i;
            t = k + 1;
            sum += Math.pow(x, t) / (t * t * Math2.factorial(k));
          }
          return sum;
        },
        /*the cosine integral function*/
        Chi: function(x) {
          var dx, g, f;
          dx = 1e-3;
          g = 0.5772156649015329;
          f = function(t) {
            return (Math.cosh(t) - 1) / t;
          };
          return Math.log(x) + g + Math2.num_integrate(f, 2e-3, x, dx);
        },
        /*the log integral*/
        Li: function(x) {
          return Math2.Ei(Math2.bigLog(x));
        },
        /*the gamma incomplete function*/
        gamma_incomplete: function(n2, x) {
          var t = n2 - 1, sum = 0, x = x || 0;
          for (var i = 0; i < t; i++) {
            sum += Math.pow(x, i) / Math2.factorial(i);
          }
          return Math2.factorial(t) * Math.exp(-x) * sum;
        },
        /*
         * Heaviside step function - Moved from Special.js (originally contributed by Brosnan Yuen)
         * Specification : http://mathworld.wolfram.com/HeavisideStepFunction.html
         * if x > 0 then 1
         * if x == 0 then 1/2
         * if x < 0 then 0
         */
        step: function(x) {
          if (x > 0)
            return 1;
          if (x < 0)
            return 0;
          return 0.5;
        },
        /*
         * Rectangle function - Moved from Special.js (originally contributed by Brosnan Yuen)
         * Specification : http://mathworld.wolfram.com/RectangleFunction.html
         * if |x| > 1/2 then 0
         * if |x| == 1/2 then 1/2
         * if |x| < 1/2 then 1
         */
        rect: function(x) {
          var x = Math.abs(x);
          if (x === 0.5)
            return x;
          if (x > 0.5)
            return 0;
          return 1;
        },
        /*
         * Sinc function - Moved from Special.js (originally contributed by Brosnan Yuen)
         * Specification : http://mathworld.wolfram.com/SincFunction.html
         * if x == 0 then 1
         * otherwise sin(x)/x
         */
        sinc: function(x) {
          if (x.equals(0))
            return 1;
          return Math.sin(x) / x;
        },
        /*
         * Triangle function - Moved from Special.js (originally contributed by Brosnan Yuen)
         * Specification : http://mathworld.wolfram.com/TriangleFunction.html
         * if |x| >= 1 then 0
         * if |x| < then 1-|x|
         */
        tri: function(x) {
          x = Math.abs(x);
          if (x >= 1)
            return 0;
          return 1 - x;
        },
        //https://en.wikipedia.org/wiki/Nth_root_algorithm
        nthroot: function(A, n2) {
          if (!(A instanceof Frac))
            A = new Frac(A.toString());
          if (!(n2 instanceof Frac))
            n2 = new Frac(n2.toString());
          if (n2.equals(1))
            return A;
          var xk = A.divide(new Frac(2));
          var e = new Frac(1e-15);
          var dk, dk0, d0;
          var a = n2.clone().invert(), b = n2.subtract(new Frac(1));
          do {
            var powb = Math2.bigpow(xk, b);
            var dk_dec = a.multiply(A.divide(powb).subtract(xk)).toDecimal(25);
            dk = Frac.create(dk_dec);
            if (d0)
              break;
            xk = xk.add(dk);
            var dk_dec = dk.toDecimal();
            d0 = dk0 ? dk0 === dk_dec : false;
            dk0 = dk_dec;
          } while (dk.abs().gte(e));
          return xk;
        },
        /*https://gist.github.com/jiggzson/0c5b33cbcd7b52b36132b1e96573285f*/
        /*Just the square root function but big :)*/
        sqrt: function(n2) {
          if (!(n2 instanceof Frac))
            n2 = new Frac(n2);
          var xn, d, ld, same_delta;
          var c = 0;
          var done = false;
          var delta = new Frac(1e-20);
          xn = n2.divide(new Frac(2));
          var safety = 1e3;
          do {
            if (c > safety)
              throw new Error("Unable to calculate square root for " + n2);
            xn = xn.add(n2.divide(xn)).divide(new Frac(2));
            xn = new Frac(xn.decimal(30));
            d = n2.subtract(xn.multiply(xn));
            same_delta = ld ? ld.equals(d) : false;
            if (d.clone().abs().lessThan(delta) || same_delta)
              done = true;
            ld = d;
            c++;
          } while (!done);
          return xn;
        }
      };
      Settings.FUNCTION_MODULES.push(Math2);
      reserveNames(Math2);
      Math.sign = Math.sign || function(x) {
        x = +x;
        if (x === 0 || isNaN(x)) {
          return x;
        }
        return x > 0 ? 1 : -1;
      };
      Math.cosh = Math.cosh || function(x) {
        var y = Math.exp(x);
        return (y + 1 / y) / 2;
      };
      Math.sech = Math.sech || function(x) {
        return 1 / Math.cosh(x);
      };
      Math.csch = Math.csch || function(x) {
        return 1 / Math.sinh(x);
      };
      Math.coth = Math.coth || function(x) {
        return 1 / Math.tanh(x);
      };
      Math.sinh = Math.sinh || function(x) {
        var y = Math.exp(x);
        return (y - 1 / y) / 2;
      };
      Math.tanh = Math.tanh || function(x) {
        if (x === Infinity) {
          return 1;
        } else if (x === -Infinity) {
          return -1;
        } else {
          var y = Math.exp(2 * x);
          return (y - 1) / (y + 1);
        }
      };
      Math.asinh = Math.asinh || function(x) {
        if (x === -Infinity) {
          return x;
        } else {
          return Math.log(x + Math.sqrt(x * x + 1));
        }
      };
      Math.acosh = Math.acosh || function(x) {
        return Math.log(x + Math.sqrt(x * x - 1));
      };
      Math.atanh = Math.atanh || function(x) {
        return Math.log((1 + x) / (1 - x)) / 2;
      };
      Math.log10 = Math.log10 || function(x) {
        return Math.log(x) * Math.LOG10E;
      };
      Math.trunc = Math.trunc || function(x) {
        if (isNaN(x)) {
          return NaN;
        }
        if (x > 0) {
          return Math.floor(x);
        }
        return Math.ceil(x);
      };
      function text(obj, option, useGroup, decp) {
        var asHash = option === "hash", wrapCondition = void 0, opt = asHash ? void 0 : option, asDecimal = opt === "decimal" || opt === "decimals";
        if (asDecimal && typeof decp === "undefined")
          decp = Settings.DEFAULT_DECP;
        function toString(obj2) {
          switch (option) {
            case "decimals":
            case "decimal":
              wrapCondition = wrapCondition || function(str2) {
                return false;
              };
              return obj2.valueOf();
            case "recurring":
              wrapCondition = wrapCondition || function(str2) {
                return str2.indexOf("'") !== -1;
              };
              var str = obj2.toString();
              var frac = /^-?\d+(?:\/\d+)?$/.exec(str);
              if (frac.length === 0)
                return str;
              var parts = frac[0].split("/");
              var negative = false;
              var m2 = Number(parts[0]);
              if (m2 < 0) {
                m2 = -m2;
                negative = true;
              }
              var n2 = Number(parts[1]);
              if (!n2)
                n2 = 1;
              var quotient = Math.floor(m2 / n2), c2 = 10 * (m2 - quotient * n2);
              quotient = quotient.toString() + ".";
              while (c2 && c2 < n2) {
                c2 *= 10;
                quotient += "0";
              }
              var digits = "", passed = [], i2 = 0;
              while (true) {
                if (typeof passed[c2] !== "undefined") {
                  var prefix = digits.slice(0, passed[c2]), cycle = digits.slice(passed[c2]), result = quotient + prefix + "'" + cycle + "'";
                  return (negative ? "-" : "") + result.replace("'0'", "").replace(/\.$/, "");
                }
                var q = Math.floor(c2 / n2), r = c2 - q * n2;
                passed[c2] = i2;
                digits += q.toString();
                i2 += 1;
                c2 = 10 * r;
              }
            case "mixed":
              wrapCondition = wrapCondition || function(str2) {
                return str2.indexOf("/") !== -1;
              };
              var str = obj2.toString();
              var frac = /^-?\d+(?:\/\d+)?$/.exec(str);
              if (frac.length === 0)
                return str;
              var parts = frac[0].split("/");
              var numer = new bigInt(parts[0]);
              var denom = new bigInt(parts[1]);
              if (denom.equals(0))
                denom = new bigInt(1);
              var divmod = numer.divmod(denom);
              var quotient = divmod.quotient;
              var remainder = divmod.remainder;
              var operator = parts[0][0] === "-" || quotient.equals(0) || remainder.equals(0) ? "" : "+";
              return (quotient.equals(0) ? "" : quotient.toString()) + operator + (remainder.equals(0) ? "" : remainder.toString() + "/" + parts[1]);
            case "scientific":
              wrapCondition = wrapCondition || function(str2) {
                return false;
              };
              return new Scientific(obj2.valueOf()).toString(Settings.SCIENTIFIC_MAX_DECIMAL_PLACES);
            default:
              wrapCondition = wrapCondition || function(str2) {
                return str2.indexOf("/") !== -1;
              };
              return obj2.toString();
          }
        }
        if (isSymbol(obj)) {
          var multiplier = "", power = "", sign = "", group = obj.group || useGroup, value = obj.value;
          if (!asHash) {
            var om = toString(obj.multiplier);
            if (om == "-1" && String(obj.multiplier) === "-1") {
              sign = "-";
              om = "1";
            }
            if (om != "1")
              multiplier = om;
            var p = obj.power ? toString(obj.power) : "";
            if (p != "1") {
              if (isSymbol(p)) {
                power = text(p, opt);
              } else {
                power = p;
              }
            }
          }
          switch (group) {
            case N:
              multiplier = "";
              var m = decp && asDecimal ? obj.multiplier.toDecimal(decp) : toString(obj.multiplier);
              value = String(obj.multiplier) == "-1" ? "1" : m;
              power = "";
              break;
            case PL:
              value = obj.collectSymbols().map(function(x) {
                var txt = text(x, opt, useGroup, decp);
                if (txt == "0")
                  txt = "";
                return txt;
              }).sort().join("+").replace(/\+\-/g, "-");
              break;
            case CP:
              value = obj.collectSymbols().map(function(x) {
                var txt = text(x, opt, useGroup, decp);
                if (txt == "0")
                  txt = "";
                return txt;
              }).sort().join("+").replace(/\+\-/g, "-");
              break;
            case CB:
              value = obj.collectSymbols(function(symbol) {
                var g = symbol.group;
                if ((g === PL || g === CP) && (symbol.power.equals(1) && symbol.multiplier.equals(1))) {
                  return inBrackets(text(symbol, opt));
                }
                return text(symbol, opt);
              }).join("*");
              break;
            case EX:
              var pg = obj.previousGroup, pwg = obj.power.group;
              if (pg === PL)
                value = obj.collectSymbols(text, opt).join("+").replace("+-", "-");
              if (!(pg === N || pg === S || pg === FN) && !asHash) {
                value = inBrackets(value);
              }
              if ((pwg === CP || pwg === CB || pwg === PL || obj.power.multiplier.toString() != "1") && power) {
                power = inBrackets(power);
              }
              break;
          }
          if (group === FN) {
            value = obj.fname + inBrackets(obj.args.map(function(symbol) {
              return text(symbol, opt);
            }).join(","));
          }
          if (group === FN && obj.fname in CUSTOM_OPERATORS) {
            var a = text(obj.args[0]);
            var b = text(obj.args[1]);
            if (obj.args[0].isComposite())
              a = inBrackets(a);
            if (obj.args[1].isComposite())
              b = inBrackets(b);
            value = a + CUSTOM_OPERATORS[obj.fname] + b;
          }
          if (power && group !== EX && wrapCondition(power)) {
            power = inBrackets(power);
          }
          if ((group === CP || group === PL) && (multiplier && multiplier != "1" || sign === "-") || (group === CB || group === CP || group === PL) && (power && power != "1") || !asHash && group === P && value == -1 || obj.fname === PARENTHESIS) {
            value = inBrackets(value);
          }
          if (decp && (option === "decimal" || option === "decimals" && multiplier)) {
            multiplier = nround(multiplier, decp);
          }
          var c = sign + multiplier;
          if (multiplier && wrapCondition(multiplier))
            c = inBrackets(c);
          if (power < 0)
            power = inBrackets(power);
          if (multiplier)
            c = c + "*";
          if (power) {
            if (value === "e" && Settings.E_TO_EXP) {
              return c + "exp" + inBrackets(power);
            }
            power = Settings.POWER_OPERATOR + power;
          }
          if (group === EX && value.charAt(0) === "-") {
            value = inBrackets(value);
          }
          var cv = c + value;
          if (obj.parens) {
            cv = inBrackets(cv);
          }
          return cv + power;
        } else if (isVector(obj)) {
          var l = obj.elements.length, c = [];
          for (var i = 0; i < l; i++)
            c.push(obj.elements[i].text(option));
          return "[" + c.join(",") + "]";
        } else {
          try {
            return obj.toString();
          } catch (e) {
            return "";
          }
        }
      }
      function primeFactors(num) {
        if (isPrime(num)) {
          return [num];
        }
        var l = num, i = 1, factors = [], epsilon = 2220446049250313e-31;
        while (i < l) {
          var quotient = num / i;
          var whole = Math.floor(quotient);
          var remainder = quotient - whole;
          if (remainder <= epsilon && i > 1) {
            if (isPrime(i)) {
              if (PRIMES.indexOf(i) === -1) {
                PRIMES.push(i);
              }
              factors.push(i);
            }
            if (isPrime(whole)) {
              factors.push(whole);
              break;
            }
            l = whole;
          }
          i++;
        }
        return factors.sort(function(a, b) {
          return a - b;
        });
      }
      ;
      primeFactors(314146179365);
      function Expression(symbol) {
        this.symbol = symbol;
      }
      Expression.getExpression = function(expression_number, asType) {
        if (expression_number === "last" || !expression_number)
          expression_number = EXPRESSIONS.length;
        if (expression_number === "first")
          expression_number = 1;
        var index = expression_number - 1, expression = EXPRESSIONS[index], retval = expression ? new Expression(expression) : expression;
        return retval;
      };
      Expression.prototype = {
        /**
         * Returns the text representation of the expression
         * @param {String} opt - option of formatting numbers
         * @param {Number} n The number of significant figures
         * @returns {String}
         */
        text: function(opt, n2) {
          n2 = n2 || Settings.EXPRESSION_DECP;
          opt = opt || "decimals";
          if (this.symbol.text_)
            return this.symbol.text_(opt);
          return text(this.symbol, opt, void 0, n2);
        },
        /**
         * Returns the latex representation of the expression
         * @param {String} option - option for formatting numbers
         * @returns {String}
         */
        latex: function(option) {
          if (this.symbol.latex)
            return this.symbol.latex(option);
          return LaTeX.latex(this.symbol, option);
        },
        valueOf: function() {
          return this.symbol.valueOf();
        },
        /**
         * Evaluates the expression and tries to reduce it to a number if possible.
         * If an argument is given in the form of %{integer} it will evaluate that expression.
         * Other than that it will just use it's own text and reparse
         * @returns {Expression}
         */
        evaluate: function() {
          if (isVector(this.symbol) && this.symbol.dimensions() === 0) {
            return this;
          }
          var first_arg = arguments[0], expression, idx = 1;
          if (typeof first_arg === "string") {
            expression = first_arg.charAt(0) === "%" ? Expression.getExpression(first_arg.substr(1)).text() : first_arg;
          } else if (first_arg instanceof Expression || isSymbol(first_arg)) {
            expression = first_arg.text();
          } else {
            expression = this.symbol.text();
            idx--;
          }
          var subs = arguments[idx] || {};
          var retval = new Expression(block("PARSE2NUMBER", function() {
            return _.parse(expression, subs);
          }, true));
          return retval;
        },
        /**
         * Converts a symbol to a JS function. Pass in an array of variables to use that order instead of
         * the default alphabetical order
         * @param vars {Array}
         */
        buildFunction: function(vars) {
          return Build.build(this.symbol, vars);
        },
        /**
         * Checks to see if the expression is just a plain old number
         * @returns {boolean}
         */
        isNumber: function() {
          return isNumericSymbol(this.symbol);
        },
        /**
         * Checks to see if the expression is infinity
         * @returns {boolean}
         */
        isInfinity: function() {
          return Math.abs(this.symbol.multiplier) === Infinity;
        },
        /**
         * Checks to see if the expression contains imaginary numbers
         * @returns {boolean}
         */
        isImaginary: function() {
          return evaluate(_.parse(this.symbol)).isImaginary();
        },
        /**
         * Returns all the variables in the expression
         * @returns {Array}
         */
        variables: function() {
          return variables(this.symbol);
        },
        toString: function() {
          try {
            if (isArray(this.symbol))
              return "[" + this.symbol.toString() + "]";
            return this.symbol.toString();
          } catch (e) {
            return "";
          }
        },
        //forces the symbol to be returned as a decimal
        toDecimal: function(prec) {
          Settings.precision = prec;
          var dec = text(this.symbol, "decimals");
          Settings.precision = void 0;
          return dec;
        },
        //checks to see if the expression is a fraction
        isFraction: function() {
          return isFraction(this.symbol);
        },
        //checks to see if the symbol is a multivariate polynomial
        isPolynomial: function() {
          return this.symbol.isPoly();
        },
        //performs a substitution
        sub: function(symbol, for_symbol) {
          return new Expression(this.symbol.sub(_.parse(symbol), _.parse(for_symbol)));
        },
        operation: function(otype, symbol) {
          if (isExpression(symbol))
            symbol = symbol.symbol;
          else if (!isSymbol(symbol))
            symbol = _.parse(symbol);
          return new Expression(_[otype](this.symbol.clone(), symbol.clone()));
        },
        add: function(symbol) {
          return this.operation("add", symbol);
        },
        subtract: function(symbol) {
          return this.operation("subtract", symbol);
        },
        multiply: function(symbol) {
          return this.operation("multiply", symbol);
        },
        divide: function(symbol) {
          return this.operation("divide", symbol);
        },
        pow: function(symbol) {
          return this.operation("pow", symbol);
        },
        expand: function() {
          return new Expression(_.expand(this.symbol));
        },
        each: function(callback, i) {
          if (this.symbol.each)
            this.symbol.each(callback, i);
          else if (isArray(this.symbol)) {
            for (var i = 0; i < this.symbol.length; i++)
              callback.call(this.symbol, this.symbol[i], i);
          } else
            callback.call(this.symbol);
        },
        eq: function(value) {
          if (!isSymbol(value))
            value = _.parse(value);
          try {
            var d = _.subtract(this.symbol.clone(), value);
            return d.equals(0);
          } catch (e) {
            return false;
          }
          ;
        },
        lt: function(value) {
          if (!isSymbol(value))
            value = _.parse(value);
          try {
            var d = evaluate(_.subtract(this.symbol.clone(), value));
            return d.lessThan(0);
          } catch (e) {
            return false;
          }
          ;
        },
        gt: function(value) {
          if (!isSymbol(value))
            value = _.parse(value);
          try {
            var d = evaluate(_.subtract(this.symbol.clone(), value));
            return d.greaterThan(0);
          } catch (e) {
            return false;
          }
        },
        gte: function(value) {
          return this.gt(value) || this.eq(value);
        },
        lte: function(value) {
          return this.lt(value) || this.eq(value);
        },
        numerator: function() {
          return new Expression(this.symbol.getNum());
        },
        denominator: function() {
          return new Expression(this.symbol.getDenom());
        },
        hasFunction: function(f) {
          return this.symbol.containsFunction(f);
        },
        contains: function(variable) {
          return this.symbol.contains(variable);
        }
      };
      Expression.prototype.toTeX = Expression.prototype.latex;
      function Scientific(num) {
        if (!(this instanceof Scientific))
          return new Scientific(num);
        num = String(typeof num === "undefined" ? 0 : num);
        if (num.startsWith("-")) {
          this.sign = -1;
          num = num.substr(1, num.length);
        } else {
          this.sign = 1;
        }
        if (Scientific.isScientific(num)) {
          this.fromScientific(num);
        } else {
          this.convert(num);
        }
        return this;
      }
      Scientific.prototype = {
        fromScientific: function(num) {
          var parts = String(num).toLowerCase().split("e");
          this.coeff = parts[0];
          this.exponent = parts[1];
          return this;
        },
        convert: function(num) {
          var parts = num.split(".");
          var w = parts[0] || "";
          var d = parts[1] || "";
          w = Scientific.removeLeadingZeroes(w);
          d = Scientific.removeTrailingZeroes(d);
          var dot_location = w.length;
          var n2 = w + d;
          var zeroes = Scientific.leadingZeroes(n2).length;
          this.exponent = dot_location - (zeroes + 1);
          var coeff = Scientific.removeLeadingZeroes(n2);
          this.coeff = coeff.charAt(0) + "." + (coeff.substr(1, coeff.length) || "0");
          var dec = this.coeff.split(".")[1] || "";
          this.decp = dec === "0" ? 0 : dec.length;
          this.dec = d;
          this.wholes = w;
          return this;
        },
        round: function(num) {
          var n2 = this.copy();
          num = Number(num);
          if (num === 0)
            n2.coeff = n2.coeff.charAt(0);
          else {
            var rounded = this.coeff.substring(0, num + 1);
            var next_two = this.coeff.substring(num + 1, num + 3);
            var ed = next_two.charAt(0);
            if (next_two.charAt(1) > 4)
              ed++;
            n2.coeff = rounded + ed;
          }
          return n2;
        },
        copy: function() {
          var n2 = new Scientific(0);
          n2.coeff = this.coeff;
          n2.exponent = this.exponent;
          n2.sign = this.sign;
          return n2;
        },
        toString: function(n2) {
          var retval;
          if (Settings.SCIENTIFIC_IGNORE_ZERO_EXPONENTS && this.exponent === 0 && this.decp < n2) {
            if (this.decp === 0)
              retval = this.wholes;
            else
              retval = this.coeff;
          } else {
            var coeff = typeof n2 === "undefined" ? this.coeff : Scientific.round(this.coeff, Math.min(n2, this.decp || 1));
            retval = this.exponent === 0 ? coeff : coeff + "e" + this.exponent;
          }
          return (this.sign === -1 ? "-" : "") + retval;
        }
      };
      Scientific.isScientific = function(num) {
        return /\d+\.?\d*e[\+\-]*\d+/i.test(num);
      };
      Scientific.leadingZeroes = function(num) {
        var match = num.match(/^(0*).*$/);
        return match ? match[1] : "";
      };
      Scientific.removeLeadingZeroes = function(num) {
        var match = num.match(/^0*(.*)$/);
        return match ? match[1] : "";
      };
      Scientific.removeTrailingZeroes = function(num) {
        var match = num.match(/0*$/);
        return match ? num.substring(0, num.length - match[0].length) : "";
      };
      Scientific.round = function(c, n2) {
        var coeff = nround(c, n2);
        var m = String(coeff).split(".").pop();
        var d = n2 - m.length;
        if (d > 0) {
          coeff = coeff + new Array(d + 1).join(0);
        }
        return coeff;
      };
      function Frac(n2) {
        if (n2 instanceof Frac)
          return n2;
        if (n2 === void 0)
          return this;
        try {
          if (isInt(n2)) {
            try {
              this.num = bigInt(n2);
              this.den = bigInt(1);
            } catch (e) {
              return Frac.simple(n2);
            }
          } else {
            var frac = n2 instanceof bigDec ? Fraction.quickConversion(n2) : Fraction.convert(n2);
            this.num = new bigInt(frac[0]);
            this.den = new bigInt(frac[1]);
          }
        } catch (e) {
          return Frac.simple(n2);
        }
      }
      Frac.create = function(n2) {
        if (n2 instanceof Frac)
          return n2;
        n2 = n2.toString();
        var is_neg = n2.charAt(0) === "-";
        if (is_neg)
          n2 = n2.substr(1, n2.length - 1);
        var frac = new Frac(n2);
        if (is_neg)
          frac.negate();
        return frac;
      };
      Frac.isFrac = function(o) {
        return o instanceof Frac;
      };
      Frac.quick = function(n2, d) {
        var frac = new Frac();
        frac.num = new bigInt(n2);
        frac.den = new bigInt(d);
        return frac;
      };
      Frac.simple = function(n2) {
        var nstr = String(scientificToDecimal(n2)), m_dc = nstr.split("."), num = m_dc.join(""), den = 1, l = (m_dc[1] || "").length;
        for (var i = 0; i < l; i++)
          den += "0";
        var frac = Frac.quick(num, den);
        return frac.simplify();
      };
      Frac.prototype = {
        multiply: function(m) {
          if (this.isOne()) {
            return m.clone();
          }
          if (m.isOne()) {
            return this.clone();
          }
          var c = this.clone();
          c.num = c.num.multiply(m.num);
          c.den = c.den.multiply(m.den);
          return c.simplify();
        },
        divide: function(m) {
          if (m.equals(0))
            throw new DivisionByZero("Division by zero not allowed!");
          return this.clone().multiply(m.clone().invert()).simplify();
        },
        subtract: function(m) {
          return this.clone().add(m.clone().neg());
        },
        neg: function() {
          this.num = this.num.multiply(-1);
          return this;
        },
        add: function(m) {
          var n1 = this.den, n2 = m.den, c = this.clone();
          var a = c.num, b = m.num;
          if (n1.equals(n2)) {
            c.num = a.add(b);
          } else {
            c.num = a.multiply(n2).add(b.multiply(n1));
            c.den = n1.multiply(n2);
          }
          return c.simplify();
        },
        mod: function(m) {
          var a = this.clone(), b = m.clone();
          a.num = a.num.multiply(b.den);
          a.den = a.den.multiply(b.den);
          b.num = b.num.multiply(this.den);
          b.den = b.den.multiply(this.den);
          a.num = a.num.mod(b.num);
          return a.simplify();
        },
        simplify: function() {
          var gcd = bigInt.gcd(this.num, this.den);
          this.num = this.num.divide(gcd);
          this.den = this.den.divide(gcd);
          return this;
        },
        clone: function() {
          var m = new Frac();
          m.num = new bigInt(this.num);
          m.den = new bigInt(this.den);
          return m;
        },
        decimal: function(prec) {
          var sign = this.num.isNegative() ? "-" : "";
          if (this.num.equals(this.den)) {
            return "1";
          }
          prec = prec || Settings.PRECISION;
          prec++;
          var narr = [], n2 = this.num.abs(), d = this.den;
          for (var i = 0; i < prec; i++) {
            var w = n2.divide(d), r = n2.subtract(w.multiply(d));
            narr.push(w);
            if (r.equals(0))
              break;
            n2 = r.times(10);
          }
          var whole = narr.shift();
          if (narr.length === 0) {
            return sign + whole.toString();
          }
          if (i === prec) {
            var lt = [];
            for (var i = 0; i < 2; i++)
              lt.unshift(narr.pop());
            narr.push(Math.round(lt.join(".")));
          }
          var dec = whole.toString() + "." + narr.join("");
          return sign + dec;
        },
        toDecimal: function(prec) {
          prec = prec || Settings.PRECISION;
          if (prec) {
            return this.decimal(prec);
          } else {
            return this.num / this.den;
          }
        },
        qcompare: function(n2) {
          return [this.num.multiply(n2.den), n2.num.multiply(this.den)];
        },
        equals: function(n2) {
          if (!isNaN(n2))
            n2 = new Frac(n2);
          var q = this.qcompare(n2);
          return q[0].equals(q[1]);
        },
        absEquals: function(n2) {
          if (!isNaN(n2))
            n2 = new Frac(n2);
          var q = this.qcompare(n2);
          return q[0].abs().equals(q[1]);
        },
        //lazy check to be fixed. Sufficient for now but will cause future problems
        greaterThan: function(n2) {
          if (!isNaN(n2))
            n2 = new Frac(n2);
          var q = this.qcompare(n2);
          return q[0].gt(q[1]);
        },
        gte: function(n2) {
          return this.greaterThan(n2) || this.equals(n2);
        },
        lte: function(n2) {
          return this.lessThan(n2) || this.equals(n2);
        },
        lessThan: function(n2) {
          if (!isNaN(n2))
            n2 = new Frac(n2);
          var q = this.qcompare(n2);
          return q[0].lt(q[1]);
        },
        isInteger: function() {
          return this.den.equals(1);
        },
        negate: function() {
          this.num = this.num.multiply(-1);
          return this;
        },
        invert: function() {
          var t = this.den;
          if (!this.num.equals(0)) {
            var isnegative = this.num.isNegative();
            this.den = this.num.abs();
            this.num = t;
            if (isnegative)
              this.num = this.num.multiply(-1);
          }
          return this;
        },
        isOne: function() {
          return this.num.equals(1) && this.den.equals(1);
        },
        sign: function() {
          return this.num.isNegative() ? -1 : 1;
        },
        abs: function() {
          this.num = this.num.abs();
          return this;
        },
        gcd: function(f) {
          return Frac.quick(bigInt.gcd(f.num, this.num), bigInt.lcm(f.den, this.den));
        },
        toString: function() {
          return !this.den.equals(1) ? this.num.toString() + "/" + this.den.toString() : this.num.toString();
        },
        valueOf: function() {
          if (Settings.USE_BIG)
            return new bigDec(this.num.toString()).div(new bigDec(this.den.toString()));
          var retval = this.num / this.den;
          return retval;
        },
        isNegative: function() {
          return this.toDecimal() < 0;
        }
      };
      function Symbol2(obj) {
        var isInfinity = obj === "Infinity";
        if (!(this instanceof Symbol2)) {
          return new Symbol2(obj);
        }
        if (obj instanceof bigDec) {
          obj = obj.toString();
        }
        if (/^(\-?\+?\d+)\.?\d*e?\-?\+?\d*/i.test(obj) || obj instanceof bigDec) {
          this.group = N;
          this.value = CONST_HASH;
          this.multiplier = new Frac(obj);
        } else {
          this.group = S;
          validateName(obj);
          this.value = obj;
          this.multiplier = new Frac(1);
          this.imaginary = obj === Settings.IMAGINARY;
          this.isInfinity = isInfinity;
        }
        this.power = new Frac(1);
        return this;
      }
      Symbol2.imaginary = function() {
        var s = new Symbol2(Settings.IMAGINARY);
        s.imaginary = true;
        return s;
      };
      Symbol2.infinity = function(negative) {
        var v = new Symbol2("Infinity");
        if (negative === -1)
          v.negate();
        return v;
      };
      Symbol2.shell = function(group, value) {
        var symbol = new Symbol2(value);
        symbol.group = group;
        symbol.symbols = {};
        symbol.length = 0;
        return symbol;
      };
      Symbol2.unwrapSQRT = function(symbol, all) {
        var p = symbol.power;
        if (symbol.fname === SQRT && (symbol.isLinear() || all)) {
          var t = symbol.args[0].clone();
          t.power = t.power.multiply(new Frac(1 / 2));
          t.multiplier = t.multiplier.multiply(symbol.multiplier);
          symbol = t;
          if (all)
            symbol.power = p.multiply(new Frac(1 / 2));
        }
        return symbol;
      };
      Symbol2.hyp = function(a, b) {
        a = a || new Symbol2(0);
        b = b || new Symbol2(0);
        return _.sqrt(_.add(_.pow(a.clone(), new Symbol2(2)), _.pow(b.clone(), new Symbol2(2))));
      };
      Symbol2.toPolarFormArray = function(symbol) {
        var re, im, r, theta;
        re = symbol.realpart();
        im = symbol.imagpart();
        r = Symbol2.hyp(re, im);
        theta = re.equals(0) ? _.parse("pi/2") : _.trig.atan(_.divide(im, re));
        return [r, theta];
      };
      Symbol2.unwrapPARENS = function(symbol) {
        if (symbol.fname === "") {
          var r = symbol.args[0];
          r.power = r.power.multiply(symbol.power);
          r.multiplier = r.multiplier.multiply(symbol.multiplier);
          if (symbol.fname === "")
            return Symbol2.unwrapPARENS(r);
          return r;
        }
        return symbol;
      };
      Symbol2.create = function(value, power) {
        power = power === void 0 ? 1 : power;
        return _.parse("(" + value + ")^(" + power + ")");
      };
      Symbol2.prototype = {
        /**
         * Gets nth root accounting for rounding errors
         * @param {Number} n
         * @return {Number}
         */
        getNth: function(n2) {
          var root = evaluate(_.pow(_.parse(this.multiplier), _.parse(n2).invert()));
          var rounded = _.parse(nround(root));
          var e = evaluate(_.pow(rounded, _.parse(n2)));
          if (e.equals(_.parse(this.multiplier))) {
            return rounded;
          }
          return root;
        },
        /**
         * Checks if symbol is to the nth power
         * @returns {Boolean}
         */
        isToNth: function(n2) {
          var root = this.getNth(n2);
          var nthMultiplier = isInt(root);
          var nthPower;
          if (this.group === CB) {
            nthPower = true;
            this.each(function(x) {
              var isNth = x.isToNth(n2);
              if (!isNth) {
                nthPower = false;
              }
            });
          } else {
            nthPower = this.group === N ? true : isInt(_.divide(_.parse(this.power), _.parse(n2)));
          }
          return nthMultiplier && nthPower;
        },
        /**
         * Checks if a symbol is square
         * @return {Boolean}
         */
        isSquare: function() {
          return this.isToNth(2);
        },
        /**
         * Checks if a symbol is cube
         * @return {Boolean}
         */
        isCube: function() {
          return this.isToNth(3);
        },
        /**
         * Checks if a symbol is a bare variable
         * @return {Boolean}
         */
        isSimple: function() {
          return this.power.equals(1) && this.multiplier.equals(1);
        },
        /**
         * Simplifies the power of the symbol
         * @returns {Symbol} a clone of the symbol
         */
        powSimp: function() {
          if (this.group === CB) {
            var powers = [], sign = this.multiplier.sign();
            this.each(function(x2) {
              var p = x2.power;
              if (isSymbol(p) || p.equals(1))
                return this.clone();
              powers.push(p);
            });
            var min = new Frac(arrayMin(powers));
            var sign = this.multiplier.sign(), m = this.multiplier.clone().abs(), mfactors = Math2.ifactor(m);
            var out_ = new Frac(1);
            var in_ = new Frac(1);
            for (var x in mfactors) {
              var n2 = new Frac(mfactors[x]);
              if (!n2.lessThan(min)) {
                n2 = n2.divide(min).subtract(new Frac(1));
                in_ = in_.multiply(new Frac(x));
              }
              out_ = out_.multiply(_.parse(inBrackets(x) + "^" + inBrackets(n2)).multiplier);
            }
            var t = new Symbol2(in_);
            this.each(function(x2) {
              x2 = x2.clone();
              x2.power = x2.power.divide(min);
              t = _.multiply(t, x2);
            });
            var xt = _.symfunction(PARENTHESIS, [t]);
            xt.power = min;
            xt.multiplier = sign < 0 ? out_.negate() : out_;
            return xt;
          }
          return this.clone();
        },
        /**
         * Checks to see if two functions are of equal value
         * @param {Symbol} symbol
         */
        equals: function(symbol) {
          if (!isSymbol(symbol))
            symbol = new Symbol2(symbol);
          return this.value === symbol.value && this.power.equals(symbol.power) && this.multiplier.equals(symbol.multiplier) && this.group === symbol.group;
        },
        abs: function() {
          var e = this.clone();
          e.multiplier.abs();
          return e;
        },
        // Greater than
        gt: function(symbol) {
          if (!isSymbol(symbol))
            symbol = new Symbol2(symbol);
          return this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);
        },
        // Greater than
        gte: function(symbol) {
          if (!isSymbol(symbol))
            symbol = new Symbol2(symbol);
          return this.equals(symbol) || this.isConstant() && symbol.isConstant() && this.multiplier.greaterThan(symbol.multiplier);
        },
        // Less than
        lt: function(symbol) {
          if (!isSymbol(symbol))
            symbol = new Symbol2(symbol);
          return this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);
        },
        // Less than
        lte: function(symbol) {
          if (!isSymbol(symbol))
            symbol = new Symbol2(symbol);
          return this.equals(symbol) || this.isConstant() && symbol.isConstant() && this.multiplier.lessThan(symbol.multiplier);
        },
        /**
         * Because nerdamer doesn't group symbols by polynomials but
         * rather a custom grouping method, this has to be
         * reinserted in order to make use of most algorithms. This function
         * checks if the symbol meets the criteria of a polynomial.
         * @param {bool} multivariate
         * @returns {boolean}
         */
        isPoly: function(multivariate) {
          var g = this.group, p = this.power;
          if (!isInt(p) || p < 0)
            return false;
          if (g === N || g === S || this.isConstant(true))
            return true;
          var vars = variables(this);
          if (g === CB && vars.length === 1) {
            var v = vars[0];
            if (!v)
              return true;
            for (var x in this.symbols) {
              var sym = this.symbols[x];
              if (sym.group === FN && !sym.args[0].isConstant())
                return false;
              if (!sym.contains(v) && !sym.isConstant(true))
                return false;
            }
            return true;
          }
          if (this.isComposite() || g === CB && multivariate) {
            if (!multivariate && vars.length > 1)
              return false;
            for (var x in this.symbols) {
              if (!this.symbols[x].isPoly(multivariate))
                return false;
            }
            return true;
          } else
            return false;
        },
        //removes the requested variable from the symbol and returns the remainder
        stripVar: function(x, exclude_x) {
          var retval;
          if ((this.group === PL || this.group === S) && this.value === x)
            retval = new Symbol2(exclude_x ? 0 : this.multiplier);
          else if (this.group === CB && this.isLinear()) {
            retval = new Symbol2(1);
            this.each(function(s) {
              if (!s.contains(x, true))
                retval = _.multiply(retval, s.clone());
            });
            retval.multiplier = retval.multiplier.multiply(this.multiplier);
          } else if (this.group === CP && !this.isLinear()) {
            retval = new Symbol2(this.multiplier);
          } else if (this.group === CP && this.isLinear()) {
            retval = new Symbol2(0);
            this.each(function(s) {
              if (!s.contains(x)) {
                var t = s.clone();
                t.multiplier = t.multiplier.multiply(this.multiplier);
                retval = _.add(retval, t);
              }
            });
            if (retval.equals(0))
              retval = new Symbol2(this.multiplier);
          } else if (this.group === EX && this.power.contains(x, true)) {
            retval = new Symbol2(this.multiplier);
          } else if (this.group === FN && this.contains(x)) {
            retval = new Symbol2(this.multiplier);
          } else
            retval = this.clone();
          return retval;
        },
        //returns symbol in array form with x as base e.g. a*x^2+b*x+c = [c, b, a].
        toArray: function(v, arr) {
          arr = arr || {
            arr: [],
            add: function(x2, idx) {
              var e = this.arr[idx];
              this.arr[idx] = e ? _.add(e, x2) : x2;
            }
          };
          var g = this.group;
          if (g === S && this.contains(v)) {
            arr.add(new Symbol2(this.multiplier), this.power);
          } else if (g === CB) {
            var a = this.stripVar(v), x = _.divide(this.clone(), a.clone());
            var p = x.isConstant() ? 0 : x.power;
            arr.add(a, p);
          } else if (g === PL && this.value === v) {
            this.each(function(x2, p2) {
              arr.add(x2.stripVar(v), p2);
            });
          } else if (g === CP) {
            this.each(function(x2) {
              x2.toArray(v, arr);
            });
          } else if (this.contains(v)) {
            throw new NerdamerTypeError("Cannot convert to array! Exiting");
          } else {
            arr.add(this.clone(), 0);
          }
          arr = arr.arr;
          for (var i = 0; i < arr.length; i++)
            if (!arr[i])
              arr[i] = new Symbol2(0);
          return arr;
        },
        //checks to see if a symbol contans a function
        hasFunc: function(v) {
          var fn_group = this.group === FN || this.group === EX;
          if (fn_group && !v || fn_group && this.contains(v))
            return true;
          if (this.symbols) {
            for (var x in this.symbols) {
              if (this.symbols[x].hasFunc(v))
                return true;
            }
          }
          return false;
        },
        sub: function(a, b) {
          a = !isSymbol(a) ? _.parse(a) : a.clone();
          b = !isSymbol(b) ? _.parse(b) : b.clone();
          if (a.group === N || a.group === P)
            err("Cannot substitute a number. Must be a variable");
          var same_pow = false, a_is_unit_multiplier = a.multiplier.equals(1), m = this.multiplier.clone(), retval;
          if (this.value === a.value && (this.group !== PL && a.group !== PL || this.group === PL && a.group === PL)) {
            if (a_is_unit_multiplier || a.multiplier.equals(this.multiplier)) {
              if (a.isLinear()) {
                retval = b;
              } else if (a.power.equals(this.power)) {
                retval = b;
                same_pow = true;
              }
              if (a.multiplier.equals(this.multiplier))
                m = new Frac(1);
            }
          } else if (this.group === CB || this.previousGroup === CB) {
            retval = new Symbol2(1);
            this.each(function(x2) {
              var subbed = _.parse(x2.sub(a, b));
              retval = _.multiply(retval, subbed);
            });
          } else if (this.isComposite()) {
            var symbol = this.clone();
            if (a.isComposite() && symbol.isComposite() && symbol.isLinear() && a.isLinear()) {
              var find = function(stack, needle) {
                for (var x2 in stack.symbols) {
                  var sym = stack.symbols[x2];
                  if (sym.isComposite() && find(sym, needle) || sym.equals(needle))
                    return true;
                }
                return false;
              };
              for (var x in a.symbols) {
                if (!find(symbol, a.symbols[x]))
                  return symbol.clone();
              }
              retval = _.add(_.subtract(symbol.clone(), a), b);
            } else {
              retval = new Symbol2(0);
              symbol.each(function(x2) {
                retval = _.add(retval, x2.sub(a, b));
              });
            }
          } else if (this.group === EX) {
            retval = _.parse(this.value).sub(a, b);
          } else if (this.group === FN) {
            var nargs = [];
            for (var i = 0; i < this.args.length; i++) {
              var arg = this.args[i];
              if (!isSymbol(arg))
                arg = _.parse(arg);
              nargs.push(arg.sub(a, b));
            }
            retval = _.symfunction(this.fname, nargs);
          }
          if (retval) {
            if (!same_pow) {
              var p = this.group === EX ? this.power.sub(a, b) : _.parse(this.power);
              retval = _.pow(retval, p);
            }
            retval.multiplier = retval.multiplier.multiply(m);
            return retval;
          }
          return this.clone();
        },
        isMonomial: function() {
          if (this.group === S)
            return true;
          if (this.group === CB) {
            for (var x in this.symbols)
              if (this.symbols[x].group !== S)
                return false;
          } else
            return false;
          return true;
        },
        isPi: function() {
          return this.group === S && this.value === "pi";
        },
        sign: function() {
          return this.multiplier.sign();
        },
        isE: function() {
          return this.value === "e";
        },
        isSQRT: function() {
          return this.fname === SQRT;
        },
        isConstant: function(check_all, check_symbols) {
          if (check_symbols && this.group === CB) {
            for (var x in this.symbols) {
              if (this.symbols[x].isConstant(true))
                return true;
            }
          }
          if (check_all === "functions" && this.isComposite()) {
            var isConstant = true;
            this.each(function(x2) {
              if (!x2.isConstant(check_all, check_symbols)) {
                isConstant = false;
              }
            }, true);
            return isConstant;
          }
          if (check_all === "all" && (this.isPi() || this.isE())) {
            return true;
          }
          if (check_all && this.group === FN) {
            for (var i = 0; i < this.args.length; i++) {
              if (!this.args[i].isConstant(check_all))
                return false;
            }
            return true;
          }
          if (check_all)
            return isNumericSymbol(this);
          return this.value === CONST_HASH;
        },
        //the symbols is imaginary if
        //1. n*i
        //2. a+b*i
        //3. a*i
        isImaginary: function() {
          if (this.imaginary)
            return true;
          else if (this.symbols) {
            for (var x in this.symbols)
              if (this.symbols[x].isImaginary())
                return true;
          }
          return false;
        },
        /**
         * Returns the real part of a symbol
         * @returns {Symbol}
         */
        realpart: function() {
          if (this.isConstant()) {
            return this.clone();
          } else if (this.imaginary)
            return new Symbol2(0);
          else if (this.isComposite()) {
            var retval = new Symbol2(0);
            this.each(function(x) {
              retval = _.add(retval, x.realpart());
            });
            return retval;
          } else if (this.isImaginary())
            return new Symbol2(0);
          return this.clone();
        },
        /*
         * Return imaginary part of a symbol
         * @returns {Symbol}
         */
        imagpart: function() {
          if (this.group === S && this.isImaginary())
            return new Symbol2(this.multiplier);
          if (this.isComposite()) {
            var retval = new Symbol2(0);
            this.each(function(x) {
              retval = _.add(retval, x.imagpart());
            });
            return retval;
          }
          if (this.group === CB)
            return this.stripVar(Settings.IMAGINARY);
          return new Symbol2(0);
        },
        isInteger: function() {
          return this.isConstant() && this.multiplier.isInteger();
        },
        isLinear: function(wrt) {
          if (wrt) {
            if (this.isConstant())
              return true;
            if (this.group === S) {
              if (this.value === wrt)
                return this.power.equals(1);
              else
                return true;
            }
            if (this.isComposite() && this.power.equals(1)) {
              for (var x in this.symbols) {
                if (!this.symbols[x].isLinear(wrt))
                  return false;
              }
              return true;
            }
            if (this.group === CB && this.symbols[wrt])
              return this.symbols[wrt].isLinear(wrt);
            return false;
          } else
            return this.power.equals(1);
        },
        /**
         * Checks to see if a symbol has a function by a specified name or within a specified list
         * @param {String|String[]} names
         * @returns {Boolean}
         */
        containsFunction: function(names) {
          if (typeof names === "string")
            names = [names];
          if (this.group === FN && names.indexOf(this.fname) !== -1)
            return true;
          if (this.symbols) {
            for (var x in this.symbols) {
              if (this.symbols[x].containsFunction(names))
                return true;
            }
          }
          return false;
        },
        multiplyPower: function(p2) {
          if (this.group === N && this.multiplier.equals(1))
            return this;
          var p1 = this.power;
          if (this.group !== EX && p2.group === N) {
            var p = p2.multiplier;
            if (this.group === N && !p.isInteger()) {
              this.convert(P);
            }
            this.power = p1.equals(1) ? p.clone() : p1.multiply(p);
            if (this.group === P && isInt(this.power)) {
              this.value = Math.pow(this.value, this.power);
              this.toLinear();
              this.convert(N);
            }
          } else {
            if (this.group !== EX) {
              p1 = new Symbol2(p1);
              this.convert(EX);
            }
            this.power = _.multiply(p1, p2);
          }
          return this;
        },
        setPower: function(p, retainSign) {
          if (this.group === N && this.multiplier.equals(1)) {
            return this;
          }
          if (this.group === EX && !isSymbol(p)) {
            this.group = this.previousGroup;
            delete this.previousGroup;
            if (this.group === N) {
              this.multiplier = new Frac(this.value);
              this.value = CONST_HASH;
            } else
              this.power = p;
          } else {
            var isSymbolic = false;
            if (isSymbol(p)) {
              if (p.group === N) {
                p = p.multiplier;
              } else {
                isSymbolic = true;
              }
            }
            var group = isSymbolic ? EX : P;
            this.power = p;
            if (this.group === N && group)
              this.convert(group, retainSign);
          }
          return this;
        },
        /**
         * Checks to see if symbol is located in the denominator
         * @returns {boolean}
         */
        isInverse: function() {
          if (this.group === EX)
            return this.power.multiplier.lessThan(0);
          return this.power < 0;
        },
        /**
         * Make a duplicate of a symbol by copying a predefined list of items.
         * The name 'copy' would probably be a more appropriate name.
         * to a new symbol
         * @param {Symbol} c
         * @returns {Symbol}
         */
        clone: function(c) {
          var clone2 = c || new Symbol2(0), properties = [
            "value",
            "group",
            "length",
            "previousGroup",
            "imaginary",
            "fname",
            "args",
            "isInfinity",
            "scientific"
          ], l = properties.length, i;
          if (this.symbols) {
            clone2.symbols = {};
            for (var x in this.symbols) {
              clone2.symbols[x] = this.symbols[x].clone();
            }
          }
          for (i = 0; i < l; i++) {
            if (this[properties[i]] !== void 0) {
              clone2[properties[i]] = this[properties[i]];
            }
          }
          clone2.power = this.power.clone();
          clone2.multiplier = this.multiplier.clone();
          if (this.isConversion)
            clone2.isConversion = this.isConversion;
          if (this.isUnit)
            clone2.isUnit = this.isUnit;
          return clone2;
        },
        /**
         * Converts a symbol multiplier to one.
         * @param {Boolean} keepSign Keep the multiplier as negative if the multiplier is negative and keepSign is true
         * @returns {Symbol}
         */
        toUnitMultiplier: function(keepSign) {
          this.multiplier.num = new bigInt(this.multiplier.num.isNegative() && keepSign ? -1 : 1);
          this.multiplier.den = new bigInt(1);
          return this;
        },
        /**
         * Converts a Symbol's power to one.
         * @returns {Symbol}
         */
        toLinear: function() {
          if (this.power.equals(1)) {
            return this;
          }
          this.setPower(new Frac(1));
          return this;
        },
        /**
         * Iterates over all the sub-symbols. If no sub-symbols exist then it's called on itself
         * @param {Function} fn
         * @@param {Boolean} deep If true it will itterate over the sub-symbols their symbols as well
         */
        each: function(fn, deep) {
          if (!this.symbols) {
            fn.call(this, this, this.value);
          } else {
            for (var x in this.symbols) {
              var sym = this.symbols[x];
              if (sym.group === PL && deep) {
                for (var y in sym.symbols) {
                  fn.call(x, sym.symbols[y], y);
                }
              } else
                fn.call(this, sym, x);
            }
          }
        },
        /**
         * A numeric value to be returned for Javascript. It will try to
         * return a number as far a possible but in case of a pure symbolic
         * symbol it will just return its text representation
         * @returns {String|Number}
         */
        valueOf: function() {
          if (this.group === N)
            return this.multiplier.valueOf();
          else if (this.power === 0) {
            return 1;
          } else if (this.multiplier === 0) {
            return 0;
          } else {
            return text(this, "decimals");
          }
        },
        /**
         * Checks to see if a symbols has a particular variable within it.
         * Pass in true as second argument to include the power of exponentials
         * which aren't check by default.
         * @example var s = _.parse('x+y+z'); s.contains('y');
         * //returns true
         * @param {any} variable
         * @param {boolean} all
         * @returns {boolean}
         */
        contains: function(variable, all) {
          variable = String(variable);
          var g = this.group;
          if (this.value === variable)
            return true;
          if (this.symbols) {
            for (var x in this.symbols) {
              if (this.symbols[x].contains(variable, all))
                return true;
            }
          }
          if (g === FN || this.previousGroup === FN) {
            for (var i = 0; i < this.args.length; i++) {
              if (this.args[i].contains(variable, all))
                return true;
            }
          }
          if (g === EX) {
            if (all && this.power.contains(variable, all)) {
              return true;
            }
            if (this.value === variable)
              return true;
          }
          return this.value === variable;
        },
        /**
         * Negates a symbols
         * @returns {boolean}
         */
        negate: function() {
          this.multiplier.negate();
          if (this.group === CP || this.group === PL)
            this.distributeMultiplier();
          return this;
        },
        /**
         * Inverts a symbol
         * @param {boolean} power_only
         * @param {boolean} all
         * @returns {boolean}
         */
        invert: function(power_only, all) {
          if (!power_only)
            this.multiplier = this.multiplier.invert();
          if (isSymbol(this.power)) {
            this.power.negate();
          } else if (this.group === CB && all) {
            this.each(function(x) {
              return x.invert();
            });
          } else {
            if (this.power && this.group !== N)
              this.power.negate();
          }
          return this;
        },
        /**
         * Symbols of group CP or PL may have the multiplier being carried by
         * the top level symbol at any given time e.g. 2*(x+y+z). This is
         * convenient in many cases, however in some cases the multiplier needs
         * to be carried individually e.g. 2*x+2*y+2*z.
         * This method distributes the multiplier over the entire symbol
         * @param {boolean} all
         * @returns {Symbol}
         */
        distributeMultiplier: function(all) {
          var is_one = all ? this.power.absEquals(1) : this.power.equals(1);
          if (this.symbols && is_one && this.group !== CB && !this.multiplier.equals(1)) {
            for (var x in this.symbols) {
              var s = this.symbols[x];
              s.multiplier = s.multiplier.multiply(this.multiplier);
              s.distributeMultiplier();
            }
            this.toUnitMultiplier();
          }
          return this;
        },
        /**
         * This method expands the exponent over the entire symbol just like
         * distributeMultiplier
         * @returns {Symbol}
         */
        distributeExponent: function() {
          if (!this.power.equals(1)) {
            var p = this.power;
            for (var x in this.symbols) {
              var s = this.symbols[x];
              if (s.group === EX) {
                s.power = _.multiply(s.power, new Symbol2(p));
              } else {
                this.symbols[x].power = this.symbols[x].power.multiply(p);
              }
            }
            this.toLinear();
          }
          return this;
        },
        /**
         * This method will attempt to up-convert or down-convert one symbol
         * from one group to another. Not all symbols are convertible from one
         * group to another however. In that case the symbol will remain
         * unchanged.
         * @param {int} group
         * @param {string} imaginary
         */
        convert: function(group, imaginary) {
          if (group > FN) {
            var cp = this.clone();
            this.symbols = {};
            if (group === CB) {
              cp.toUnitMultiplier();
            } else {
              this.toUnitMultiplier();
            }
            if (this.group === FN) {
              cp.args = this.args;
              delete this.args;
              delete this.fname;
            }
            if (this.isImgSymbol)
              delete this.isImgSymbol;
            this.toLinear();
            this.symbols[cp.keyForGroup(group)] = cp;
            this.group = group;
            this.length = 1;
          } else if (group === EX) {
            if (!(this.group === N && this.multiplier.equals(1))) {
              if (this.group !== EX)
                this.previousGroup = this.group;
              if (this.group === N) {
                this.value = this.multiplier.num.toString();
                this.toUnitMultiplier();
              } else
                this.value = text(this, "hash");
              this.group = EX;
            }
          } else if (group === N) {
            var m = this.multiplier.toDecimal();
            if (this.symbols)
              this.symbols = void 0;
            new Symbol2(this.group === P ? m * Math.pow(this.value, this.power) : m).clone(this);
          } else if (group === P && this.group === N) {
            this.value = imaginary ? this.multiplier.num.toString() : Math.abs(this.multiplier.num.toString());
            this.toUnitMultiplier(!imaginary);
            this.group = P;
          }
          return this;
        },
        /**
         * This method is one of the principal methods to make it all possible.
         * It performs cleanup and prep operations whenever a symbols is
         * inserted. If the symbols results in a 1 in a CB (multiplication)
         * group for instance it will remove the redundant symbol. Similarly
         * in a symbol of group PL or CP (symbols glued by multiplication) it
         * will remove any dangling zeroes from the symbol. It will also
         * up-convert or down-convert a symbol if it detects that it's
         * incorrectly grouped. It should be noted that this method is not
         * called directly but rather by the 'attach' method for addition groups
         * and the 'combine' method for multiplication groups.
         * @param {Symbol} symbol
         * @param {String} action
         */
        insert: function(symbol, action) {
          if (!isSymbol(symbol))
            err("Object " + symbol + " is not of type Symbol!");
          if (this.symbols) {
            var group = this.group;
            if (group > FN) {
              var key = symbol.keyForGroup(group);
              var existing = key in this.symbols ? this.symbols[key] : false;
              if (action === "add") {
                var hash = key;
                if (existing) {
                  this.symbols[hash] = _.add(existing, symbol);
                  if (this.symbols[hash].multiplier.equals(0)) {
                    delete this.symbols[hash];
                    this.length--;
                    if (this.length === 0) {
                      this.convert(N);
                      this.multiplier = new Frac(0);
                    }
                  }
                } else {
                  this.symbols[key] = symbol;
                  this.length++;
                }
              } else {
                if (symbol.group === P && isInt(symbol.power)) {
                  symbol.convert(N);
                }
                if (symbol.group !== EX) {
                  this.multiplier = this.multiplier.multiply(symbol.multiplier);
                  symbol.toUnitMultiplier();
                } else {
                  symbol.parens = symbol.multiplier.lessThan(0);
                  this.multiplier = this.multiplier.multiply(symbol.multiplier.clone().abs());
                  symbol.toUnitMultiplier(true);
                }
                if (existing) {
                  symbol = _.multiply(remove(this.symbols, key), symbol);
                  if (symbol.isConstant()) {
                    this.multiplier = this.multiplier.multiply(symbol.multiplier);
                    symbol = new Symbol2(1);
                  }
                  this.length--;
                }
                if (!symbol.isOne(true)) {
                  this.symbols[key] = symbol;
                  this.length++;
                } else if (symbol.multiplier.lessThan(0)) {
                  this.negate();
                }
              }
              if (this.length === 0)
                this.convert(N);
              if (this.group === CP || this.group === CB) {
                this.updateHash();
              }
            }
          }
          return this;
        },
        //the insert method for addition
        attach: function(symbol) {
          if (isArray(symbol)) {
            for (var i = 0; i < symbol.length; i++)
              this.insert(symbol[i], "add");
            return this;
          }
          return this.insert(symbol, "add");
        },
        //the insert method for multiplication
        combine: function(symbol) {
          if (isArray(symbol)) {
            for (var i = 0; i < symbol.length; i++)
              this.insert(symbol[i], "multiply");
            return this;
          }
          return this.insert(symbol, "multiply");
        },
        /**
         * This method should be called after any major "surgery" on a symbol.
         * It updates the hash of the symbol for example if the fname of a
         * function has changed it will update the hash of the symbol.
         */
        updateHash: function() {
          if (this.group === N)
            return;
          if (this.group === FN) {
            var contents = "", args = this.args, is_parens = this.fname === PARENTHESIS;
            for (var i = 0; i < args.length; i++)
              contents += (i === 0 ? "" : ",") + text(args[i]);
            var fn_name = is_parens ? "" : this.fname;
            this.value = fn_name + (is_parens ? contents : inBrackets(contents));
          } else if (!(this.group === S || this.group === PL)) {
            this.value = text(this, "hash");
          }
        },
        /**
         * this function defines how every group in stored within a group of
         * higher order think of it as the switchboard for the library. It
         * defines the hashes for symbols.
         * @param {int} group
         */
        keyForGroup: function(group) {
          var g = this.group;
          var key;
          if (g === N) {
            key = this.value;
          } else if (g === S || g === P) {
            if (group === PL)
              key = this.power.toDecimal();
            else
              key = this.value;
          } else if (g === FN) {
            if (group === PL)
              key = this.power.toDecimal();
            else
              key = text(this, "hash");
          } else if (g === PL) {
            if (group === CB)
              key = text(this, "hash");
            else if (group === CP) {
              if (this.power.equals(1))
                key = this.value;
              else
                key = inBrackets(text(this, "hash")) + Settings.POWER_OPERATOR + this.power.toDecimal();
            } else if (group === PL)
              key = this.power.toString();
            else
              key = this.value;
            return key;
          } else if (g === CP) {
            if (group === CP) {
              key = text(this, "hash");
            }
            if (group === PL)
              key = this.power.toDecimal();
            else
              key = this.value;
          } else if (g === CB) {
            if (group === PL)
              key = this.power.toDecimal();
            else
              key = text(this, "hash");
          } else if (g === EX) {
            if (group === PL)
              key = text(this.power);
            else
              key = text(this, "hash");
          }
          return key;
        },
        /**
         * Symbols are typically stored in an object which works fine for most
         * cases but presents a problem when the order of the symbols makes
         * a difference. This function simply collects all the symbols and
         * returns them as an array. If a function is supplied then that
         * function is called on every symbol contained within the object.
         * @param {Function} fn
         * @param {Object} opt
         * @param {Function} sort_fn
         * @@param {Boolean} expand_symbol
         * @returns {Array}
         */
        collectSymbols: function(fn, opt, sort_fn, expand_symbol) {
          var collected = [];
          if (!this.symbols)
            collected.push(this);
          else {
            for (var x in this.symbols) {
              var symbol = this.symbols[x];
              if (expand_symbol && (symbol.group === PL || symbol.group === CP)) {
                collected = collected.concat(symbol.collectSymbols());
              } else
                collected.push(fn ? fn(symbol, opt) : symbol);
            }
          }
          if (sort_fn === null)
            sort_fn = void 0;
          return collected.sort(sort_fn);
        },
        /**
         * Returns the latex representation of the symbol
         * @param {String} option
         * @returns {String}
         */
        latex: function(option) {
          return LaTeX.latex(this, option);
        },
        /**
         * Returns the text representation of a symbol
         * @param {String} option
         * @returns {String}
         */
        text: function(option) {
          return text(this, option);
        },
        /**
         * Checks if the function evaluates to 1. e.g. x^0 or 1 :)
         * @@param {bool} abs Compares the absolute value
         */
        isOne: function(abs) {
          var f = abs ? "absEquals" : "equals";
          if (this.group === N)
            return this.multiplier[f](1);
          else
            return this.power.equals(0);
        },
        isComposite: function() {
          var g = this.group, pg = this.previousGroup;
          return g === CP || g === PL || pg === PL || pg === CP;
        },
        isCombination: function() {
          var g = this.group, pg = this.previousGroup;
          return g === CB || pg === CB;
        },
        lessThan: function(n2) {
          return this.multiplier.lessThan(n2);
        },
        greaterThan: function(n2) {
          if (!isSymbol(n2)) {
            n2 = new Symbol2(n2);
          }
          if (!this.isConstant(true) || !n2.isConstant(true)) {
            return false;
          }
          return this.multiplier.greaterThan(n2.multiplier);
        },
        /**
         * Get's the denominator of the symbol if the symbol is of class CB (multiplication)
         * with other classes the symbol is either the denominator or not.
         * Take x^-1+x^-2. If the symbol was to be mixed such as x+x^-2 then the symbol doesn't have have an exclusive
         * denominator and has to be found by looking at the actual symbols themselves.
         */
        getDenom: function() {
          var retval, symbol;
          symbol = this.clone();
          if (this.group === CB && this.power.lessThan(0))
            symbol = _.expand(symbol);
          if (symbol.power.lessThan(0) || symbol.group === EX && symbol.power.multiplier.lessThan(0)) {
            var d = _.parse(symbol.multiplier.den);
            retval = symbol.toUnitMultiplier();
            retval.power.negate();
            retval = _.multiply(d, retval);
          } else if (symbol.group === CB) {
            retval = _.parse(symbol.multiplier.den);
            for (var x in symbol.symbols) {
              var s = symbol.symbols[x];
              if (s.power < 0 || s.group === EX && s.power.multiplier.lessThan(0))
                retval = _.multiply(retval, symbol.symbols[x].clone().invert());
            }
          } else {
            retval = _.parse(symbol.multiplier.den);
          }
          return retval;
        },
        getNum: function() {
          var retval, symbol;
          symbol = this.clone();
          if (symbol.group === CB && symbol.power.lessThan(0))
            symbol = _.expand(symbol);
          if (symbol.power.greaterThan(0) && symbol.group !== CB || symbol.group === EX && symbol.power.multiplier.greaterThan(0)) {
            retval = _.multiply(_.parse(symbol.multiplier.num), symbol.toUnitMultiplier());
          } else if (symbol.group === CB) {
            retval = _.parse(symbol.multiplier.num);
            symbol.each(function(x) {
              if (x.power > 0 || x.group === EX && x.power.multiplier > 0) {
                retval = _.multiply(retval, x.clone());
              }
            });
          } else {
            retval = _.parse(symbol.multiplier.num);
          }
          return retval;
        },
        toString: function() {
          return this.text();
        }
      };
      function Parser() {
        var _2 = this;
        var bin = {};
        var preprocessors = { names: [], actions: [] };
        function Slice(upper, lower) {
          this.start = upper;
          this.end = lower;
        }
        ;
        Slice.prototype.isConstant = function() {
          return this.start.isConstant() && this.end.isConstant();
        };
        Slice.prototype.text = function() {
          return text(this.start) + ":" + text(this.end);
        };
        function Collection() {
          this.elements = [];
        }
        Collection.prototype.append = function(e) {
          this.elements.push(e);
        };
        Collection.prototype.getItems = function() {
          return this.elements;
        };
        Collection.prototype.toString = function() {
          return _2.pretty_print(this.elements);
        };
        Collection.create = function(e) {
          var collection = new Collection();
          if (e)
            collection.append(e);
          return collection;
        };
        function Token(node, node_type, column) {
          this.type = node_type;
          this.value = node;
          if (column !== void 0)
            this.column = column + 1;
          if (node_type === Token.OPERATOR) {
            var operator = operators[node];
            for (var x in operator)
              this[x] = operator[x];
          } else if (node_type === Token.FUNCTION) {
            this.precedence = Token.MAX_PRECEDENCE;
            this.leftAssoc = false;
          }
        }
        Token.prototype.toString = function() {
          return this.value;
        };
        Token.prototype.toString = function() {
          if (this.is_prefix)
            return "`" + this.value;
          return this.value;
        };
        Token.OPERATOR = "OPERATOR";
        Token.VARIABLE_OR_LITERAL = "VARIABLE_OR_LITERAL";
        Token.FUNCTION = "FUNCTION";
        Token.UNIT = "UNIT";
        Token.KEYWORD = "KEYWORD";
        Token.MAX_PRECEDENCE = 999;
        this.classes = {
          Collection,
          Slice,
          Token
        };
        var complex = {
          prec: void 0,
          cos: function(r, i) {
            var re, im;
            re = _2.parse(Math.cos(r) * Math.cosh(i));
            im = _2.parse(Math.sin(r) * Math.sinh(i));
            return _2.subtract(re, _2.multiply(im, Symbol2.imaginary()));
          },
          sin: function(r, i) {
            var re, im;
            re = _2.parse(Math.sin(r) * Math.cosh(i));
            im = _2.parse(Math.cos(r) * Math.sinh(i));
            return _2.subtract(re, _2.multiply(im, Symbol2.imaginary()));
          },
          tan: function(r, i) {
            var re, im;
            re = _2.parse(Math.sin(2 * r) / (Math.cos(2 * r) + Math.cosh(2 * i)));
            im = _2.parse(Math.sinh(2 * i) / (Math.cos(2 * r) + Math.cosh(2 * i)));
            return _2.add(re, _2.multiply(im, Symbol2.imaginary()));
          },
          sec: function(r, i) {
            var t = this.removeDen(this.cos(r, i));
            return _2.subtract(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          csc: function(r, i) {
            var t = this.removeDen(this.sin(r, i));
            return _2.add(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          cot: function(r, i) {
            var t = this.removeDen(this.tan(r, i));
            return _2.subtract(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          acos: function(r, i) {
            var symbol, sq, a, b, c, squared;
            symbol = this.fromArray([r, i]);
            squared = _2.pow(symbol.clone(), new Symbol2(2));
            sq = _2.expand(squared);
            a = _2.multiply(sqrt(_2.subtract(new Symbol2(1), sq)), Symbol2.imaginary());
            b = _2.expand(_2.add(symbol.clone(), a));
            c = log(b);
            return _2.expand(_2.multiply(Symbol2.imaginary().negate(), c));
          },
          asin: function(r, i) {
            return _2.subtract(_2.parse("pi/2"), this.acos(r, i));
          },
          atan: function(r, i) {
            if (r.equals(0) && (i.equals(1) || i.equals(-1))) {
              return _2.parse(`${Symbol2.infinity()}*${Settings.IMAGINARY}*${i}`);
            }
            var a, b, c, symbol;
            symbol = complex.fromArray([r, i]);
            a = _2.expand(_2.multiply(Symbol2.imaginary(), symbol.clone()));
            b = log(_2.expand(_2.subtract(new Symbol2(1), a.clone())));
            c = log(_2.expand(_2.add(new Symbol2(1), a.clone())));
            return _2.expand(_2.multiply(_2.divide(Symbol2.imaginary(), new Symbol2(2)), _2.subtract(b, c)));
          },
          asec: function(r, i) {
            var d = this.removeDen([r, i]);
            d[1].negate();
            return this.acos.apply(this, d);
          },
          acsc: function(r, i) {
            var d = this.removeDen([r, i]);
            d[1].negate();
            return this.asin.apply(this, d);
          },
          acot: function(r, i) {
            var d = this.removeDen([r, i]);
            d[1].negate();
            return this.atan.apply(this, d);
          },
          //Hyperbolic trig
          cosh: function(r, i) {
            var re, im;
            re = _2.parse(Math.cosh(r) * Math.cos(i));
            im = _2.parse(Math.sinh(r) * Math.sin(i));
            return _2.add(re, _2.multiply(im, Symbol2.imaginary()));
          },
          sinh: function(r, i) {
            var re, im;
            re = _2.parse(Math.sinh(r) * Math.cos(i));
            im = _2.parse(Math.cosh(r) * Math.sin(i));
            return _2.add(re, _2.multiply(im, Symbol2.imaginary()));
          },
          tanh: function(r, i) {
            var re, im;
            re = _2.parse(Math.sinh(2 * r) / (Math.cos(2 * i) + Math.cosh(2 * r)));
            im = _2.parse(Math.sin(2 * i) / (Math.cos(2 * i) + Math.cosh(2 * r)));
            return _2.subtract(re, _2.multiply(im, Symbol2.imaginary()));
          },
          sech: function(r, i) {
            var t = this.removeDen(this.cosh(r, i));
            return _2.subtract(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          csch: function(r, i) {
            var t = this.removeDen(this.sinh(r, i));
            return _2.subtract(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          coth: function(r, i) {
            var t = this.removeDen(this.tanh(r, i));
            return _2.add(t[0], _2.multiply(t[1], Symbol2.imaginary()));
          },
          acosh: function(r, i) {
            var a, b, z;
            z = this.fromArray([r, i]);
            a = sqrt(_2.add(z.clone(), new Symbol2(1)));
            b = sqrt(_2.subtract(z.clone(), new Symbol2(1)));
            return _2.expand(log(_2.add(z, _2.expand(_2.multiply(a, b)))));
          },
          asinh: function(r, i) {
            var a, z;
            z = this.fromArray([r, i]);
            a = sqrt(_2.add(new Symbol2(1), _2.expand(_2.pow(z.clone(), new Symbol2(2)))));
            return _2.expand(log(_2.add(z, a)));
          },
          atanh: function(r, i) {
            var a, b, z;
            z = this.fromArray([r, i]);
            a = log(_2.add(z.clone(), new Symbol2(1)));
            b = log(_2.subtract(new Symbol2(1), z));
            return _2.expand(_2.divide(_2.subtract(a, b), new Symbol2(2)));
          },
          asech: function(r, i) {
            var t = this.removeDen([r, i]);
            t[1].negate();
            return this.acosh.apply(this, t);
          },
          acsch: function(r, i) {
            var t = this.removeDen([r, i]);
            t[1].negate();
            return this.asinh.apply(this, t);
          },
          acoth: function(r, i) {
            var t = this.removeDen([r, i]);
            t[1].negate();
            return this.atanh.apply(this, t);
          },
          sqrt: function(symbol) {
            var re, im, h, a, d;
            re = symbol.realpart();
            im = symbol.imagpart();
            h = Symbol2.hyp(re, im);
            a = _2.add(re.clone(), h);
            d = sqrt(_2.multiply(new Symbol2(2), a.clone()));
            return _2.add(_2.divide(a.clone(), d.clone()), _2.multiply(_2.divide(im, d), Symbol2.imaginary()));
          },
          log: function(r, i) {
            var re, im, phi;
            re = log(Symbol2.hyp(r, i));
            phi = Settings.USE_BIG ? Symbol2(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal())) : Math.atan2(i, r);
            im = _2.parse(phi);
            return _2.add(re, _2.multiply(Symbol2.imaginary(), im));
          },
          erf(symbol, n2) {
            return _2.symfunction("erf", [symbol]);
            n2 = n2 || 30;
            var f = function(R, I) {
              return block("PARSE2NUMBER", function() {
                var retval = new Symbol2(0);
                for (var i = 0; i < n2; i++) {
                  var a2, b2;
                  a2 = _2.parse(bigDec.exp(bigDec(i).toPower(2).neg().dividedBy(bigDec(n2).pow(2).plus(bigDec(R).toPower(2).times(4)))));
                  b2 = _2.parse(format("2*({1})-e^(-(2*{0}*{1}*{2}))*(2*{1}*cosh({2}*{3})-{0}*{3}*sinh({3}*{2}))", Settings.IMAGINARY, R, I, i));
                  retval = _2.add(retval, _2.multiply(a2, b2));
                }
                return _2.multiply(retval, new Symbol2(2));
              }, true);
            };
            var re, im, a, b, c, k;
            re = symbol.realpart();
            im = symbol.imagpart();
            k = _2.parse(format("(e^(-{0}^2))/pi", re));
            a = _2.parse(format("(1-e^(-(2*{0}*{1}*{2})))/(2*{1})", Settings.IMAGINARY, re, im));
            b = f(re.toString(), im.toString());
            return _2.add(_2.parse(Math2.erf(re.toString())), _2.multiply(k, _2.add(a, b)));
          },
          removeDen: function(symbol) {
            var den, r, i, re, im;
            if (isArray(symbol)) {
              r = symbol[0];
              i = symbol[1];
            } else {
              r = symbol.realpart();
              i = symbol.imagpart();
            }
            den = Math.pow(r, 2) + Math.pow(i, 2);
            re = _2.parse(r / den);
            im = _2.parse(i / den);
            return [re, im];
          },
          fromArray: function(arr) {
            return _2.add(arr[0], _2.multiply(Symbol2.imaginary(), arr[1]));
          },
          evaluate: function(symbol, f) {
            var re, im, sign2;
            sign2 = symbol.power.sign();
            symbol.power = symbol.power.abs();
            if (symbol.power.greaterThan(1))
              symbol = _2.expand(symbol);
            if (sign2 < 0) {
              var d = this.removeDen(symbol);
              re = d[0];
              im = d[1];
            } else {
              re = symbol.realpart();
              im = symbol.imagpart();
            }
            if (re.isConstant("all") && im.isConstant("all"))
              return this[f].call(this, re, im);
            return _2.symfunction(f, [symbol]);
          }
        };
        var trig = this.trig = {
          //container for trigonometric function
          cos: function(symbol) {
            if (symbol.equals("pi") && symbol.multiplier.den.equals(2))
              return new Symbol2(0);
            if (Settings.PARSE2NUMBER) {
              if (symbol.equals(new Symbol2(Settings.PI / 2)))
                return new Symbol2(0);
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.cos(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.cos(symbol.valueOf()));
              }
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "cos");
              }
            }
            if (symbol.equals(0))
              return new Symbol2(1);
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), m = symbol.multiplier.abs();
            symbol.multiplier = m;
            if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                retval = new Symbol2(even(m) ? 1 : -1);
              } else {
                var n2 = Number(m.num), d = Number(m.den);
                if (d === 2)
                  retval = new Symbol2(0);
                else if (d === 3) {
                  retval = _2.parse("1/2");
                  c = true;
                } else if (d === 4) {
                  retval = _2.parse("1/sqrt(2)");
                  c = true;
                } else if (d === 6) {
                  retval = _2.parse("sqrt(3)/2");
                  c = true;
                } else
                  retval = _2.symfunction("cos", [symbol]);
              }
            }
            if (c && (q === 2 || q === 3))
              retval.negate();
            if (!retval)
              retval = _2.symfunction("cos", [symbol]);
            return retval;
          },
          sin: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (symbol % Math.PI === 0) {
                  return new Symbol2(0);
                }
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.sin(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.sin(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "sin");
            }
            if (symbol.equals(0))
              return new Symbol2(0);
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), sign2 = symbol.multiplier.sign(), m = symbol.multiplier.abs();
            symbol.multiplier = m;
            if (symbol.equals("pi"))
              retval = new Symbol2(0);
            else if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                retval = new Symbol2(0);
              } else {
                var n2 = m.num, d = m.den;
                if (d == 2) {
                  retval = new Symbol2(1);
                  c = true;
                } else if (d == 3) {
                  retval = _2.parse("sqrt(3)/2");
                  c = true;
                } else if (d == 4) {
                  retval = _2.parse("1/sqrt(2)");
                  c = true;
                } else if (d == 6) {
                  retval = _2.parse("1/2");
                  c = true;
                } else
                  retval = _2.multiply(new Symbol2(sign2), _2.symfunction("sin", [symbol]));
              }
            }
            if (!retval)
              retval = _2.multiply(new Symbol2(sign2), _2.symfunction("sin", [symbol]));
            if (c && (q === 3 || q === 4))
              retval.negate();
            return retval;
          },
          tan: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol % Math.PI === 0 && symbol.isLinear()) {
                return new Symbol2(0);
              }
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.tan(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.tan(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "tan");
            }
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), m = symbol.multiplier;
            symbol.multiplier = m;
            if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                retval = new Symbol2(0);
              } else {
                var n2 = m.num, d = m.den;
                if (d == 2)
                  throw new UndefinedError("tan is undefined for " + symbol.toString());
                else if (d == 3) {
                  retval = _2.parse("sqrt(3)");
                  c = true;
                } else if (d == 4) {
                  retval = new Symbol2(1);
                  c = true;
                } else if (d == 6) {
                  retval = _2.parse("1/sqrt(3)");
                  c = true;
                } else
                  retval = _2.symfunction("tan", [symbol]);
              }
            }
            if (!retval)
              retval = _2.symfunction("tan", [symbol]);
            if (c && (q === 2 || q === 4))
              retval.negate();
            return retval;
          },
          sec: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(new bigDec(1).dividedBy(bigDec.cos(symbol.multiplier.toDecimal())));
                }
                return new Symbol2(Math2.sec(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "sec");
              return _2.parse(format("1/cos({0})", symbol));
            }
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), m = symbol.multiplier.abs();
            symbol.multiplier = m;
            if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                retval = new Symbol2(even(m) ? 1 : -1);
              } else {
                var n2 = m.num, d = m.den;
                if (d == 2)
                  throw new UndefinedError("sec is undefined for " + symbol.toString());
                else if (d == 3) {
                  retval = new Symbol2(2);
                  c = true;
                } else if (d == 4) {
                  retval = _2.parse("sqrt(2)");
                  c = true;
                } else if (d == 6) {
                  retval = _2.parse("2/sqrt(3)");
                  c = true;
                } else
                  retval = _2.symfunction("sec", [symbol]);
              }
            }
            if (c && (q === 2 || q === 3))
              retval.negate();
            if (!retval)
              retval = _2.symfunction("sec", [symbol]);
            return retval;
          },
          csc: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(new bigDec(1).dividedBy(bigDec.sin(symbol.multiplier.toDecimal())));
                }
                return new Symbol2(Math2.csc(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "csc");
              return _2.parse(format("1/sin({0})", symbol));
            }
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), sign2 = symbol.multiplier.sign(), m = symbol.multiplier.abs();
            symbol.multiplier = m;
            if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                throw new UndefinedError("csc is undefined for " + symbol.toString());
              } else {
                var n2 = m.num, d = m.den;
                if (d == 2) {
                  retval = new Symbol2(1);
                  c = true;
                } else if (d == 3) {
                  retval = _2.parse("2/sqrt(3)");
                  c = true;
                } else if (d == 4) {
                  retval = _2.parse("sqrt(2)");
                  c = true;
                } else if (d == 6) {
                  retval = new Symbol2(2);
                  c = true;
                } else
                  retval = _2.multiply(new Symbol2(sign2), _2.symfunction("csc", [symbol]));
              }
            }
            if (!retval)
              retval = _2.multiply(new Symbol2(sign2), _2.symfunction("csc", [symbol]));
            if (c && (q === 3 || q === 4))
              retval.negate();
            return retval;
          },
          cot: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol % (Math.PI / 2) === 0) {
                return new Symbol2(0);
              }
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(new bigDec(1).dividedBy(bigDec.tan(symbol.multiplier.toDecimal())));
                }
                return new Symbol2(Math2.cot(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "cot");
              return _2.parse(format("1/tan({0})", symbol));
            }
            var retval, c = false, q = getQuadrant(symbol.multiplier.toDecimal()), m = symbol.multiplier;
            symbol.multiplier = m;
            if (symbol.isPi() && symbol.isLinear()) {
              if (isInt(m)) {
                throw new UndefinedError("cot is undefined for " + symbol.toString());
              } else {
                var n2 = m.num, d = m.den;
                if (d == 2)
                  retval = new Symbol2(0);
                else if (d == 3) {
                  retval = _2.parse("1/sqrt(3)");
                  c = true;
                } else if (d == 4) {
                  retval = new Symbol2(1);
                  c = true;
                } else if (d == 6) {
                  retval = _2.parse("sqrt(3)");
                  c = true;
                } else
                  retval = _2.symfunction("cot", [symbol]);
              }
            }
            if (!retval)
              retval = _2.symfunction("cot", [symbol]);
            if (c && (q === 2 || q === 4))
              retval.negate();
            return retval;
          },
          acos: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (symbol.gt(1) || symbol.lt(-1)) {
                  var x = symbol.toString();
                  return expand(evaluate(`pi/2-asin(${x})`));
                }
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.acos(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.acos(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "acos");
            }
            return _2.symfunction("acos", arguments);
          },
          asin: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (symbol.gt(1) || symbol.lt(-1)) {
                  var i = Settings.IMAGINARY;
                  var x = symbol.multiplier.toDecimal();
                  return expand(evaluate(`${i}*log(sqrt(1-${x}^2)-${i}*${x})`));
                }
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.asin(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.asin(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "asin");
            }
            return _2.symfunction("asin", arguments);
          },
          atan: function(symbol) {
            var retval;
            if (symbol.equals(0))
              retval = new Symbol2(0);
            else if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                if (Settings.USE_BIG) {
                  return new Symbol2(bigDec.atan(symbol.multiplier.toDecimal()));
                }
                return new Symbol2(Math.atan(symbol.valueOf()));
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "atan");
              return _2.symfunction("atan", arguments);
            } else if (symbol.equals(-1))
              retval = _2.parse("-pi/4");
            else
              retval = _2.symfunction("atan", arguments);
            return retval;
          },
          asec: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.equals(0)) {
                throw new OutOfFunctionDomainError("Input is out of the domain of sec!");
              }
              if (symbol.isConstant()) {
                return trig.acos(symbol.invert());
              }
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "asec");
              }
            }
            return _2.symfunction("asec", arguments);
          },
          acsc: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                return trig.asin(symbol.invert());
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "acsc");
            }
            return _2.symfunction("acsc", arguments);
          },
          acot: function(symbol) {
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                return new _2.add(_2.parse("pi/2"), trig.atan(symbol).negate());
              }
              if (symbol.isImaginary())
                return complex.evaluate(symbol, "acot");
            }
            return _2.symfunction("acot", arguments);
          },
          atan2: function(a, b) {
            if (a.equals(0) && b.equals(0))
              throw new UndefinedError("atan2 is undefined for 0, 0");
            if (Settings.PARSE2NUMBER && a.isConstant() && b.isConstant()) {
              return new Symbol2(Math.atan2(a, b));
            }
            return _2.symfunction("atan2", arguments);
          }
        };
        var trigh = this.trigh = {
          //container for hyperbolic trig function
          cosh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant())
                return new Symbol2(Math.cosh(symbol.valueOf()));
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "cosh");
              }
            }
            return retval = _2.symfunction("cosh", arguments);
          },
          sinh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant())
                return new Symbol2(Math.sinh(symbol.valueOf()));
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "sinh");
              }
            }
            return retval = _2.symfunction("sinh", arguments);
          },
          tanh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant())
                return new Symbol2(Math.tanh(symbol.valueOf()));
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "tanh");
              }
            }
            return retval = _2.symfunction("tanh", arguments);
          },
          sech: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant()) {
                return new Symbol2(Math.sech(symbol.valueOf()));
              }
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "sech");
              }
              return _2.parse(format("1/cosh({0})", symbol));
            }
            return retval = _2.symfunction("sech", arguments);
          },
          csch: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant())
                return new Symbol2(Math.csch(symbol.valueOf()));
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "csch");
              }
              return _2.parse(format("1/sinh({0})", symbol));
            }
            return retval = _2.symfunction("csch", arguments);
          },
          coth: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER) {
              if (symbol.isConstant())
                return new Symbol2(Math.coth(symbol.valueOf()));
              if (symbol.isImaginary()) {
                return complex.evaluate(symbol, "coth");
              }
              return _2.parse(format("1/tanh({0})", symbol));
            }
            return retval = _2.symfunction("coth", arguments);
          },
          acosh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "acosh");
            else if (Settings.PARSE2NUMBER)
              retval = evaluate(_2.parse(format(Settings.LOG + "(({0})+sqrt(({0})^2-1))", symbol.toString())));
            else
              retval = _2.symfunction("acosh", arguments);
            return retval;
          },
          asinh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "asinh");
            else if (Settings.PARSE2NUMBER)
              retval = evaluate(_2.parse(format(Settings.LOG + "(({0})+sqrt(({0})^2+1))", symbol.toString())));
            else
              retval = _2.symfunction("asinh", arguments);
            return retval;
          },
          atanh: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "atanh");
            else if (Settings.PARSE2NUMBER) {
              retval = evaluate(_2.parse(format("(1/2)*" + Settings.LOG + "((1+({0}))/(1-({0})))", symbol.toString())));
            } else
              retval = _2.symfunction("atanh", arguments);
            return retval;
          },
          asech: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "asech");
            else if (Settings.PARSE2NUMBER)
              retval = evaluate(log(_2.add(symbol.clone().invert(), sqrt(_2.subtract(_2.pow(symbol, new Symbol2(-2)), new Symbol2(1))))));
            else
              retval = _2.symfunction("asech", arguments);
            return retval;
          },
          acsch: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "acsch");
            else if (Settings.PARSE2NUMBER)
              retval = evaluate(_2.parse(format(Settings.LOG + "((1+sqrt(1+({0})^2))/({0}))", symbol.toString())));
            else
              retval = _2.symfunction("acsch", arguments);
            return retval;
          },
          acoth: function(symbol) {
            var retval;
            if (Settings.PARSE2NUMBER && symbol.isImaginary())
              retval = complex.evaluate(symbol, "acoth");
            else if (Settings.PARSE2NUMBER) {
              if (symbol.equals(1))
                retval = Symbol2.infinity();
              else
                retval = evaluate(
                  _2.divide(
                    log(_2.divide(_2.add(symbol.clone(), new Symbol2(1)), _2.subtract(symbol.clone(), new Symbol2(1)))),
                    new Symbol2(2)
                  )
                );
            } else
              retval = _2.symfunction("acoth", arguments);
            return retval;
          }
        };
        this.units = {};
        var operators = {
          "\\": {
            precedence: 8,
            operator: "\\",
            action: "slash",
            prefix: true,
            postfix: false,
            leftAssoc: true,
            operation: function(e) {
              return e;
            }
          },
          "!!": {
            precedence: 7,
            operator: "!!",
            action: "dfactorial",
            prefix: false,
            postfix: true,
            leftAssoc: true,
            operation: function(e) {
              return _2.symfunction(Settings.DOUBLEFACTORIAL, [e]);
            }
          },
          "!": {
            precedence: 7,
            operator: "!",
            action: "factorial",
            prefix: false,
            postfix: true,
            leftAssoc: true,
            operation: function(e) {
              return factorial(e);
            }
          },
          "^": {
            precedence: 6,
            operator: "^",
            action: "pow",
            prefix: false,
            postfix: false,
            leftAssoc: true
          },
          "**": {
            precedence: 6,
            operator: "**",
            action: "pow",
            prefix: false,
            postfix: false,
            leftAssoc: true
          },
          "%": {
            precedence: 4,
            operator: "%",
            action: "percent",
            prefix: false,
            postfix: true,
            leftAssoc: true,
            overloaded: true,
            overloadAction: "mod",
            overloadLeftAssoc: false,
            operation: function(x) {
              return _2.divide(x, new Symbol2(100));
            }
          },
          "*": {
            precedence: 4,
            operator: "*",
            action: "multiply",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "/": {
            precedence: 4,
            operator: "/",
            action: "divide",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "+": {
            precedence: 3,
            operator: "+",
            action: "add",
            prefix: true,
            postfix: false,
            leftAssoc: false,
            operation: function(x) {
              return x;
            }
          },
          "plus": {
            precedence: 3,
            operator: "plus",
            action: "add",
            prefix: true,
            postfix: false,
            leftAssoc: false,
            operation: function(x) {
              return x;
            }
          },
          "-": {
            precedence: 3,
            operator: "-",
            action: "subtract",
            prefix: true,
            postfix: false,
            leftAssoc: false,
            operation: function(x) {
              return x.negate();
            }
          },
          "=": {
            precedence: 2,
            operator: "=",
            action: "equals",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "==": {
            precedence: 1,
            operator: "==",
            action: "eq",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "<": {
            precedence: 1,
            operator: "<",
            action: "lt",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "<=": {
            precedence: 1,
            operator: "<=",
            action: "lte",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          ">": {
            precedence: 1,
            operator: ">",
            action: "gt",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          "=>": {
            precedence: 1,
            operator: "=>",
            action: "gte",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          ",": {
            precedence: 0,
            operator: ",",
            action: "comma",
            prefix: false,
            postfix: false,
            leftAssoc: false
          },
          ":": {
            precedence: 0,
            operator: ",",
            action: "assign",
            prefix: false,
            postfix: false,
            leftAssoc: false,
            vectorFn: "slice"
          },
          ":=": {
            precedence: 0,
            operator: ",",
            action: "function_assign",
            prefix: false,
            postfix: false,
            leftAssoc: true
          }
        };
        var brackets = {
          "(": {
            type: "round",
            id: 1,
            is_open: true,
            is_close: false
          },
          ")": {
            type: "round",
            id: 2,
            is_open: false,
            is_close: true
          },
          "[": {
            type: "square",
            id: 3,
            is_open: true,
            is_close: false,
            maps_to: "vector"
          },
          "]": {
            type: "square",
            id: 4,
            is_open: false,
            is_close: true
          },
          "{": {
            type: "curly",
            id: 5,
            is_open: true,
            is_close: false,
            maps_to: "Set"
          },
          "}": {
            type: "curly",
            id: 6,
            is_open: false,
            is_close: true
          }
        };
        var functions = this.functions = {
          "cos": [trig.cos, 1],
          "sin": [trig.sin, 1],
          "tan": [trig.tan, 1],
          "sec": [trig.sec, 1],
          "csc": [trig.csc, 1],
          "cot": [trig.cot, 1],
          "acos": [trig.acos, 1],
          "asin": [trig.asin, 1],
          "atan": [trig.atan, 1],
          "arccos": [trig.acos, 1],
          "arcsin": [trig.asin, 1],
          "arctan": [trig.atan, 1],
          "asec": [trig.asec, 1],
          "acsc": [trig.acsc, 1],
          "acot": [trig.acot, 1],
          "atan2": [trig.atan2, 2],
          "acoth": [trigh.acoth, 1],
          "asech": [trigh.asech, 1],
          "acsch": [trigh.acsch, 1],
          "sinh": [trigh.sinh, 1],
          "cosh": [trigh.cosh, 1],
          "tanh": [trigh.tanh, 1],
          "asinh": [trigh.asinh, 1],
          "sech": [trigh.sech, 1],
          "csch": [trigh.csch, 1],
          "coth": [trigh.coth, 1],
          "acosh": [trigh.acosh, 1],
          "atanh": [trigh.atanh, 1],
          "log10": [, 1],
          "exp": [exp, 1],
          "radians": [radians, 1],
          "degrees": [degrees, 1],
          "min": [min, -1],
          "max": [max, -1],
          "erf": [, 1],
          "floor": [, 1],
          "ceil": [, 1],
          "trunc": [, 1],
          "Si": [, 1],
          "step": [, 1],
          "rect": [, 1],
          "sinc": [sinc, 1],
          "tri": [, 1],
          "sign": [sign, 1],
          "Ci": [, 1],
          "Ei": [, 1],
          "Shi": [, 1],
          "Chi": [, 1],
          "Li": [, 1],
          "fib": [, 1],
          "fact": [factorial, 1],
          "factorial": [factorial, 1],
          "continued_fraction": [continued_fraction, [1, 2]],
          "dfactorial": [, 1],
          "gamma_incomplete": [, [1, 2]],
          "round": [round, [1, 2]],
          "scientific": [scientific, [1, 2]],
          "mod": [mod, 2],
          "pfactor": [pfactor, 1],
          "vector": [vector, -1],
          "matrix": [matrix, -1],
          "Set": [set, -1],
          "imatrix": [imatrix, -1],
          "parens": [parens, -1],
          "sqrt": [sqrt, 1],
          "cbrt": [cbrt, 1],
          "nthroot": [nthroot, 2],
          "log": [log, [1, 2]],
          "expand": [expandall, 1],
          "abs": [abs, 1],
          "invert": [invert, 1],
          "determinant": [determinant, 1],
          "size": [size, 1],
          "transpose": [transpose, 1],
          "dot": [dot, 2],
          "cross": [cross, 2],
          "vecget": [vecget, 2],
          "vecset": [vecset, 3],
          "vectrim": [vectrim, [1, 2]],
          "matget": [matget, 3],
          "matset": [matset, 4],
          "matgetrow": [matgetrow, 2],
          "matsetrow": [matsetrow, 3],
          "matgetcol": [matgetcol, 2],
          "matsetcol": [matsetcol, 3],
          "rationalize": [rationalize, 1],
          "IF": [IF, 3],
          "is_in": [is_in, 2],
          //imaginary support
          "realpart": [realpart, 1],
          "imagpart": [imagpart, 1],
          "conjugate": [conjugate, 1],
          "arg": [arg, 1],
          "polarform": [polarform, 1],
          "rectform": [rectform, 1],
          "sort": [sort, [1, 2]],
          "integer_part": [, 1],
          "union": [union2, 2],
          "contains": [contains, 2],
          "intersection": [intersection2, 2],
          "difference": [difference, 2],
          "intersects": [intersects, 2],
          "is_subset": [is_subset, 2],
          //system support
          "print": [print, -1]
        };
        this.error = err;
        var findFunction = function(fname) {
          var fmodules = Settings.FUNCTION_MODULES, l = fmodules.length;
          for (var i = 0; i < l; i++) {
            var fmodule = fmodules[i];
            if (fname in fmodule)
              return fmodule[fname];
          }
          err("The function " + fname + " is undefined!");
        };
        this.override = function(which, with_what) {
          if (!bin[which])
            bin[which] = [];
          bin[which].push(this[which]);
          this[which] = with_what;
        };
        this.restore = function(what) {
          if (this[what])
            this[what] = bin[what].pop();
        };
        this.extend = function(what, with_what, force_call) {
          var _3 = this, extended = this[what];
          if (typeof extended === "function" && typeof with_what === "function") {
            var f = this[what];
            this[what] = function(a, b) {
              if (isSymbol(a) && isSymbol(b) && !force_call)
                return f.call(_3, a, b);
              else
                return with_what.call(_3, a, b, f);
            };
          }
        };
        this.symfunction = function(fn_name, params) {
          var f = new Symbol2(fn_name);
          f.group = FN;
          if (typeof params === "object")
            params = [].slice.call(params);
          f.args = params;
          f.fname = fn_name === PARENTHESIS ? "" : fn_name;
          f.updateHash();
          return f;
        };
        this.callfunction = function(fn_name, args, allowed_args) {
          var fn_settings = functions[fn_name];
          if (!fn_settings)
            err("Nerdamer currently does not support the function " + fn_name);
          var num_allowed_args = fn_settings[1] || allowed_args, fn = fn_settings[0], retval;
          if (!(args instanceof Array))
            args = args !== void 0 ? [args] : [];
          if (num_allowed_args !== -1) {
            var is_array = isArray(num_allowed_args), min_args = is_array ? num_allowed_args[0] : num_allowed_args, max_args = is_array ? num_allowed_args[1] : num_allowed_args, num_args = args.length;
            var error_msg = fn_name + " requires a {0} of {1} arguments. {2} provided!";
            if (num_args < min_args)
              err(format(error_msg, "minimum", min_args, num_args));
            if (num_args > max_args)
              err(format(error_msg, "maximum", max_args, num_args));
          }
          var numericArgs = allNumbers(args);
          if (!fn) {
            fn = findFunction(fn_name);
            if (Settings.PARSE2NUMBER && numericArgs)
              retval = bigConvert(fn.apply(fn, args));
            else
              retval = _2.symfunction(fn_name, args);
          } else {
            retval = fn.apply(fn_settings[2], args);
          }
          return retval;
        };
        this.operator_filter_regex = (function() {
          var ostr = "^\\" + Object.keys(operators).filter(function(x) {
            if (x.length === 1)
              return x;
          }).join("\\");
          return new RegExp("([" + ostr + "])\\s+([" + ostr + "])");
        })();
        this.setOperator = function(operator, action, shift) {
          var name = operator.operator;
          operators[name] = operator;
          if (action)
            this[operator.action] = action;
          _2[name] = operator.operation;
          if (!operator.action && !(operator.prefix || operator.postif)) {
            operator.action = name;
          }
          if (shift === "over" || shift === "under") {
            var precedence = operator.precedence;
            for (var x in operators) {
              var o = operators[x];
              var condition = shift === "over" ? o.precedence >= precedence : o.precedence > precedence;
              if (condition)
                o.precedence++;
            }
            ;
          }
        };
        this.getOperator = function(operator) {
          return operators[operator];
        };
        this.aliasOperator = function(o, n2) {
          var t = {};
          var operator = operators[o];
          for (var x in operator) {
            t[x] = operator[x];
          }
          t.operator = n2;
          this.setOperator(t);
        };
        this.getOperators = function() {
          return operators;
        };
        this.getBrackets = function() {
          return brackets;
        };
        var prepare_expression = function(e) {
          e = String(e);
          for (var i = 0; i < preprocessors.actions.length; i++)
            e = preprocessors.actions[i].call(this, e);
          e = e.replace(/\s+/g, " ");
          if (/e/gi.test(e)) {
            e = e.replace(/\-*\d+\.*\d*e\+?\-?\d+/gi, function(x) {
              return scientificToDecimal(x);
            });
          }
          e = e.replace(Settings.IMPLIED_MULTIPLICATION_REGEX, function() {
            var str = arguments[4], group1 = arguments[1], group2 = arguments[2], start = arguments[3], first = str.charAt(start), before = "", d = "*";
            if (!first.match(/[\+\-\/\*]/))
              before = str.charAt(start - 1);
            if (before.match(/[a-z]/i))
              d = "";
            return group1 + d + group2;
          }).replace(/([a-z0-9_]+)/gi, function(match, a) {
            if (Settings.USE_MULTICHARACTER_VARS === false && !(a in functions)) {
              if (!isNaN(a))
                return a;
              return a.split("").join("*");
            }
            return a;
          }).replace(/\)\(/g, ")*(") || "0";
          while (true) {
            var e_org = e;
            e = e.replace(/([a-z0-9_]+)(\()|(\))([a-z0-9]+)/gi, function(match, a, b, c, d) {
              var g1 = a || c, g2 = b || d;
              if (g1 in functions)
                return g1 + g2;
              return g1 + "*" + g2;
            });
            if (e_org === e)
              break;
          }
          return e;
        };
        this.initConstants = function() {
          this.CONSTANTS = {
            E: new Symbol2(Settings.E),
            PI: new Symbol2(Settings.PI)
          };
        };
        this.pretty_print = function(o) {
          if (Array.isArray(o)) {
            var s = o.map((x) => _2.pretty_print(x)).join(", ");
            if (o.type === "vector")
              return "vector<" + s + ">";
            return "(" + s + ")";
          }
          return o.toString();
        };
        this.peekers = {
          pre_operator: [],
          post_operator: [],
          pre_function: [],
          post_function: []
        };
        this.callPeekers = function(name) {
          if (Settings.callPeekers) {
            var peekers = this.peekers[name];
            var args = arguments2Array(arguments).slice(1).map(stringify);
            for (var i = 0; i < peekers.length; i++) {
              peekers[i].apply(null, args);
            }
          }
        };
        this.tokenize = function(e) {
          e = String(e);
          e = e.trim().replace(/\s+/g, " ");
          for (var x in brackets) {
            var regex = new RegExp(brackets[x].is_close ? "\\s+\\" + x : "\\" + x + "\\s+", "g");
            e = e.replace(regex, x);
          }
          var col = 0;
          var L = e.length;
          var lpos = 0;
          var tokens = [];
          var scopes = [tokens];
          var target = scopes[0];
          var depth = 0;
          var open_brackets = [];
          var has_space = false;
          var SPACE = " ";
          var EMPTY_STRING = "";
          var COMMA = ",";
          var MINUS = "-";
          var MULT = "*";
          var addScope = function(scope_type, column) {
            var new_scope = [];
            if (scope_type !== void 0) {
              new_scope.type = scope_type;
            }
            new_scope.column = column;
            scopes.push(new_scope);
            target.push(new_scope);
            target = new_scope;
            depth++;
          };
          var goUp = function() {
            scopes.pop();
            target = scopes[--depth];
          };
          var get_operator_str = function(start_at) {
            start_at = start_at !== void 0 ? start_at : col;
            var end = start_at + 1;
            while (e.charAt(end++) in operators) {
            }
            return e.substring(start_at, end - 1);
          };
          var chunkify = function(operator_str2) {
            var start = col - operator_str2.length;
            var _operators = [];
            var operator = operator_str2.charAt(0);
            for (var i = 1, L2 = operator_str2.length; i < L2; i++) {
              var ch2 = operator_str2.charAt(i);
              var o = operator + ch2;
              if (!(o in operators)) {
                _operators.push(new Token(operator, Token.OPERATOR, start + i));
                operator = ch2;
              } else
                operator = o;
            }
            _operators.push(new Token(operator, Token.OPERATOR, start + i));
            return _operators;
          };
          var add_token = function(at, token) {
            if (token === void 0)
              token = e.substring(lpos, at);
            if (token in _2.units)
              target.push(new Token(token, Token.UNIT, lpos));
            else if (token !== "")
              target.push(new Token(token, Token.VARIABLE_OR_LITERAL, lpos));
          };
          var add_function = function(f2) {
            target.push(new Token(f2, Token.FUNCTION, lpos));
          };
          var set_last_position = function(position) {
            lpos = position + 1;
          };
          var adjust_column_position = function() {
            lpos = lpos + operator_str.length - 2;
            col = lpos - 1;
          };
          for (; col < L; col++) {
            var ch = e.charAt(col);
            if (ch in operators) {
              add_token(col);
              var last_token_is_numeric = target[0] && isNumber(target[0]);
              var is_multiplication = last_token_is_numeric && ch === MULT;
              if (has_space && lpos < col && !(ch === COMMA || is_multiplication)) {
                has_space = false;
                goUp();
              }
              set_last_position(col + 1);
              var operator_str = get_operator_str(col);
              adjust_column_position();
              target.push.apply(target, chunkify(operator_str));
            } else if (ch in brackets) {
              var bracket = brackets[ch];
              if (bracket.is_open) {
                open_brackets.push([bracket, lpos]);
                var f = e.substring(lpos, col);
                if (f in functions) {
                  add_function(f);
                } else if (f !== "") {
                  target.push(new Token(f, Token.VARIABLE_OR_LITERAL, lpos));
                }
                addScope(bracket.maps_to, col);
              } else if (bracket.is_close) {
                var pair = open_brackets.pop();
                if (!pair)
                  throw new ParityError("Missing open bracket for bracket at: " + (col + 1));
                else if (pair[0].id !== bracket.id - 1)
                  throw new ParityError("Parity error");
                add_token(col);
                goUp();
              }
              set_last_position(col);
            } else if (ch === SPACE) {
              var prev = e.substring(lpos, col);
              var nxt = e.charAt(col + 1);
              if (has_space) {
                if (prev in operators) {
                  target.push(new Token(prev, Token.OPERATOR, col));
                } else {
                  add_token(void 0, prev);
                  goUp();
                  var is_operator = nxt in operators;
                  if (is_operator && operators[nxt].value === MINUS || !is_operator) {
                    target.push(new Token(MULT, Token.OPERATOR, col));
                  }
                }
                has_space = false;
              } else {
                var f = e.substring(lpos, col);
                if (f in functions) {
                  has_space = true;
                  add_function(f);
                  addScope();
                } else if (f in operators) {
                  target.push(new Token(f, Token.OPERATOR, col));
                } else {
                  add_token(void 0, f);
                  var nxt = e.charAt(col + 1);
                  if (prev !== EMPTY_STRING && nxt !== EMPTY_STRING && !(prev in operators) && !(nxt in operators))
                    target.push(new Token(MULT, Token.OPERATOR, col));
                }
              }
              set_last_position(col);
            }
          }
          if (open_brackets.length) {
            var b = open_brackets.pop();
            throw new ParityError("Missing closed bracket for bracket at " + (b[1] + 1));
          }
          add_token(col);
          return tokens;
        };
        this.toRPN = function(tokens) {
          var fn = tokens.type;
          var l = tokens.length, i;
          var output = [];
          var stack = [];
          var prefixes = [];
          var collapse = function(target, destination) {
            while (target.length)
              destination.push(target.pop());
          };
          for (i = 0; i < l; i++) {
            var token = tokens[i];
            if (token.type !== Token.OPERATOR)
              break;
            if (!token.prefix)
              throw new OperatorError("Not a prefix operator");
            token.is_prefix = true;
            stack.push(token);
          }
          for (; i < l; i++) {
            var e = tokens[i];
            if (e.type === Token.OPERATOR) {
              var operator = e;
              if (operator.overloaded) {
                var next = tokens[i + 1];
                if (next && next.type === Token.VARIABLE_OR_LITERAL) {
                  operator.postfix = false;
                  operator.action = operator.overloadAction;
                  operator.leftAssoc = operator.overloadLeftAssoc;
                }
              }
              while (stack.length) {
                var last = stack[stack.length - 1];
                if (!(last.precedence > operator.precedence || !operator.leftAssoc && last.precedence === operator.precedence))
                  break;
                output.push(stack.pop());
              }
              if ((fn === "vector" || fn === "set") && "vectorFn" in operator)
                operator.action = operator.vectorFn;
              if (operator.postfix) {
                var previous = tokens[i - 1];
                if (!previous)
                  throw new OperatorError("Unexpected prefix operator '" + e.value + "'! at " + e.column);
                else if (previous.type === Token.OPERATOR) {
                  if (!previous.postfix)
                    throw new OperatorError("Unexpected prefix operator '" + previous.value + "'! at " + previous.column);
                }
              } else {
                do {
                  var next = tokens[i + 1];
                  var next_is_operator = next ? next.type === Token.OPERATOR : false;
                  if (next_is_operator) {
                    if (!next.prefix) {
                      throw new OperatorError("A prefix operator was expected at " + next.column);
                    }
                    next.is_prefix = true;
                    prefixes.push(next);
                    i++;
                  }
                } while (next_is_operator);
              }
              if (operator.is_prefix)
                prefixes.push(operator);
              else
                stack.push(operator);
              while (prefixes.length) {
                if (operator.leftAssoc || !operator.leftAssoc && prefixes[prefixes.length - 1].precedence >= operator.precedence)
                  stack.push(prefixes.pop());
                else
                  break;
              }
            } else if (e.type === Token.VARIABLE_OR_LITERAL) {
              if (output.length === 0)
                collapse(prefixes, stack);
              output.push(e);
              var last_on_stack = stack[stack.length - 1];
              if (!last_on_stack || !last_on_stack.leftAssoc)
                collapse(prefixes, output);
            } else if (e.type === Token.FUNCTION) {
              stack.push(e);
            } else if (e.type === Token.UNIT) {
              output.push(e);
            }
            if (Array.isArray(e)) {
              output.push(this.toRPN(e));
              if (e.type)
                output.push(new Token(e.type, Token.FUNCTION, e.column));
            }
          }
          collapse(stack, output);
          collapse(prefixes, output);
          return output;
        };
        this.parseRPN = function(rpn, substitutions) {
          try {
            substitutions = substitutions || {};
            for (var x in substitutions)
              substitutions[x] = _2.parse(substitutions[x], {});
            if (Settings.PARSE2NUMBER) {
              if (!("e" in substitutions))
                substitutions.e = new Symbol2(Settings.E);
              if (!("pi" in substitutions))
                substitutions.pi = new Symbol2(Settings.PI);
            }
            var Q = [];
            for (var i = 0, l = rpn.length; i < l; i++) {
              var e = rpn[i];
              if (Array.isArray(e)) {
                e = this.parseRPN(e, substitutions);
              }
              if (e) {
                if (e.type === Token.OPERATOR) {
                  if (e.is_prefix || e.postfix)
                    Q.push(e.operation(Q.pop()));
                  else {
                    var b = Q.pop();
                    var a = Q.pop();
                    if (typeof a === "undefined")
                      throw new OperatorError(e + " is not a valid postfix operator at " + e.column);
                    var is_comma = e.action === "comma";
                    if (a instanceof Set2 && !is_comma)
                      a = Vector.fromSet(a);
                    if (b instanceof Set2 && !is_comma)
                      b = Vector.fromSet(b);
                    this.callPeekers("pre_operator", a, b, e);
                    var ans = _2[e.action](a, b);
                    this.callPeekers("post_operator", ans, a, b, e);
                    Q.push(ans);
                  }
                } else if (e.type === Token.FUNCTION) {
                  var args = Q.pop();
                  var parent = args.parent;
                  if (!(args instanceof Collection))
                    args = Collection.create(args);
                  var fn_name = e.value;
                  var fn_args = args.getItems();
                  this.callPeekers("pre_function", fn_name, fn_args);
                  var ret = _2.callfunction(fn_name, fn_args);
                  this.callPeekers("post_function", ret, fn_name, fn_args);
                  var last = Q[Q.length - 1];
                  var next = rpn[i + 1];
                  var next_is_comma = next && next.type === Token.OPERATOR && next.value === ",";
                  if (!next_is_comma && ret instanceof Vector && last && last.elements && !(last instanceof Collection)) {
                    var item = Q.pop();
                    var getter = ret.elements[0];
                    if (!getter.isConstant()) {
                      item.getter = getter;
                      Q.push(item);
                      Q.push(ret);
                    } else if (getter instanceof Slice) {
                      Q.push(Vector.fromArray(item.elements.slice(getter.start, getter.end)));
                    } else {
                      var index = Number(getter);
                      var il = item.elements.length;
                      if (index < 0)
                        index = il + index;
                      if (index < 0 || index >= il)
                        throw new OutOfRangeError("Index out of range " + (e.column + 1));
                      var element = item.elements[index];
                      item.getter = index;
                      element.parent = item;
                      Q.push(element);
                    }
                  } else {
                    if (parent)
                      ret.parent = parent;
                    Q.push(ret);
                  }
                } else {
                  var subbed;
                  var v = e.value;
                  if (v in Settings.ALIASES)
                    e = _2.parse(Settings.ALIASES[e]);
                  else if (e.type === Token.VARIABLE_OR_LITERAL)
                    e = new Symbol2(v);
                  else if (e.type === Token.UNIT) {
                    e = new Symbol2(v);
                    e.isUnit = true;
                  }
                  if (v in _2.CONSTANTS) {
                    subbed = e;
                    e = new Symbol2(_2.CONSTANTS[v]);
                  } else if (v in substitutions && v !== substitutions[v].toString()) {
                    subbed = e;
                    e = substitutions[v].clone();
                  } else if (v in VARS) {
                    subbed = e;
                    e = VARS[v].clone();
                  }
                  if (subbed)
                    e.subbed = subbed;
                  Q.push(e);
                }
              }
            }
            var retval = Q[0];
            if (["undefined", "string", "number"].indexOf(typeof retval) !== -1) {
              throw new UnexpectedTokenError("Unexpected token!");
            }
            return retval;
          } catch (error) {
            var rethrowErrors = [OutOfFunctionDomainError];
            rethrowErrors.forEach(function(E) {
              if (error instanceof E) {
                throw new E(error.message + ": " + e.column);
              }
            });
            throw new ParseError(error.message + ": " + e.column);
          }
        };
        function Node(token) {
          this.type = token.type;
          this.value = token.value;
          this.left = token.left;
          this.right = token.right;
        }
        Node.prototype.toString = function() {
          var left = this.left ? this.left.toString() + "---" : "";
          var right = this.right ? "---" + this.right.toString() : "";
          return left + "(" + this.value + ")" + right;
        };
        Node.prototype.toHTML = function(depth, indent) {
          depth = depth || 0;
          indent = typeof indent === "undefined" ? 4 : indent;
          var tab = function(n2) {
            return " ".repeat(indent * n2);
          };
          var html = "";
          var left = this.left ? tab(depth + 1) + "<li>\n" + this.left.toHTML(depth + 2, indent) + tab(depth + 1) + "</li> \n" : "";
          var right = this.right ? tab(depth + 1) + "<li>\n" + this.right.toHTML(depth + 2, indent) + tab(depth + 1) + "</li>\n" : "";
          var html = tab(depth) + '<div class="' + this.type.toLowerCase() + '"><span>' + this.value + "</span></div>" + tab(depth) + "\n";
          if (left || right) {
            html += tab(depth) + "<ul>\n" + left + right + tab(depth) + "</ul>\n";
          }
          html += "";
          return html;
        };
        this.tree = function(tokens) {
          var Q = [];
          for (var i = 0; i < tokens.length; i++) {
            var e = tokens[i];
            if (Array.isArray(e)) {
              e = this.tree(e);
              Q.push(e);
              continue;
            }
            if (e.type === Token.OPERATOR) {
              if (e.is_prefix || e.postfix) {
                var location = e.is_prefix ? "left" : "right";
                var last = Q.pop();
                e = new Node(e);
                e[location] = last;
                Q.push(e);
              } else {
                e = new Node(e);
                e.right = Q.pop();
                e.left = Q.pop();
                Q.push(e);
              }
            } else if (e.type === Token.FUNCTION) {
              e = new Node(e);
              var args = Q.pop();
              e.right = args;
              if (e.value === "object") {
                var last = Q[Q.length - 1];
                if (last) {
                  while (last.right) {
                    last = last.right;
                  }
                  last.right = e;
                  continue;
                }
              }
              Q.push(e);
            } else {
              Q.push(new Node(e));
            }
          }
          return Q[0];
        };
        this.parse = function(e, substitutions) {
          e = prepare_expression(e);
          substitutions = substitutions || {};
          var tokens = this.tokenize(e);
          var rpn = this.toRPN(tokens);
          return this.parseRPN(rpn, substitutions);
        };
        this.toObject = function(expression_string) {
          var objectify = function(tokens) {
            var output = [];
            for (var i = 0, l = tokens.length; i < l; i++) {
              var token = tokens[i];
              var v = token.value;
              if (token.type === Token.VARIABLE_OR_LITERAL) {
                output.push(new Symbol2(v));
              } else if (token.type === Token.FUNCTION) {
                i++;
                var f = _2.symfunction(v, objectify(tokens[i]));
                f.isConversion = true;
                output.push(f);
              } else if (token.type === Token.OPERATOR) {
                output.push(v);
              } else {
                output.push(objectify(token));
              }
            }
            return output;
          };
          return objectify(_2.tokenize(expression_string));
        };
        var chunkAtCommas = function(arr) {
          var j, k = 0, chunks = [[]];
          for (var j = 0, l = arr.length; j < l; j++) {
            if (arr[j] === ",") {
              k++;
              chunks[k] = [];
            } else {
              chunks[k].push(arr[j]);
            }
          }
          return chunks;
        };
        var rem_brackets = function(str) {
          return str.replace(/^\\left\((.+)\\right\)$/g, function(str2, a) {
            if (a)
              return a;
            return str2;
          });
        };
        var remove_redundant_powers = function(arr) {
          var narr = [];
          while (arr.length) {
            var e = arr.shift();
            var next = arr[0];
            var next_is_array = isArray(next);
            var next_is_minus = next === "-";
            if (e === "^") {
              if (next === "+") {
                arr.shift();
              } else if (next_is_array && next[0] === "+") {
                next.shift();
              }
              if (next_is_array && next.length === 1) {
                arr.unshift(arr.shift()[0]);
              }
            }
            if (e === "^" && (next_is_array && next[0] === "-" || next_is_minus)) {
              var last = narr.pop();
              var before = narr[narr.length - 1];
              var before_last = "1";
              if (before === "*") {
                narr.pop();
                before_last = narr.pop();
              } else if (isArray(before)) {
                before_last = narr.pop();
              }
              narr.push(before_last, "/", last, e);
              if (next_is_array) {
                next.shift();
              } else {
                arr.shift();
              }
              if (next_is_array && next.length === 1) {
                narr.push(arr.shift()[0]);
              }
            } else {
              narr.push(e);
            }
          }
          return narr;
        };
        this.toTeX = function(expression_or_obj, opt) {
          opt = opt || {};
          var decimals = opt.decimals === true ? "decimals" : void 0;
          var obj = typeof expression_or_obj === "string" ? this.toObject(expression_or_obj) : expression_or_obj, TeX = [], cdot = typeof opt.cdot === "undefined" ? "\\cdot" : opt.cdot;
          obj = remove_redundant_powers(obj);
          if (isArray(obj)) {
            var nobj = [], a, b;
            for (var i = 0; i < obj.length; i++) {
              a = obj[i];
              if (obj[i + 1] === "^") {
                b = obj[i + 2];
                nobj.push(LaTeX.braces(this.toTeX([a])) + "^" + LaTeX.braces(this.toTeX([b])));
                i += 2;
              } else {
                nobj.push(a);
              }
            }
            obj = nobj;
          }
          for (var i = 0, l = obj.length; i < l; i++) {
            var e = obj[i];
            if (e === "*") {
              e = cdot;
            }
            if (isSymbol(e)) {
              if (e.group === FN) {
                var fname = e.fname, f;
                if (fname === SQRT) {
                  f = "\\sqrt" + LaTeX.braces(this.toTeX(e.args));
                } else if (fname === ABS) {
                  f = LaTeX.brackets(this.toTeX(e.args), "abs");
                } else if (fname === PARENTHESIS) {
                  f = LaTeX.brackets(this.toTeX(e.args), "parens");
                } else if (fname === Settings.LOG10) {
                  f = "\\" + Settings.LOG10_LATEX + "\\left( " + this.toTeX(e.args) + "\\right)";
                } else if (fname === "integrate") {
                  var chunks = chunkAtCommas(e.args);
                  var expr = LaTeX.braces(this.toTeX(chunks[0])), dx = this.toTeX(chunks[1]);
                  f = "\\int " + expr + "\\, d" + dx;
                } else if (fname === "defint") {
                  var chunks = chunkAtCommas(e.args), expr = LaTeX.braces(this.toTeX(chunks[0])), dx = this.toTeX(chunks[3]), lb = this.toTeX(chunks[1]), ub = this.toTeX(chunks[2]);
                  f = "\\int\\limits_{" + lb + "}^{" + ub + "} " + expr + "\\, d" + dx;
                } else if (fname === "diff") {
                  var chunks = chunkAtCommas(e.args);
                  var dx = "", expr = LaTeX.braces(this.toTeX(chunks[0]));
                  if (chunks.length === 1) {
                    var vars = [];
                    for (j = 0; j < chunks[0].length; j++) {
                      if (chunks[0][j].group === 3) {
                        vars.push(chunks[0][j].value);
                      }
                    }
                    vars.sort();
                    dx = vars.length > 0 ? "\\frac{d}{d " + vars[0] + "}" : "\\frac{d}{d x}";
                  } else if (chunks.length === 2) {
                    dx = "\\frac{d}{d " + chunks[1] + "}";
                  } else {
                    dx = "\\frac{d^{" + chunks[2] + "}}{d " + this.toTeX(chunks[1]) + "^{" + chunks[2] + "}}";
                  }
                  f = dx + "\\left(" + expr + "\\right)";
                } else if (fname === "sum" || fname === "product") {
                  var argSplit = [[], [], [], []], j = 0, i;
                  for (i = 0; i < e.args.length; i++) {
                    if (e.args[i] === ",") {
                      j++;
                      continue;
                    }
                    argSplit[j].push(e.args[i]);
                  }
                  f = (fname === "sum" ? "\\sum_" : "\\prod_") + LaTeX.braces(this.toTeX(argSplit[1]) + " = " + this.toTeX(argSplit[2]));
                  f += "^" + LaTeX.braces(this.toTeX(argSplit[3])) + LaTeX.braces(this.toTeX(argSplit[0]));
                } else if (fname === "limit") {
                  var args = chunkAtCommas(e.args).map(function(x) {
                    if (Array.isArray(x))
                      return _2.toTeX(x.join(""));
                    return _2.toTeX(String(x));
                  });
                  f = "\\lim_" + LaTeX.braces(args[1] + "\\to " + args[2]) + " " + LaTeX.braces(args[0]);
                } else if (fname === FACTORIAL || fname === DOUBLEFACTORIAL) {
                  f = this.toTeX(e.args) + (fname === FACTORIAL ? "!" : "!!");
                } else {
                  f = LaTeX.latex(e, decimals);
                }
                TeX.push(f);
              } else {
                TeX.push(LaTeX.latex(e, decimals));
              }
            } else if (isArray(e)) {
              TeX.push(LaTeX.brackets(this.toTeX(e)));
            } else {
              if (e === "/")
                TeX.push(LaTeX.frac(rem_brackets(TeX.pop()), rem_brackets(this.toTeX([obj[++i]]))));
              else
                TeX.push(e);
            }
          }
          return TeX.join(" ");
        };
        function parens(symbol) {
          if (Settings.PARSE2NUMBER) {
            return symbol;
          }
          return _2.symfunction("parens", [symbol]);
        }
        function abs(symbol) {
          if (symbol.isInfinity) {
            return Symbol2.infinity();
          }
          if (symbol.multiplier.lessThan(0))
            symbol.multiplier.negate();
          if (symbol.isImaginary()) {
            var re = symbol.realpart();
            var im = symbol.imagpart();
            if (re.isConstant() && im.isConstant())
              return sqrt(_2.add(_2.pow(re, new Symbol2(2)), _2.pow(im, new Symbol2(2))));
          } else if (isNumericSymbol(symbol) || even(symbol.power)) {
            return symbol;
          }
          if (symbol.isComposite()) {
            var ms = [];
            symbol.each(function(x) {
              ms.push(x.multiplier);
            });
            var gcd = Math2.QGCD.apply(null, ms);
            if (gcd.lessThan(0)) {
              symbol.multiplier = symbol.multiplier.multiply(new Frac(-1));
              symbol.distributeMultiplier();
            }
          }
          var m = _2.parse(symbol.multiplier);
          symbol.toUnitMultiplier();
          return _2.multiply(m, _2.symfunction(ABS, [symbol]));
        }
        function factorial(symbol) {
          var retval;
          if (isVector(symbol)) {
            var V = new Vector();
            symbol.each(function(x, i) {
              V.set(i - 1, factorial(x));
            });
            return V;
          }
          if (isMatrix(symbol)) {
            var M = new Matrix();
            symbol.each(function(x, i, j) {
              M.set(i, j, factorial(x));
            });
            return M;
          }
          if (Settings.PARSE2NUMBER && symbol.isConstant()) {
            if (isInt(symbol)) {
              retval = Math2.bigfactorial(symbol);
            } else {
              retval = Math2.gamma(symbol.multiplier.add(new Frac(1)).toDecimal());
            }
            retval = bigConvert(retval);
            return retval;
          } else if (symbol.isConstant()) {
            var den = symbol.getDenom();
            if (den.equals(2)) {
              var num = symbol.getNum();
              var a, b, c, n2;
              if (!symbol.multiplier.isNegative()) {
                n2 = _2.add(num, new Symbol2(1)).multiplier.divide(new Frac(2));
                a = Math2.bigfactorial(new Frac(2).multiply(n2));
                b = _2.pow(new Symbol2(4), new Symbol2(n2)).multiplier.multiply(Math2.bigfactorial(n2));
              } else {
                n2 = _2.subtract(num.negate(), new Symbol2(1)).multiplier.divide(new Frac(2));
                a = _2.pow(new Symbol2(-4), new Symbol2(n2)).multiplier.multiply(Math2.bigfactorial(n2));
                b = Math2.bigfactorial(new Frac(2).multiply(n2));
              }
              c = a.divide(b);
              return _2.multiply(_2.parse("sqrt(pi)"), new Symbol2(c));
            }
          }
          return _2.symfunction(FACTORIAL, [symbol]);
        }
        ;
        function continued_fraction(symbol, n2) {
          var _symbol2 = evaluate(symbol);
          if (_symbol2.isConstant()) {
            var cf = Math2.continuedFraction(_symbol2, n2);
            var fractions = Vector.fromArray(cf.fractions.map(function(x) {
              return new Symbol2(x);
            }));
            return Vector.fromArray([new Symbol2(cf.sign), new Symbol2(cf.whole), fractions]);
          }
          return _2.symfunction("continued_fraction", arguments);
        }
        function erf(symbol) {
          var _symbol2 = evaluate(symbol);
          if (_symbol2.isConstant()) {
            return Math2.erf(_symbol2);
          } else if (_symbol2.isImaginary()) {
            return complex.erf(symbol);
          }
          return _2.symfunction("erf", arguments);
        }
        ;
        function mod(symbol1, symbol2) {
          if (symbol1.isConstant() && symbol2.isConstant()) {
            var retval = new Symbol2(1);
            retval.multiplier = retval.multiplier.multiply(symbol1.multiplier.mod(symbol2.multiplier));
            return retval;
          }
          var r = _2.divide(symbol1.clone(), symbol2.clone());
          if (isInt(r))
            return new Symbol2(0);
          return _2.symfunction("mod", [symbol1, symbol2]);
        }
        function IF(condition, a, b) {
          if (typeof condition !== "boolean") {
            if (isNumericSymbol(condition))
              condition = !!Number(condition);
          }
          if (condition)
            return a;
          return b;
        }
        function is_in(obj, item) {
          if (isMatrix(obj)) {
            for (var i = 0, l = obj.rows(); i < l; i++) {
              for (var j = 0, l2 = obj.cols(); j < l2; j++) {
                var element = obj.elements[i][j];
                if (element.equals(item))
                  return new Symbol2(1);
              }
            }
          } else if (obj.elements) {
            for (var i = 0, l = obj.elements.length; i < l; i++) {
              if (obj.elements[i].equals(item))
                return new Symbol2(1);
            }
          }
          return new Symbol2(0);
        }
        function sinc(symbol) {
          if (Settings.PARSE2NUMBER) {
            if (symbol.isConstant()) {
              return new Symbol2(Math2.sinc(symbol));
            }
            return _2.parse(format("sin({0})/({0})", symbol));
          }
          return _2.symfunction("sinc", [symbol]);
        }
        function exp(symbol) {
          if (symbol.fname === Settings.LOG && symbol.isLinear()) {
            return _2.pow(symbol.args[0], Symbol2.create(symbol.multiplier));
          }
          return _2.parse(format("e^({0})", symbol));
        }
        function radians(symbol) {
          return _2.parse(format("({0})*pi/180", symbol));
        }
        function degrees(symbol) {
          return _2.parse(format("({0})*180/pi", symbol));
        }
        function nroots2(symbol) {
          var a, b;
          if (symbol.group === FN && symbol.fname === "") {
            a = Symbol2.unwrapPARENS(_2.parse(symbol).toLinear());
            b = _2.parse(symbol.power);
          } else if (symbol.group === P) {
            a = _2.parse(symbol.value);
            b = _2.parse(symbol.power);
          }
          if (a && b && a.group === N && b.group === N) {
            var _roots = [];
            var parts = Symbol2.toPolarFormArray(symbol);
            var r = _2.parse(a).abs().toString();
            var x = arg(a).toString();
            var n2 = b.multiplier.den.toString();
            var p = b.multiplier.num.toString();
            var formula = "(({0})^({1})*(cos({3})+({2})*sin({3})))^({4})";
            for (var i = 0; i < n2; i++) {
              var t = evaluate(_2.parse(format("(({0})+2*pi*({1}))/({2})", x, i, n2))).multiplier.toDecimal();
              _roots.push(evaluate(_2.parse(format(formula, r, n2, Settings.IMAGINARY, t, p))));
            }
            return Vector.fromArray(_roots);
          } else if (symbol.isConstant(true)) {
            var sign2 = symbol.sign();
            var x = evaluate(symbol.abs());
            var root = _2.sqrt(x);
            var _roots = [root.clone(), root.negate()];
            if (sign2 < 0)
              _roots = _roots.map(function(x2) {
                return _2.multiply(x2, Symbol2.imaginary());
              });
          } else {
            _roots = [_2.parse(symbol)];
          }
          return Vector.fromArray(_roots);
        }
        function rationalize(symbol) {
          if (symbol.isComposite()) {
            var retval = new Symbol2(0);
            var num, den, retnum, retden, a, b, n2, d;
            symbol.each(function(x) {
              num = x.getNum();
              den = x.getDenom();
              retnum = retval.getNum();
              retden = retval.getDenom();
              a = _2.multiply(den, retnum);
              b = _2.multiply(num, retden);
              n2 = _2.expand(_2.add(a, b));
              d = _2.multiply(retden, den);
              retval = _2.divide(n2, d);
            }, true);
            return retval;
          }
          return symbol;
        }
        function sqrt(symbol) {
          if (!isSymbol(symbol)) {
            symbol = _2.parse(symbol);
          }
          if (symbol.group === EX) {
            return _2.symfunction(SQRT, [symbol]);
          }
          if (symbol.fname === "" && symbol.power.equals(1))
            symbol = symbol.args[0];
          var is_negative = symbol.multiplier.sign() < 0;
          if (Settings.PARSE2NUMBER) {
            if (symbol.isConstant() && !is_negative) {
              return new Symbol2(bigDec.sqrt(symbol.multiplier.toDecimal()));
            } else if (symbol.isImaginary()) {
              return complex.sqrt(symbol);
            } else if (symbol.group === S) {
              return _2.symfunction("sqrt", [symbol]);
            }
          }
          var img, retval, isConstant = symbol.isConstant();
          if (symbol.group === CB && symbol.isLinear()) {
            var m = sqrt(Symbol2(symbol.multiplier));
            for (var s in symbol.symbols) {
              var x = symbol.symbols[s];
              m = _2.multiply(m, sqrt(x));
            }
            retval = m;
          } else if (symbol.fname === SQRT) {
            var s = symbol.args[0];
            var ms = symbol.multiplier;
            s.setPower(symbol.power.multiply(new Frac(0.25)));
            retval = s;
            if (!ms.equals(1))
              retval = _2.multiply(sqrt(_2.parse(ms)), retval);
          } else if (!symbol.power.isInteger()) {
            symbol.setPower(symbol.power.multiply(new Frac(0.5)));
            retval = symbol;
          } else if (symbol.multiplier < 0 && symbol.group === S) {
            var a = _2.parse(symbol.multiplier).negate();
            var b = _2.parse(symbol).toUnitMultiplier().negate();
            retval = _2.multiply(_2.symfunction(Settings.SQRT, [b]), sqrt(a));
          } else {
            var sign2 = symbol.power.sign();
            symbol.power = symbol.power.abs();
            if (isConstant && symbol.multiplier.lessThan(0)) {
              img = Symbol2.imaginary();
              symbol.multiplier = symbol.multiplier.abs();
            }
            var q = symbol.multiplier.toDecimal(), qa = Math.abs(q), t = Math.sqrt(qa);
            var m;
            if (isInt(t)) {
              m = new Symbol2(t);
            } else if (isInt(q)) {
              var factors = Math2.ifactor(q);
              var tw = 1;
              for (var x in factors) {
                var n2 = factors[x], nn = n2 - n2 % 2;
                if (nn) {
                  var w = Math.pow(x, nn);
                  tw *= Math.pow(x, nn / 2);
                  q /= w;
                }
              }
              m = _2.multiply(_2.symfunction(SQRT, [new Symbol2(q)]), new Symbol2(tw));
            } else {
              var c = [new Symbol2(symbol.multiplier.num), new Symbol2(symbol.multiplier.den)];
              var r = [new Symbol2(1), new Symbol2(1)];
              var sq = [new Symbol2(1), new Symbol2(1)];
              for (var i = 0; i < 2; i++) {
                var n2 = c[i];
                pfactor(n2).each(function(x2) {
                  x2 = Symbol2.unwrapPARENS(x2);
                  var b2 = x2.clone().toLinear();
                  var p = Number(x2.power);
                  var rem = p % 2;
                  var w2 = (p - rem) / 2;
                  r[i] = _2.multiply(r[i], _2.pow(b2, new Symbol2(w2)));
                  sq[i] = _2.multiply(sq[i], sqrt(_2.pow(b2, new Symbol2(rem))));
                });
              }
              m = _2.divide(_2.multiply(r[0], sq[0]), _2.multiply(r[1], sq[1]));
            }
            symbol = symbol.toUnitMultiplier(true);
            if (symbol.isOne()) {
              retval = symbol;
            } else if (even(symbol.power.toString())) {
              retval = _2.pow(symbol.clone(), new Symbol2(0.5));
            } else {
              retval = _2.symfunction(SQRT, [symbol]);
            }
            if (sign2 < 0)
              retval.power.negate();
            if (m)
              retval = _2.multiply(m, retval);
            if (img)
              retval = _2.multiply(img, retval);
          }
          if (is_negative && Settings.PARSE2NUMBER)
            return _2.parse(retval);
          return retval;
        }
        function cbrt(symbol) {
          if (!symbol.isConstant(true)) {
            var retval;
            var n2 = symbol.power / 3;
            var m = _2.pow(_2.parse(symbol.multiplier), new Symbol2(1 / 3));
            var sym = symbol.toUnitMultiplier();
            if (isInt(n2)) {
              retval = _2.pow(sym.toLinear(), _2.parse(n2));
            } else {
              if (sym.group === CB) {
                retval = new Symbol2(1);
                sym.each(function(x) {
                  retval = _2.multiply(retval, cbrt(x));
                });
              } else {
                retval = _2.symfunction("cbrt", [sym]);
              }
            }
            return _2.multiply(m, retval);
          }
          return nthroot(symbol, new Symbol2(3));
        }
        function scientific(symbol, sigfigs) {
          symbol.scientific = sigfigs || 10;
          return symbol;
        }
        function nthroot(num, p, prec, asbig) {
          p = evaluate(_2.parse(p));
          if (p.equals(0)) {
            throw new UndefinedError("Unable to calculate nthroots of zero");
          }
          if (num < 0 && even(p))
            throw new Error("Cannot calculate nthroot of negative number for even powers");
          if (!num.isConstant(true)) {
            return _2.symfunction("nthroot", arguments);
          }
          if (num.group !== N) {
            num = evaluate(num);
          }
          if (typeof asbig === "undefined")
            asbig = true;
          prec = prec || 25;
          var sign2 = num.sign();
          var retval;
          var ans;
          if (sign2 < 0) {
            num = abs(num);
          }
          if (isInt(num) && p.isConstant()) {
            if (num < 18446744073709552e3) {
              ans = Frac.create(Math.pow(num, 1 / p));
            } else {
              ans = Math2.nthroot(num, p);
            }
            var retval;
            if (asbig) {
              retval = new Symbol2(ans);
            }
            retval = new Symbol2(ans.toDecimal(prec));
            return _2.multiply(new Symbol2(sign2), retval);
          }
        }
        function pfactor(symbol) {
          if (symbol.greaterThan(9999999999998891e26) || symbol.equals(-1))
            return symbol;
          if (symbol.equals(Math.PI))
            return new Symbol2(Math.PI);
          symbol = evaluate(symbol.clone());
          if (symbol.isConstant()) {
            var retval = new Symbol2(1);
            var m = symbol.toString();
            if (isInt(m)) {
              var factors = Math2.ifactor(m);
              for (var factor in factors) {
                var p = factors[factor];
                retval = _2.multiply(retval, _2.symfunction("parens", [new Symbol2(factor).setPower(new Frac(p))]));
              }
            } else {
              var n2 = pfactor(new Symbol2(symbol.multiplier.num));
              var d = pfactor(new Symbol2(symbol.multiplier.den));
              retval = _2.multiply(_2.symfunction("parens", [n2]), _2.symfunction("parens", [d]).invert());
            }
          } else
            retval = _2.symfunction("pfactor", arguments);
          return retval;
        }
        function realpart(symbol) {
          return symbol.realpart();
        }
        function imagpart(symbol) {
          return symbol.imagpart();
        }
        function conjugate(symbol) {
          var re = symbol.realpart();
          var im = symbol.imagpart();
          return _2.add(re, _2.multiply(im.negate(), Symbol2.imaginary()));
        }
        function arg(symbol) {
          var re = symbol.realpart();
          var im = symbol.imagpart();
          if (re.isConstant() && im.isConstant())
            return new Symbol2(Math.atan2(im, re));
          return _2.symfunction("atan2", [im, re]);
        }
        function arg(symbol) {
          var re = symbol.realpart();
          var im = symbol.imagpart();
          if (re.isConstant() && im.isConstant()) {
            if (im.equals(0) && re.equals(-1)) {
              return _2.parse("pi");
            } else if (im.equals(1) && re.equals(0)) {
              return _2.parse("pi/2");
            } else if (im.equals(1) && re.equals(1)) {
              return _2.parse("pi/4");
            }
            return new Symbol2(Math.atan2(im, re));
          }
          return _2.symfunction("atan2", [im, re]);
        }
        function polarform(symbol) {
          var p, r, e, theta;
          p = Symbol2.toPolarFormArray(symbol);
          theta = p[1];
          r = p[0];
          e = _2.parse(format("e^({0}*({1}))", Settings.IMAGINARY, theta));
          return _2.multiply(r, e);
        }
        function rectform(symbol) {
          var original = symbol.clone();
          try {
            var f, p, q, s, h, d, n2;
            f = decompose_fn(symbol, "e", true);
            p = _2.divide(f.x.power, Symbol2.imaginary());
            q = evaluate(trig.tan(p));
            s = _2.pow(f.a, new Symbol2(2));
            d = q.getDenom(true);
            n2 = q.getNum();
            h = Symbol2.hyp(n2, d);
            if (h.equals(f.a)) {
              return _2.add(d, _2.multiply(Symbol2.imaginary(), n2));
            } else {
              return original;
            }
          } catch (e) {
            return original;
          }
        }
        function symMinMax(f, args) {
          args.map(function(x) {
            x.numVal = evaluate(x).multiplier;
          });
          var l, a, b, a_val, b_val;
          while (true) {
            l = args.length;
            if (l < 2)
              return args[0];
            a = args.pop();
            b = args[l - 2];
            if (f === "min" ? a.numVal < b.numVal : a.numVal > b.numVal) {
              args.pop();
              args.push(a);
            }
          }
        }
        function max() {
          var args = [].slice.call(arguments);
          if (allSame(args))
            return args[0];
          if (allNumbers(args))
            return new Symbol2(Math.max.apply(null, args));
          if (Settings.SYMBOLIC_MIN_MAX && allConstants(args))
            return symMinMax("max", args);
          return _2.symfunction("max", args);
        }
        function min() {
          var args = [].slice.call(arguments);
          if (allSame(args))
            return args[0];
          if (allNumbers(args))
            return new Symbol2(Math.min.apply(null, args));
          if (Settings.SYMBOLIC_MIN_MAX && allConstants(args))
            return symMinMax("min", args);
          return _2.symfunction("min", args);
        }
        function sign(x) {
          if (x.isConstant(true))
            return new Symbol2(Math.sign(evaluate(x)));
          return _2.symfunction("sign", arguments);
        }
        function sort(symbol, opt) {
          opt = opt ? opt.toString() : "asc";
          var getval = function(e) {
            if (e.group === N)
              return e.multiplier;
            if (e.group === FN) {
              if (e.fname === "")
                return getval(e.args[0]);
              return e.fname;
            }
            if (e.group === S)
              return e.power;
            return e.value;
          };
          var symbols = isVector(symbol) ? symbol.elements : symbol.collectSymbols();
          return new Vector(symbols.sort(function(a, b) {
            var aval = getval(a), bval = getval(b);
            if (opt === "desc")
              return bval - aval;
            return aval - bval;
          }));
        }
        function log(symbol, base) {
          if (symbol.equals(1)) {
            return new Symbol2(0);
          }
          var retval;
          if (symbol.fname === SQRT && symbol.multiplier.equals(1)) {
            retval = _2.divide(log(symbol.args[0]), new Symbol2(2));
            if (symbol.power.sign() < 0) {
              retval.negate();
            }
            return retval;
          }
          if (symbol.equals(0)) {
            throw new UndefinedError(Settings.LOG + "(0) is undefined!");
          }
          if (symbol.isImaginary()) {
            return complex.evaluate(symbol, Settings.LOG);
          }
          if (symbol.isConstant() && typeof base !== "undefined" && base.isConstant()) {
            var log_sym = Math.log(symbol);
            var log_base = Math.log(base);
            retval = new Symbol2(log_sym / log_base);
          } else if (symbol.group === EX && symbol.power.multiplier.lessThan(0) || symbol.power.toString() === "-1") {
            symbol.power.negate();
            retval = log(symbol).negate();
          } else if (symbol.value === "e" && symbol.multiplier.equals(1)) {
            var p = symbol.power;
            retval = isSymbol(p) ? p : new Symbol2(p);
          } else if (symbol.group === FN && symbol.fname === "exp") {
            var s = symbol.args[0];
            if (symbol.multiplier.equals(1))
              retval = _2.multiply(s, new Symbol2(symbol.power));
            else
              retval = _2.symfunction(Settings.LOG, [symbol]);
          } else if (Settings.PARSE2NUMBER && isNumericSymbol(symbol)) {
            symbol = _2.parse(symbol);
            var img_part;
            if (symbol.multiplier.lessThan(0)) {
              symbol.negate();
              img_part = _2.multiply(new Symbol2(Math.PI), new Symbol2("i"));
            }
            retval = new Symbol2(Math.log(symbol.multiplier.toDecimal()));
            if (img_part) {
              retval = _2.add(retval, img_part);
            }
          } else {
            var s;
            if (!symbol.power.equals(1) && !symbol.contains("e")) {
              s = symbol.group === EX ? symbol.power : new Symbol2(symbol.power);
              symbol.toLinear();
            }
            if (arguments.length > 1 && allSame(arguments)) {
              retval = new Symbol2(1);
            } else {
              retval = _2.symfunction(Settings.LOG, arguments);
            }
            if (s)
              retval = _2.multiply(s, retval);
          }
          return retval;
        }
        function round(x, s) {
          var sIsConstant = s && s.isConstant() || typeof s === "undefined";
          if (x.isConstant() && sIsConstant) {
            var v, e, exp2, retval;
            v = x;
            if (s && s.lessThan(0)) {
              s = abs(s);
              e = Number(x).toExponential().toString().split("e");
              v = e[0];
              exp2 = e[1];
            }
            retval = new Symbol2(nround(v, Number(s || 0)));
            return _2.multiply(retval, _2.pow(new Symbol2(10), new Symbol2(exp2 || 0)));
          }
          return _2.symfunction("round", arguments);
        }
        function getQuadrant(m) {
          var v = m % 2, quadrant;
          if (v < 0)
            v = 2 + v;
          if (v >= 0 && v <= 0.5)
            quadrant = 1;
          else if (v > 0.5 && v <= 1)
            quadrant = 2;
          else if (v > 1 && v <= 1.5)
            quadrant = 3;
          else
            quadrant = 4;
          return quadrant;
        }
        function bigConvert(n2) {
          if (!isFinite(n2)) {
            var sign2 = Math.sign(n2);
            var r = new Symbol2(String(Math.abs(n2)));
            r.multiplier = r.multiplier.multiply(new Frac(sign2));
            return r;
          }
          if (isSymbol(n2))
            return n2;
          if (typeof n2 === "number") {
            try {
              n2 = Frac.simple(n2);
            } catch (e) {
              n2 = new Frac(n2);
            }
          }
          var symbol = new Symbol2(0);
          symbol.multiplier = n2;
          return symbol;
        }
        ;
        function clean(symbol) {
          var g = symbol.group, retval;
          if (g === CP) {
            var num = symbol.getNum(), den = symbol.getDenom() || new Symbol2(1), p = Number(symbol.power), factor = new Symbol2(1);
            if (Math.abs(p) === 1) {
              den.each(function(x) {
                if (x.group === CB) {
                  factor = _2.multiply(factor, clean(x.getDenom()));
                } else if (x.power.lessThan(0)) {
                  factor = _2.multiply(factor, clean(x.clone().toUnitMultiplier()));
                }
              });
              var new_den = new Symbol2(0);
              den.each(function(x) {
                new_den = _2.add(_2.divide(x, factor.clone()), new_den);
              });
              factor.invert();
              var new_num;
              if (num.isComposite()) {
                new_num = new Symbol2(0);
                num.each(function(x) {
                  new_num = _2.add(_2.multiply(clean(x), factor.clone()), new_num);
                });
              } else
                new_num = _2.multiply(factor, num);
              retval = _2.divide(new_num, new_den);
            }
          } else if (g === CB) {
            retval = new Symbol2(1);
            symbol.each(function(x) {
              retval = _2.multiply(retval, _2.clean(x));
            });
          } else if (g === FN) {
            if (symbol.args.length === 1 && symbol.args[0].isConstant())
              retval = block("PARSE2NUMBER", function() {
                return _2.parse(symbol);
              }, true);
          }
          if (!retval)
            retval = symbol;
          return retval;
        }
        function expandall(symbol, opt) {
          opt = opt || {
            expand_denominator: true,
            expand_functions: true
          };
          return expand(symbol, opt);
        }
        function expand(symbol, opt) {
          if (Array.isArray(symbol)) {
            return symbol.map(function(x2) {
              return expand(x2, opt);
            });
          }
          opt = opt || {};
          if (symbol.group === FN && symbol.fname === "") {
            var f = expand(symbol.args[0], opt);
            var x = expand(_2.pow(f, _2.parse(symbol.power)), opt);
            return _2.multiply(_2.parse(symbol.multiplier), x).distributeMultiplier();
          }
          if ([N, P, S].indexOf(symbol.group) !== -1) {
            return symbol;
          }
          var original = symbol.clone();
          try {
            var m = symbol.multiplier.toString();
            var p = Number(symbol.power);
            var retval = symbol;
            if (symbol.isComposite() && isInt(symbol.power) && symbol.power > 0) {
              var n2 = p - 1;
              var f = new Symbol2(0);
              symbol.each(function(x2) {
                f = _2.add(f, expand(_2.parse(x2), opt));
              });
              var expanded = _2.parse(f);
              for (var i = 0; i < n2; i++) {
                expanded = mix(expanded, f, opt);
              }
              retval = _2.multiply(_2.parse(m), expanded).distributeMultiplier();
            } else if (symbol.group === FN && opt.expand_functions === true) {
              var args = [];
              symbol.args.forEach(function(x2) {
                args.push(expand(x2, opt));
              });
              retval = _2.pow(_2.symfunction(symbol.fname, args), _2.parse(symbol.power));
              retval = _2.multiply(retval, _2.parse(symbol.multiplier));
            } else if (symbol.isComposite() && isInt(symbol.power) && symbol.power < 0 && opt.expand_denominator === true) {
              symbol = symbol.invert();
              retval = expand(symbol, opt);
              retval.invert();
            } else if (symbol.group === CB) {
              var rank = function(s) {
                switch (s.group) {
                  case CP:
                    return 0;
                  case PL:
                    return 1;
                  case CB:
                    return 2;
                  case FN:
                    return 3;
                  default:
                    return 4;
                }
              };
              var symbols = symbol.collectSymbols().sort(function(a, b) {
                return rank(b) - rank(a);
              }).map(function(s) {
                var x2 = _2.pow(s, _2.parse(p));
                var e = expand(x2, opt);
                return e;
              });
              var f = symbols.pop();
              if (f.isComposite() && f.isLinear()) {
                symbols.forEach(function(s) {
                  f = mix(f, s, opt);
                });
                if (f.isComposite()) {
                  if (f.power > 1) {
                    f = expand(_2.pow(f, _2.parse(f.power)), opt);
                  }
                  retval = _2.multiply(_2.parse(m), f).distributeMultiplier();
                  ;
                } else {
                  retval = f;
                }
              } else {
                retval = f;
                symbols.forEach(function(s) {
                  retval = _2.multiply(retval, s);
                });
                retval = _2.multiply(retval, _2.parse(m)).distributeMultiplier();
              }
              if (retval.group === CB) {
                retval = _2.parse(retval);
              }
            } else {
              retval = symbol;
            }
            return retval;
          } catch (e) {
            return original;
          }
          return original;
        }
        function imatrix(n2) {
          return Matrix.identity(n2);
        }
        function vecget(vector2, index) {
          if (index.isConstant() && isInt(index))
            return vector2.elements[index];
          return _2.symfunction("vecget", arguments);
        }
        function vectrim(vector2, tolerance) {
          tolerance = typeof tolerance === "undefined" ? 1e-14 : tolerance;
          vector2 = vector2.clone();
          tolerance = Number(tolerance);
          vector2.elements.sort(function(a, b) {
            return b.group - a.group;
          });
          vector2.elements = removeDuplicates(vector2.elements, function(a, b) {
            var diff = Number(_2.subtract(evaluate(a), evaluate(b)).abs());
            return diff <= tolerance;
          });
          return vector2;
        }
        function vecset(vector2, index, value) {
          if (!index.isConstant)
            return _2.symfunction("vecset", arguments);
          vector2.elements[index] = value;
          return vector2;
        }
        function matget(matrix2, i, j) {
          if (i.isConstant() && j.isConstant())
            return matrix2.elements[i][j];
          return _2.symfunction("matget", arguments);
        }
        function matgetrow(matrix2, i) {
          if (i.isConstant())
            return new Matrix(matrix2.elements[i]);
          return _2.symfunction("matgetrow", arguments);
        }
        function matsetrow(matrix2, i, x) {
          if (!i.isConstant())
            return _2.symfunction("matsetrow", arguments);
          if (matrix2.elements[i].length !== x.elements.length)
            throw new DimensionError("Matrix row must match row dimensions!");
          var M = matrix2.clone();
          M.elements[i] = x.clone().elements;
          return M;
        }
        function matgetcol(matrix2, col_index) {
          if (!col_index.isConstant())
            return _2.symfunction("matgetcol", arguments);
          col_index = Number(col_index);
          var M = Matrix.fromArray([]);
          matrix2.each(function(x, i, j) {
            if (j === col_index) {
              M.elements.push([x.clone()]);
            }
          });
          return M;
        }
        function matsetcol(matrix2, j, col) {
          if (!j.isConstant())
            return _2.symfunction("matsetcol", arguments);
          j = Number(j);
          if (matrix2.rows() !== col.elements.length)
            throw new DimensionError("Matrix columns must match number of columns!");
          col.each(function(x, i) {
            matrix2.set(i - 1, j, x.elements[0].clone());
          });
          return matrix2;
        }
        function matset(matrix2, i, j, value) {
          matrix2.elements[i][j] = value;
          return matrix2;
        }
        function vector() {
          return new Vector([].slice.call(arguments));
        }
        function matrix() {
          return Matrix.fromArray(arguments);
        }
        function set() {
          return Set2.fromArray(arguments);
        }
        function determinant(symbol) {
          if (isMatrix(symbol)) {
            return symbol.determinant();
          }
          return symbol;
        }
        function size(symbol) {
          var retval;
          if (isMatrix(symbol))
            retval = [new Symbol2(symbol.cols()), new Symbol2(symbol.rows())];
          else if (isVector(symbol) || isSet(symbol))
            retval = new Symbol2(symbol.elements.length);
          else
            err("size expects a matrix or a vector");
          return retval;
        }
        function dot(vec1, vec2) {
          if (isVector(vec1) && isVector(vec2))
            return vec1.dot(vec2);
          err("function dot expects 2 vectors");
        }
        function cross(vec1, vec2) {
          if (isVector(vec1) && isVector(vec2))
            return vec1.cross(vec2);
          err("function cross expects 2 vectors");
        }
        function transpose(mat) {
          if (isMatrix(mat))
            return mat.transpose();
          err("function transpose expects a matrix");
        }
        function invert(mat) {
          if (isMatrix(mat))
            return mat.invert();
          err("invert expects a matrix");
        }
        function union2(set1, set2) {
          return set1.union(set2);
        }
        function intersection2(set1, set2) {
          return set1.intersection(set2);
        }
        function contains(set1, e) {
          return set1.contains(e);
        }
        function difference(set1, set2) {
          return set1.difference(set2);
        }
        function intersects(set1, set2) {
          return new Symbol2(Number(set1.intersects(set2)));
        }
        function is_subset(set1, set2) {
          return new Symbol2(Number(set1.is_subset(set2)));
        }
        function print() {
          arguments2Array(arguments).map(function(x) {
            console.log(x.toString());
          });
        }
        function testSQRT(symbol) {
          if (!isSymbol(symbol.power) && symbol.power.absEquals(0.5)) {
            var sign2 = symbol.power.sign();
            var retval = sqrt(symbol.group === P ? new Symbol2(symbol.value) : symbol.toLinear());
            if (sign2 < 0)
              retval.invert();
            return retval;
          }
          return symbol;
        }
        function testPow(symbol) {
          if (symbol.group === P) {
            var v = symbol.value;
            var fct = primeFactors(v)[0];
            if (!fct) {
              warn("Unable to compute prime factors. This should not happen. Please review and report.");
              return symbol;
            }
            var n2 = new Frac(Math.log(v) / Math.log(fct)), p = n2.multiply(symbol.power);
            if (p.den > symbol.power.den)
              return symbol;
            if (isInt(p))
              symbol = Symbol2(Math.pow(fct, p));
            else
              symbol = new Symbol2(fct).setPower(p);
          }
          return symbol;
        }
        this.expand = expand;
        this.round = round;
        this.clean = clean;
        this.sqrt = sqrt;
        this.cbrt = cbrt;
        this.abs = abs;
        this.log = log;
        this.rationalize = rationalize;
        this.nthroot = nthroot;
        this.arg = arg;
        this.conjugate = conjugate;
        this.imagpart = imagpart;
        this.realpart = realpart;
        this.getFunction = function(name) {
          return functions[name][0];
        };
        this.addPreprocessor = function(name, action, order, shift_cells) {
          var names = preprocessors.names;
          var actions = preprocessors.actions;
          if (typeof action !== "function")
            throw new PreprocessorError("Incorrect parameters. Function expected!");
          if (!order) {
            names.push(name);
            actions.push(action);
          } else {
            if (shift_cells) {
              names.splice(order, 0, name);
              actions.splice(order, 0, action);
            } else {
              names[order] = name;
              actions[order] = action;
            }
          }
        };
        this.getPreprocessors = function() {
          var preprocessors2 = {};
          for (var i = 0, l = preprocessors2.names.length; i < l; i++) {
            var name = preprocessors2.names[i];
            preprocessors2[name] = {
              order: i,
              action: preprocessors2.actions[i]
            };
          }
          return preprocessors2;
        };
        this.removePreprocessor = function(name, shift_cells) {
          var i = preprocessors.names.indexOf(name);
          if (shift_cells) {
            remove(preprocessors.names, i);
            remove(preprocessors.actions, i);
          } else {
            preprocessors.names[i] = void 0;
            preprocessors.actions[i] = void 0;
          }
        };
        this.mapped_function = function() {
          var subs = {}, params = this.params;
          for (var i = 0; i < params.length; i++) {
            subs[params[i]] = String(arguments[i]);
          }
          return _2.parse(this.body, subs);
        };
        this.add = function(a, b) {
          var aIsSymbol = isSymbol(a), bIsSymbol = isSymbol(b);
          if (aIsSymbol && bIsSymbol) {
            if (a.unit || b.unit) {
              return _2.Unit.add(a, b);
            }
            if (a.isInfinity || b.isInfinity) {
              var aneg = a.multiplier.lessThan(0), bneg = b.multiplier.lessThan(0);
              if (a.isInfinity && b.isInfinity && aneg !== bneg) {
                throw new UndefinedError("(" + a + ")+(" + b + ") is not defined!");
              }
              var inf = Symbol2.infinity();
              if (bneg)
                inf.negate();
              return inf;
            }
            if (a.isComposite() && a.isLinear() && b.isComposite() && b.isLinear()) {
              a.distributeMultiplier();
              b.distributeMultiplier();
              if (b.length > a.length && a.group === b.group) {
                [a, b] = [b, a];
              }
            }
            if (a.multiplier.equals(0))
              return b;
            if (b.multiplier.equals(0))
              return a;
            if (a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {
              var result = new Symbol2(a.multiplier.add(b.multiplier).toDecimal(Settings.PRECISION));
              return result;
            }
            var g1 = a.group, g2 = b.group, ap = a.power.toString(), bp = b.power.toString();
            if (g1 < g2 || g1 === g2 && ap > bp && bp > 0) {
              return this.add(b, a);
            }
            if (g1 === CB && g2 === PL && a.value === b.value) {
              var t = a;
              a = b;
              b = t;
              g1 = a.group;
              g2 = b.group;
              ap = a.power.toString();
              bp = b.power.toString();
            }
            var powEQ = ap === bp, v1 = a.value, v2 = b.value, aIsComposite = a.isComposite(), bIsComposite = b.isComposite(), h1, h2, result;
            if (aIsComposite)
              h1 = text(a, "hash");
            if (bIsComposite)
              h2 = text(b, "hash");
            if (g1 === CP && g2 === CP && b.isLinear() && !a.isLinear() && h1 !== h2) {
              return this.add(b, a);
            }
            if (g1 === PL && g2 === PL) {
              v1 = h1;
              v2 = h2;
            }
            var PN = g1 === P && g2 === N, PNEQ = a.value === b.multiplier.toString(), valEQ = v1 === v2 || h1 === h2 && h1 !== void 0 || PN && PNEQ;
            if (valEQ && powEQ && g1 === g2) {
              if (PN)
                b = b.convert(P);
              if (g1 === PL && (g2 === S || g2 === P)) {
                a.distributeMultiplier();
                result = a.attach(b);
              } else {
                result = a;
                if (a.multiplier.isOne() && b.multiplier.isOne() && g1 === CP && a.isLinear() && b.isLinear()) {
                  for (var s in b.symbols) {
                    var x = b.symbols[s];
                    result.attach(x);
                  }
                } else
                  result.multiplier = result.multiplier.add(b.multiplier);
              }
            } else if (valEQ && g1 !== PL) {
              if (g1 === CP && g2 === PL) {
                b.insert(a, "add");
                result = b;
              } else {
                result = Symbol2.shell(PL).attach([a, b]);
                result.value = g1 === PL ? h1 : v1;
              }
            } else if (aIsComposite && a.isLinear()) {
              var canIterate = g1 === g2, bothPL = g1 === PL && g2 === PL;
              if (bothPL)
                canIterate = a.value === b.value;
              a.distributeMultiplier();
              if (b.isComposite() && b.isLinear() && canIterate) {
                b.distributeMultiplier();
                for (var s in b.symbols) {
                  var x = b.symbols[s];
                  a.attach(x);
                }
                result = a;
              } else if (bothPL && a.value !== h2 || g1 === PL && !valEQ) {
                result = Symbol2.shell(CP).attach([a, b]);
                result.updateHash();
              } else {
                result = a.attach(b);
              }
            } else {
              if (g1 === FN && a.fname === SQRT && g2 !== EX && b.power.equals(0.5)) {
                var m = b.multiplier.clone();
                b = sqrt(b.toUnitMultiplier().toLinear());
                b.multiplier = m;
              }
              if (a.length === 2 && b.length === 2 && even(a.power) && even(b.power)) {
                result = _2.add(expand(a), expand(b));
              } else {
                result = Symbol2.shell(CP).attach([a, b]);
                result.updateHash();
              }
            }
            if (result.multiplier.equals(0))
              result = new Symbol2(0);
            if (result.length === 1) {
              var m = result.multiplier;
              result = firstObject(result.symbols);
              result.multiplier = result.multiplier.multiply(m);
            }
            return result;
          } else {
            if (bIsSymbol && !aIsSymbol) {
              var t = a;
              a = b;
              b = t;
              t = bIsSymbol;
              bIsSymbol = aIsSymbol;
              aIsSymbol = t;
            }
            var bIsMatrix = isMatrix(b);
            if (aIsSymbol && bIsMatrix) {
              var M = new Matrix();
              b.eachElement(function(e, i, j) {
                M.set(i, j, _2.add(a.clone(), e));
              });
              b = M;
            } else {
              if (isMatrix(a) && bIsMatrix) {
                b = a.add(b);
              } else if (aIsSymbol && isVector(b)) {
                b.each(function(x2, i) {
                  i--;
                  b.elements[i] = _2.add(a.clone(), b.elements[i]);
                });
              } else {
                if (isVector(a) && isVector(b)) {
                  b.each(function(x2, i) {
                    i--;
                    b.elements[i] = _2.add(a.elements[i], b.elements[i]);
                  });
                } else if (isVector(a) && isMatrix(b)) {
                  return _2.add(b, a);
                } else if (isMatrix(a) && isVector(b)) {
                  if (b.elements.length === a.rows()) {
                    var M = new Matrix(), l = a.cols();
                    b.each(function(e, i) {
                      var row = [];
                      for (var j = 0; j < l; j++) {
                        row.push(_2.add(a.elements[i - 1][j].clone(), e.clone()));
                      }
                      M.elements.push(row);
                    });
                    return M;
                  } else
                    err("Dimensions must match!");
                }
              }
            }
            return b;
          }
        };
        this.subtract = function(a, b) {
          var aIsSymbol = aIsSymbol = isSymbol(a), bIsSymbol = isSymbol(b), t;
          if (aIsSymbol && bIsSymbol) {
            if (a.unit || b.unit) {
              return _2.Unit.subtract(a, b);
            }
            return this.add(a, b.negate());
          } else {
            if (bIsSymbol && isVector(a)) {
              b = a.map(function(x) {
                return _2.subtract(x, b.clone());
              });
            } else if (aIsSymbol && isVector(b)) {
              b = b.map(function(x) {
                return _2.subtract(a.clone(), x);
              });
            } else if (isVector(a) && isVector(b)) {
              if (a.dimensions() === b.dimensions())
                b = a.subtract(b);
              else
                _2.error("Unable to subtract vectors. Dimensions do not match.");
            } else if (isMatrix(a) && isVector(b)) {
              if (b.elements.length === a.rows()) {
                var M = new Matrix(), l = a.cols();
                b.each(function(e, i) {
                  var row = [];
                  for (var j = 0; j < l; j++) {
                    row.push(_2.subtract(a.elements[i - 1][j].clone(), e.clone()));
                  }
                  M.elements.push(row);
                });
                return M;
              } else
                err("Dimensions must match!");
            } else if (isVector(a) && isMatrix(b)) {
              var M = b.clone().negate();
              return _2.add(M, a);
            } else if (isMatrix(a) && isMatrix(b)) {
              b = a.subtract(b);
            } else if (isMatrix(a) && bIsSymbol) {
              var M = new Matrix();
              a.each(function(x, i, j) {
                M.set(i, j, _2.subtract(x, b.clone()));
              });
              b = M;
            } else if (aIsSymbol && isMatrix(b)) {
              var M = new Matrix();
              b.each(function(x, i, j) {
                M.set(i, j, _2.subtract(a.clone(), x));
              });
              b = M;
            }
            return b;
          }
        };
        this.multiply = function(a, b) {
          var aIsSymbol = isSymbol(a), bIsSymbol = isSymbol(b);
          if (aIsSymbol && b instanceof Collection) {
            b.elements.push(a);
            return b;
          }
          if (aIsSymbol && bIsSymbol) {
            if (b.isUnit) {
              var result = a.clone();
              a.unit = b;
              return result;
            }
            if (a.unit || b.unit) {
              return _2.Unit.multiply(a, b);
            }
            if (a.isInfinity || b.isInfinity) {
              if (a.equals(0) || b.equals(0))
                throw new UndefinedError(a + "*" + b + " is undefined!");
              if (b.power.lessThan(0)) {
                if (!a.isInfinity) {
                  return new Symbol2(0);
                } else {
                  throw new UndefinedError("Infinity/Infinity is not defined!");
                }
              }
              var sign2 = a.multiplier.multiply(b.multiplier).sign(), inf = Symbol2.infinity();
              if (a.isConstant() || b.isConstant() || a.isInfinity && b.isInfinity) {
                if (sign2 < 0)
                  inf.negate();
                return inf;
              }
            }
            if (a.isConstant() && b.isConstant() && Settings.PARSE2NUMBER) {
              var t = new bigDec(a.multiplier.toDecimal()).times(new bigDec(b.multiplier.toDecimal())).toFixed();
              var retval = new Symbol2(t);
              return retval;
            }
            if (a.isOne()) {
              return b.clone();
            }
            if (b.isOne()) {
              return a.clone();
            }
            if (a.multiplier.equals(0) || b.multiplier.equals(0))
              return new Symbol2(0);
            if (b.group > a.group && !(b.group === CP))
              return this.multiply(b, a);
            if (a.group === CB && b.group === PL && a.value === b.value) {
              var t = a;
              a = b;
              b = t;
            }
            var g1 = a.group, g2 = b.group, bnum = b.multiplier.num, bden = b.multiplier.den;
            if (g1 === FN && a.fname === SQRT && !b.isConstant() && a.args[0].value === b.value && !a.args[0].multiplier.lessThan(0)) {
              var a_pow = a.power;
              var a_multiplier = _2.parse(a.multiplier);
              a = _2.multiply(a_multiplier, a.args[0].clone());
              a.setPower(new Frac(0.5).multiply(a_pow));
              g1 = a.group;
            } else if (g1 === FN && a.fname === SQRT && a.multiplier.equals(1) && a.power.equals(-1) && b.isConstant() && a.args[0].equals(b)) {
              a = _2.symfunction(SQRT, [b.clone()]);
              b = new Symbol2(1);
            }
            ;
            var v1 = a.value, v2 = b.value, sign2 = new Frac(a.sign()), ONN = g1 === P && g2 === N && b.multiplier.equals(a.value), m = ONN ? new Frac(1).multiply(a.multiplier).abs() : a.multiplier.multiply(b.multiplier).abs(), result = a.clone().toUnitMultiplier();
            b = b.clone().toUnitMultiplier(true);
            if (g1 === FN && g2 === FN) {
              var u = a.args[0].clone();
              var v = b.args[0].clone();
              if (a.fname === SQRT && b.fname === SQRT && a.isLinear() && b.isLinear()) {
                var q = _2.divide(u, v).invert();
                if (q.gt(1) && isInt(q)) {
                  result = _2.multiply(a.args[0].clone(), sqrt(q.clone()));
                  b = new Symbol2(1);
                }
              } else if (a.fname === FACTORIAL && b.fname === FACTORIAL && !u.isConstant() && !v.isConstant() && b.power < 0) {
                var d = _2.subtract(u.clone(), v.clone());
                if (d.isConstant()) {
                  t = new Symbol2(1);
                  if (d < 0) {
                    for (var i = 0, n2 = Math.abs(d); i <= n2; i++) {
                      var s = _2.add(u.clone(), new Symbol2(i));
                      t = _2.multiply(t, s);
                    }
                    result = _2.multiply(_2.pow(u, new Symbol2(a.power)), _2.pow(t, new Symbol2(b.power)));
                    b = new Symbol2(1);
                  } else {
                    for (var i = 0, n2 = Math.abs(d); i <= n2; i++) {
                      var s = _2.add(v.clone(), new Symbol2(i));
                      t = _2.multiply(t, s);
                    }
                    result = _2.multiply(_2.pow(t, new Symbol2(a.power)), _2.pow(v, new Symbol2(b.power)));
                    b = new Symbol2(1);
                  }
                }
              }
            }
            if (v1 === v2 && g1 === PL && g1 === g2) {
              v1 = a.text("hash");
              v2 = b.text("hash");
            }
            if (g2 === EX && b.previousGroup === PL && g1 === PL) {
              v1 = text(a, "hash", EX);
            }
            if ((v1 === v2 || ONN) && !(g1 === PL && (g2 === S || g2 === P || g2 === FN)) && !(g1 === PL && g2 === CB)) {
              var p1 = a.power, p2 = b.power, isSymbolP1 = isSymbol(p1), isSymbolP2 = isSymbol(p2), toEX = isSymbolP1 || isSymbolP2;
              if (g1 === PL && g2 !== PL && b.previousGroup !== PL && p1.equals(1)) {
                result = new Symbol2(0);
                a.each(function(x2) {
                  result = _2.add(result, _2.multiply(x2, b.clone()));
                }, true);
              } else {
                result.power = toEX ? _2.add(
                  !isSymbol(p1) ? new Symbol2(p1) : p1,
                  !isSymbol(p2) ? new Symbol2(p2) : p2
                ) : g1 === N ? p1 : p1.add(p2);
                if (result.power.equals(0))
                  result = result.convert(N);
                if (toEX)
                  result.convert(EX);
                if (a.imaginary && b.imaginary) {
                  var isEven = even(result.power % 2);
                  if (isEven) {
                    result = new Symbol2(1);
                    m.negate();
                  }
                }
                if (result.group !== EX && result.previousGroup)
                  result.previousGroup = void 0;
                result.multiplier = result.multiplier.multiply(b.multiplier);
              }
            } else if (g1 === CB && a.isLinear()) {
              if (g2 === CB)
                b.distributeExponent();
              if (g2 === CB && b.isLinear()) {
                for (var s in b.symbols) {
                  var x = b.symbols[s];
                  result = result.combine(x);
                }
                result.multiplier = result.multiplier.multiply(b.multiplier);
              } else {
                result.combine(b);
              }
            } else {
              if (g1 !== N) {
                if (g1 === CB) {
                  result.distributeExponent();
                  result.combine(b);
                } else if (!b.isOne()) {
                  var bm = b.multiplier.clone();
                  b.toUnitMultiplier();
                  result = Symbol2.shell(CB).combine([result, b]);
                  result.multiplier = result.multiplier.multiply(bm);
                }
              } else {
                result = b.clone().toUnitMultiplier();
              }
            }
            if (result.group === P) {
              var logV = Math.log(result.value), n1 = Math.log(bnum) / logV, n22 = Math.log(bden) / logV, ndiv = m.num / bnum, ddiv = m.den / bden;
              if (n1 !== 0 && isInt(n1) && isInt(ndiv)) {
                result.power = result.power.add(new Frac(n1));
                m.num /= bnum;
              }
              if (n22 !== 0 && isInt(n22) && isInt(ddiv)) {
                result.power = result.power.subtract(new Frac(n22));
                m.den /= bden;
              }
            }
            if (result.length === 1) {
              var t = result.multiplier;
              result = firstObject(result.symbols);
              result.multiplier = result.multiplier.multiply(t);
            }
            var ps = result.power.toString();
            if (even(ps) && result.fname === SQRT) {
              sign2 = sign2 * result.sign();
              var p = result.power;
              result = result.args[0];
              result = _2.multiply(new Symbol2(m), _2.pow(result, new Symbol2(p.divide(new Frac(2)))));
              if (sign2 < 0)
                result.negate();
            } else {
              result.multiplier = result.multiplier.multiply(m).multiply(sign2);
              if (result.group === CP && result.isImaginary())
                result.distributeMultiplier();
            }
            if (result.group === P && isInt(result.power.toDecimal()))
              result = result.convert(N);
            return result;
          } else {
            if (bIsSymbol && !aIsSymbol) {
              t = a;
              a = b;
              b = t;
              t = bIsSymbol;
              bIsSymbol = aIsSymbol;
              aIsSymbol = t;
            }
            var isMatrixB = isMatrix(b), isMatrixA = isMatrix(a);
            if (aIsSymbol && isMatrixB) {
              var M = new Matrix();
              b.eachElement(function(e, i2, j) {
                M.set(i2, j, _2.multiply(a.clone(), e));
              });
              b = M;
            } else {
              if (isMatrixA && isMatrixB) {
                b = a.multiply(b);
              } else if (aIsSymbol && isVector(b)) {
                b.each(function(x2, i2) {
                  i2--;
                  b.elements[i2] = _2.multiply(a.clone(), b.elements[i2]);
                });
              } else {
                if (isVector(a) && isVector(b)) {
                  b.each(function(x2, i2) {
                    i2--;
                    b.elements[i2] = _2.multiply(a.elements[i2], b.elements[i2]);
                  });
                } else if (isVector(a) && isMatrix(b)) {
                  return this.multiply(b, a);
                } else if (isMatrix(a) && isVector(b)) {
                  if (b.elements.length === a.rows()) {
                    var M = new Matrix(), l = a.cols();
                    b.each(function(e, i2) {
                      var row = [];
                      for (var j = 0; j < l; j++) {
                        row.push(_2.multiply(a.elements[i2 - 1][j].clone(), e.clone()));
                      }
                      M.elements.push(row);
                    });
                    return M;
                  } else
                    err("Dimensions must match!");
                }
              }
            }
            return b;
          }
        };
        this.divide = function(a, b) {
          var aIsSymbol = isSymbol(a), bIsSymbol = isSymbol(b);
          if (aIsSymbol && bIsSymbol) {
            if (a.unit || b.unit) {
              return _2.Unit.divide(a, b);
            }
            var result;
            if (b.equals(0))
              throw new DivisionByZero("Division by zero not allowed!");
            if (a.isConstant() && b.isConstant()) {
              result = a.clone();
              result.multiplier = result.multiplier.divide(b.multiplier);
            } else {
              b.invert();
              result = _2.multiply(a, b);
            }
            return result;
          } else {
            var isVectorA = isVector(a), isVectorB = isVector(b);
            if (aIsSymbol && isVectorB) {
              b = b.map(function(x) {
                return _2.divide(a.clone(), x);
              });
            } else if (isVectorA && bIsSymbol) {
              b = a.map(function(x) {
                return _2.divide(x, b.clone());
              });
            } else if (isVectorA && isVectorB) {
              if (a.dimensions() === b.dimensions()) {
                b = b.map(function(x, i) {
                  return _2.divide(a.elements[--i], x);
                });
              } else
                _2.error("Cannot divide vectors. Dimensions do not match!");
            } else {
              var isMatrixA = isMatrix(a), isMatrixB = isMatrix(b);
              if (isMatrixA && bIsSymbol) {
                var M = new Matrix();
                a.eachElement(function(x, i, j) {
                  M.set(i, j, _2.divide(x, b.clone()));
                });
                b = M;
              } else if (aIsSymbol && isMatrixB) {
                var M = new Matrix();
                b.eachElement(function(x, i, j) {
                  M.set(i, j, _2.divide(a.clone(), x));
                });
                b = M;
              } else if (isMatrixA && isMatrixB) {
                var M = new Matrix();
                if (a.rows() === b.rows() && a.cols() === b.cols()) {
                  a.eachElement(function(x, i, j) {
                    M.set(i, j, _2.divide(x, b.elements[i][j]));
                  });
                  b = M;
                } else {
                  _2.error("Dimensions do not match!");
                }
              } else if (isMatrixA && isVectorB) {
                if (a.cols() === b.dimensions()) {
                  var M = new Matrix();
                  a.eachElement(function(x, i, j) {
                    M.set(i, j, _2.divide(x, b.elements[i].clone()));
                  });
                  b = M;
                } else {
                  _2.error("Unable to divide matrix by vector.");
                }
              }
            }
            return b;
          }
        };
        this.pow = function(a, b) {
          var aIsSymbol = isSymbol(a), bIsSymbol = isSymbol(b);
          if (aIsSymbol && bIsSymbol) {
            if (a.unit || b.unit) {
              return _2.Unit.pow(a, b);
            }
            if (a.group === FN && a.fname === ABS && even(b)) {
              var m = a.multiplier.clone();
              var raised = _2.pow(a.args[0], b);
              raised.multiplier = m;
              return raised;
            }
            if (a.isInfinity || b.isInfinity) {
              if (a.isInfinity && b.isInfinity)
                throw new UndefinedError("(" + a + ")^(" + b + ") is undefined!");
              if (a.isConstant() && b.isInfinity) {
                if (a.equals(0)) {
                  if (b.lessThan(0))
                    throw new UndefinedError("0^Infinity is undefined!");
                  return new Symbol2(0);
                }
                if (a.equals(1))
                  throw new UndefinedError("1^" + b.toString() + " is undefined!");
                if (b.lessThan(0))
                  return new Symbol2(0);
                if (!a.lessThan(0))
                  return Symbol2.infinity();
              }
              if (a.isInfinity && b.isConstant()) {
                if (b.equals(0))
                  throw new UndefinedError(a + "^0 is undefined!");
                if (b.lessThan(0))
                  return new Symbol2(0);
                return _2.multiply(Symbol2.infinity(), _2.pow(new Symbol2(a.sign()), b.clone()));
              }
            }
            var aIsZero = a.equals(0);
            var bIsZero = b.equals(0);
            if (aIsZero && bIsZero)
              throw new UndefinedError("0^0 is undefined!");
            if (aIsZero && b.isConstant() && b.multiplier.greaterThan(0))
              return new Symbol2(0);
            if (bIsZero)
              return new Symbol2(1);
            var bIsConstant = b.isConstant(), aIsConstant = a.isConstant(), bIsInt = b.isInteger(), m = a.multiplier, result = a.clone();
            if (aIsConstant && bIsConstant && a.equals(0) && b.lessThan(0))
              throw new UndefinedError("Division by zero is not allowed!");
            if (Settings.PARSE2NUMBER && aIsConstant && bIsConstant && a.sign() < 0 && evenFraction(b)) {
              var k, re, im;
              k = Math.PI * b;
              re = new Symbol2(Math.cos(k));
              im = _2.multiply(Symbol2.imaginary(), new Symbol2(Math.sin(k)));
              return _2.add(re, im);
            }
            if (Settings.PARSE2NUMBER && a.isImaginary() && bIsConstant && isInt(b) && !b.lessThan(0)) {
              var re, im, r, theta, nre, nim, phi;
              re = a.realpart();
              im = a.imagpart();
              if (re.isConstant("all") && im.isConstant("all")) {
                phi = Settings.USE_BIG ? Symbol2(bigDec.atan2(i.multiplier.toDecimal(), r.multiplier.toDecimal()).times(b.toString())) : Math.atan2(im, re) * b;
                theta = new Symbol2(phi);
                r = _2.pow(Symbol2.hyp(re, im), b);
                nre = _2.multiply(r.clone(), _2.trig.cos(theta.clone()));
                nim = _2.multiply(r, _2.trig.sin(theta));
                return _2.add(nre, _2.multiply(Symbol2.imaginary(), nim));
              }
            }
            result.toUnitMultiplier();
            if (result.group === FN && result.fname === SQRT && !bIsConstant) {
              var s = result.args[0];
              s.multiplyPower(new Symbol2(0.5));
              s.multiplier.multiply(result.multiplier);
              s.multiplyPower(b);
              result = s;
            } else {
              var sign2 = m.sign();
              if (evenFraction(b) && sign2 < 0) {
                result.negate();
                result = _2.symfunction(PARENTHESIS, [result]);
                result.negate();
              }
              result.multiplyPower(b);
            }
            if (aIsConstant && bIsConstant && Settings.PARSE2NUMBER) {
              var c;
              if (sign2 < 0) {
                a.negate();
                if (b.multiplier.den.equals(2))
                  c = new Symbol2(Settings.IMAGINARY);
                else if (isInt(b.multiplier)) {
                  if (even(b.multiplier))
                    c = new Symbol2(1);
                  else
                    c = new Symbol2(-1);
                } else if (!even(b.multiplier.den)) {
                  c = new Symbol2(Math.pow(sign2, b.multiplier.num));
                } else {
                  c = _2.pow(_2.symfunction(PARENTHESIS, [new Symbol2(sign2)]), b.clone());
                }
              }
              result = new Symbol2(Math.pow(a.multiplier.toDecimal(), b.multiplier.toDecimal()));
              if (c)
                result = _2.multiply(result, c);
            } else if (bIsInt && !m.equals(1)) {
              var abs_b = b.abs();
              if (abs_b.gt(Settings.MAX_EXP)) {
                if (b.sign() < 0)
                  return new Symbol2(0);
                return Symbol2.infinity();
              } else {
                var p = b.multiplier.toDecimal();
                var sgn = Math.sign(p);
                p = Math.abs(p);
                var multiplier = new Frac(1);
                multiplier.num = m.num.pow(p);
                multiplier.den = m.den.pow(p);
                if (sgn < 0)
                  multiplier.invert();
                result.multiplier = result.multiplier.multiply(multiplier);
              }
            } else {
              var sign2 = a.sign();
              if (b.isConstant() && a.isConstant() && !b.multiplier.den.equals(1) && sign2 < 0) {
                if (b.multiplier.den.equals(2)) {
                  var i = new Symbol2(Settings.IMAGINARY);
                  a.negate();
                  if (b.lessThan(0)) {
                    i.negate();
                    b.negate();
                  }
                  result = _2.multiply(_2.pow(a, b), i);
                } else {
                  var aa = a.clone();
                  aa.multiplier.negate();
                  result = _2.pow(_2.symfunction(PARENTHESIS, [new Symbol2(sign2)]), b.clone());
                  var _a = _2.pow(new Symbol2(aa.multiplier.num), b.clone());
                  var _b = _2.pow(new Symbol2(aa.multiplier.den), b.clone());
                  var r = _2.divide(_a, _b);
                  result = _2.multiply(result, r);
                }
              } else if (Settings.PARSE2NUMBER && b.isImaginary()) {
                var re = b.realpart();
                var im = b.imagpart();
                var aa = a.clone().toLinear();
                var a1 = _2.pow(aa.clone(), re);
                var log_a = log(aa.clone());
                var b1 = trig.cos(_2.multiply(im.clone(), log_a));
                var c1 = _2.multiply(trig.sin(_2.multiply(im, log(aa))), Symbol2.imaginary());
                result = _2.multiply(a1, _2.add(b1, c1));
                result = _2.expand(_2.parse(result));
              } else {
                var neg_num = a.group === N && sign2 < 0, num = testSQRT(new Symbol2(neg_num ? m.num : Math.abs(m.num)).setPower(b.clone())), den = testSQRT(new Symbol2(m.den).setPower(b.clone()).invert());
                if (a.imaginary) {
                  if (bIsInt) {
                    var s, p, n2;
                    s = Math.sign(b);
                    p = abs(b);
                    n2 = p % 4;
                    result = new Symbol2(even(n2) ? -1 : Settings.IMAGINARY);
                    if (n2 === 0 || s < 0 && n2 === 1 || s > 0 && n2 === 3) {
                      result.negate();
                    }
                  } else {
                    var nr = b.multiplier.multiply(Frac.quick(1, 2)), tn = Math.pow(-1, nr.num);
                    result = even(nr.den) ? new Symbol2(-1).setPower(nr, true) : new Symbol2(tn);
                  }
                }
                if (sign2 < 0 && !neg_num)
                  result.negate();
                if (bIsConstant && a.group !== EX) {
                  var evenr = even(b.multiplier.den), evenp = even(a.power), n2 = result.power.toDecimal(), evennp = even(n2);
                  if (evenr && evenp && !evennp) {
                    if (n2 === 1)
                      result = _2.symfunction(ABS, [result]);
                    else if (!isInt(n2)) {
                      var p = result.power;
                      result = _2.symfunction(ABS, [result.toLinear()]).setPower(p);
                    } else {
                      result = _2.multiply(
                        _2.symfunction(ABS, [result.clone().toLinear()]),
                        result.clone().setPower(new Frac(n2 - 1))
                      );
                    }
                    if (Settings.POSITIVE_MULTIPLIERS && result.fname === ABS)
                      result = result.args[0];
                  }
                }
                if (b.equals(2) && result.group === CB) {
                  var _result = new Symbol2(1);
                  result.each(function(sym) {
                    _result = _2.multiply(_result, _2.pow(sym, b));
                  });
                  result = _result;
                }
              }
            }
            result = testSQRT(result);
            if (num && den) {
              result = _2.multiply(result, testPow(_2.multiply(num, den)));
            }
            if (result.fname === SQRT) {
              var isEX = result.group === EX;
              var t = isEX ? result.power.multiplier.toString() : result.power.toString();
              if (even(t)) {
                var pt = isEX ? _2.divide(result.power, new Symbol2(2)) : new Symbol2(result.power.divide(new Frac(2))), m = result.multiplier;
                result = _2.pow(result.args[0], pt);
                result.multiplier = result.multiplier.multiply(m);
              }
            } else if (!Settings.IGNORE_E && result.isE() && result.group === EX && result.power.contains("pi") && result.power.contains(Settings.IMAGINARY) && b.group === CB) {
              var theta = b.stripVar(Settings.IMAGINARY);
              result = _2.add(trig.cos(theta), _2.multiply(Symbol2.imaginary(), trig.sin(theta)));
            }
            return result;
          } else {
            if (isVector(a) && bIsSymbol) {
              a = a.map(function(x) {
                return _2.pow(x, b.clone());
              });
            } else if (isMatrix(a) && bIsSymbol) {
              var M = new Matrix();
              a.eachElement(function(x, i2, j) {
                M.set(i2, j, _2.pow(x, b.clone()));
              });
              a = M;
            } else if (aIsSymbol && isMatrix(b)) {
              var M = new Matrix();
              b.eachElement(function(x, i2, j) {
                M.set(i2, j, _2.pow(a.clone(), x));
              });
              a = M;
            }
            return a;
          }
        };
        this.comma = function(a, b) {
          if (!(a instanceof Collection))
            a = Collection.create(a);
          a.append(b);
          return a;
        };
        this.mod = function(a, b) {
          return mod(a, b);
        };
        this.slice = function(a, b) {
          return new Slice(a, b);
        };
        this.equals = function(a, b) {
          if (a.group !== S && !a.isLinear())
            err("Cannot set equality for " + a.toString());
          VARS[a.value] = b.clone();
          return b;
        };
        this.percent = function(a) {
          return _2.divide(a, new Symbol2(100));
        };
        this.assign = function(a, b) {
          if (a instanceof Collection && b instanceof Collection) {
            a.elements.map(function(x, i) {
              return _2.assign(x, b.elements[i]);
            });
            return Vector.fromArray(b.elements);
          }
          if (a.parent) {
            var e = a.parent;
            e.elements[e.getter] = b;
            delete e.getter;
            return e;
          }
          if (a.group !== S)
            throw new NerdamerValueError("Cannot complete operation. Incorrect LH value for " + a);
          VARS[a.value] = b;
          return b;
        };
        this.function_assign = function(a, b) {
          var f = a.elements.pop();
          return setFunction(f, a.elements, b);
        };
        var bool2Symbol = function(x) {
          return new Symbol2(x === true ? 1 : 0);
        };
        this.eq = function(a, b) {
          return bool2Symbol(a.equals(b));
        };
        this.gt = function(a, b) {
          return bool2Symbol(a.gt(b));
        };
        this.gte = function(a, b) {
          return bool2Symbol(a.gte(b));
        };
        this.lt = function(a, b) {
          return bool2Symbol(a.lt(b));
        };
        this.lte = function(a, b) {
          return bool2Symbol(a.lte(b));
        };
        this.factorial = function(a) {
          return this.symfunction(FACTORIAL, [a]);
        };
        this.dfactorial = function(a) {
          return this.symfunction(DOUBLEFACTORIAL, [a]);
        };
      }
      ;
      var Fraction = {
        /**
         * Converts a decimal to a fraction
         * @param {number} value
         * @param {object} opts
         * @returns {Array} - an array containing the denominator and the numerator
         */
        convert: function(value, opts) {
          var frac;
          if (value === 0) {
            frac = [0, 1];
          } else {
            if (value < 1e-6 || value > 1e20) {
              var qc = this.quickConversion(Number(value));
              if (qc[1] <= 1e20) {
                var abs = Math.abs(value);
                var sign = value / abs;
                frac = this.fullConversion(abs.toFixed((qc[1] + "").length - 1));
                frac[0] = frac[0] * sign;
              } else {
                frac = qc;
              }
            } else {
              frac = this.fullConversion(value);
            }
          }
          return frac;
        },
        /**
         * If the fraction is too small or too large this gets called instead of fullConversion method
         * @param {number} dec
         * @returns {Array} - an array containing the denominator and the numerator
         */
        quickConversion: function(value) {
          var stripSign = function(s) {
            if (typeof s !== "string") {
              s = s.toString();
            }
            var sign = "";
            var start = s.charAt(0);
            if (start === "-") {
              s = s.substr(1, s.length);
              sign = "-";
            } else if (start === "+") {
              s = s.substr(1, s.length);
            }
            return {
              sign,
              value: s
            };
          };
          function convert(value2) {
            if (Scientific.isScientific(value2)) {
              value2 = scientificToDecimal(value2);
            }
            var nparts = stripSign(value2);
            var cparts = nparts.value.split(".");
            var num;
            if (cparts.length === 1) {
              num = cparts[0];
            } else {
              num = cparts[0] + cparts[1];
            }
            var n2 = cparts[1] ? cparts[1].length : 0;
            var den = `1${"0".repeat(n2)}`;
            if (num !== "0") {
              num = num.replace(/^0+/, "");
            }
            return [nparts.sign + num, den];
          }
          return convert(value);
        },
        /**
         * Returns a good approximation of a fraction. This method gets called by convert
         * http://mathforum.org/library/drmath/view/61772.html
         * Decimal To Fraction Conversion - A Simpler Version
         * Dr Peterson
         * @param {number} dec
         * @returns {Array} - an array containing the denominator and the numerator
         */
        fullConversion: function(dec) {
          var done = false;
          var n1 = 0, d1 = 1, n2 = 1, d2 = 0, n3 = 0, q = dec, epsilon = 1e-16;
          while (!done) {
            n3++;
            if (n3 > 1e4) {
              done = true;
            }
            var a = Math.floor(q);
            var num = n1 + a * n2;
            var den = d1 + a * d2;
            var e = q - a;
            if (e < epsilon) {
              done = true;
            }
            q = 1 / e;
            n1 = n2;
            d1 = d2;
            n2 = num;
            d2 = den;
            if (Math.abs(num / den - dec) < epsilon || n3 > 30) {
              done = true;
            }
          }
          return [num, den];
        }
      };
      var LaTeX = {
        parser: (function() {
          var keep = ["classes", "setOperator", "getOperators", "getBrackets", "tokenize", "toRPN", "tree", "units"];
          var parser = new Parser();
          for (var x in parser) {
            if (keep.indexOf(x) === -1)
              delete parser[x];
          }
          parser.setOperator({
            precedence: 8,
            operator: "\\",
            action: "slash",
            prefix: true,
            postfix: false,
            leftAssoc: true,
            operation: function(e) {
              return e;
            }
          });
          parser.setOperator({
            precedence: 8,
            operator: "\\,",
            action: "slash_comma",
            prefix: true,
            postfix: false,
            leftAssoc: true,
            operation: function(e) {
              return e;
            }
          });
          var brackets = parser.getBrackets();
          brackets["{"].maps_to = void 0;
          return parser;
        })(),
        space: "~",
        dot: " \\cdot ",
        // grab a list of supported functions but remove the excluded ones found in exclFN
        latex: function(symbol, option) {
          if (symbol.clone) {
            symbol = symbol.clone();
          }
          if (symbol instanceof _.classes.Collection)
            symbol = symbol.elements;
          if (isArray(symbol)) {
            var LaTeXArray = [];
            for (var i = 0; i < symbol.length; i++) {
              var sym = symbol[i];
              if (!isSymbol(sym))
                sym = _.parse(sym);
              LaTeXArray.push(this.latex(sym, option));
            }
            return this.brackets(LaTeXArray.join(", "), "square");
          } else if (isMatrix(symbol)) {
            var TeX = "\\begin{pmatrix}\n";
            for (var i = 0; i < symbol.elements.length; i++) {
              var rowTeX = [], e = symbol.elements[i];
              for (var j = 0; j < e.length; j++) {
                rowTeX.push(this.latex(e[j], option));
              }
              TeX += rowTeX.join(" & ");
              if (i < symbol.elements.length - 1) {
                TeX += "\\\\\n";
              }
            }
            TeX += "\\end{pmatrix}";
            return TeX;
          } else if (isVector(symbol)) {
            var TeX = "\\left[";
            for (var i = 0; i < symbol.elements.length; i++) {
              TeX += this.latex(symbol.elements[i], option) + " " + (i !== symbol.elements.length - 1 ? ",\\," : "");
            }
            TeX += "\\right]";
            return TeX;
          } else if (isSet(symbol)) {
            var TeX = "\\{";
            for (var i = 0; i < symbol.elements.length; i++) {
              TeX += this.latex(symbol.elements[i], option) + " " + (i !== symbol.elements.length - 1 ? ",\\," : "");
            }
            TeX += "\\}";
            return TeX;
          }
          symbol = symbol.clone();
          var decimal = option === "decimal" || option === "decimals", power = symbol.power, invert = isNegative(power), negative = symbol.multiplier.lessThan(0);
          if (symbol.group === P && decimal) {
            return String(symbol.multiplier.toDecimal() * Math.pow(symbol.value, symbol.power.toDecimal()));
          } else {
            symbol.multiplier = symbol.multiplier.abs();
            var m_array;
            if (decimal) {
              var m = String(symbol.multiplier.toDecimal());
              m_array = [m, ""];
            } else {
              m_array = [symbol.multiplier.num, symbol.multiplier.den];
            }
            var v_array = this.value(symbol, invert, option, negative), p;
            if (invert)
              power.negate();
            if (decimal) {
              p = isSymbol(power) ? LaTeX.latex(power, option) : String(power.toDecimal());
              if (String(p) === "1")
                p = "";
            } else if (isSymbol(power))
              p = this.latex(power, option);
            else
              p = this.formatFrac(power, true);
            var p_array = ["", ""], index = invert ? 1 : 0;
            p_array[index] = p;
            var retval = (negative ? "-" : "") + this.set(m_array, v_array, p_array, symbol.group === CB);
            return retval.replace(/\+\-/gi, "-");
          }
        },
        // greek mapping
        greek: {
          alpha: "\\alpha",
          beta: "\\beta",
          gamma: "\\gamma",
          delta: "\\delta",
          epsilon: "\\epsilon",
          zeta: "\\zeta",
          eta: "\\eta",
          theta: "\\theta",
          iota: "\\iota",
          kappa: "\\kappa",
          lambda: "\\lambda",
          mu: "\\mu",
          nu: "\\nu",
          xi: "\\xi",
          omnikron: "\\omnikron",
          pi: "\\pi",
          rho: "\\rho",
          sigma: "\\sigma",
          tau: "\\tau",
          upsilon: "\\upsilon",
          phi: "\\phi",
          chi: "\\chi",
          psi: "\\psi",
          omega: "\\omega",
          Gamma: "\\Gamma",
          Delta: "\\Delta",
          Epsilon: "\\Epsilon",
          Theta: "\\Theta",
          Lambda: "\\Lambda",
          Xi: "\\Xi",
          Pi: "\\Pi",
          Sigma: "\\Sigma",
          Phi: "\\Phi",
          Psi: "\\Psi",
          Omega: "\\Omega"
        },
        symbols: {
          arccos: "\\arccos",
          cos: "\\cos",
          csc: "\\csc",
          exp: "\\exp",
          ker: "\\ker",
          limsup: "\\limsup",
          min: "\\min",
          sinh: "\\sinh",
          arcsin: "\\arcsin",
          cosh: "\\cosh",
          deg: "\\deg",
          gcd: "\\gcd",
          lg: "\\lg",
          ln: "\\ln",
          Pr: "\\Pr",
          sqrt: "\\sqrt",
          sup: "\\sup",
          arctan: "\\arctan",
          cot: "\\cot",
          det: "\\det",
          hom: "\\hom",
          lim: "\\lim",
          log: "\\log",
          LN: "\\LN",
          sec: "\\sec",
          tan: "\\tan",
          arg: "\\arg",
          coth: "\\coth",
          dim: "\\dim",
          inf: "\\inf",
          liminf: "\\liminf",
          max: "\\max",
          sin: "\\sin",
          tanh: "\\tanh"
        },
        // get the raw value of the symbol as an array
        value: function(symbol, inverted, option, negative) {
          var group = symbol.group, previousGroup = symbol.previousGroup, v = ["", ""], index = inverted ? 1 : 0;
          if (symbol.isInfinity) {
            v[index] = "\\infty";
          } else if (group === S || group === P || previousGroup === S || previousGroup === P || previousGroup === N) {
            var value = this.formatSubscripts(symbol.value);
            if (value.replace)
              value = value.replace(/(.+)_$/, "$1\\_");
            var t_varray = String(value).split("_");
            var greek = this.greek[t_varray[0]];
            if (greek) {
              t_varray[0] = greek;
              value = t_varray.join("_");
            }
            var symbol = this.symbols[t_varray[0]];
            if (symbol) {
              t_varray[0] = symbol;
              value = t_varray.join("_");
            }
            v[index] = value;
          } else if (group === FN || previousGroup === FN) {
            var name, input = [], fname = symbol.fname;
            for (var i = 0; i < symbol.args.length; i++) {
              var arg = symbol.args[i], item;
              if (typeof arg === "string")
                item = arg;
              else {
                item = this.latex(arg, option);
              }
              input.push(item);
            }
            if (fname === SQRT) {
              v[index] = "\\sqrt" + this.braces(input.join(","));
            } else if (fname === ABS) {
              v[index] = this.brackets(input.join(","), "abs");
            } else if (fname === PARENTHESIS) {
              v[index] = this.brackets(input.join(","), "parens");
            } else if (fname === "limit") {
              v[index] = " \\lim\\limits_{" + input[1] + " \\to " + input[2] + "} " + input[0];
            } else if (fname === "integrate") {
              v[index] = "\\int" + this.braces(input[0]) + this.braces("d" + input[1]);
            } else if (fname === "defint") {
              v[index] = "\\int\\limits_" + this.braces(input[1]) + "^" + this.braces(input[2]) + " " + input[0] + " d" + input[3];
            } else if (fname === FACTORIAL || fname === DOUBLEFACTORIAL) {
              var arg = symbol.args[0];
              if (arg.power.equals(1) && (arg.isComposite() || arg.isCombination())) {
                input[0] = this.brackets(input[0]);
              }
              v[index] = input[0] + (fname === FACTORIAL ? "!" : "!!");
            } else if (fname === "floor") {
              v[index] = "\\left \\lfloor" + this.braces(input[0]) + "\\right \\rfloor";
            } else if (fname === "ceil") {
              v[index] = "\\left \\lceil" + this.braces(input[0]) + "\\right \\rceil";
            } else if (fname === Settings.LOG && input.length > 1) {
              v[index] = "\\mathrm" + this.braces(Settings.LOG) + "_" + this.braces(input[1]) + this.brackets(input[0]);
            } else if (fname === Settings.LOG10) {
              v[index] = "\\mathrm" + this.braces(Settings.LOG) + "_" + this.braces(10) + this.brackets(input[0]);
            } else if (fname === "sum") {
              var a = input[0], b = input[1], c = input[2], d = input[3];
              v[index] = "\\sum\\limits_{" + this.braces(b) + "=" + this.braces(c) + "}^" + this.braces(d) + " " + this.braces(a);
            } else if (fname === "product") {
              var a = input[0], b = input[1], c = input[2], d = input[3];
              v[index] = "\\prod\\limits_{" + this.braces(b) + "=" + this.braces(c) + "}^" + this.braces(d) + " " + this.braces(a);
            } else if (fname === "nthroot") {
              v[index] = "\\sqrt[" + input[1] + "]" + this.braces(input[0]);
            } else if (fname === "mod") {
              v[index] = input[0] + " \\bmod " + input[1];
            } else if (fname === "realpart") {
              v[index] = "\\operatorname{Re}" + this.brackets(input[0]);
            } else if (fname === "imagpart") {
              v[index] = "\\operatorname{Im}" + this.brackets(input[0]);
            } else {
              var name = fname !== "" ? "\\mathrm" + this.braces(fname.replace(/_/g, "\\_")) : "";
              if (symbol.isConversion)
                v[index] = name + this.brackets(input.join(""), "parens");
              else
                v[index] = name + this.brackets(input.join(","), "parens");
            }
          } else if (symbol.isComposite()) {
            var collected = symbol.collectSymbols().sort(
              group === CP || previousGroup === CP ? function(a2, b2) {
                return b2.group - a2.group;
              } : function(a2, b2) {
                var x = isSymbol(a2.power) ? -1 : a2.power;
                var y = isSymbol(b2.power) ? -1 : b2.power;
                return y - x;
              }
            ), symbols = [], l = collected.length;
            for (var i = 0; i < l; i++) {
              symbols.push(LaTeX.latex(collected[i], option));
            }
            var value = symbols.join("+");
            v[index] = !(symbol.isLinear() && symbol.multiplier.equals(1)) || negative ? this.brackets(value, "parens") : value;
          } else if (group === CB || previousGroup === EX || previousGroup === CB) {
            if (group === CB)
              symbol.distributeExponent();
            var denominator = [], numerator = [];
            var den_map = [], num_map = [], num_c = 0, den_c = 0;
            var setBrackets = function(container, map, counter) {
              if (counter > 1 && map.length > 0) {
                var l2 = map.length;
                for (var i2 = 0; i2 < l2; i2++) {
                  var idx = map[i2], item2 = container[idx];
                  if (!(/^\\left\(.+\\right\)\^\{.+\}$/g.test(item2) || /^\\left\(.+\\right\)$/g.test(item2))) {
                    container[idx] = LaTeX.brackets(item2, "parens");
                  }
                }
              }
              return container;
            };
            symbol.each(function(x) {
              var isDenom = isNegative(x.power), laTex;
              if (isDenom) {
                laTex = LaTeX.latex(x.invert(), option);
                den_c++;
                if (x.isComposite()) {
                  if (symbol.multiplier.den != 1 && Math.abs(x.power) == 1)
                    laTex = LaTeX.brackets(laTex, "parens");
                  den_map.push(denominator.length);
                }
                denominator.push(laTex);
              } else {
                laTex = LaTeX.latex(x, option);
                num_c++;
                if (x.isComposite()) {
                  if (symbol.multiplier.num != 1 && Math.abs(x.power) == 1)
                    laTex = LaTeX.brackets(laTex, "parens");
                  num_map.push(numerator.length);
                }
                numerator.push(laTex);
              }
            });
            setBrackets(numerator, num_map, num_c);
            v[0] = numerator.join(this.dot);
            setBrackets(denominator, den_map, den_c);
            v[1] = denominator.join(this.dot);
          }
          return v;
        },
        set: function(m, v, p, combine_power) {
          var isBracketed = function(v2) {
            return /^\\left\(.+\\right\)$/.test(v2);
          };
          if (p)
            p = this.formatP(p);
          if (combine_power) {
            var tp = p[0];
            p[0] = "";
          }
          v = this.merge(v, p);
          var mn = m[0], md = m[1], vn = v[0], vd = v[1];
          if (vn && Number(mn) === 1)
            mn = "";
          if (Number(md) === 1)
            md = "";
          var top = this.join(mn, vn, !isBracketed(vn) ? this.dot : "");
          var bottom = this.join(md, vd, !isBracketed(vd) ? this.dot : "");
          if (top && bottom) {
            var frac = this.frac(top, bottom);
            if (combine_power && tp)
              frac = this.brackets(frac) + tp;
            return frac;
          } else
            return top;
        },
        merge: function(a, b) {
          var r = [];
          for (var i = 0; i < 2; i++)
            r[i] = a[i] + b[i];
          return r;
        },
        // joins together two strings if both exist
        join: function(n2, d, glue) {
          if (!n2 && !d)
            return "";
          if (n2 && !d)
            return n2;
          if (d && !n2)
            return d;
          return n2 + glue + d;
        },
        /**
         * Places subscripts in braces for proper formatting
         * @param {String} v
         * @returns {String}
         */
        formatSubscripts: function(v) {
          var arr = v.toString().split("_");
          var name = "";
          while (arr.length > 1) {
            if (arr.length > 0) {
              name = "_" + this.braces(arr.pop() + name);
            }
          }
          return arr[0] + name;
        },
        formatP: function(p_array) {
          for (var i = 0; i < 2; i++) {
            var p = p_array[i];
            if (p)
              p_array[i] = "^" + this.braces(p);
          }
          return p_array;
        },
        /**
         * formats the fractions accordingly.
         * @param {Frac} f
         * @param {bool} is_pow
         */
        formatFrac: function(f, is_pow) {
          var n2 = f.num.toString(), d = f.den.toString();
          if (is_pow && n2 === "1" && d === "1")
            return "";
          if (d === "1")
            return n2;
          return this.frac(n2, d);
        },
        frac: function(n2, d) {
          return "\\frac" + this.braces(n2) + this.braces(d);
        },
        braces: function(e) {
          return "{" + e + "}";
        },
        brackets: function(e, typ) {
          typ = typ || "parens";
          var bracketTypes = {
            parens: ["(", ")"],
            square: ["[", "]"],
            brace: ["{", "}"],
            abs: ["|", "|"],
            angle: ["\\langle", "\\rangle"]
          };
          var bracket = bracketTypes[typ];
          return "\\left" + bracket[0] + e + "\\right" + bracket[1];
        },
        /**
         * Removes extreneous tokens
         * @param {Tokens[]} tokens
         * @returns {Tokens[]}
         */
        filterTokens: function(tokens) {
          var filtered = [];
          if (isArray(tokens)) {
            filtered.type = tokens.type;
          }
          var d = ["\\", "left", "right", "big", "Big", "large", "Large"];
          for (var i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            var next_token = tokens[i + 1];
            if (token.value === "\\" && next_token.value === "\\") {
              filtered.push(token);
            } else if (isArray(token)) {
              filtered.push(LaTeX.filterTokens(token));
            } else if (d.indexOf(token.value) === -1) {
              filtered.push(token);
            }
          }
          return filtered;
        },
        /*
         * Parses tokens from LaTeX string. Does not do any error checking
         * @param {Tokens[]} rpn
         * @returns {String}
         */
        parse: function(raw_tokens) {
          var i, l;
          var retval = "";
          var tokens = this.filterTokens(raw_tokens);
          var replace = {
            "cdot": "",
            "times": "",
            "infty": "Infinity"
          };
          var next = function(n3) {
            return tokens[typeof n3 === "undefined" ? ++i : i += n3];
          };
          var parse_next = function() {
            return LaTeX.parse(next());
          };
          var get = function(token2) {
            if (token2 in replace) {
              return replace[token2];
            }
            if (token2 === "*" && tokens[i + 1].value === "&") {
              next(2);
              return ",";
            }
            if (token2 === "&") {
              next();
              return ",";
            }
            if (token2 === "\\") {
              return "],[";
            }
            return token2;
          };
          for (i = 0, l = tokens.length; i < l; i++) {
            var token = tokens[i];
            if (token.value === "frac") {
              var n2 = parse_next();
              var d = parse_next();
              retval += n2 + "/" + d;
            } else if (token.value in LaTeX.symbols) {
              if (token.value === SQRT && tokens[i + 1].type === "vector" && tokens[i + 2].type === "Set") {
                var base = parse_next();
                var expr = parse_next();
                retval += expr + "^" + inBrackets("1/" + base);
              } else {
                retval += token.value + parse_next();
              }
            } else if (token.value === "int") {
              var f = parse_next();
              i++;
              var dx = next().value;
              dx = get(dx.substring(1, dx.length));
              retval += "integrate" + inBrackets(f + "," + dx);
            } else if (token.value === "int_") {
              var l = parse_next();
              i++;
              var u = next().value;
              if (u === void 0) {
                i--;
                var u = parse_next();
              }
              var f = parse_next();
              var dx = next().value;
              if (dx === ",") {
                var dx = next().value;
              }
              if (dx === "differentialD") {
                i++;
                var dx = next().value;
              }
              if (dx === "mathrm") {
                i++;
                var dx = next().value;
              }
              retval += "defint" + inBrackets(f + "," + l + "," + u + "," + dx);
            } else if (token.value && token.value.startsWith("int_")) {
              var l = token.value.replace("int_", "");
              console.log("uppernow");
              i++;
              var u = next().value;
              if (u === void 0) {
                i--;
                var u = parse_next();
              }
              var f = parse_next();
              var dx = next().value;
              if (dx === ",") {
                var dx = next().value;
              }
              if (dx === "differentialD") {
                i++;
                var dx = next().value;
              }
              if (dx === "mathrm") {
                i++;
                var dx = next().value;
              }
              retval += "defint" + inBrackets(f + "," + l + "," + u + "," + dx);
            } else if (token.value === "mathrm") {
              var f = tokens[++i][0].value;
              retval += f + parse_next();
            } else if (token.value === "sum_" || token.value === "prod_") {
              var fn = token.value === "sum_" ? "sum" : "product";
              var nxt = next();
              i++;
              var end = parse_next();
              var f = parse_next();
              retval += fn + inBrackets([f, get(nxt[0]), get(nxt[2]), get(end)].join(","));
            } else if (token.value === "lim_") {
              var nxt = next();
              retval += "limit" + inBrackets([parse_next(), get(nxt[0]), get(nxt[2])].join(","));
            } else if (token.value === "begin") {
              var nxt = next();
              if (Array.isArray(nxt)) {
                var v = nxt[0].value;
                if (v === "matrix") {
                  retval += "matrix([";
                }
              }
            } else if (token.value === "end") {
              var nxt = next();
              if (Array.isArray(nxt)) {
                var v = nxt[0].value;
                if (v === "matrix") {
                  retval += "])";
                }
              }
            } else {
              if (Array.isArray(token)) {
                retval += get(LaTeX.parse(token));
              } else {
                retval += get(token.value.toString());
              }
            }
          }
          return inBrackets(retval);
        }
      };
      function Vector(v) {
        if (isVector(v))
          this.elements = v.items.slice(0);
        else if (isArray(v))
          this.elements = v.slice(0);
        else
          this.elements = [].slice.call(arguments);
      }
      Vector.arrayPrefill = function(n2, val) {
        var a = [];
        val = val || 0;
        for (var i = 0; i < n2; i++)
          a[i] = val;
        return a;
      };
      Vector.fromArray = function(a) {
        var v = new Vector();
        v.elements = a;
        return v;
      };
      Vector.fromSet = function(set) {
        return Vector.fromArray(set.elements);
      };
      Vector.prototype = {
        custom: true,
        // Returns element i of the vector
        e: function(i) {
          return i < 1 || i > this.elements.length ? null : this.elements[i - 1];
        },
        set: function(i, val) {
          if (!isSymbol(val))
            val = new Symbol2(val);
          this.elements[i] = val;
        },
        // Returns the number of elements the vector has
        dimensions: function() {
          return this.elements.length;
        },
        // Returns the modulus ('length') of the vector
        modulus: function() {
          return block("SAFE", function() {
            return _.pow(this.dot(this.clone()), new Symbol2(0.5));
          }, void 0, this);
        },
        // Returns true iff the vector is equal to the argument
        eql: function(vector) {
          var n2 = this.elements.length;
          var V = vector.elements || vector;
          if (n2 !== V.length) {
            return false;
          }
          do {
            if (Math.abs(_.subtract(this.elements[n2 - 1], V[n2 - 1]).valueOf()) > PRECISION) {
              return false;
            }
          } while (--n2);
          return true;
        },
        // Returns a clone of the vector
        clone: function() {
          var V = new Vector(), l = this.elements.length;
          for (var i = 0; i < l; i++) {
            V.elements.push(this.elements[i].clone());
          }
          if (this.getter) {
            V.getter = this.getter.clone();
          }
          return V;
        },
        // Maps the vector to another vector according to the given function
        map: function(fn) {
          var elements = [];
          this.each(function(x, i) {
            elements.push(fn(x, i));
          });
          return new Vector(elements);
        },
        // Calls the iterator for each element of the vector in turn
        each: function(fn) {
          var n2 = this.elements.length, k = n2, i;
          do {
            i = k - n2;
            fn(this.elements[i], i + 1);
          } while (--n2);
        },
        // Returns a new vector created by normalizing the receiver
        toUnitVector: function() {
          return block("SAFE", function() {
            var r = this.modulus();
            if (r.valueOf() === 0) {
              return this.clone();
            }
            return this.map(function(x) {
              return _.divide(x, r);
            });
          }, void 0, this);
        },
        // Returns the angle between the vector and the argument (also a vector)
        angleFrom: function(vector) {
          return block("SAFE", function() {
            var V = vector.elements || vector;
            var n2 = this.elements.length;
            if (n2 !== V.length) {
              return null;
            }
            var dot = new Symbol2(0), mod1 = new Symbol2(0), mod2 = new Symbol2(0);
            this.each(function(x, i) {
              dot = _.add(dot, _.multiply(x, V[i - 1]));
              mod1 = _.add(mod1, _.multiply(x, x));
              mod2 = _.add(mod2, _.multiply(V[i - 1], V[i - 1]));
            });
            mod1 = _.pow(mod1, new Symbol2(0.5));
            mod2 = _.pow(mod2, new Symbol2(0.5));
            var product = _.multiply(mod1, mod2);
            if (product.valueOf() === 0) {
              return null;
            }
            var theta = _.divide(dot, product);
            var theta_val = theta.valueOf();
            if (theta_val < -1) {
              theta = -1;
            }
            if (theta_val > 1) {
              theta = 1;
            }
            return new Symbol2(Math.acos(theta));
          }, void 0, this);
        },
        // Returns true iff the vector is parallel to the argument
        isParallelTo: function(vector) {
          var angle = this.angleFrom(vector).valueOf();
          return angle === null ? null : angle <= PRECISION;
        },
        // Returns true iff the vector is antiparallel to the argument
        isAntiparallelTo: function(vector) {
          var angle = this.angleFrom(vector).valueOf();
          return angle === null ? null : Math.abs(angle - Math.PI) <= PRECISION;
        },
        // Returns true iff the vector is perpendicular to the argument
        isPerpendicularTo: function(vector) {
          var dot = this.dot(vector);
          return dot === null ? null : Math.abs(dot) <= PRECISION;
        },
        // Returns the result of adding the argument to the vector
        add: function(vector) {
          return block("SAFE", function() {
            var V = vector.elements || vector;
            if (this.elements.length !== V.length) {
              return null;
            }
            return this.map(function(x, i) {
              return _.add(x, V[i - 1]);
            });
          }, void 0, this);
        },
        // Returns the result of subtracting the argument from the vector
        subtract: function(vector) {
          return block("SAFE", function() {
            var V = vector.elements || vector;
            if (this.elements.length !== V.length) {
              return null;
            }
            return this.map(function(x, i) {
              return _.subtract(x, V[i - 1]);
            });
          }, void 0, this);
        },
        // Returns the result of multiplying the elements of the vector by the argument
        multiply: function(k) {
          return this.map(function(x) {
            return x.clone() * k.clone();
          });
        },
        x: function(k) {
          return this.multiply(k);
        },
        // Returns the scalar product of the vector with the argument
        // Both vectors must have equal dimensionality
        dot: function(vector) {
          return block("SAFE", function() {
            var V = vector.elements || vector;
            var product = new Symbol2(0), n2 = this.elements.length;
            if (n2 !== V.length) {
              return null;
            }
            do {
              product = _.add(product, _.multiply(this.elements[n2 - 1], V[n2 - 1]));
            } while (--n2);
            return product;
          }, void 0, this);
        },
        // Returns the vector product of the vector with the argument
        // Both vectors must have dimensionality 3
        cross: function(vector) {
          var B = vector.elements || vector;
          if (this.elements.length !== 3 || B.length !== 3) {
            return null;
          }
          var A = this.elements;
          return block("SAFE", function() {
            return new Vector([
              _.subtract(_.multiply(A[1], B[2]), _.multiply(A[2], B[1])),
              _.subtract(_.multiply(A[2], B[0]), _.multiply(A[0], B[2])),
              _.subtract(_.multiply(A[0], B[1]), _.multiply(A[1], B[0]))
            ]);
          }, void 0, this);
        },
        // Returns the (absolute) largest element of the vector
        max: function() {
          var m = 0, n2 = this.elements.length, k = n2, i;
          do {
            i = k - n2;
            if (Math.abs(this.elements[i].valueOf()) > Math.abs(m.valueOf())) {
              m = this.elements[i];
            }
          } while (--n2);
          return m;
        },
        magnitude: function() {
          var magnitude = new Symbol2(0);
          this.each(function(e) {
            magnitude = _.add(magnitude, _.pow(e, new Symbol2(2)));
          });
          return _.sqrt(magnitude);
        },
        // Returns the index of the first match found
        indexOf: function(x) {
          var index = null, n2 = this.elements.length, k = n2, i;
          do {
            i = k - n2;
            if (index === null && this.elements[i].valueOf() === x.valueOf()) {
              index = i + 1;
            }
          } while (--n2);
          return index;
        },
        text: function(x) {
          return text(this);
        },
        toString: function() {
          return this.text();
        },
        latex: function(option) {
          var tex = [];
          for (var i = 0; i < this.elements.length; i++) {
            tex.push(LaTeX.latex.call(LaTeX, this.elements[i], option));
          }
          return "[" + tex.join(", ") + "]";
        }
      };
      function Matrix() {
        var m = arguments, l = m.length, i, el = [];
        if (isMatrix(m)) {
          for (i = 0; i < l; i++) {
            el.push(m[i].slice(0));
          }
        } else {
          var row, lw, rl;
          for (i = 0; i < l; i++) {
            row = m[i];
            if (isVector(row))
              row = row.elements;
            if (!isArray(row))
              row = [row];
            rl = row.length;
            if (lw && lw !== rl)
              err("Unable to create Matrix. Row dimensions do not match!");
            el.push(row);
            lw = rl;
          }
        }
        this.elements = el;
      }
      Matrix.identity = function(n2) {
        var m = new Matrix();
        for (var i = 0; i < n2; i++) {
          m.elements.push([]);
          for (var j = 0; j < n2; j++) {
            m.set(i, j, i === j ? new Symbol2(1) : new Symbol2(0));
          }
        }
        return m;
      };
      Matrix.fromArray = function(arr) {
        function F(args) {
          return Matrix.apply(this, args);
        }
        F.prototype = Matrix.prototype;
        return new F(arr);
      };
      Matrix.zeroMatrix = function(rows, cols) {
        var m = new Matrix();
        for (var i = 0; i < rows; i++) {
          m.elements.push(Vector.arrayPrefill(cols, new Symbol2(0)));
        }
        return m;
      };
      Matrix.prototype = {
        // needs be true to let the parser know not to try to cast it to a symbol
        custom: true,
        get: function(row, column) {
          if (!this.elements[row])
            return void 0;
          return this.elements[row][column];
        },
        map: function(f, raw_values) {
          var M = new Matrix();
          this.each(function(e, i, j) {
            M.set(i, j, f.call(M, e), raw_values);
          });
          return M;
        },
        set: function(row, column, value, raw) {
          if (!this.elements[row])
            this.elements[row] = [];
          this.elements[row][column] = raw ? value : isSymbol(value) ? value : new Symbol2(value);
        },
        cols: function() {
          return this.elements[0].length;
        },
        rows: function() {
          return this.elements.length;
        },
        row: function(n2) {
          if (!n2 || n2 > this.cols())
            return [];
          return this.elements[n2 - 1];
        },
        col: function(n2) {
          var nr = this.rows(), col = [];
          if (n2 > this.cols() || !n2)
            return col;
          for (var i = 0; i < nr; i++) {
            col.push(this.elements[i][n2 - 1]);
          }
          return col;
        },
        eachElement: function(fn) {
          var nr = this.rows(), nc = this.cols(), i, j;
          for (i = 0; i < nr; i++) {
            for (j = 0; j < nc; j++) {
              fn.call(this, this.elements[i][j], i, j);
            }
          }
        },
        // ported from Sylvester.js
        determinant: function() {
          if (!this.isSquare()) {
            return null;
          }
          var M = this.toRightTriangular();
          var det = M.elements[0][0], n2 = M.elements.length - 1, k = n2, i;
          do {
            i = k - n2 + 1;
            det = _.multiply(det, M.elements[i][i]);
          } while (--n2);
          return det;
        },
        isSquare: function() {
          return this.elements.length === this.elements[0].length;
        },
        isSingular: function() {
          return this.isSquare() && this.determinant() === 0;
        },
        augment: function(m) {
          var r = this.rows(), rr = m.rows();
          if (r !== rr)
            err("Cannot augment matrix. Rows don't match.");
          for (var i = 0; i < r; i++) {
            this.elements[i] = this.elements[i].concat(m.elements[i]);
          }
          return this;
        },
        clone: function() {
          var r = this.rows(), c = this.cols(), m = new Matrix();
          for (var i = 0; i < r; i++) {
            m.elements[i] = [];
            for (var j = 0; j < c; j++) {
              var symbol = this.elements[i][j];
              m.elements[i][j] = isSymbol(symbol) ? symbol.clone() : symbol;
            }
          }
          return m;
        },
        // ported from Sylvester.js
        invert: function() {
          if (!this.isSquare())
            err("Matrix is not square!");
          return block("SAFE", function() {
            var ni = this.elements.length, ki = ni, i, j;
            var imatrix = Matrix.identity(ni);
            var M = this.augment(imatrix).toRightTriangular();
            var np, kp = M.elements[0].length, p, els, divisor;
            var inverse_elements = [], new_element;
            do {
              i = ni - 1;
              els = [];
              np = kp;
              inverse_elements[i] = [];
              divisor = M.elements[i][i];
              do {
                p = kp - np;
                new_element = _.divide(M.elements[i][p], divisor.clone());
                els.push(new_element);
                if (p >= ki) {
                  inverse_elements[i].push(new_element);
                }
              } while (--np);
              M.elements[i] = els;
              for (j = 0; j < i; j++) {
                els = [];
                np = kp;
                do {
                  p = kp - np;
                  els.push(_.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), M.elements[j][i].clone())));
                } while (--np);
                M.elements[j] = els;
              }
            } while (--ni);
            return Matrix.fromArray(inverse_elements);
          }, void 0, this);
        },
        // ported from Sylvester.js
        toRightTriangular: function() {
          return block("SAFE", function() {
            var M = this.clone(), els, fel, nel, n2 = this.elements.length, k = n2, i, np, kp = this.elements[0].length, p;
            do {
              i = k - n2;
              fel = M.elements[i][i];
              if (fel.valueOf() === 0) {
                for (var j = i + 1; j < k; j++) {
                  nel = M.elements[j][i];
                  if (nel && nel.valueOf() !== 0) {
                    els = [];
                    np = kp;
                    do {
                      p = kp - np;
                      els.push(_.add(M.elements[i][p].clone(), M.elements[j][p].clone()));
                    } while (--np);
                    M.elements[i] = els;
                    break;
                  }
                }
              }
              var fel = M.elements[i][i];
              if (fel.valueOf() !== 0) {
                for (j = i + 1; j < k; j++) {
                  var multiplier = _.divide(M.elements[j][i].clone(), M.elements[i][i].clone());
                  els = [];
                  np = kp;
                  do {
                    p = kp - np;
                    els.push(p <= i ? new Symbol2(0) : _.subtract(M.elements[j][p].clone(), _.multiply(M.elements[i][p].clone(), multiplier.clone())));
                  } while (--np);
                  M.elements[j] = els;
                }
              }
            } while (--n2);
            return M;
          }, void 0, this);
        },
        transpose: function() {
          var rows = this.elements.length, cols = this.elements[0].length;
          var M = new Matrix(), ni = cols, i, nj, j;
          do {
            i = cols - ni;
            M.elements[i] = [];
            nj = rows;
            do {
              j = rows - nj;
              M.elements[i][j] = this.elements[j][i].clone();
            } while (--nj);
          } while (--ni);
          return M;
        },
        // Returns true if the matrix can multiply the argument from the left
        canMultiplyFromLeft: function(matrix) {
          var l = isMatrix(matrix) ? matrix.elements.length : matrix.length;
          return this.elements[0].length === l;
        },
        sameSize: function(matrix) {
          return this.rows() === matrix.rows() && this.cols() === matrix.cols();
        },
        multiply: function(matrix) {
          return block("SAFE", function() {
            var M = matrix.elements || matrix;
            if (!this.canMultiplyFromLeft(M)) {
              if (this.sameSize(matrix)) {
                var MM = new Matrix();
                var rows = this.rows();
                for (var i = 0; i < rows; i++) {
                  var e = _.multiply(new Vector(this.elements[i]), new Vector(matrix.elements[i]));
                  MM.elements[i] = e.elements;
                }
                return MM;
              }
              return null;
            }
            var ni = this.elements.length, ki = ni, i, nj, kj = M[0].length, j;
            var cols = this.elements[0].length, elements = [], sum, nc, c;
            do {
              i = ki - ni;
              elements[i] = [];
              nj = kj;
              do {
                j = kj - nj;
                sum = new Symbol2(0);
                nc = cols;
                do {
                  c = cols - nc;
                  sum = _.add(sum, _.multiply(this.elements[i][c], M[c][j]));
                } while (--nc);
                elements[i][j] = sum;
              } while (--nj);
            } while (--ni);
            return Matrix.fromArray(elements);
          }, void 0, this);
        },
        add: function(matrix, callback) {
          var M = new Matrix();
          if (this.sameSize(matrix)) {
            this.eachElement(function(e, i, j) {
              var result = _.add(e.clone(), matrix.elements[i][j].clone());
              if (callback) {
                result = callback.call(M, result, e, matrix.elements[i][j]);
              }
              M.set(i, j, result);
            });
          }
          return M;
        },
        subtract: function(matrix, callback) {
          var M = new Matrix();
          if (this.sameSize(matrix)) {
            this.eachElement(function(e, i, j) {
              var result = _.subtract(e.clone(), matrix.elements[i][j].clone());
              if (callback) {
                result = callback.call(M, result, e, matrix.elements[i][j]);
              }
              M.set(i, j, result);
            });
          }
          return M;
        },
        negate: function() {
          this.each(function(e) {
            return e.negate();
          });
          return this;
        },
        toVector: function() {
          if (this.rows() === 1 || this.cols() === 1) {
            var v = new Vector();
            v.elements = this.elements;
            return v;
          }
          return this;
        },
        toString: function(newline, to_decimal) {
          var l = this.rows(), s = [];
          newline = newline === void 0 ? "\n" : newline;
          for (var i = 0; i < l; i++) {
            s.push("[" + this.elements[i].map(function(x) {
              var v = to_decimal ? x.multiplier.toDecimal() : x.toString();
              return x !== void 0 ? v : "";
            }).join(",") + "]");
          }
          return "matrix" + inBrackets(s.join(","));
        },
        text: function() {
          return "matrix(" + this.elements.toString("") + ")";
        },
        latex: function(option) {
          var cols = this.cols(), elements = this.elements;
          return format("\\begin{vmatrix}{0}\\end{vmatrix}", function() {
            var tex = [];
            for (var row in elements) {
              var row_tex = [];
              for (var i = 0; i < cols; i++) {
                row_tex.push(LaTeX.latex.call(LaTeX, elements[row][i], option));
              }
              tex.push(row_tex.join(" & "));
            }
            return tex.join(" \\cr ");
          });
        }
      };
      Matrix.prototype.each = Matrix.prototype.eachElement;
      function Set2(set) {
        this.elements = [];
        if (!isVector(set))
          set = Vector.fromArray(arguments);
        if (set) {
          var elements = set.elements;
          for (var i = 0, l = elements.length; i < l; i++) {
            this.add(elements[i]);
          }
        }
      }
      Set2.fromArray = function(arr) {
        function F(args) {
          return Set2.apply(this, args);
        }
        F.prototype = Set2.prototype;
        return new F(arr);
      };
      Set2.prototype = {
        add: function(x) {
          if (!this.contains(x))
            this.elements.push(x.clone());
        },
        contains: function(x) {
          for (var i = 0; i < this.elements.length; i++) {
            var e = this.elements[i];
            if (x.equals(e))
              return true;
          }
          return false;
        },
        each: function(f) {
          var elements = this.elements;
          var set = new Set2();
          for (var i = 0, l = elements.length; i < l; i++) {
            var e = elements[i];
            f.call(this, e, set, i);
          }
          return set;
        },
        clone: function() {
          var set = new Set2();
          this.each(function(e) {
            set.add(e.clone());
          });
          return set;
        },
        union: function(set) {
          var _union = this.clone();
          set.each(function(e) {
            _union.add(e);
          });
          return _union;
        },
        difference: function(set) {
          var diff = this.clone();
          set.each(function(e) {
            diff.remove(e);
          });
          return diff;
        },
        remove: function(element) {
          for (var i = 0, l = this.elements.length; i < l; i++) {
            var e = this.elements[i];
            if (e.equals(element)) {
              remove(this.elements, i);
              return true;
            }
          }
          return false;
        },
        intersection: function(set) {
          var _intersection = new Set2();
          var A = this;
          set.each(function(e) {
            if (A.contains(e)) {
              _intersection.add(e);
            }
            ;
          });
          return _intersection;
        },
        intersects: function(set) {
          return this.intersection(set).elements.length > 0;
        },
        is_subset: function(set) {
          var elements = set.elements;
          for (var i = 0, l = elements.length; i < l; i++) {
            if (!this.contains(elements[i])) {
              return false;
            }
          }
          return true;
        },
        toString: function() {
          return "{" + this.elements.join(",") + "}";
        }
      };
      var Build = {
        dependencies: {
          _rename: {
            "Math2.factorial": "factorial"
          },
          factorial: {
            "Math2.gamma": Math2.gamma
          },
          gamma_incomplete: {
            "Math2.factorial": Math2.factorial
          },
          Li: {
            "Math2.Ei": Math2.Ei,
            "Math2.bigLog": Math2.bigLog,
            "Frac": Frac
          },
          Ci: {
            "Math2.factorial": Math2.factorial
          },
          Ei: {
            "Math2.factorial": Math2.factorial
          },
          Si: {
            "Math2.factorial": Math2.factorial
          },
          Shi: {
            "Math2.factorial": Math2.factorial
          },
          Chi: {
            "isInt": isInt,
            "nround": nround,
            "Math2.num_integrate": Math2.num_integrate
          },
          factor: {
            "Math2.ifactor": Math2.ifactor,
            "Symbol": Symbol2
          },
          num_integrate: {
            "Math2.simpson": Math2.simpson,
            "nround": nround
          },
          fib: {
            "even": even
          }
        },
        /* Some functions need to be made numeric safe. Build checks if there's a
         * reformat option and calls that instead when compiling the function string.
         */
        reformat: {
          // this simply extends the build function
          diff: function(symbol, deps) {
            var v = symbol.args[1].toString();
            var f = "var f = " + Build.build(symbol.args[0].toString(), [v]) + ";";
            deps[1] += "var diff = " + Math2.diff.toString() + ";";
            deps[1] += f;
            return ["diff(f)(" + v + ")", deps];
          }
        },
        getProperName: function(f) {
          var map = {
            continued_fraction: "continuedFraction"
          };
          return map[f] || f;
        },
        // assumes that dependences are at max 2 levels
        compileDependencies: function(f, deps) {
          var dependencies = Build.dependencies[f];
          var dep_string = deps && deps[1] ? deps[1] : "";
          var replacements = deps && deps[0] ? deps[0] : {};
          for (var x in dependencies) {
            if (typeof dependencies[x] === "object")
              continue;
            var components = x.split(".");
            dep_string += "var " + (components.length > 1 ? components[1] : components[0]) + "=" + dependencies[x] + ";";
            replacements[x] = components.pop();
          }
          return [replacements, dep_string];
        },
        getArgsDeps: function(symbol, dependencies) {
          var args = symbol.args;
          for (var i = 0; i < args.length; i++) {
            symbol.args[i].each(function(x) {
              if (x.group === FN)
                dependencies = Build.compileDependencies(x.fname, dependencies);
            });
          }
          return dependencies;
        },
        build: function(symbol, arg_array) {
          symbol = block("PARSE2NUMBER", function() {
            return _.parse(symbol);
          }, true);
          var args = variables(symbol);
          var supplements = [];
          var dependencies = [];
          var ftext = function(symbol2, xports) {
            if (symbol2.fname === "") {
              symbol2 = Symbol2.unwrapPARENS(symbol2);
            }
            xports = xports || [];
            var c = [], group = symbol2.group, prefix = "";
            var ftext_complex = function(group2) {
              var d = group2 === CB ? "*" : "+", cc = [];
              for (var x2 in symbol2.symbols) {
                var sym = symbol2.symbols[x2], ft = ftext(sym, xports)[0];
                if (sym.isComposite())
                  ft = inBrackets(ft);
                cc.push(ft);
              }
              var retval = cc.join(d);
              retval = retval && !symbol2.multiplier.equals(1) ? inBrackets(retval) : retval;
              return retval;
            }, ftext_function = function(bn) {
              var retval;
              if (bn in Math)
                retval = "Math." + bn;
              else {
                bn = Build.getProperName(bn);
                if (supplements.indexOf(bn) === -1) {
                  xports.push("var " + bn + " = " + Math2[bn].toString() + "; ");
                  supplements.push(bn);
                }
                retval = bn;
              }
              retval = retval + inBrackets(symbol2.args.map(function(x2) {
                return ftext(x2, xports)[0];
              }).join(","));
              return retval;
            };
            if (group === N)
              c.push(symbol2.multiplier.toDecimal());
            else if (symbol2.multiplier.equals(-1))
              prefix = "-";
            else if (!symbol2.multiplier.equals(1))
              c.push(symbol2.multiplier.toDecimal());
            var value;
            if (group === S || group === P)
              value = symbol2.value;
            else if (group === FN) {
              dependencies = Build.compileDependencies(symbol2.fname, dependencies);
              dependencies = Build.getArgsDeps(symbol2, dependencies);
              if (Build.reformat[symbol2.fname]) {
                var components = Build.reformat[symbol2.fname](symbol2, dependencies);
                dependencies = components[1];
                value = components[0];
              } else {
                value = ftext_function(symbol2.fname);
              }
            } else if (group === EX) {
              var pg = symbol2.previousGroup;
              if (pg === N || pg === S)
                value = symbol2.value;
              else if (pg === FN) {
                value = ftext_function(symbol2.fname);
                dependencies = Build.compileDependencies(symbol2.fname, dependencies);
                dependencies = Build.getArgsDeps(symbol2, dependencies);
              } else
                value = ftext_complex(symbol2.previousGroup);
            } else {
              value = ftext_complex(symbol2.group);
            }
            if (symbol2.group !== N && !symbol2.power.equals(1)) {
              var pow = ftext(_.parse(symbol2.power));
              xports.push(pow[1]);
              value = "Math.pow" + inBrackets(value + "," + pow[0]);
            }
            if (value)
              c.push(prefix + value);
            return [c.join("*"), xports.join("").replace(/\n+\s+/g, " ")];
          };
          if (arg_array) {
            args = arg_array;
          }
          var f_array = ftext(symbol);
          for (var x in dependencies[0]) {
            var alias = dependencies[0][x];
            f_array[1] = f_array[1].replace(x, alias);
            dependencies[1] = dependencies[1].replace(x, alias);
          }
          var f = new Function(args, (dependencies[1] || "") + f_array[1] + " return " + f_array[0] + ";");
          return f;
        }
      };
      (function() {
        reserveNames(_.CONSTANTS);
        reserveNames(_.functions);
        _.initConstants();
        if (!_.error)
          _.error = err;
        Settings.LOG_FNS = {
          log: _.functions["log"],
          log10: _.functions["log10"]
        };
      })();
      var Utils = {
        allSame,
        allNumeric,
        arguments2Array,
        arrayAddSlices,
        arrayClone,
        arrayMax,
        arrayMin,
        arrayEqual,
        arrayUnique,
        arrayGetVariables,
        arraySum,
        block,
        build: Build.build,
        clearU,
        comboSort,
        compare,
        convertToVector,
        customError,
        customType,
        decompose_fn,
        each,
        evaluate,
        even,
        evenFraction,
        fillHoles,
        firstObject,
        format,
        generatePrimes,
        getCoeffs,
        getU,
        importFunctions,
        inBrackets,
        isArray,
        isExpression,
        isFraction,
        isInt,
        isMatrix,
        isNegative,
        isNumericSymbol,
        isPrime,
        isReserved,
        isSymbol,
        isVariableSymbol,
        isVector,
        keys,
        knownVariable,
        nroots,
        remove,
        reserveNames,
        range,
        round: nround,
        sameSign,
        scientificToDecimal,
        separate,
        stringReplace,
        text,
        validateName,
        variables,
        warn
      };
      var C = {
        groups: Groups,
        Symbol: Symbol2,
        Expression,
        Frac,
        Vector,
        Matrix,
        Parser,
        Scientific,
        Fraction,
        Math2,
        LaTeX,
        Utils,
        PARSER: _,
        PARENTHESIS,
        Settings,
        err,
        bigInt,
        bigDec,
        exceptions
      };
      var libExports = function(expression, subs, option, location) {
        var numer = false;
        var fndec = /^([a-z_][a-z\d\_]*)\(([a-z_,\s]*)\):=(.+)$/gi.exec(expression);
        if (fndec)
          return nerdamer3.setFunction(fndec[1], fndec[2].split(","), fndec[3]);
        if (expression instanceof Expression)
          expression = expression.toString();
        if (!isArray(option)) {
          option = typeof option === "undefined" ? [] : [option];
        }
        option.forEach(function(o) {
          if (o === "numer") {
            numer = true;
            return;
          }
          var f = _.functions[option];
          if (f && f[1] === 1) {
            expression = `${o}(${expression})`;
          }
        });
        var e = block("PARSE2NUMBER", function() {
          return _.parse(expression, subs);
        }, numer || Settings.PARSE2NUMBER);
        if (location) {
          EXPRESSIONS[location - 1] = e;
        } else {
          EXPRESSIONS.push(e);
        }
        return new Expression(e);
      };
      libExports.rpn = function(expression) {
        return _.tokenize(_.toRPN(expression));
      };
      libExports.convertToLaTeX = function(e, opt) {
        return _.toTeX(e, opt);
      };
      libExports.convertFromLaTeX = function(e) {
        var txt = LaTeX.parse(_.tokenize(e));
        return new Expression(_.parse(txt));
      };
      libExports.version = function(add_on) {
        if (add_on) {
          try {
            return C[add_on].version;
          } catch (e) {
            return "No module named " + add_on + " found!";
          }
        }
        return version2;
      };
      libExports.getWarnings = function() {
        return WARNINGS;
      };
      libExports.setConstant = function(constant, value) {
        validateName(constant);
        if (!isReserved(constant)) {
          if (value === "delete" || value === "") {
            delete _.CONSTANTS[constant];
          } else {
            if (isNaN(value))
              throw new NerdamerTypeError("Constant must be a number!");
            _.CONSTANTS[constant] = value;
          }
        }
        return this;
      };
      libExports.getConstant = function(constant) {
        return String(_.constant[constant]);
      };
      libExports.setFunction = setFunction;
      libExports.getCore = function() {
        return C;
      };
      libExports.getExpression = libExports.getEquation = Expression.getExpression;
      libExports.reserved = function(asArray) {
        if (asArray) {
          return RESERVED;
        }
        return RESERVED.join(", ");
      };
      libExports.clear = function(equation_number, keep_EXPRESSIONS_fixed) {
        if (equation_number === "all") {
          EXPRESSIONS = [];
        } else if (equation_number === "last") {
          EXPRESSIONS.pop();
        } else if (equation_number === "first") {
          EXPRESSIONS.shift();
        } else {
          var index = !equation_number ? EXPRESSIONS.length : equation_number - 1;
          keep_EXPRESSIONS_fixed === true ? EXPRESSIONS[index] = void 0 : remove(EXPRESSIONS, index);
        }
        return this;
      };
      libExports.flush = function() {
        this.clear("all");
        return this;
      };
      libExports.expressions = function(asObject, asLaTeX, option) {
        var result = asObject ? {} : [];
        for (var i = 0; i < EXPRESSIONS.length; i++) {
          var eq = asLaTeX ? LaTeX.latex(EXPRESSIONS[i], option) : text(EXPRESSIONS[i], option);
          asObject ? result[i + 1] = eq : result.push(eq);
        }
        return result;
      };
      libExports.register = function(obj) {
        var core = this.getCore();
        if (isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
            if (obj)
              this.register(obj[i]);
          }
        } else if (obj && Settings.exclude.indexOf(obj.name) === -1) {
          if (obj.dependencies) {
            for (var i = 0; i < obj.dependencies.length; i++)
              if (!core[obj.dependencies[i]])
                throw new Error(format("{0} requires {1} to be loaded!", obj.name, obj.dependencies[i]));
          }
          var parent_obj = obj.parent, fn = obj.build.call(core);
          if (parent_obj) {
            if (!core[parent_obj])
              core[obj.parent] = {};
            var ref_obj = parent_obj === "nerdamer" ? this : core[parent_obj];
            ref_obj[obj.name] = fn;
          }
          if (obj.visible)
            _.functions[obj.name] = [fn, obj.numargs];
        }
      };
      libExports.validateName = validateName;
      libExports.validVarName = function(varname) {
        try {
          validateName(varname);
          return RESERVED.indexOf(varname) === -1;
        } catch (e) {
          return false;
        }
      };
      libExports.supported = function() {
        return keys(_.functions);
      };
      libExports.numEquations = libExports.numExpressions = function() {
        return EXPRESSIONS.length;
      };
      libExports.setVar = function(v, val) {
        validateName(v);
        if (v in _.CONSTANTS)
          err("Cannot set value for constant " + v);
        if (val === "delete" || val === "")
          delete VARS[v];
        else {
          VARS[v] = isSymbol(val) ? val : _.parse(val);
        }
        return this;
      };
      libExports.getVar = function(v) {
        return VARS[v];
      };
      libExports.clearVars = function() {
        VARS = {};
        return this;
      };
      libExports.load = function(loader) {
        loader.call(this);
        return this;
      };
      libExports.getVars = function(output, option) {
        output = output || "text";
        var variables2 = {};
        if (output === "object")
          variables2 = VARS;
        else {
          for (var v in VARS) {
            if (output === "latex") {
              variables2[v] = VARS[v].latex(option);
            } else if (output === "text") {
              variables2[v] = VARS[v].text(option);
            }
          }
        }
        return variables2;
      };
      libExports.set = function(setting, value) {
        if (typeof setting === "object")
          for (var x in setting) {
            libExports.set(x, setting[x]);
          }
        var disallowed = ["SAFE"];
        if (disallowed.indexOf(setting) !== -1)
          err("Cannot modify setting: " + setting);
        if (setting === "PRECISION") {
          bigDec.set({ precision: value });
          Settings.PRECISION = value;
          if (value > 21) {
            this.set("USE_BIG", true);
          }
        } else if (setting === "USE_LN" && value === true) {
          Settings.LOG = "LN";
          Settings.LOG10 = "log";
          _.functions["log"] = Settings.LOG_FNS.log10;
          _.functions["log"][0] = function(x2) {
            if (x2.isConstant())
              return new Symbol2(Math.log10(x2));
            return _.symfunction(Settings.LOG10, [x2]);
          };
          _.functions["LN"] = Settings.LOG_FNS.log;
          delete _.functions["log10"];
        } else
          Settings[setting] = value;
      };
      libExports.get = function(setting) {
        return Settings[setting];
      };
      libExports.updateAPI = function(override) {
        var linker = function(fname) {
          return function() {
            var args = [].slice.call(arguments);
            for (var i = 0; i < args.length; i++)
              args[i] = _.parse(args[i]);
            return new Expression(block("PARSE2NUMBER", function() {
              return _.callfunction(fname, args);
            }));
          };
        };
        for (var x in _.functions)
          if (!(x in libExports) || override)
            libExports[x] = linker(x);
      };
      libExports.replaceFunction = function(name, fn, num_args) {
        var existing = _.functions[name];
        var new_num_args = typeof num_args === "undefined" ? existing[1] : num_args;
        _.functions[name] = [fn.call(void 0, existing[0], C), new_num_args];
      };
      libExports.setOperator = function(operator, shift) {
        _.setOperator(operator, shift);
      };
      libExports.getOperator = function(operator) {
        return _.getOperator(operator);
      };
      libExports.aliasOperator = function(operator, withOperator) {
        _.aliasOperator(operator, withOperator);
      };
      libExports.tree = function(expression) {
        return _.tree(_.toRPN(_.tokenize(expression)));
      };
      libExports.htmlTree = function(expression, indent) {
        var tree = this.tree(expression);
        return '<div class="tree">\n    <ul>\n        <li>\n' + tree.toHTML(3, indent) + "\n        </li>\n    </ul>\n</div>";
      };
      libExports.addPeeker = function(name, f) {
        if (_.peekers[name])
          _.peekers[name].push(f);
      };
      libExports.removePeeker = function(name, f) {
        remove(_.peekers[name], f);
      };
      libExports.parse = function(e) {
        return String(e).split(";").map(function(x) {
          return _.parse(x);
        });
      };
      libExports.updateAPI();
      return libExports;
    })({
      //https://github.com/peterolson/BigInteger.js
      bigInt: (function() {
        var bigInt = (function(undefined2) {
          "use strict";
          var BASE = 1e7, LOG_BASE = 7, MAX_INT = 9007199254740992, MAX_INT_ARR = smallToArray(MAX_INT), LOG_MAX_INT = Math.log(MAX_INT);
          function Integer(v, radix) {
            if (typeof v === "undefined") return Integer[0];
            if (typeof radix !== "undefined") return +radix === 10 ? parseValue(v) : parseBase(v, radix);
            return parseValue(v);
          }
          function BigInteger(value, sign) {
            this.value = value;
            this.sign = sign;
            this.isSmall = false;
          }
          BigInteger.prototype = Object.create(Integer.prototype);
          function SmallInteger(value) {
            this.value = value;
            this.sign = value < 0;
            this.isSmall = true;
          }
          SmallInteger.prototype = Object.create(Integer.prototype);
          function isPrecise(n2) {
            return -MAX_INT < n2 && n2 < MAX_INT;
          }
          function smallToArray(n2) {
            if (n2 < 1e7) return [n2];
            if (n2 < 1e14) return [n2 % 1e7, Math.floor(n2 / 1e7)];
            return [n2 % 1e7, Math.floor(n2 / 1e7) % 1e7, Math.floor(n2 / 1e14)];
          }
          function arrayToSmall(arr) {
            trim(arr);
            var length = arr.length;
            if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
              switch (length) {
                case 0:
                  return 0;
                case 1:
                  return arr[0];
                case 2:
                  return arr[0] + arr[1] * BASE;
                default:
                  return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
              }
            }
            return arr;
          }
          function trim(v) {
            var i2 = v.length;
            while (v[--i2] === 0) ;
            v.length = i2 + 1;
          }
          function createArray(length) {
            var x = new Array(length);
            var i2 = -1;
            while (++i2 < length) {
              x[i2] = 0;
            }
            return x;
          }
          function truncate(n2) {
            if (n2 > 0) return Math.floor(n2);
            return Math.ceil(n2);
          }
          function add(a, b) {
            var l_a = a.length, l_b = b.length, r = new Array(l_a), carry = 0, base = BASE, sum, i2;
            for (i2 = 0; i2 < l_b; i2++) {
              sum = a[i2] + b[i2] + carry;
              carry = sum >= base ? 1 : 0;
              r[i2] = sum - carry * base;
            }
            while (i2 < l_a) {
              sum = a[i2] + carry;
              carry = sum === base ? 1 : 0;
              r[i2++] = sum - carry * base;
            }
            if (carry > 0) r.push(carry);
            return r;
          }
          function addAny(a, b) {
            if (a.length >= b.length) return add(a, b);
            return add(b, a);
          }
          function addSmall(a, carry) {
            var l = a.length, r = new Array(l), base = BASE, sum, i2;
            for (i2 = 0; i2 < l; i2++) {
              sum = a[i2] - base + carry;
              carry = Math.floor(sum / base);
              r[i2] = sum - carry * base;
              carry += 1;
            }
            while (carry > 0) {
              r[i2++] = carry % base;
              carry = Math.floor(carry / base);
            }
            return r;
          }
          BigInteger.prototype.add = function(v) {
            var n2 = parseValue(v);
            if (this.sign !== n2.sign) {
              return this.subtract(n2.negate());
            }
            var a = this.value, b = n2.value;
            if (n2.isSmall) {
              return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
            }
            return new BigInteger(addAny(a, b), this.sign);
          };
          BigInteger.prototype.plus = BigInteger.prototype.add;
          SmallInteger.prototype.add = function(v) {
            var n2 = parseValue(v);
            var a = this.value;
            if (a < 0 !== n2.sign) {
              return this.subtract(n2.negate());
            }
            var b = n2.value;
            if (n2.isSmall) {
              if (isPrecise(a + b)) return new SmallInteger(a + b);
              b = smallToArray(Math.abs(b));
            }
            return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
          };
          SmallInteger.prototype.plus = SmallInteger.prototype.add;
          function subtract(a, b) {
            var a_l = a.length, b_l = b.length, r = new Array(a_l), borrow = 0, base = BASE, i2, difference;
            for (i2 = 0; i2 < b_l; i2++) {
              difference = a[i2] - borrow - b[i2];
              if (difference < 0) {
                difference += base;
                borrow = 1;
              } else borrow = 0;
              r[i2] = difference;
            }
            for (i2 = b_l; i2 < a_l; i2++) {
              difference = a[i2] - borrow;
              if (difference < 0) difference += base;
              else {
                r[i2++] = difference;
                break;
              }
              r[i2] = difference;
            }
            for (; i2 < a_l; i2++) {
              r[i2] = a[i2];
            }
            trim(r);
            return r;
          }
          function subtractAny(a, b, sign) {
            var value;
            if (compareAbs(a, b) >= 0) {
              value = subtract(a, b);
            } else {
              value = subtract(b, a);
              sign = !sign;
            }
            value = arrayToSmall(value);
            if (typeof value === "number") {
              if (sign) value = -value;
              return new SmallInteger(value);
            }
            return new BigInteger(value, sign);
          }
          function subtractSmall(a, b, sign) {
            var l = a.length, r = new Array(l), carry = -b, base = BASE, i2, difference;
            for (i2 = 0; i2 < l; i2++) {
              difference = a[i2] + carry;
              carry = Math.floor(difference / base);
              difference %= base;
              r[i2] = difference < 0 ? difference + base : difference;
            }
            r = arrayToSmall(r);
            if (typeof r === "number") {
              if (sign) r = -r;
              return new SmallInteger(r);
            }
            return new BigInteger(r, sign);
          }
          BigInteger.prototype.subtract = function(v) {
            var n2 = parseValue(v);
            if (this.sign !== n2.sign) {
              return this.add(n2.negate());
            }
            var a = this.value, b = n2.value;
            if (n2.isSmall) return subtractSmall(a, Math.abs(b), this.sign);
            return subtractAny(a, b, this.sign);
          };
          BigInteger.prototype.minus = BigInteger.prototype.subtract;
          SmallInteger.prototype.subtract = function(v) {
            var n2 = parseValue(v);
            var a = this.value;
            if (a < 0 !== n2.sign) {
              return this.add(n2.negate());
            }
            var b = n2.value;
            if (n2.isSmall) {
              return new SmallInteger(a - b);
            }
            return subtractSmall(b, Math.abs(a), a >= 0);
          };
          SmallInteger.prototype.minus = SmallInteger.prototype.subtract;
          BigInteger.prototype.negate = function() {
            return new BigInteger(this.value, !this.sign);
          };
          SmallInteger.prototype.negate = function() {
            var sign = this.sign;
            var small = new SmallInteger(-this.value);
            small.sign = !sign;
            return small;
          };
          BigInteger.prototype.abs = function() {
            return new BigInteger(this.value, false);
          };
          SmallInteger.prototype.abs = function() {
            return new SmallInteger(Math.abs(this.value));
          };
          function multiplyLong(a, b) {
            var a_l = a.length, b_l = b.length, l = a_l + b_l, r = createArray(l), base = BASE, product, carry, i2, a_i, b_j;
            for (i2 = 0; i2 < a_l; ++i2) {
              a_i = a[i2];
              for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i2 + j];
                carry = Math.floor(product / base);
                r[i2 + j] = product - carry * base;
                r[i2 + j + 1] += carry;
              }
            }
            trim(r);
            return r;
          }
          function multiplySmall(a, b) {
            var l = a.length, r = new Array(l), base = BASE, carry = 0, product, i2;
            for (i2 = 0; i2 < l; i2++) {
              product = a[i2] * b + carry;
              carry = Math.floor(product / base);
              r[i2] = product - carry * base;
            }
            while (carry > 0) {
              r[i2++] = carry % base;
              carry = Math.floor(carry / base);
            }
            return r;
          }
          function shiftLeft(x, n2) {
            var r = [];
            while (n2-- > 0) r.push(0);
            return r.concat(x);
          }
          function multiplyKaratsuba(x, y) {
            var n2 = Math.max(x.length, y.length);
            if (n2 <= 30) return multiplyLong(x, y);
            n2 = Math.ceil(n2 / 2);
            var b = x.slice(n2), a = x.slice(0, n2), d = y.slice(n2), c = y.slice(0, n2);
            var ac = multiplyKaratsuba(a, c), bd = multiplyKaratsuba(b, d), abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));
            var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n2)), shiftLeft(bd, 2 * n2));
            trim(product);
            return product;
          }
          function useKaratsuba(l1, l2) {
            return -0.012 * l1 - 0.012 * l2 + 15e-6 * l1 * l2 > 0;
          }
          BigInteger.prototype.multiply = function(v) {
            var n2 = parseValue(v), a = this.value, b = n2.value, sign = this.sign !== n2.sign, abs;
            if (n2.isSmall) {
              if (b === 0) return Integer[0];
              if (b === 1) return this;
              if (b === -1) return this.negate();
              abs = Math.abs(b);
              if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
              }
              b = smallToArray(abs);
            }
            if (useKaratsuba(a.length, b.length)) return new BigInteger(multiplyKaratsuba(a, b), sign);
            return new BigInteger(multiplyLong(a, b), sign);
          };
          BigInteger.prototype.times = BigInteger.prototype.multiply;
          function multiplySmallAndArray(a, b, sign) {
            if (a < BASE) {
              return new BigInteger(multiplySmall(b, a), sign);
            }
            return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
          }
          SmallInteger.prototype._multiplyBySmall = function(a) {
            if (isPrecise(a.value * this.value)) {
              return new SmallInteger(a.value * this.value);
            }
            return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
          };
          BigInteger.prototype._multiplyBySmall = function(a) {
            if (a.value === 0) return Integer[0];
            if (a.value === 1) return this;
            if (a.value === -1) return this.negate();
            return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
          };
          SmallInteger.prototype.multiply = function(v) {
            return parseValue(v)._multiplyBySmall(this);
          };
          SmallInteger.prototype.times = SmallInteger.prototype.multiply;
          function square(a) {
            var l = a.length, r = createArray(l + l), base = BASE, product, carry, i2, a_i, a_j;
            for (i2 = 0; i2 < l; i2++) {
              a_i = a[i2];
              carry = 0 - a_i * a_i;
              for (var j = i2; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i2 + j] + carry;
                carry = Math.floor(product / base);
                r[i2 + j] = product - carry * base;
              }
              r[i2 + l] = carry;
            }
            trim(r);
            return r;
          }
          BigInteger.prototype.square = function() {
            return new BigInteger(square(this.value), false);
          };
          SmallInteger.prototype.square = function() {
            var value = this.value * this.value;
            if (isPrecise(value)) return new SmallInteger(value);
            return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
          };
          function divMod1(a, b) {
            var a_l = a.length, b_l = b.length, base = BASE, result = createArray(b.length), divisorMostSignificantDigit = b[b_l - 1], lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)), remainder = multiplySmall(a, lambda), divisor = multiplySmall(b, lambda), quotientDigit, shift, carry, borrow, i2, l, q;
            if (remainder.length <= a_l) remainder.push(0);
            divisor.push(0);
            divisorMostSignificantDigit = divisor[b_l - 1];
            for (shift = a_l - b_l; shift >= 0; shift--) {
              quotientDigit = base - 1;
              if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
              }
              carry = 0;
              borrow = 0;
              l = divisor.length;
              for (i2 = 0; i2 < l; i2++) {
                carry += quotientDigit * divisor[i2];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i2] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                  remainder[shift + i2] = borrow + base;
                  borrow = -1;
                } else {
                  remainder[shift + i2] = borrow;
                  borrow = 0;
                }
              }
              while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i2 = 0; i2 < l; i2++) {
                  carry += remainder[shift + i2] - base + divisor[i2];
                  if (carry < 0) {
                    remainder[shift + i2] = carry + base;
                    carry = 0;
                  } else {
                    remainder[shift + i2] = carry;
                    carry = 1;
                  }
                }
                borrow += carry;
              }
              result[shift] = quotientDigit;
            }
            remainder = divModSmall(remainder, lambda)[0];
            return [arrayToSmall(result), arrayToSmall(remainder)];
          }
          function divMod2(a, b) {
            var a_l = a.length, b_l = b.length, result = [], part = [], base = BASE, guess, xlen, highx, highy, check2;
            while (a_l) {
              part.unshift(a[--a_l]);
              trim(part);
              if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
              }
              xlen = part.length;
              highx = part[xlen - 1] * base + part[xlen - 2];
              highy = b[b_l - 1] * base + b[b_l - 2];
              if (xlen > b_l) {
                highx = (highx + 1) * base;
              }
              guess = Math.ceil(highx / highy);
              do {
                check2 = multiplySmall(b, guess);
                if (compareAbs(check2, part) <= 0) break;
                guess--;
              } while (guess);
              result.push(guess);
              part = subtract(part, check2);
            }
            result.reverse();
            return [arrayToSmall(result), arrayToSmall(part)];
          }
          function divModSmall(value, lambda) {
            var length = value.length, quotient = createArray(length), base = BASE, i2, q, remainder, divisor;
            remainder = 0;
            for (i2 = length - 1; i2 >= 0; --i2) {
              divisor = remainder * base + value[i2];
              q = truncate(divisor / lambda);
              remainder = divisor - q * lambda;
              quotient[i2] = q | 0;
            }
            return [quotient, remainder | 0];
          }
          function divModAny(self2, v) {
            var value, n2 = parseValue(v);
            var a = self2.value, b = n2.value;
            var quotient;
            if (b === 0) throw new Error("Cannot divide by zero");
            if (self2.isSmall) {
              if (n2.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
              }
              return [Integer[0], self2];
            }
            if (n2.isSmall) {
              if (b === 1) return [self2, Integer[0]];
              if (b == -1) return [self2.negate(), Integer[0]];
              var abs = Math.abs(b);
              if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self2.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                  if (self2.sign !== n2.sign) quotient = -quotient;
                  return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self2.sign !== n2.sign), new SmallInteger(remainder)];
              }
              b = smallToArray(abs);
            }
            var comparison = compareAbs(a, b);
            if (comparison === -1) return [Integer[0], self2];
            if (comparison === 0) return [Integer[self2.sign === n2.sign ? 1 : -1], Integer[0]];
            if (a.length + b.length <= 200) value = divMod1(a, b);
            else value = divMod2(a, b);
            quotient = value[0];
            var qSign = self2.sign !== n2.sign, mod = value[1], mSign = self2.sign;
            if (typeof quotient === "number") {
              if (qSign) quotient = -quotient;
              quotient = new SmallInteger(quotient);
            } else quotient = new BigInteger(quotient, qSign);
            if (typeof mod === "number") {
              if (mSign) mod = -mod;
              mod = new SmallInteger(mod);
            } else mod = new BigInteger(mod, mSign);
            return [quotient, mod];
          }
          BigInteger.prototype.divmod = function(v) {
            var result = divModAny(this, v);
            return { quotient: result[0], remainder: result[1] };
          };
          SmallInteger.prototype.divmod = BigInteger.prototype.divmod;
          BigInteger.prototype.divide = function(v) {
            return divModAny(this, v)[0];
          };
          SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;
          BigInteger.prototype.mod = function(v) {
            return divModAny(this, v)[1];
          };
          SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;
          BigInteger.prototype.pow = function(v) {
            var n2 = parseValue(v), a = this.value, b = n2.value, value, x, y;
            if (b === 0) return Integer[1];
            if (a === 0) return Integer[0];
            if (a === 1) return Integer[1];
            if (a === -1) return n2.isEven() ? Integer[1] : Integer[-1];
            if (n2.sign) {
              return Integer[0];
            }
            if (!n2.isSmall) throw new Error("The exponent " + n2.toString() + " is too large.");
            if (this.isSmall) {
              if (isPrecise(value = Math.pow(a, b))) return new SmallInteger(truncate(value));
            }
            x = this;
            y = Integer[1];
            while (true) {
              if (b & true) {
                y = y.times(x);
                --b;
              }
              if (b === 0) break;
              b /= 2;
              x = x.square();
            }
            return y;
          };
          SmallInteger.prototype.pow = BigInteger.prototype.pow;
          BigInteger.prototype.modPow = function(exp, mod) {
            exp = parseValue(exp);
            mod = parseValue(mod);
            if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
            var r = Integer[1], base = this.mod(mod);
            while (exp.isPositive()) {
              if (base.isZero()) return Integer[0];
              if (exp.isOdd()) r = r.multiply(base).mod(mod);
              exp = exp.divide(2);
              base = base.square().mod(mod);
            }
            return r;
          };
          SmallInteger.prototype.modPow = BigInteger.prototype.modPow;
          function compareAbs(a, b) {
            if (a.length !== b.length) {
              return a.length > b.length ? 1 : -1;
            }
            for (var i2 = a.length - 1; i2 >= 0; i2--) {
              if (a[i2] !== b[i2]) return a[i2] > b[i2] ? 1 : -1;
            }
            return 0;
          }
          BigInteger.prototype.compareAbs = function(v) {
            var n2 = parseValue(v), a = this.value, b = n2.value;
            if (n2.isSmall) return 1;
            return compareAbs(a, b);
          };
          SmallInteger.prototype.compareAbs = function(v) {
            var n2 = parseValue(v), a = Math.abs(this.value), b = n2.value;
            if (n2.isSmall) {
              b = Math.abs(b);
              return a === b ? 0 : a > b ? 1 : -1;
            }
            return -1;
          };
          BigInteger.prototype.compare = function(v) {
            if (v === Infinity) {
              return -1;
            }
            if (v === -Infinity) {
              return 1;
            }
            var n2 = parseValue(v), a = this.value, b = n2.value;
            if (this.sign !== n2.sign) {
              return n2.sign ? 1 : -1;
            }
            if (n2.isSmall) {
              return this.sign ? -1 : 1;
            }
            return compareAbs(a, b) * (this.sign ? -1 : 1);
          };
          BigInteger.prototype.compareTo = BigInteger.prototype.compare;
          SmallInteger.prototype.compare = function(v) {
            if (v === Infinity) {
              return -1;
            }
            if (v === -Infinity) {
              return 1;
            }
            var n2 = parseValue(v), a = this.value, b = n2.value;
            if (n2.isSmall) {
              return a == b ? 0 : a > b ? 1 : -1;
            }
            if (a < 0 !== n2.sign) {
              return a < 0 ? -1 : 1;
            }
            return a < 0 ? 1 : -1;
          };
          SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;
          BigInteger.prototype.equals = function(v) {
            return this.compare(v) === 0;
          };
          SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;
          BigInteger.prototype.notEquals = function(v) {
            return this.compare(v) !== 0;
          };
          SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;
          BigInteger.prototype.greater = function(v) {
            return this.compare(v) > 0;
          };
          SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;
          BigInteger.prototype.lesser = function(v) {
            return this.compare(v) < 0;
          };
          SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;
          BigInteger.prototype.greaterOrEquals = function(v) {
            return this.compare(v) >= 0;
          };
          SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;
          BigInteger.prototype.lesserOrEquals = function(v) {
            return this.compare(v) <= 0;
          };
          SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;
          BigInteger.prototype.isEven = function() {
            return (this.value[0] & 1) === 0;
          };
          SmallInteger.prototype.isEven = function() {
            return (this.value & 1) === 0;
          };
          BigInteger.prototype.isOdd = function() {
            return (this.value[0] & 1) === 1;
          };
          SmallInteger.prototype.isOdd = function() {
            return (this.value & 1) === 1;
          };
          BigInteger.prototype.isPositive = function() {
            return !this.sign;
          };
          SmallInteger.prototype.isPositive = function() {
            return this.value > 0;
          };
          BigInteger.prototype.isNegative = function() {
            return this.sign;
          };
          SmallInteger.prototype.isNegative = function() {
            return this.value < 0;
          };
          BigInteger.prototype.isUnit = function() {
            return false;
          };
          SmallInteger.prototype.isUnit = function() {
            return Math.abs(this.value) === 1;
          };
          BigInteger.prototype.isZero = function() {
            return false;
          };
          SmallInteger.prototype.isZero = function() {
            return this.value === 0;
          };
          BigInteger.prototype.isDivisibleBy = function(v) {
            var n2 = parseValue(v);
            var value = n2.value;
            if (value === 0) return false;
            if (value === 1) return true;
            if (value === 2) return this.isEven();
            return this.mod(n2).equals(Integer[0]);
          };
          SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;
          function isBasicPrime(v) {
            var n2 = v.abs();
            if (n2.isUnit()) return false;
            if (n2.equals(2) || n2.equals(3) || n2.equals(5)) return true;
            if (n2.isEven() || n2.isDivisibleBy(3) || n2.isDivisibleBy(5)) return false;
            if (n2.lesser(49)) return true;
          }
          function millerRabinTest(n2, a) {
            var nPrev = n2.prev(), b = nPrev, r = 0, d, t, i2, x;
            while (b.isEven()) b = b.divide(2), r++;
            next: for (i2 = 0; i2 < a.length; i2++) {
              if (n2.lesser(a[i2])) continue;
              x = bigInt(a[i2]).modPow(b, n2);
              if (x.equals(Integer[1]) || x.equals(nPrev)) continue;
              for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n2);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
              }
              return false;
            }
            return true;
          }
          BigInteger.prototype.isPrime = function(strict) {
            var isPrime = isBasicPrime(this);
            if (isPrime !== undefined2) return isPrime;
            var n2 = this.abs();
            var bits = n2.bitLength();
            if (bits <= 64) return millerRabinTest(n2, [2, 325, 9375, 28178, 450775, 9780504, 1795265022]);
            var logN = Math.log(2) * bits;
            var t = Math.ceil(strict === true ? 2 * Math.pow(logN, 2) : logN);
            for (var a = [], i2 = 0; i2 < t; i2++) {
              a.push(bigInt(i2 + 2));
            }
            return millerRabinTest(n2, a);
          };
          SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;
          BigInteger.prototype.isProbablePrime = function(iterations) {
            var isPrime = isBasicPrime(this);
            if (isPrime !== undefined2) return isPrime;
            var n2 = this.abs();
            var t = iterations === undefined2 ? 5 : iterations;
            for (var a = [], i2 = 0; i2 < t; i2++) {
              a.push(bigInt.randBetween(2, n2.minus(2)));
            }
            return millerRabinTest(n2, a);
          };
          SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;
          BigInteger.prototype.modInv = function(n2) {
            var t = bigInt.zero, newT = bigInt.one, r = parseValue(n2), newR = this.abs(), q, lastT, lastR;
            while (!newR.equals(bigInt.zero)) {
              q = r.divide(newR);
              lastT = t;
              lastR = r;
              t = newT;
              r = newR;
              newT = lastT.subtract(q.multiply(newT));
              newR = lastR.subtract(q.multiply(newR));
            }
            if (!r.equals(1)) throw new Error(this.toString() + " and " + n2.toString() + " are not co-prime");
            if (t.compare(0) === -1) {
              t = t.add(n2);
            }
            if (this.isNegative()) {
              return t.negate();
            }
            return t;
          };
          SmallInteger.prototype.modInv = BigInteger.prototype.modInv;
          BigInteger.prototype.next = function() {
            var value = this.value;
            if (this.sign) {
              return subtractSmall(value, 1, this.sign);
            }
            return new BigInteger(addSmall(value, 1), this.sign);
          };
          SmallInteger.prototype.next = function() {
            var value = this.value;
            if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
            return new BigInteger(MAX_INT_ARR, false);
          };
          BigInteger.prototype.prev = function() {
            var value = this.value;
            if (this.sign) {
              return new BigInteger(addSmall(value, 1), true);
            }
            return subtractSmall(value, 1, this.sign);
          };
          SmallInteger.prototype.prev = function() {
            var value = this.value;
            if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
            return new BigInteger(MAX_INT_ARR, true);
          };
          var powersOfTwo = [1];
          while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
          var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];
          function shift_isSmall(n2) {
            return (typeof n2 === "number" || typeof n2 === "string") && +Math.abs(n2) <= BASE || n2 instanceof BigInteger && n2.value.length <= 1;
          }
          BigInteger.prototype.shiftLeft = function(n2) {
            if (!shift_isSmall(n2)) {
              throw new Error(String(n2) + " is too large for shifting.");
            }
            n2 = +n2;
            if (n2 < 0) return this.shiftRight(-n2);
            var result = this;
            if (result.isZero()) return result;
            while (n2 >= powers2Length) {
              result = result.multiply(highestPower2);
              n2 -= powers2Length - 1;
            }
            return result.multiply(powersOfTwo[n2]);
          };
          SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;
          BigInteger.prototype.shiftRight = function(n2) {
            var remQuo;
            if (!shift_isSmall(n2)) {
              throw new Error(String(n2) + " is too large for shifting.");
            }
            n2 = +n2;
            if (n2 < 0) return this.shiftLeft(-n2);
            var result = this;
            while (n2 >= powers2Length) {
              if (result.isZero() || result.isNegative() && result.isUnit()) return result;
              remQuo = divModAny(result, highestPower2);
              result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
              n2 -= powers2Length - 1;
            }
            remQuo = divModAny(result, powersOfTwo[n2]);
            return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
          };
          SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;
          function bitwise(x, y, fn) {
            y = parseValue(y);
            var xSign = x.isNegative(), ySign = y.isNegative();
            var xRem = xSign ? x.not() : x, yRem = ySign ? y.not() : y;
            var xDigit = 0, yDigit = 0;
            var xDivMod = null, yDivMod = null;
            var result = [];
            while (!xRem.isZero() || !yRem.isZero()) {
              xDivMod = divModAny(xRem, highestPower2);
              xDigit = xDivMod[1].toJSNumber();
              if (xSign) {
                xDigit = highestPower2 - 1 - xDigit;
              }
              yDivMod = divModAny(yRem, highestPower2);
              yDigit = yDivMod[1].toJSNumber();
              if (ySign) {
                yDigit = highestPower2 - 1 - yDigit;
              }
              xRem = xDivMod[0];
              yRem = yDivMod[0];
              result.push(fn(xDigit, yDigit));
            }
            var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
            for (var i2 = result.length - 1; i2 >= 0; i2 -= 1) {
              sum = sum.multiply(highestPower2).add(bigInt(result[i2]));
            }
            return sum;
          }
          BigInteger.prototype.not = function() {
            return this.negate().prev();
          };
          SmallInteger.prototype.not = BigInteger.prototype.not;
          BigInteger.prototype.and = function(n2) {
            return bitwise(this, n2, function(a, b) {
              return a & b;
            });
          };
          SmallInteger.prototype.and = BigInteger.prototype.and;
          BigInteger.prototype.or = function(n2) {
            return bitwise(this, n2, function(a, b) {
              return a | b;
            });
          };
          SmallInteger.prototype.or = BigInteger.prototype.or;
          BigInteger.prototype.xor = function(n2) {
            return bitwise(this, n2, function(a, b) {
              return a ^ b;
            });
          };
          SmallInteger.prototype.xor = BigInteger.prototype.xor;
          var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
          function roughLOB(n2) {
            var v = n2.value, x = typeof v === "number" ? v | LOBMASK_I : v[0] + v[1] * BASE | LOBMASK_BI;
            return x & -x;
          }
          function integerLogarithm(value, base) {
            if (base.compareTo(value) <= 0) {
              var tmp = integerLogarithm(value, base.square(base));
              var p = tmp.p;
              var e = tmp.e;
              var t = p.multiply(base);
              return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p, e: e * 2 };
            }
            return { p: bigInt(1), e: 0 };
          }
          BigInteger.prototype.bitLength = function() {
            var n2 = this;
            if (n2.compareTo(bigInt(0)) < 0) {
              n2 = n2.negate().subtract(bigInt(1));
            }
            if (n2.compareTo(bigInt(0)) === 0) {
              return bigInt(0);
            }
            return bigInt(integerLogarithm(n2, bigInt(2)).e).add(bigInt(1));
          };
          SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;
          function max(a, b) {
            a = parseValue(a);
            b = parseValue(b);
            return a.greater(b) ? a : b;
          }
          function min(a, b) {
            a = parseValue(a);
            b = parseValue(b);
            return a.lesser(b) ? a : b;
          }
          function gcd(a, b) {
            a = parseValue(a).abs();
            b = parseValue(b).abs();
            if (a.equals(b)) return a;
            if (a.isZero()) return b;
            if (b.isZero()) return a;
            var c = Integer[1], d, t;
            while (a.isEven() && b.isEven()) {
              d = Math.min(roughLOB(a), roughLOB(b));
              a = a.divide(d);
              b = b.divide(d);
              c = c.multiply(d);
            }
            while (a.isEven()) {
              a = a.divide(roughLOB(a));
            }
            do {
              while (b.isEven()) {
                b = b.divide(roughLOB(b));
              }
              if (a.greater(b)) {
                t = b;
                b = a;
                a = t;
              }
              b = b.subtract(a);
            } while (!b.isZero());
            return c.isUnit() ? a : a.multiply(c);
          }
          function lcm(a, b) {
            a = parseValue(a).abs();
            b = parseValue(b).abs();
            return a.divide(gcd(a, b)).multiply(b);
          }
          function randBetween(a, b) {
            a = parseValue(a);
            b = parseValue(b);
            var low = min(a, b), high = max(a, b);
            var range = high.subtract(low).add(1);
            if (range.isSmall) return low.add(Math.floor(Math.random() * range));
            var length = range.value.length - 1;
            var result = [], restricted = true;
            for (var i2 = length; i2 >= 0; i2--) {
              var top = restricted ? range.value[i2] : BASE;
              var digit = truncate(Math.random() * top);
              result.unshift(digit);
              if (digit < top) restricted = false;
            }
            result = arrayToSmall(result);
            return low.add(typeof result === "number" ? new SmallInteger(result) : new BigInteger(result, false));
          }
          var parseBase = function(text, base) {
            var length = text.length;
            var i2;
            var absBase = Math.abs(base);
            for (var i2 = 0; i2 < length; i2++) {
              var c = text[i2].toLowerCase();
              if (c === "-") continue;
              if (/[a-z0-9]/.test(c)) {
                if (/[0-9]/.test(c) && +c >= absBase) {
                  if (c === "1" && absBase === 1) continue;
                  throw new Error(c + " is not a valid digit in base " + base + ".");
                } else if (c.charCodeAt(0) - 87 >= absBase) {
                  throw new Error(c + " is not a valid digit in base " + base + ".");
                }
              }
            }
            if (2 <= base && base <= 36) {
              if (length <= LOG_MAX_INT / Math.log(base)) {
                var result = parseInt(text, base);
                if (isNaN(result)) {
                  throw new Error(c + " is not a valid digit in base " + base + ".");
                }
                return new SmallInteger(parseInt(text, base));
              }
            }
            base = parseValue(base);
            var digits = [];
            var isNegative = text[0] === "-";
            for (i2 = isNegative ? 1 : 0; i2 < text.length; i2++) {
              var c = text[i2].toLowerCase(), charCode = c.charCodeAt(0);
              if (48 <= charCode && charCode <= 57) digits.push(parseValue(c));
              else if (97 <= charCode && charCode <= 122) digits.push(parseValue(c.charCodeAt(0) - 87));
              else if (c === "<") {
                var start = i2;
                do {
                  i2++;
                } while (text[i2] !== ">");
                digits.push(parseValue(text.slice(start + 1, i2)));
              } else throw new Error(c + " is not a valid character");
            }
            return parseBaseFromArray(digits, base, isNegative);
          };
          function parseBaseFromArray(digits, base, isNegative) {
            var val = Integer[0], pow = Integer[1], i2;
            for (i2 = digits.length - 1; i2 >= 0; i2--) {
              val = val.add(digits[i2].times(pow));
              pow = pow.times(base);
            }
            return isNegative ? val.negate() : val;
          }
          function stringify(digit) {
            if (digit <= 35) {
              return "0123456789abcdefghijklmnopqrstuvwxyz".charAt(digit);
            }
            return "<" + digit + ">";
          }
          function toBase(n2, base) {
            base = bigInt(base);
            if (base.isZero()) {
              if (n2.isZero()) return { value: [0], isNegative: false };
              throw new Error("Cannot convert nonzero numbers to base 0.");
            }
            if (base.equals(-1)) {
              if (n2.isZero()) return { value: [0], isNegative: false };
              if (n2.isNegative()) return { value: [].concat.apply([], Array.apply(null, Array(-n2)).map(Array.prototype.valueOf, [1, 0])), isNegative: false };
              var arr = Array.apply(null, Array(+n2 - 1)).map(Array.prototype.valueOf, [0, 1]);
              arr.unshift([1]);
              return { value: [].concat.apply([], arr), isNegative: false };
            }
            var neg = false;
            if (n2.isNegative() && base.isPositive()) {
              neg = true;
              n2 = n2.abs();
            }
            if (base.equals(1)) {
              if (n2.isZero()) return { value: [0], isNegative: false };
              return { value: Array.apply(null, Array(+n2)).map(Number.prototype.valueOf, 1), isNegative: neg };
            }
            var out = [];
            var left = n2, divmod;
            while (left.isNegative() || left.compareAbs(base) >= 0) {
              divmod = left.divmod(base);
              left = divmod.quotient;
              var digit = divmod.remainder;
              if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
              }
              out.push(digit.toJSNumber());
            }
            out.push(left.toJSNumber());
            return { value: out.reverse(), isNegative: neg };
          }
          function toBaseString(n2, base) {
            var arr = toBase(n2, base);
            return (arr.isNegative ? "-" : "") + arr.value.map(stringify).join("");
          }
          BigInteger.prototype.toArray = function(radix) {
            return toBase(this, radix);
          };
          SmallInteger.prototype.toArray = function(radix) {
            return toBase(this, radix);
          };
          BigInteger.prototype.toString = function(radix) {
            if (radix === undefined2) radix = 10;
            if (radix !== 10) return toBaseString(this, radix);
            var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
            while (--l >= 0) {
              digit = String(v[l]);
              str += zeros.slice(digit.length) + digit;
            }
            var sign = this.sign ? "-" : "";
            return sign + str;
          };
          SmallInteger.prototype.toString = function(radix) {
            if (radix === undefined2) radix = 10;
            if (radix != 10) return toBaseString(this, radix);
            return String(this.value);
          };
          BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function() {
            return this.toString();
          };
          BigInteger.prototype.valueOf = function() {
            return parseInt(this.toString(), 10);
          };
          BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;
          SmallInteger.prototype.valueOf = function() {
            return this.value;
          };
          SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
          function parseStringValue(v) {
            if (isPrecise(+v)) {
              var x = +v;
              if (x === truncate(x)) return new SmallInteger(x);
              throw new Error("Invalid integer: " + v);
            }
            var sign = v[0] === "-";
            if (sign) v = v.slice(1);
            var split = v.split(/e/i);
            if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
            if (split.length === 2) {
              var exp = split[1];
              if (exp[0] === "+") exp = exp.slice(1);
              exp = +exp;
              if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
              var text = split[0];
              var decimalPlace = text.indexOf(".");
              if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
              }
              if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
              text += new Array(exp + 1).join("0");
              v = text;
            }
            var isValid2 = /^([0-9][0-9]*)$/.test(v);
            if (!isValid2) throw new Error("Invalid integer: " + v);
            var r = [], max2 = v.length, l = LOG_BASE, min2 = max2 - l;
            while (max2 > 0) {
              r.push(+v.slice(min2, max2));
              min2 -= l;
              if (min2 < 0) min2 = 0;
              max2 -= l;
            }
            trim(r);
            return new BigInteger(r, sign);
          }
          function parseNumberValue(v) {
            if (isPrecise(v)) {
              if (v !== truncate(v)) throw new Error(v + " is not an integer.");
              return new SmallInteger(v);
            }
            return parseStringValue(v.toString());
          }
          function parseValue(v) {
            if (typeof v === "number") {
              return parseNumberValue(v);
            }
            if (typeof v === "string") {
              return parseStringValue(v);
            }
            return v;
          }
          for (var i = 0; i < 1e3; i++) {
            Integer[i] = new SmallInteger(i);
            if (i > 0) Integer[-i] = new SmallInteger(-i);
          }
          Integer.one = Integer[1];
          Integer.zero = Integer[0];
          Integer.minusOne = Integer[-1];
          Integer.max = max;
          Integer.min = min;
          Integer.gcd = gcd;
          Integer.lcm = lcm;
          Integer.isInstance = function(x) {
            return x instanceof BigInteger || x instanceof SmallInteger;
          };
          Integer.randBetween = randBetween;
          Integer.fromArray = function(digits, base, isNegative) {
            return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
          };
          return Integer;
        })();
        if (typeof module2 !== "undefined" && module2.hasOwnProperty("exports")) {
          module2.exports = bigInt;
        }
        if (typeof define === "function" && define.amd) {
          define("big-integer", [], function() {
            return bigInt;
          });
        }
        return bigInt;
      })(),
      /*
       *  decimal.js v10.2.1
       *  An arbitrary-precision Decimal type for JavaScript.
       *  https://github.com/MikeMcl/decimal.js
       *  Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>
       *  MIT Licence
       */
      bigDec: (function(n2) {
        "use strict";
        var e, i, t, r, s = 9e15, o = 1e9, u = "0123456789abcdef", c = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", f = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", a = { precision: 20, rounding: 4, modulo: 1, toExpNeg: -7, toExpPos: 21, minE: -s, maxE: s, crypto: false }, h = true, d = "[DecimalError] ", l = d + "Invalid argument: ", p = d + "Precision limit exceeded", g = d + "crypto unavailable", m = Math.floor, w = Math.pow, v = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, N = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, b = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, E = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, x = 1e7, y = 7, M = c.length - 1, q = f.length - 1, O = { name: "[object Decimal]" };
        function D(n3) {
          var e2, i2, t2, r2 = n3.length - 1, s2 = "", o2 = n3[0];
          if (r2 > 0) {
            for (s2 += o2, e2 = 1; e2 < r2; e2++) t2 = n3[e2] + "", (i2 = y - t2.length) && (s2 += k(i2)), s2 += t2;
            o2 = n3[e2], (i2 = y - (t2 = o2 + "").length) && (s2 += k(i2));
          } else if (0 === o2) return "0";
          for (; o2 % 10 == 0; ) o2 /= 10;
          return s2 + o2;
        }
        function F(n3, e2, i2) {
          if (n3 !== ~~n3 || n3 < e2 || n3 > i2) throw Error(l + n3);
        }
        function A(n3, e2, i2, t2) {
          var r2, s2, o2, u2;
          for (s2 = n3[0]; s2 >= 10; s2 /= 10) --e2;
          return --e2 < 0 ? (e2 += y, r2 = 0) : (r2 = Math.ceil((e2 + 1) / y), e2 %= y), s2 = w(10, y - e2), u2 = n3[r2] % s2 | 0, null == t2 ? e2 < 3 ? (0 == e2 ? u2 = u2 / 100 | 0 : 1 == e2 && (u2 = u2 / 10 | 0), o2 = i2 < 4 && 99999 == u2 || i2 > 3 && 49999 == u2 || 5e4 == u2 || 0 == u2) : o2 = (i2 < 4 && u2 + 1 == s2 || i2 > 3 && u2 + 1 == s2 / 2) && (n3[r2 + 1] / s2 / 100 | 0) == w(10, e2 - 2) - 1 || (u2 == s2 / 2 || 0 == u2) && 0 == (n3[r2 + 1] / s2 / 100 | 0) : e2 < 4 ? (0 == e2 ? u2 = u2 / 1e3 | 0 : 1 == e2 ? u2 = u2 / 100 | 0 : 2 == e2 && (u2 = u2 / 10 | 0), o2 = (t2 || i2 < 4) && 9999 == u2 || !t2 && i2 > 3 && 4999 == u2) : o2 = ((t2 || i2 < 4) && u2 + 1 == s2 || !t2 && i2 > 3 && u2 + 1 == s2 / 2) && (n3[r2 + 1] / s2 / 1e3 | 0) == w(10, e2 - 3) - 1, o2;
        }
        function S(n3, e2, i2) {
          for (var t2, r2, s2 = [0], o2 = 0, c2 = n3.length; o2 < c2; ) {
            for (r2 = s2.length; r2--; ) s2[r2] *= e2;
            for (s2[0] += u.indexOf(n3.charAt(o2++)), t2 = 0; t2 < s2.length; t2++) s2[t2] > i2 - 1 && (void 0 === s2[t2 + 1] && (s2[t2 + 1] = 0), s2[t2 + 1] += s2[t2] / i2 | 0, s2[t2] %= i2);
          }
          return s2.reverse();
        }
        O.absoluteValue = O.abs = function() {
          var n3 = new this.constructor(this);
          return n3.s < 0 && (n3.s = 1), P(n3);
        }, O.ceil = function() {
          return P(new this.constructor(this), this.e + 1, 2);
        }, O.comparedTo = O.cmp = function(n3) {
          var e2, i2, t2, r2, s2 = this, o2 = s2.d, u2 = (n3 = new s2.constructor(n3)).d, c2 = s2.s, f2 = n3.s;
          if (!o2 || !u2) return c2 && f2 ? c2 !== f2 ? c2 : o2 === u2 ? 0 : !o2 ^ c2 < 0 ? 1 : -1 : NaN;
          if (!o2[0] || !u2[0]) return o2[0] ? c2 : u2[0] ? -f2 : 0;
          if (c2 !== f2) return c2;
          if (s2.e !== n3.e) return s2.e > n3.e ^ c2 < 0 ? 1 : -1;
          for (e2 = 0, i2 = (t2 = o2.length) < (r2 = u2.length) ? t2 : r2; e2 < i2; ++e2) if (o2[e2] !== u2[e2]) return o2[e2] > u2[e2] ^ c2 < 0 ? 1 : -1;
          return t2 === r2 ? 0 : t2 > r2 ^ c2 < 0 ? 1 : -1;
        }, O.cosine = O.cos = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return i2.d ? i2.d[0] ? (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + Math.max(i2.e, i2.sd()) + y, t2.rounding = 1, i2 = (function(n4, e3) {
            var i3, t3, r2 = e3.d.length;
            r2 < 32 ? (i3 = Math.ceil(r2 / 3), t3 = (1 / z(4, i3)).toString()) : (i3 = 16, t3 = "2.3283064365386962890625e-10");
            n4.precision += i3, e3 = J(n4, 1, e3.times(t3), new n4(1));
            for (var s2 = i3; s2--; ) {
              var o2 = e3.times(e3);
              e3 = o2.times(o2).minus(o2).times(8).plus(1);
            }
            return n4.precision -= i3, e3;
          })(t2, G(t2, i2)), t2.precision = n3, t2.rounding = e2, P(2 == r || 3 == r ? i2.neg() : i2, n3, e2, true)) : new t2(1) : new t2(NaN);
        }, O.cubeRoot = O.cbrt = function() {
          var n3, e2, i2, t2, r2, s2, o2, u2, c2, f2, a2 = this, d2 = a2.constructor;
          if (!a2.isFinite() || a2.isZero()) return new d2(a2);
          for (h = false, (s2 = a2.s * w(a2.s * a2, 1 / 3)) && Math.abs(s2) != 1 / 0 ? t2 = new d2(s2.toString()) : (i2 = D(a2.d), (s2 = ((n3 = a2.e) - i2.length + 1) % 3) && (i2 += 1 == s2 || -2 == s2 ? "0" : "00"), s2 = w(i2, 1 / 3), n3 = m((n3 + 1) / 3) - (n3 % 3 == (n3 < 0 ? -1 : 2)), (t2 = new d2(i2 = s2 == 1 / 0 ? "5e" + n3 : (i2 = s2.toExponential()).slice(0, i2.indexOf("e") + 1) + n3)).s = a2.s), o2 = (n3 = d2.precision) + 3; ; ) if (f2 = (c2 = (u2 = t2).times(u2).times(u2)).plus(a2), t2 = Z(f2.plus(a2).times(u2), f2.plus(c2), o2 + 2, 1), D(u2.d).slice(0, o2) === (i2 = D(t2.d)).slice(0, o2)) {
            if ("9999" != (i2 = i2.slice(o2 - 3, o2 + 1)) && (r2 || "4999" != i2)) {
              +i2 && (+i2.slice(1) || "5" != i2.charAt(0)) || (P(t2, n3 + 1, 1), e2 = !t2.times(t2).times(t2).eq(a2));
              break;
            }
            if (!r2 && (P(u2, n3 + 1, 0), u2.times(u2).times(u2).eq(a2))) {
              t2 = u2;
              break;
            }
            o2 += 4, r2 = 1;
          }
          return h = true, P(t2, n3, d2.rounding, e2);
        }, O.decimalPlaces = O.dp = function() {
          var n3, e2 = this.d, i2 = NaN;
          if (e2) {
            if (i2 = ((n3 = e2.length - 1) - m(this.e / y)) * y, n3 = e2[n3]) for (; n3 % 10 == 0; n3 /= 10) i2--;
            i2 < 0 && (i2 = 0);
          }
          return i2;
        }, O.dividedBy = O.div = function(n3) {
          return Z(this, new this.constructor(n3));
        }, O.dividedToIntegerBy = O.divToInt = function(n3) {
          var e2 = this.constructor;
          return P(Z(this, new e2(n3), 0, 1, 1), e2.precision, e2.rounding);
        }, O.equals = O.eq = function(n3) {
          return 0 === this.cmp(n3);
        }, O.floor = function() {
          return P(new this.constructor(this), this.e + 1, 3);
        }, O.greaterThan = O.gt = function(n3) {
          return this.cmp(n3) > 0;
        }, O.greaterThanOrEqualTo = O.gte = function(n3) {
          var e2 = this.cmp(n3);
          return 1 == e2 || 0 === e2;
        }, O.hyperbolicCosine = O.cosh = function() {
          var n3, e2, i2, t2, r2, s2 = this, o2 = s2.constructor, u2 = new o2(1);
          if (!s2.isFinite()) return new o2(s2.s ? 1 / 0 : NaN);
          if (s2.isZero()) return u2;
          i2 = o2.precision, t2 = o2.rounding, o2.precision = i2 + Math.max(s2.e, s2.sd()) + 4, o2.rounding = 1, (r2 = s2.d.length) < 32 ? e2 = (1 / z(4, n3 = Math.ceil(r2 / 3))).toString() : (n3 = 16, e2 = "2.3283064365386962890625e-10"), s2 = J(o2, 1, s2.times(e2), new o2(1), true);
          for (var c2, f2 = n3, a2 = new o2(8); f2--; ) c2 = s2.times(s2), s2 = u2.minus(c2.times(a2.minus(c2.times(a2))));
          return P(s2, o2.precision = i2, o2.rounding = t2, true);
        }, O.hyperbolicSine = O.sinh = function() {
          var n3, e2, i2, t2, r2 = this, s2 = r2.constructor;
          if (!r2.isFinite() || r2.isZero()) return new s2(r2);
          if (e2 = s2.precision, i2 = s2.rounding, s2.precision = e2 + Math.max(r2.e, r2.sd()) + 4, s2.rounding = 1, (t2 = r2.d.length) < 3) r2 = J(s2, 2, r2, r2, true);
          else {
            n3 = (n3 = 1.4 * Math.sqrt(t2)) > 16 ? 16 : 0 | n3, r2 = J(s2, 2, r2 = r2.times(1 / z(5, n3)), r2, true);
            for (var o2, u2 = new s2(5), c2 = new s2(16), f2 = new s2(20); n3--; ) o2 = r2.times(r2), r2 = r2.times(u2.plus(o2.times(c2.times(o2).plus(f2))));
          }
          return s2.precision = e2, s2.rounding = i2, P(r2, e2, i2, true);
        }, O.hyperbolicTangent = O.tanh = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return i2.isFinite() ? i2.isZero() ? new t2(i2) : (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + 7, t2.rounding = 1, Z(i2.sinh(), i2.cosh(), t2.precision = n3, t2.rounding = e2)) : new t2(i2.s);
        }, O.inverseCosine = O.acos = function() {
          var n3, e2 = this, i2 = e2.constructor, t2 = e2.abs().cmp(1), r2 = i2.precision, s2 = i2.rounding;
          return -1 !== t2 ? 0 === t2 ? e2.isNeg() ? U(i2, r2, s2) : new i2(0) : new i2(NaN) : e2.isZero() ? U(i2, r2 + 4, s2).times(0.5) : (i2.precision = r2 + 6, i2.rounding = 1, e2 = e2.asin(), n3 = U(i2, r2 + 4, s2).times(0.5), i2.precision = r2, i2.rounding = s2, n3.minus(e2));
        }, O.inverseHyperbolicCosine = O.acosh = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return i2.lte(1) ? new t2(i2.eq(1) ? 0 : NaN) : i2.isFinite() ? (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + Math.max(Math.abs(i2.e), i2.sd()) + 4, t2.rounding = 1, h = false, i2 = i2.times(i2).minus(1).sqrt().plus(i2), h = true, t2.precision = n3, t2.rounding = e2, i2.ln()) : new t2(i2);
        }, O.inverseHyperbolicSine = O.asinh = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return !i2.isFinite() || i2.isZero() ? new t2(i2) : (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + 2 * Math.max(Math.abs(i2.e), i2.sd()) + 6, t2.rounding = 1, h = false, i2 = i2.times(i2).plus(1).sqrt().plus(i2), h = true, t2.precision = n3, t2.rounding = e2, i2.ln());
        }, O.inverseHyperbolicTangent = O.atanh = function() {
          var n3, e2, i2, t2, r2 = this, s2 = r2.constructor;
          return r2.isFinite() ? r2.e >= 0 ? new s2(r2.abs().eq(1) ? r2.s / 0 : r2.isZero() ? r2 : NaN) : (n3 = s2.precision, e2 = s2.rounding, t2 = r2.sd(), Math.max(t2, n3) < 2 * -r2.e - 1 ? P(new s2(r2), n3, e2, true) : (s2.precision = i2 = t2 - r2.e, r2 = Z(r2.plus(1), new s2(1).minus(r2), i2 + n3, 1), s2.precision = n3 + 4, s2.rounding = 1, r2 = r2.ln(), s2.precision = n3, s2.rounding = e2, r2.times(0.5))) : new s2(NaN);
        }, O.inverseSine = O.asin = function() {
          var n3, e2, i2, t2, r2 = this, s2 = r2.constructor;
          return r2.isZero() ? new s2(r2) : (e2 = r2.abs().cmp(1), i2 = s2.precision, t2 = s2.rounding, -1 !== e2 ? 0 === e2 ? ((n3 = U(s2, i2 + 4, t2).times(0.5)).s = r2.s, n3) : new s2(NaN) : (s2.precision = i2 + 6, s2.rounding = 1, r2 = r2.div(new s2(1).minus(r2.times(r2)).sqrt().plus(1)).atan(), s2.precision = i2, s2.rounding = t2, r2.times(2)));
        }, O.inverseTangent = O.atan = function() {
          var n3, e2, i2, t2, r2, s2, o2, u2, c2, f2 = this, a2 = f2.constructor, d2 = a2.precision, l2 = a2.rounding;
          if (f2.isFinite()) {
            if (f2.isZero()) return new a2(f2);
            if (f2.abs().eq(1) && d2 + 4 <= q) return (o2 = U(a2, d2 + 4, l2).times(0.25)).s = f2.s, o2;
          } else {
            if (!f2.s) return new a2(NaN);
            if (d2 + 4 <= q) return (o2 = U(a2, d2 + 4, l2).times(0.5)).s = f2.s, o2;
          }
          for (a2.precision = u2 = d2 + 10, a2.rounding = 1, n3 = i2 = Math.min(28, u2 / y + 2 | 0); n3; --n3) f2 = f2.div(f2.times(f2).plus(1).sqrt().plus(1));
          for (h = false, e2 = Math.ceil(u2 / y), t2 = 1, c2 = f2.times(f2), o2 = new a2(f2), r2 = f2; -1 !== n3; ) if (r2 = r2.times(c2), s2 = o2.minus(r2.div(t2 += 2)), r2 = r2.times(c2), void 0 !== (o2 = s2.plus(r2.div(t2 += 2))).d[e2]) for (n3 = e2; o2.d[n3] === s2.d[n3] && n3--; ) ;
          return i2 && (o2 = o2.times(2 << i2 - 1)), h = true, P(o2, a2.precision = d2, a2.rounding = l2, true);
        }, O.isFinite = function() {
          return !!this.d;
        }, O.isInteger = O.isInt = function() {
          return !!this.d && m(this.e / y) > this.d.length - 2;
        }, O.isNaN = function() {
          return !this.s;
        }, O.isNegative = O.isNeg = function() {
          return this.s < 0;
        }, O.isPositive = O.isPos = function() {
          return this.s > 0;
        }, O.isZero = function() {
          return !!this.d && 0 === this.d[0];
        }, O.lessThan = O.lt = function(n3) {
          return this.cmp(n3) < 0;
        }, O.lessThanOrEqualTo = O.lte = function(n3) {
          return this.cmp(n3) < 1;
        }, O.logarithm = O.log = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2, c2, f2 = this.constructor, a2 = f2.precision, d2 = f2.rounding;
          if (null == n3) n3 = new f2(10), e2 = true;
          else {
            if (i2 = (n3 = new f2(n3)).d, n3.s < 0 || !i2 || !i2[0] || n3.eq(1)) return new f2(NaN);
            e2 = n3.eq(10);
          }
          if (i2 = this.d, this.s < 0 || !i2 || !i2[0] || this.eq(1)) return new f2(i2 && !i2[0] ? -1 / 0 : 1 != this.s ? NaN : i2 ? 0 : 1 / 0);
          if (e2) if (i2.length > 1) s2 = true;
          else {
            for (r2 = i2[0]; r2 % 10 == 0; ) r2 /= 10;
            s2 = 1 !== r2;
          }
          if (h = false, o2 = V(this, u2 = a2 + 5), t2 = e2 ? T(f2, u2 + 10) : V(n3, u2), A((c2 = Z(o2, t2, u2, 1)).d, r2 = a2, d2)) do {
            if (o2 = V(this, u2 += 10), t2 = e2 ? T(f2, u2 + 10) : V(n3, u2), c2 = Z(o2, t2, u2, 1), !s2) {
              +D(c2.d).slice(r2 + 1, r2 + 15) + 1 == 1e14 && (c2 = P(c2, a2 + 1, 0));
              break;
            }
          } while (A(c2.d, r2 += 10, d2));
          return h = true, P(c2, a2, d2);
        }, O.minus = O.sub = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2, c2, f2, a2, d2, l2, p2 = this, g2 = p2.constructor;
          if (n3 = new g2(n3), !p2.d || !n3.d) return p2.s && n3.s ? p2.d ? n3.s = -n3.s : n3 = new g2(n3.d || p2.s !== n3.s ? p2 : NaN) : n3 = new g2(NaN), n3;
          if (p2.s != n3.s) return n3.s = -n3.s, p2.plus(n3);
          if (f2 = p2.d, l2 = n3.d, u2 = g2.precision, c2 = g2.rounding, !f2[0] || !l2[0]) {
            if (l2[0]) n3.s = -n3.s;
            else {
              if (!f2[0]) return new g2(3 === c2 ? -0 : 0);
              n3 = new g2(p2);
            }
            return h ? P(n3, u2, c2) : n3;
          }
          if (i2 = m(n3.e / y), a2 = m(p2.e / y), f2 = f2.slice(), s2 = a2 - i2) {
            for ((d2 = s2 < 0) ? (e2 = f2, s2 = -s2, o2 = l2.length) : (e2 = l2, i2 = a2, o2 = f2.length), s2 > (t2 = Math.max(Math.ceil(u2 / y), o2) + 2) && (s2 = t2, e2.length = 1), e2.reverse(), t2 = s2; t2--; ) e2.push(0);
            e2.reverse();
          } else {
            for ((d2 = (t2 = f2.length) < (o2 = l2.length)) && (o2 = t2), t2 = 0; t2 < o2; t2++) if (f2[t2] != l2[t2]) {
              d2 = f2[t2] < l2[t2];
              break;
            }
            s2 = 0;
          }
          for (d2 && (e2 = f2, f2 = l2, l2 = e2, n3.s = -n3.s), o2 = f2.length, t2 = l2.length - o2; t2 > 0; --t2) f2[o2++] = 0;
          for (t2 = l2.length; t2 > s2; ) {
            if (f2[--t2] < l2[t2]) {
              for (r2 = t2; r2 && 0 === f2[--r2]; ) f2[r2] = x - 1;
              --f2[r2], f2[t2] += x;
            }
            f2[t2] -= l2[t2];
          }
          for (; 0 === f2[--o2]; ) f2.pop();
          for (; 0 === f2[0]; f2.shift()) --i2;
          return f2[0] ? (n3.d = f2, n3.e = L(f2, i2), h ? P(n3, u2, c2) : n3) : new g2(3 === c2 ? -0 : 0);
        }, O.modulo = O.mod = function(n3) {
          var e2, i2 = this, t2 = i2.constructor;
          return n3 = new t2(n3), !i2.d || !n3.s || n3.d && !n3.d[0] ? new t2(NaN) : !n3.d || i2.d && !i2.d[0] ? P(new t2(i2), t2.precision, t2.rounding) : (h = false, 9 == t2.modulo ? (e2 = Z(i2, n3.abs(), 0, 3, 1)).s *= n3.s : e2 = Z(i2, n3, 0, t2.modulo, 1), e2 = e2.times(n3), h = true, i2.minus(e2));
        }, O.naturalExponential = O.exp = function() {
          return B(this);
        }, O.naturalLogarithm = O.ln = function() {
          return V(this);
        }, O.negated = O.neg = function() {
          var n3 = new this.constructor(this);
          return n3.s = -n3.s, P(n3);
        }, O.plus = O.add = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2, c2, f2, a2, d2 = this, l2 = d2.constructor;
          if (n3 = new l2(n3), !d2.d || !n3.d) return d2.s && n3.s ? d2.d || (n3 = new l2(n3.d || d2.s === n3.s ? d2 : NaN)) : n3 = new l2(NaN), n3;
          if (d2.s != n3.s) return n3.s = -n3.s, d2.minus(n3);
          if (f2 = d2.d, a2 = n3.d, u2 = l2.precision, c2 = l2.rounding, !f2[0] || !a2[0]) return a2[0] || (n3 = new l2(d2)), h ? P(n3, u2, c2) : n3;
          if (s2 = m(d2.e / y), t2 = m(n3.e / y), f2 = f2.slice(), r2 = s2 - t2) {
            for (r2 < 0 ? (i2 = f2, r2 = -r2, o2 = a2.length) : (i2 = a2, t2 = s2, o2 = f2.length), r2 > (o2 = (s2 = Math.ceil(u2 / y)) > o2 ? s2 + 1 : o2 + 1) && (r2 = o2, i2.length = 1), i2.reverse(); r2--; ) i2.push(0);
            i2.reverse();
          }
          for ((o2 = f2.length) - (r2 = a2.length) < 0 && (r2 = o2, i2 = a2, a2 = f2, f2 = i2), e2 = 0; r2; ) e2 = (f2[--r2] = f2[r2] + a2[r2] + e2) / x | 0, f2[r2] %= x;
          for (e2 && (f2.unshift(e2), ++t2), o2 = f2.length; 0 == f2[--o2]; ) f2.pop();
          return n3.d = f2, n3.e = L(f2, t2), h ? P(n3, u2, c2) : n3;
        }, O.precision = O.sd = function(n3) {
          var e2, i2 = this;
          if (void 0 !== n3 && n3 !== !!n3 && 1 !== n3 && 0 !== n3) throw Error(l + n3);
          return i2.d ? (e2 = _(i2.d), n3 && i2.e + 1 > e2 && (e2 = i2.e + 1)) : e2 = NaN, e2;
        }, O.round = function() {
          var n3 = this, e2 = n3.constructor;
          return P(new e2(n3), n3.e + 1, e2.rounding);
        }, O.sine = O.sin = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return i2.isFinite() ? i2.isZero() ? new t2(i2) : (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + Math.max(i2.e, i2.sd()) + y, t2.rounding = 1, i2 = (function(n4, e3) {
            var i3, t3 = e3.d.length;
            if (t3 < 3) return J(n4, 2, e3, e3);
            i3 = (i3 = 1.4 * Math.sqrt(t3)) > 16 ? 16 : 0 | i3, e3 = e3.times(1 / z(5, i3)), e3 = J(n4, 2, e3, e3);
            for (var r2, s2 = new n4(5), o2 = new n4(16), u2 = new n4(20); i3--; ) r2 = e3.times(e3), e3 = e3.times(s2.plus(r2.times(o2.times(r2).minus(u2))));
            return e3;
          })(t2, G(t2, i2)), t2.precision = n3, t2.rounding = e2, P(r > 2 ? i2.neg() : i2, n3, e2, true)) : new t2(NaN);
        }, O.squareRoot = O.sqrt = function() {
          var n3, e2, i2, t2, r2, s2, o2 = this, u2 = o2.d, c2 = o2.e, f2 = o2.s, a2 = o2.constructor;
          if (1 !== f2 || !u2 || !u2[0]) return new a2(!f2 || f2 < 0 && (!u2 || u2[0]) ? NaN : u2 ? o2 : 1 / 0);
          for (h = false, 0 == (f2 = Math.sqrt(+o2)) || f2 == 1 / 0 ? (((e2 = D(u2)).length + c2) % 2 == 0 && (e2 += "0"), f2 = Math.sqrt(e2), c2 = m((c2 + 1) / 2) - (c2 < 0 || c2 % 2), t2 = new a2(e2 = f2 == 1 / 0 ? "5e" + c2 : (e2 = f2.toExponential()).slice(0, e2.indexOf("e") + 1) + c2)) : t2 = new a2(f2.toString()), i2 = (c2 = a2.precision) + 3; ; ) if (t2 = (s2 = t2).plus(Z(o2, s2, i2 + 2, 1)).times(0.5), D(s2.d).slice(0, i2) === (e2 = D(t2.d)).slice(0, i2)) {
            if ("9999" != (e2 = e2.slice(i2 - 3, i2 + 1)) && (r2 || "4999" != e2)) {
              +e2 && (+e2.slice(1) || "5" != e2.charAt(0)) || (P(t2, c2 + 1, 1), n3 = !t2.times(t2).eq(o2));
              break;
            }
            if (!r2 && (P(s2, c2 + 1, 0), s2.times(s2).eq(o2))) {
              t2 = s2;
              break;
            }
            i2 += 4, r2 = 1;
          }
          return h = true, P(t2, c2, a2.rounding, n3);
        }, O.tangent = O.tan = function() {
          var n3, e2, i2 = this, t2 = i2.constructor;
          return i2.isFinite() ? i2.isZero() ? new t2(i2) : (n3 = t2.precision, e2 = t2.rounding, t2.precision = n3 + 10, t2.rounding = 1, (i2 = i2.sin()).s = 1, i2 = Z(i2, new t2(1).minus(i2.times(i2)).sqrt(), n3 + 10, 0), t2.precision = n3, t2.rounding = e2, P(2 == r || 4 == r ? i2.neg() : i2, n3, e2, true)) : new t2(NaN);
        }, O.times = O.mul = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2, c2, f2, a2 = this, d2 = a2.constructor, l2 = a2.d, p2 = (n3 = new d2(n3)).d;
          if (n3.s *= a2.s, !(l2 && l2[0] && p2 && p2[0])) return new d2(!n3.s || l2 && !l2[0] && !p2 || p2 && !p2[0] && !l2 ? NaN : l2 && p2 ? 0 * n3.s : n3.s / 0);
          for (i2 = m(a2.e / y) + m(n3.e / y), (c2 = l2.length) < (f2 = p2.length) && (s2 = l2, l2 = p2, p2 = s2, o2 = c2, c2 = f2, f2 = o2), s2 = [], t2 = o2 = c2 + f2; t2--; ) s2.push(0);
          for (t2 = f2; --t2 >= 0; ) {
            for (e2 = 0, r2 = c2 + t2; r2 > t2; ) u2 = s2[r2] + p2[t2] * l2[r2 - t2 - 1] + e2, s2[r2--] = u2 % x | 0, e2 = u2 / x | 0;
            s2[r2] = (s2[r2] + e2) % x | 0;
          }
          for (; !s2[--o2]; ) s2.pop();
          return e2 ? ++i2 : s2.shift(), n3.d = s2, n3.e = L(s2, i2), h ? P(n3, d2.precision, d2.rounding) : n3;
        }, O.toBinary = function(n3, e2) {
          return K(this, 2, n3, e2);
        }, O.toDecimalPlaces = O.toDP = function(n3, e2) {
          var i2 = this, t2 = i2.constructor;
          return i2 = new t2(i2), void 0 === n3 ? i2 : (F(n3, 0, o), void 0 === e2 ? e2 = t2.rounding : F(e2, 0, 8), P(i2, n3 + i2.e + 1, e2));
        }, O.toExponential = function(n3, e2) {
          var i2, t2 = this, r2 = t2.constructor;
          return void 0 === n3 ? i2 = R(t2, true) : (F(n3, 0, o), void 0 === e2 ? e2 = r2.rounding : F(e2, 0, 8), i2 = R(t2 = P(new r2(t2), n3 + 1, e2), true, n3 + 1)), t2.isNeg() && !t2.isZero() ? "-" + i2 : i2;
        }, O.toFixed = function(n3, e2) {
          var i2, t2, r2 = this, s2 = r2.constructor;
          return void 0 === n3 ? i2 = R(r2) : (F(n3, 0, o), void 0 === e2 ? e2 = s2.rounding : F(e2, 0, 8), i2 = R(t2 = P(new s2(r2), n3 + r2.e + 1, e2), false, n3 + t2.e + 1)), r2.isNeg() && !r2.isZero() ? "-" + i2 : i2;
        }, O.toFraction = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2, c2, f2, a2, d2, p2, g2 = this, m2 = g2.d, v2 = g2.constructor;
          if (!m2) return new v2(g2);
          if (f2 = i2 = new v2(1), t2 = c2 = new v2(0), o2 = (s2 = (e2 = new v2(t2)).e = _(m2) - g2.e - 1) % y, e2.d[0] = w(10, o2 < 0 ? y + o2 : o2), null == n3) n3 = s2 > 0 ? e2 : f2;
          else {
            if (!(u2 = new v2(n3)).isInt() || u2.lt(f2)) throw Error(l + u2);
            n3 = u2.gt(e2) ? s2 > 0 ? e2 : f2 : u2;
          }
          for (h = false, u2 = new v2(D(m2)), a2 = v2.precision, v2.precision = s2 = m2.length * y * 2; d2 = Z(u2, e2, 0, 1, 1), 1 != (r2 = i2.plus(d2.times(t2))).cmp(n3); ) i2 = t2, t2 = r2, r2 = f2, f2 = c2.plus(d2.times(r2)), c2 = r2, r2 = e2, e2 = u2.minus(d2.times(r2)), u2 = r2;
          return r2 = Z(n3.minus(i2), t2, 0, 1, 1), c2 = c2.plus(r2.times(f2)), i2 = i2.plus(r2.times(t2)), c2.s = f2.s = g2.s, p2 = Z(f2, t2, s2, 1).minus(g2).abs().cmp(Z(c2, i2, s2, 1).minus(g2).abs()) < 1 ? [f2, t2] : [c2, i2], v2.precision = a2, h = true, p2;
        }, O.toHexadecimal = O.toHex = function(n3, e2) {
          return K(this, 16, n3, e2);
        }, O.toNearest = function(n3, e2) {
          var i2 = this, t2 = i2.constructor;
          if (i2 = new t2(i2), null == n3) {
            if (!i2.d) return i2;
            n3 = new t2(1), e2 = t2.rounding;
          } else {
            if (n3 = new t2(n3), void 0 === e2 ? e2 = t2.rounding : F(e2, 0, 8), !i2.d) return n3.s ? i2 : n3;
            if (!n3.d) return n3.s && (n3.s = i2.s), n3;
          }
          return n3.d[0] ? (h = false, i2 = Z(i2, n3, 0, e2, 1).times(n3), h = true, P(i2)) : (n3.s = i2.s, i2 = n3), i2;
        }, O.toNumber = function() {
          return +this;
        }, O.toOctal = function(n3, e2) {
          return K(this, 8, n3, e2);
        }, O.toPower = O.pow = function(n3) {
          var e2, i2, t2, r2, s2, o2, u2 = this, c2 = u2.constructor, f2 = +(n3 = new c2(n3));
          if (!(u2.d && n3.d && u2.d[0] && n3.d[0])) return new c2(w(+u2, f2));
          if ((u2 = new c2(u2)).eq(1)) return u2;
          if (t2 = c2.precision, s2 = c2.rounding, n3.eq(1)) return P(u2, t2, s2);
          if ((e2 = m(n3.e / y)) >= n3.d.length - 1 && (i2 = f2 < 0 ? -f2 : f2) <= 9007199254740991) return r2 = C(c2, u2, i2, t2), n3.s < 0 ? new c2(1).div(r2) : P(r2, t2, s2);
          if ((o2 = u2.s) < 0) {
            if (e2 < n3.d.length - 1) return new c2(NaN);
            if (0 == (1 & n3.d[e2]) && (o2 = 1), 0 == u2.e && 1 == u2.d[0] && 1 == u2.d.length) return u2.s = o2, u2;
          }
          return (e2 = 0 != (i2 = w(+u2, f2)) && isFinite(i2) ? new c2(i2 + "").e : m(f2 * (Math.log("0." + D(u2.d)) / Math.LN10 + u2.e + 1))) > c2.maxE + 1 || e2 < c2.minE - 1 ? new c2(e2 > 0 ? o2 / 0 : 0) : (h = false, c2.rounding = u2.s = 1, i2 = Math.min(12, (e2 + "").length), (r2 = B(n3.times(V(u2, t2 + i2)), t2)).d && A((r2 = P(r2, t2 + 5, 1)).d, t2, s2) && (e2 = t2 + 10, +D((r2 = P(B(n3.times(V(u2, e2 + i2)), e2), e2 + 5, 1)).d).slice(t2 + 1, t2 + 15) + 1 == 1e14 && (r2 = P(r2, t2 + 1, 0))), r2.s = o2, h = true, c2.rounding = s2, P(r2, t2, s2));
        }, O.toPrecision = function(n3, e2) {
          var i2, t2 = this, r2 = t2.constructor;
          return void 0 === n3 ? i2 = R(t2, t2.e <= r2.toExpNeg || t2.e >= r2.toExpPos) : (F(n3, 1, o), void 0 === e2 ? e2 = r2.rounding : F(e2, 0, 8), i2 = R(t2 = P(new r2(t2), n3, e2), n3 <= t2.e || t2.e <= r2.toExpNeg, n3)), t2.isNeg() && !t2.isZero() ? "-" + i2 : i2;
        }, O.toSignificantDigits = O.toSD = function(n3, e2) {
          var i2 = this.constructor;
          return void 0 === n3 ? (n3 = i2.precision, e2 = i2.rounding) : (F(n3, 1, o), void 0 === e2 ? e2 = i2.rounding : F(e2, 0, 8)), P(new i2(this), n3, e2);
        }, O.toString = function() {
          var n3 = this, e2 = n3.constructor, i2 = R(n3, n3.e <= e2.toExpNeg || n3.e >= e2.toExpPos);
          return n3.isNeg() && !n3.isZero() ? "-" + i2 : i2;
        }, O.truncated = O.trunc = function() {
          return P(new this.constructor(this), this.e + 1, 1);
        }, O.valueOf = O.toJSON = function() {
          var n3 = this, e2 = n3.constructor, i2 = R(n3, n3.e <= e2.toExpNeg || n3.e >= e2.toExpPos);
          return n3.isNeg() ? "-" + i2 : i2;
        };
        var Z = /* @__PURE__ */ (function() {
          function n3(n4, e3, i2) {
            var t3, r2 = 0, s2 = n4.length;
            for (n4 = n4.slice(); s2--; ) t3 = n4[s2] * e3 + r2, n4[s2] = t3 % i2 | 0, r2 = t3 / i2 | 0;
            return r2 && n4.unshift(r2), n4;
          }
          function e2(n4, e3, i2, t3) {
            var r2, s2;
            if (i2 != t3) s2 = i2 > t3 ? 1 : -1;
            else for (r2 = s2 = 0; r2 < i2; r2++) if (n4[r2] != e3[r2]) {
              s2 = n4[r2] > e3[r2] ? 1 : -1;
              break;
            }
            return s2;
          }
          function t2(n4, e3, i2, t3) {
            for (var r2 = 0; i2--; ) n4[i2] -= r2, r2 = n4[i2] < e3[i2] ? 1 : 0, n4[i2] = r2 * t3 + n4[i2] - e3[i2];
            for (; !n4[0] && n4.length > 1; ) n4.shift();
          }
          return function(r2, s2, o2, u2, c2, f2) {
            var a2, h2, d2, l2, p2, g2, w2, v2, N2, b2, E2, M2, q2, O2, D2, F5, A2, S2, Z2, R2, L2 = r2.constructor, T2 = r2.s == s2.s ? 1 : -1, U2 = r2.d, _2 = s2.d;
            if (!(U2 && U2[0] && _2 && _2[0])) return new L2(r2.s && s2.s && (U2 ? !_2 || U2[0] != _2[0] : _2) ? U2 && 0 == U2[0] || !_2 ? 0 * T2 : T2 / 0 : NaN);
            for (f2 ? (p2 = 1, h2 = r2.e - s2.e) : (f2 = x, p2 = y, h2 = m(r2.e / p2) - m(s2.e / p2)), Z2 = _2.length, A2 = U2.length, b2 = (N2 = new L2(T2)).d = [], d2 = 0; _2[d2] == (U2[d2] || 0); d2++) ;
            if (_2[d2] > (U2[d2] || 0) && h2--, null == o2 ? (O2 = o2 = L2.precision, u2 = L2.rounding) : O2 = c2 ? o2 + (r2.e - s2.e) + 1 : o2, O2 < 0) b2.push(1), g2 = true;
            else {
              if (O2 = O2 / p2 + 2 | 0, d2 = 0, 1 == Z2) {
                for (l2 = 0, _2 = _2[0], O2++; (d2 < A2 || l2) && O2--; d2++) D2 = l2 * f2 + (U2[d2] || 0), b2[d2] = D2 / _2 | 0, l2 = D2 % _2 | 0;
                g2 = l2 || d2 < A2;
              } else {
                for ((l2 = f2 / (_2[0] + 1) | 0) > 1 && (_2 = n3(_2, l2, f2), U2 = n3(U2, l2, f2), Z2 = _2.length, A2 = U2.length), F5 = Z2, M2 = (E2 = U2.slice(0, Z2)).length; M2 < Z2; ) E2[M2++] = 0;
                (R2 = _2.slice()).unshift(0), S2 = _2[0], _2[1] >= f2 / 2 && ++S2;
                do {
                  l2 = 0, (a2 = e2(_2, E2, Z2, M2)) < 0 ? (q2 = E2[0], Z2 != M2 && (q2 = q2 * f2 + (E2[1] || 0)), (l2 = q2 / S2 | 0) > 1 ? (l2 >= f2 && (l2 = f2 - 1), 1 == (a2 = e2(w2 = n3(_2, l2, f2), E2, v2 = w2.length, M2 = E2.length)) && (l2--, t2(w2, Z2 < v2 ? R2 : _2, v2, f2))) : (0 == l2 && (a2 = l2 = 1), w2 = _2.slice()), (v2 = w2.length) < M2 && w2.unshift(0), t2(E2, w2, M2, f2), -1 == a2 && (a2 = e2(_2, E2, Z2, M2 = E2.length)) < 1 && (l2++, t2(E2, Z2 < M2 ? R2 : _2, M2, f2)), M2 = E2.length) : 0 === a2 && (l2++, E2 = [0]), b2[d2++] = l2, a2 && E2[0] ? E2[M2++] = U2[F5] || 0 : (E2 = [U2[F5]], M2 = 1);
                } while ((F5++ < A2 || void 0 !== E2[0]) && O2--);
                g2 = void 0 !== E2[0];
              }
              b2[0] || b2.shift();
            }
            if (1 == p2) N2.e = h2, i = g2;
            else {
              for (d2 = 1, l2 = b2[0]; l2 >= 10; l2 /= 10) d2++;
              N2.e = d2 + h2 * p2 - 1, P(N2, c2 ? o2 + N2.e + 1 : o2, u2, g2);
            }
            return N2;
          };
        })();
        function P(n3, e2, i2, t2) {
          var r2, s2, o2, u2, c2, f2, a2, d2, l2, p2 = n3.constructor;
          n: if (null != e2) {
            if (!(d2 = n3.d)) return n3;
            for (r2 = 1, u2 = d2[0]; u2 >= 10; u2 /= 10) r2++;
            if ((s2 = e2 - r2) < 0) s2 += y, o2 = e2, c2 = (a2 = d2[l2 = 0]) / w(10, r2 - o2 - 1) % 10 | 0;
            else if ((l2 = Math.ceil((s2 + 1) / y)) >= (u2 = d2.length)) {
              if (!t2) break n;
              for (; u2++ <= l2; ) d2.push(0);
              a2 = c2 = 0, r2 = 1, o2 = (s2 %= y) - y + 1;
            } else {
              for (a2 = u2 = d2[l2], r2 = 1; u2 >= 10; u2 /= 10) r2++;
              c2 = (o2 = (s2 %= y) - y + r2) < 0 ? 0 : a2 / w(10, r2 - o2 - 1) % 10 | 0;
            }
            if (t2 = t2 || e2 < 0 || void 0 !== d2[l2 + 1] || (o2 < 0 ? a2 : a2 % w(10, r2 - o2 - 1)), f2 = i2 < 4 ? (c2 || t2) && (0 == i2 || i2 == (n3.s < 0 ? 3 : 2)) : c2 > 5 || 5 == c2 && (4 == i2 || t2 || 6 == i2 && (s2 > 0 ? o2 > 0 ? a2 / w(10, r2 - o2) : 0 : d2[l2 - 1]) % 10 & 1 || i2 == (n3.s < 0 ? 8 : 7)), e2 < 1 || !d2[0]) return d2.length = 0, f2 ? (e2 -= n3.e + 1, d2[0] = w(10, (y - e2 % y) % y), n3.e = -e2 || 0) : d2[0] = n3.e = 0, n3;
            if (0 == s2 ? (d2.length = l2, u2 = 1, l2--) : (d2.length = l2 + 1, u2 = w(10, y - s2), d2[l2] = o2 > 0 ? (a2 / w(10, r2 - o2) % w(10, o2) | 0) * u2 : 0), f2) for (; ; ) {
              if (0 == l2) {
                for (s2 = 1, o2 = d2[0]; o2 >= 10; o2 /= 10) s2++;
                for (o2 = d2[0] += u2, u2 = 1; o2 >= 10; o2 /= 10) u2++;
                s2 != u2 && (n3.e++, d2[0] == x && (d2[0] = 1));
                break;
              }
              if (d2[l2] += u2, d2[l2] != x) break;
              d2[l2--] = 0, u2 = 1;
            }
            for (s2 = d2.length; 0 === d2[--s2]; ) d2.pop();
          }
          return h && (n3.e > p2.maxE ? (n3.d = null, n3.e = NaN) : n3.e < p2.minE && (n3.e = 0, n3.d = [0])), n3;
        }
        function R(n3, e2, i2) {
          if (!n3.isFinite()) return j(n3);
          var t2, r2 = n3.e, s2 = D(n3.d), o2 = s2.length;
          return e2 ? (i2 && (t2 = i2 - o2) > 0 ? s2 = s2.charAt(0) + "." + s2.slice(1) + k(t2) : o2 > 1 && (s2 = s2.charAt(0) + "." + s2.slice(1)), s2 = s2 + (n3.e < 0 ? "e" : "e+") + n3.e) : r2 < 0 ? (s2 = "0." + k(-r2 - 1) + s2, i2 && (t2 = i2 - o2) > 0 && (s2 += k(t2))) : r2 >= o2 ? (s2 += k(r2 + 1 - o2), i2 && (t2 = i2 - r2 - 1) > 0 && (s2 = s2 + "." + k(t2))) : ((t2 = r2 + 1) < o2 && (s2 = s2.slice(0, t2) + "." + s2.slice(t2)), i2 && (t2 = i2 - o2) > 0 && (r2 + 1 === o2 && (s2 += "."), s2 += k(t2))), s2;
        }
        function L(n3, e2) {
          var i2 = n3[0];
          for (e2 *= y; i2 >= 10; i2 /= 10) e2++;
          return e2;
        }
        function T(n3, e2, i2) {
          if (e2 > M) throw h = true, i2 && (n3.precision = i2), Error(p);
          return P(new n3(c), e2, 1, true);
        }
        function U(n3, e2, i2) {
          if (e2 > q) throw Error(p);
          return P(new n3(f), e2, i2, true);
        }
        function _(n3) {
          var e2 = n3.length - 1, i2 = e2 * y + 1;
          if (e2 = n3[e2]) {
            for (; e2 % 10 == 0; e2 /= 10) i2--;
            for (e2 = n3[0]; e2 >= 10; e2 /= 10) i2++;
          }
          return i2;
        }
        function k(n3) {
          for (var e2 = ""; n3--; ) e2 += "0";
          return e2;
        }
        function C(n3, e2, i2, t2) {
          var r2, s2 = new n3(1), o2 = Math.ceil(t2 / y + 4);
          for (h = false; ; ) {
            if (i2 % 2 && Q((s2 = s2.times(e2)).d, o2) && (r2 = true), 0 === (i2 = m(i2 / 2))) {
              i2 = s2.d.length - 1, r2 && 0 === s2.d[i2] && ++s2.d[i2];
              break;
            }
            Q((e2 = e2.times(e2)).d, o2);
          }
          return h = true, s2;
        }
        function I(n3) {
          return 1 & n3.d[n3.d.length - 1];
        }
        function H(n3, e2, i2) {
          for (var t2, r2 = new n3(e2[0]), s2 = 0; ++s2 < e2.length; ) {
            if (!(t2 = new n3(e2[s2])).s) {
              r2 = t2;
              break;
            }
            r2[i2](t2) && (r2 = t2);
          }
          return r2;
        }
        function B(n3, e2) {
          var i2, t2, r2, s2, o2, u2, c2, f2 = 0, a2 = 0, d2 = 0, l2 = n3.constructor, p2 = l2.rounding, g2 = l2.precision;
          if (!n3.d || !n3.d[0] || n3.e > 17) return new l2(n3.d ? n3.d[0] ? n3.s < 0 ? 0 : 1 / 0 : 1 : n3.s ? n3.s < 0 ? 0 : n3 : NaN);
          for (null == e2 ? (h = false, c2 = g2) : c2 = e2, u2 = new l2(0.03125); n3.e > -2; ) n3 = n3.times(u2), d2 += 5;
          for (c2 += t2 = Math.log(w(2, d2)) / Math.LN10 * 2 + 5 | 0, i2 = s2 = o2 = new l2(1), l2.precision = c2; ; ) {
            if (s2 = P(s2.times(n3), c2, 1), i2 = i2.times(++a2), D((u2 = o2.plus(Z(s2, i2, c2, 1))).d).slice(0, c2) === D(o2.d).slice(0, c2)) {
              for (r2 = d2; r2--; ) o2 = P(o2.times(o2), c2, 1);
              if (null != e2) return l2.precision = g2, o2;
              if (!(f2 < 3 && A(o2.d, c2 - t2, p2, f2))) return P(o2, l2.precision = g2, p2, h = true);
              l2.precision = c2 += 10, i2 = s2 = u2 = new l2(1), a2 = 0, f2++;
            }
            o2 = u2;
          }
        }
        function V(n3, e2) {
          var i2, t2, r2, s2, o2, u2, c2, f2, a2, d2, l2, p2 = 1, g2 = n3, m2 = g2.d, w2 = g2.constructor, v2 = w2.rounding, N2 = w2.precision;
          if (g2.s < 0 || !m2 || !m2[0] || !g2.e && 1 == m2[0] && 1 == m2.length) return new w2(m2 && !m2[0] ? -1 / 0 : 1 != g2.s ? NaN : m2 ? 0 : g2);
          if (null == e2 ? (h = false, a2 = N2) : a2 = e2, w2.precision = a2 += 10, t2 = (i2 = D(m2)).charAt(0), !(Math.abs(s2 = g2.e) < 15e14)) return f2 = T(w2, a2 + 2, N2).times(s2 + ""), g2 = V(new w2(t2 + "." + i2.slice(1)), a2 - 10).plus(f2), w2.precision = N2, null == e2 ? P(g2, N2, v2, h = true) : g2;
          for (; t2 < 7 && 1 != t2 || 1 == t2 && i2.charAt(1) > 3; ) t2 = (i2 = D((g2 = g2.times(n3)).d)).charAt(0), p2++;
          for (s2 = g2.e, t2 > 1 ? (g2 = new w2("0." + i2), s2++) : g2 = new w2(t2 + "." + i2.slice(1)), d2 = g2, c2 = o2 = g2 = Z(g2.minus(1), g2.plus(1), a2, 1), l2 = P(g2.times(g2), a2, 1), r2 = 3; ; ) {
            if (o2 = P(o2.times(l2), a2, 1), D((f2 = c2.plus(Z(o2, new w2(r2), a2, 1))).d).slice(0, a2) === D(c2.d).slice(0, a2)) {
              if (c2 = c2.times(2), 0 !== s2 && (c2 = c2.plus(T(w2, a2 + 2, N2).times(s2 + ""))), c2 = Z(c2, new w2(p2), a2, 1), null != e2) return w2.precision = N2, c2;
              if (!A(c2.d, a2 - 10, v2, u2)) return P(c2, w2.precision = N2, v2, h = true);
              w2.precision = a2 += 10, f2 = o2 = g2 = Z(d2.minus(1), d2.plus(1), a2, 1), l2 = P(g2.times(g2), a2, 1), r2 = u2 = 1;
            }
            c2 = f2, r2 += 2;
          }
        }
        function j(n3) {
          return String(n3.s * n3.s / 0);
        }
        function $(n3, e2) {
          var i2, t2, r2;
          for ((i2 = e2.indexOf(".")) > -1 && (e2 = e2.replace(".", "")), (t2 = e2.search(/e/i)) > 0 ? (i2 < 0 && (i2 = t2), i2 += +e2.slice(t2 + 1), e2 = e2.substring(0, t2)) : i2 < 0 && (i2 = e2.length), t2 = 0; 48 === e2.charCodeAt(t2); t2++) ;
          for (r2 = e2.length; 48 === e2.charCodeAt(r2 - 1); --r2) ;
          if (e2 = e2.slice(t2, r2)) {
            if (r2 -= t2, n3.e = i2 = i2 - t2 - 1, n3.d = [], t2 = (i2 + 1) % y, i2 < 0 && (t2 += y), t2 < r2) {
              for (t2 && n3.d.push(+e2.slice(0, t2)), r2 -= y; t2 < r2; ) n3.d.push(+e2.slice(t2, t2 += y));
              e2 = e2.slice(t2), t2 = y - e2.length;
            } else t2 -= r2;
            for (; t2--; ) e2 += "0";
            n3.d.push(+e2), h && (n3.e > n3.constructor.maxE ? (n3.d = null, n3.e = NaN) : n3.e < n3.constructor.minE && (n3.e = 0, n3.d = [0]));
          } else n3.e = 0, n3.d = [0];
          return n3;
        }
        function W(n3, i2) {
          var t2, r2, s2, o2, u2, c2, f2, a2, d2;
          if ("Infinity" === i2 || "NaN" === i2) return +i2 || (n3.s = NaN), n3.e = NaN, n3.d = null, n3;
          if (N.test(i2)) t2 = 16, i2 = i2.toLowerCase();
          else if (v.test(i2)) t2 = 2;
          else {
            if (!b.test(i2)) throw Error(l + i2);
            t2 = 8;
          }
          for ((o2 = i2.search(/p/i)) > 0 ? (f2 = +i2.slice(o2 + 1), i2 = i2.substring(2, o2)) : i2 = i2.slice(2), u2 = (o2 = i2.indexOf(".")) >= 0, r2 = n3.constructor, u2 && (o2 = (c2 = (i2 = i2.replace(".", "")).length) - o2, s2 = C(r2, new r2(t2), o2, 2 * o2)), o2 = d2 = (a2 = S(i2, t2, x)).length - 1; 0 === a2[o2]; --o2) a2.pop();
          return o2 < 0 ? new r2(0 * n3.s) : (n3.e = L(a2, d2), n3.d = a2, h = false, u2 && (n3 = Z(n3, s2, 4 * c2)), f2 && (n3 = n3.times(Math.abs(f2) < 54 ? w(2, f2) : e.pow(2, f2))), h = true, n3);
        }
        function J(n3, e2, i2, t2, r2) {
          var s2, o2, u2, c2, f2 = n3.precision, a2 = Math.ceil(f2 / y);
          for (h = false, c2 = i2.times(i2), u2 = new n3(t2); ; ) {
            if (o2 = Z(u2.times(c2), new n3(e2++ * e2++), f2, 1), u2 = r2 ? t2.plus(o2) : t2.minus(o2), t2 = Z(o2.times(c2), new n3(e2++ * e2++), f2, 1), void 0 !== (o2 = u2.plus(t2)).d[a2]) {
              for (s2 = a2; o2.d[s2] === u2.d[s2] && s2--; ) ;
              if (-1 == s2) break;
            }
            s2 = u2, u2 = t2, t2 = o2, o2 = s2, 0;
          }
          return h = true, o2.d.length = a2 + 1, o2;
        }
        function z(n3, e2) {
          for (var i2 = n3; --e2; ) i2 *= n3;
          return i2;
        }
        function G(n3, e2) {
          var i2, t2 = e2.s < 0, s2 = U(n3, n3.precision, 1), o2 = s2.times(0.5);
          if ((e2 = e2.abs()).lte(o2)) return r = t2 ? 4 : 1, e2;
          if ((i2 = e2.divToInt(s2)).isZero()) r = t2 ? 3 : 2;
          else {
            if ((e2 = e2.minus(i2.times(s2))).lte(o2)) return r = I(i2) ? t2 ? 2 : 3 : t2 ? 4 : 1, e2;
            r = I(i2) ? t2 ? 1 : 4 : t2 ? 3 : 2;
          }
          return e2.minus(s2).abs();
        }
        function K(n3, e2, t2, r2) {
          var s2, c2, f2, a2, h2, d2, l2, p2, g2, m2 = n3.constructor, w2 = void 0 !== t2;
          if (w2 ? (F(t2, 1, o), void 0 === r2 ? r2 = m2.rounding : F(r2, 0, 8)) : (t2 = m2.precision, r2 = m2.rounding), n3.isFinite()) {
            for (w2 ? (s2 = 2, 16 == e2 ? t2 = 4 * t2 - 3 : 8 == e2 && (t2 = 3 * t2 - 2)) : s2 = e2, (f2 = (l2 = R(n3)).indexOf(".")) >= 0 && (l2 = l2.replace(".", ""), (g2 = new m2(1)).e = l2.length - f2, g2.d = S(R(g2), 10, s2), g2.e = g2.d.length), c2 = h2 = (p2 = S(l2, 10, s2)).length; 0 == p2[--h2]; ) p2.pop();
            if (p2[0]) {
              if (f2 < 0 ? c2-- : ((n3 = new m2(n3)).d = p2, n3.e = c2, p2 = (n3 = Z(n3, g2, t2, r2, 0, s2)).d, c2 = n3.e, d2 = i), f2 = p2[t2], a2 = s2 / 2, d2 = d2 || void 0 !== p2[t2 + 1], d2 = r2 < 4 ? (void 0 !== f2 || d2) && (0 === r2 || r2 === (n3.s < 0 ? 3 : 2)) : f2 > a2 || f2 === a2 && (4 === r2 || d2 || 6 === r2 && 1 & p2[t2 - 1] || r2 === (n3.s < 0 ? 8 : 7)), p2.length = t2, d2) for (; ++p2[--t2] > s2 - 1; ) p2[t2] = 0, t2 || (++c2, p2.unshift(1));
              for (h2 = p2.length; !p2[h2 - 1]; --h2) ;
              for (f2 = 0, l2 = ""; f2 < h2; f2++) l2 += u.charAt(p2[f2]);
              if (w2) {
                if (h2 > 1) if (16 == e2 || 8 == e2) {
                  for (f2 = 16 == e2 ? 4 : 3, --h2; h2 % f2; h2++) l2 += "0";
                  for (h2 = (p2 = S(l2, s2, e2)).length; !p2[h2 - 1]; --h2) ;
                  for (f2 = 1, l2 = "1."; f2 < h2; f2++) l2 += u.charAt(p2[f2]);
                } else l2 = l2.charAt(0) + "." + l2.slice(1);
                l2 = l2 + (c2 < 0 ? "p" : "p+") + c2;
              } else if (c2 < 0) {
                for (; ++c2; ) l2 = "0" + l2;
                l2 = "0." + l2;
              } else if (++c2 > h2) for (c2 -= h2; c2--; ) l2 += "0";
              else c2 < h2 && (l2 = l2.slice(0, c2) + "." + l2.slice(c2));
            } else l2 = w2 ? "0p+0" : "0";
            l2 = (16 == e2 ? "0x" : 2 == e2 ? "0b" : 8 == e2 ? "0o" : "") + l2;
          } else l2 = j(n3);
          return n3.s < 0 ? "-" + l2 : l2;
        }
        function Q(n3, e2) {
          if (n3.length > e2) return n3.length = e2, true;
        }
        function X(n3) {
          return new this(n3).abs();
        }
        function Y(n3) {
          return new this(n3).acos();
        }
        function nn(n3) {
          return new this(n3).acosh();
        }
        function en(n3, e2) {
          return new this(n3).plus(e2);
        }
        function tn(n3) {
          return new this(n3).asin();
        }
        function rn(n3) {
          return new this(n3).asinh();
        }
        function sn(n3) {
          return new this(n3).atan();
        }
        function on(n3) {
          return new this(n3).atanh();
        }
        function un(n3, e2) {
          n3 = new this(n3), e2 = new this(e2);
          var i2, t2 = this.precision, r2 = this.rounding, s2 = t2 + 4;
          return n3.s && e2.s ? n3.d || e2.d ? !e2.d || n3.isZero() ? (i2 = e2.s < 0 ? U(this, t2, r2) : new this(0)).s = n3.s : !n3.d || e2.isZero() ? (i2 = U(this, s2, 1).times(0.5)).s = n3.s : e2.s < 0 ? (this.precision = s2, this.rounding = 1, i2 = this.atan(Z(n3, e2, s2, 1)), e2 = U(this, s2, 1), this.precision = t2, this.rounding = r2, i2 = n3.s < 0 ? i2.minus(e2) : i2.plus(e2)) : i2 = this.atan(Z(n3, e2, s2, 1)) : (i2 = U(this, s2, 1).times(e2.s > 0 ? 0.25 : 0.75)).s = n3.s : i2 = new this(NaN), i2;
        }
        function cn(n3) {
          return new this(n3).cbrt();
        }
        function fn(n3) {
          return P(n3 = new this(n3), n3.e + 1, 2);
        }
        function an(n3) {
          if (!n3 || "object" != typeof n3) throw Error(d + "Object expected");
          var e2, i2, t2, r2 = true === n3.defaults, u2 = ["precision", 1, o, "rounding", 0, 8, "toExpNeg", -s, 0, "toExpPos", 0, s, "maxE", 0, s, "minE", -s, 0, "modulo", 0, 9];
          for (e2 = 0; e2 < u2.length; e2 += 3) if (i2 = u2[e2], r2 && (this[i2] = a[i2]), void 0 !== (t2 = n3[i2])) {
            if (!(m(t2) === t2 && t2 >= u2[e2 + 1] && t2 <= u2[e2 + 2])) throw Error(l + i2 + ": " + t2);
            this[i2] = t2;
          }
          if (i2 = "crypto", r2 && (this[i2] = a[i2]), void 0 !== (t2 = n3[i2])) {
            if (true !== t2 && false !== t2 && 0 !== t2 && 1 !== t2) throw Error(l + i2 + ": " + t2);
            if (t2) {
              if ("undefined" == typeof crypto || !crypto || !crypto.getRandomValues && !crypto.randomBytes) throw Error(g);
              this[i2] = true;
            } else this[i2] = false;
          }
          return this;
        }
        function hn(n3) {
          return new this(n3).cos();
        }
        function dn(n3) {
          return new this(n3).cosh();
        }
        function ln(n3, e2) {
          return new this(n3).div(e2);
        }
        function pn(n3) {
          return new this(n3).exp();
        }
        function gn(n3) {
          return P(n3 = new this(n3), n3.e + 1, 3);
        }
        function mn() {
          var n3, e2, i2 = new this(0);
          for (h = false, n3 = 0; n3 < arguments.length; ) if ((e2 = new this(arguments[n3++])).d) i2.d && (i2 = i2.plus(e2.times(e2)));
          else {
            if (e2.s) return h = true, new this(1 / 0);
            i2 = e2;
          }
          return h = true, i2.sqrt();
        }
        function wn(n3) {
          return n3 instanceof e || n3 && "[object Decimal]" === n3.name || false;
        }
        function vn(n3) {
          return new this(n3).ln();
        }
        function Nn(n3, e2) {
          return new this(n3).log(e2);
        }
        function bn(n3) {
          return new this(n3).log(2);
        }
        function En(n3) {
          return new this(n3).log(10);
        }
        function xn() {
          return H(this, arguments, "lt");
        }
        function yn() {
          return H(this, arguments, "gt");
        }
        function Mn(n3, e2) {
          return new this(n3).mod(e2);
        }
        function qn(n3, e2) {
          return new this(n3).mul(e2);
        }
        function On(n3, e2) {
          return new this(n3).pow(e2);
        }
        function Dn(n3) {
          var e2, i2, t2, r2, s2 = 0, u2 = new this(1), c2 = [];
          if (void 0 === n3 ? n3 = this.precision : F(n3, 1, o), t2 = Math.ceil(n3 / y), this.crypto) if (crypto.getRandomValues) for (e2 = crypto.getRandomValues(new Uint32Array(t2)); s2 < t2; ) (r2 = e2[s2]) >= 429e7 ? e2[s2] = crypto.getRandomValues(new Uint32Array(1))[0] : c2[s2++] = r2 % 1e7;
          else {
            if (!crypto.randomBytes) throw Error(g);
            for (e2 = crypto.randomBytes(t2 *= 4); s2 < t2; ) (r2 = e2[s2] + (e2[s2 + 1] << 8) + (e2[s2 + 2] << 16) + ((127 & e2[s2 + 3]) << 24)) >= 214e7 ? crypto.randomBytes(4).copy(e2, s2) : (c2.push(r2 % 1e7), s2 += 4);
            s2 = t2 / 4;
          }
          else for (; s2 < t2; ) c2[s2++] = 1e7 * Math.random() | 0;
          for (t2 = c2[--s2], n3 %= y, t2 && n3 && (r2 = w(10, y - n3), c2[s2] = (t2 / r2 | 0) * r2); 0 === c2[s2]; s2--) c2.pop();
          if (s2 < 0) i2 = 0, c2 = [0];
          else {
            for (i2 = -1; 0 === c2[0]; i2 -= y) c2.shift();
            for (t2 = 1, r2 = c2[0]; r2 >= 10; r2 /= 10) t2++;
            t2 < y && (i2 -= y - t2);
          }
          return u2.e = i2, u2.d = c2, u2;
        }
        function Fn(n3) {
          return P(n3 = new this(n3), n3.e + 1, this.rounding);
        }
        function An(n3) {
          return (n3 = new this(n3)).d ? n3.d[0] ? n3.s : 0 * n3.s : n3.s || NaN;
        }
        function Sn(n3) {
          return new this(n3).sin();
        }
        function Zn(n3) {
          return new this(n3).sinh();
        }
        function Pn(n3) {
          return new this(n3).sqrt();
        }
        function Rn(n3, e2) {
          return new this(n3).sub(e2);
        }
        function Ln(n3) {
          return new this(n3).tan();
        }
        function Tn(n3) {
          return new this(n3).tanh();
        }
        function Un(n3) {
          return P(n3 = new this(n3), n3.e + 1, 1);
        }
        return (e = (function n3(e2) {
          var i2, t2, r2;
          function s2(n4) {
            var e3, i3, t3, r3 = this;
            if (!(r3 instanceof s2)) return new s2(n4);
            if (r3.constructor = s2, n4 instanceof s2) return r3.s = n4.s, void (h ? !n4.d || n4.e > s2.maxE ? (r3.e = NaN, r3.d = null) : n4.e < s2.minE ? (r3.e = 0, r3.d = [0]) : (r3.e = n4.e, r3.d = n4.d.slice()) : (r3.e = n4.e, r3.d = n4.d ? n4.d.slice() : n4.d));
            if ("number" == (t3 = typeof n4)) {
              if (0 === n4) return r3.s = 1 / n4 < 0 ? -1 : 1, r3.e = 0, void (r3.d = [0]);
              if (n4 < 0 ? (n4 = -n4, r3.s = -1) : r3.s = 1, n4 === ~~n4 && n4 < 1e7) {
                for (e3 = 0, i3 = n4; i3 >= 10; i3 /= 10) e3++;
                return void (h ? e3 > s2.maxE ? (r3.e = NaN, r3.d = null) : e3 < s2.minE ? (r3.e = 0, r3.d = [0]) : (r3.e = e3, r3.d = [n4]) : (r3.e = e3, r3.d = [n4]));
              }
              return 0 * n4 != 0 ? (n4 || (r3.s = NaN), r3.e = NaN, void (r3.d = null)) : $(r3, n4.toString());
            }
            if ("string" !== t3) throw Error(l + n4);
            return 45 === (i3 = n4.charCodeAt(0)) ? (n4 = n4.slice(1), r3.s = -1) : (43 === i3 && (n4 = n4.slice(1)), r3.s = 1), E.test(n4) ? $(r3, n4) : W(r3, n4);
          }
          if (s2.prototype = O, s2.ROUND_UP = 0, s2.ROUND_DOWN = 1, s2.ROUND_CEIL = 2, s2.ROUND_FLOOR = 3, s2.ROUND_HALF_UP = 4, s2.ROUND_HALF_DOWN = 5, s2.ROUND_HALF_EVEN = 6, s2.ROUND_HALF_CEIL = 7, s2.ROUND_HALF_FLOOR = 8, s2.EUCLID = 9, s2.config = s2.set = an, s2.clone = n3, s2.isDecimal = wn, s2.abs = X, s2.acos = Y, s2.acosh = nn, s2.add = en, s2.asin = tn, s2.asinh = rn, s2.atan = sn, s2.atanh = on, s2.atan2 = un, s2.cbrt = cn, s2.ceil = fn, s2.cos = hn, s2.cosh = dn, s2.div = ln, s2.exp = pn, s2.floor = gn, s2.hypot = mn, s2.ln = vn, s2.log = Nn, s2.log10 = En, s2.log2 = bn, s2.max = xn, s2.min = yn, s2.mod = Mn, s2.mul = qn, s2.pow = On, s2.random = Dn, s2.round = Fn, s2.sign = An, s2.sin = Sn, s2.sinh = Zn, s2.sqrt = Pn, s2.sub = Rn, s2.tan = Ln, s2.tanh = Tn, s2.trunc = Un, void 0 === e2 && (e2 = {}), e2 && true !== e2.defaults) for (r2 = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"], i2 = 0; i2 < r2.length; ) e2.hasOwnProperty(t2 = r2[i2++]) || (e2[t2] = this[t2]);
          return s2.config(e2), s2;
        })(a)).default = e.Decimal = e, c = new e(c), f = new e(f), "function" == typeof define && define.amd ? define(function() {
          return e;
        }) : "undefined" != typeof module2 && module2.exports ? ("function" == typeof Symbol && "symbol" == typeof Symbol.iterator && (O[Symbol.for("nodejs.util.inspect.custom")] = O.toString, O[Symbol.toStringTag] = "Decimal"), module2.exports = e) : (n2 || (n2 = "undefined" != typeof self && self && self.self == self ? self : window), t = n2.Decimal, e.noConflict = function() {
          return n2.Decimal = t, e;
        }, n2.Decimal = e), e;
      })(exports2)
      //    bigDec: require('decimal.js')
    });
    if (typeof module2 !== "undefined") {
      module2.exports = nerdamer3;
    }
  }
});

// node_modules/nerdamer/Algebra.js
var require_Algebra = __commonJS({
  "node_modules/nerdamer/Algebra.js"(exports2, module2) {
    if (typeof module2 !== "undefined") {
      nerdamer3 = require_nerdamer_core();
      require_Calculus();
    }
    var nerdamer3;
    (function() {
      "use strict";
      var core = nerdamer3.getCore(), _ = core.PARSER, N = core.groups.N, P = core.groups.P, S = core.groups.S, EX = core.groups.EX, FN = core.groups.FN, PL = core.groups.PL, CP = core.groups.CP, CB = core.groups.CB, keys = core.Utils.keys, even = core.Utils.even, variables = core.Utils.variables, format = core.Utils.format, round = core.Utils.round, Frac = core.Frac, isInt = core.Utils.isInt, Symbol2 = core.Symbol, CONST_HASH = core.Settings.CONST_HASH, math = core.Utils.importFunctions(), evaluate = core.Utils.evaluate;
      function Polynomial(symbol, variable, order) {
        if (core.Utils.isSymbol(symbol)) {
          this.parse(symbol);
          this.variable = this.variable || variable;
        } else if (!isNaN(symbol)) {
          order = order || 0;
          if (variable === void 0)
            throw new core.exceptions.InvalidVariableNameError("Polynomial expects a variable name when creating using order");
          this.coeffs = [];
          this.coeffs[order] = symbol;
          this.fill(symbol);
        } else if (typeof symbol === "string") {
          this.parse(_.parse(symbol));
        }
      }
      Polynomial.fromArray = function(arr, variable) {
        if (typeof variable === "undefined")
          throw new core.exceptions.InvalidVariableNameError("A variable name must be specified when creating polynomial from array");
        var p = new Polynomial();
        p.coeffs = arr;
        p.variable = variable;
        return p;
      };
      Polynomial.fit = function(c1, c2, n2, base, p, variable) {
        var terms = new Array(p + 1), t = n2 - c2;
        terms[0] = c2;
        terms[p] = c1;
        t -= c1 * Math.pow(base, p);
        for (var i = p - 1; i > 0; i--) {
          var b = Math.pow(base, i), q = t / b, sign = Math.sign(q);
          var c = sign * Math.floor(Math.abs(q));
          t -= c * b;
          terms[i] = c;
        }
        if (t !== 0)
          return null;
        for (var i = 0; i < terms.length; i++)
          terms[i] = new Frac(terms[i]);
        return Polynomial.fromArray(terms, variable);
      };
      Polynomial.prototype = {
        /**
         * Converts Symbol to Polynomial
         * @param {Symbol} symbol
         * @param {Array} c - a collector array
         * @returns {Polynomial}
         */
        parse: function(symbol, c) {
          this.variable = variables(symbol)[0];
          if (!symbol.isPoly())
            throw core.exceptions.NerdamerTypeError("Polynomial Expected! Received " + core.Utils.text(symbol));
          c = c || [];
          if (!symbol.power.absEquals(1))
            symbol = _.expand(symbol);
          if (symbol.group === core.groups.N) {
            c[0] = symbol.multiplier;
          } else if (symbol.group === core.groups.S) {
            c[symbol.power.toDecimal()] = symbol.multiplier;
          } else {
            for (var x in symbol.symbols) {
              var sub = symbol.symbols[x], p = sub.power;
              if (core.Utils.isSymbol(p))
                throw new core.exceptions.NerdamerTypeError("power cannot be a Symbol");
              p = sub.group === N ? 0 : p.toDecimal();
              if (sub.symbols) {
                this.parse(sub, c);
              } else {
                c[p] = sub.multiplier;
              }
            }
          }
          this.coeffs = c;
          this.fill();
        },
        /**
         * Fills in the holes in a polynomial with zeroes
         * @param {Number} x - The number to fill the holes with
         */
        fill: function(x) {
          x = Number(x) || 0;
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            if (this.coeffs[i] === void 0) {
              this.coeffs[i] = new Frac(x);
            }
          }
          return this;
        },
        /**
         * Removes higher order zeros or a specific coefficient
         * @returns {Array}
         */
        trim: function() {
          var l = this.coeffs.length;
          while (l--) {
            var c = this.coeffs[l];
            var equalsZero = c.equals(0);
            if (c && equalsZero) {
              if (l === 0)
                break;
              this.coeffs.pop();
            } else
              break;
          }
          return this;
        },
        /*
         * Returns polynomial mod p **currently fails**
         * @param {Number} p
         * @returns {Polynomial}
         */
        modP: function(p) {
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var c = this.coeffs[i];
            if (c < 0) {
              var b;
              for (var j = i; j < l; j++) {
                if (this.coeffs[j] > 0) {
                  b = this.coeffs[j];
                  break;
                }
              }
              if (b) {
                for (j; j > i; j--) {
                  this.coeffs[j] = this.coeffs[j].subtract(new Frac(1));
                  this.coeffs[j - 1] = this.coeffs[j - 1].add(new Frac(p));
                }
                c = this.coeffs[i];
              }
            }
            var d = c.mod(p);
            var w = c.subtract(d).divide(p);
            if (!w.equals(0)) {
              var up_one = i + 1;
              var next = this.coeffs[up_one] || new Frac(0);
              next = next.add(w);
              this.coeffs[up_one] = new Frac(next);
              this.coeffs[i] = new Frac(d);
            }
          }
          return this;
        },
        /**
         * Adds together 2 polynomials
         * @param {Polynomial} poly
         */
        add: function(poly) {
          var l = Math.max(this.coeffs.length, poly.coeffs.length);
          for (var i = 0; i < l; i++) {
            var a = this.coeffs[i] || new Frac(0), b = poly.coeffs[i] || new Frac(0);
            this.coeffs[i] = a.add(b);
          }
          return this;
        },
        /**
         * Adds together 2 polynomials
         * @param {Polynomial} poly
         */
        subtract: function(poly) {
          var l = Math.max(this.coeffs.length, poly.coeffs.length);
          for (var i = 0; i < l; i++) {
            var a = this.coeffs[i] || new Frac(0), b = poly.coeffs[i] || new Frac(0);
            this.coeffs[i] = a.subtract(b);
          }
          return this;
        },
        divide: function(poly) {
          var variable = this.variable, dividend = core.Utils.arrayClone(this.coeffs), divisor = core.Utils.arrayClone(poly.coeffs), n2 = dividend.length, mp = divisor.length - 1, quotient = [];
          for (var i = 0; i < n2; i++) {
            var p = n2 - (i + 1);
            var d = p - mp;
            var q = dividend[p].divide(divisor[mp]);
            if (d < 0)
              break;
            quotient[d] = q;
            for (var j = 0; j <= mp; j++) {
              dividend[j + d] = dividend[j + d].subtract(divisor[j].multiply(q));
            }
          }
          var p1 = Polynomial.fromArray(dividend, variable || "x").trim(), p2 = Polynomial.fromArray(quotient, variable || "x");
          return [p2, p1];
        },
        multiply: function(poly) {
          var l1 = this.coeffs.length, l2 = poly.coeffs.length, c = [];
          for (var i = 0; i < l1; i++) {
            var x1 = this.coeffs[i];
            for (var j = 0; j < l2; j++) {
              var k = i + j, x2 = poly.coeffs[j], e = c[k] || new Frac(0);
              c[k] = e.add(x1.multiply(x2));
            }
          }
          this.coeffs = c;
          return this;
        },
        /**
         * Checks if a polynomial is zero
         * @returns {Boolean}
         */
        isZero: function() {
          var l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var e = this.coeffs[i];
            if (!e.equals(0))
              return false;
          }
          return true;
        },
        /** 
         * Substitutes in a number n into the polynomial p(n)
         * @param {Number} n
         * @returns {Frac}
         */
        sub: function(n2) {
          var sum = new Frac(0), l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var t = this.coeffs[i];
            if (!t.equals(0))
              sum = sum.add(t.multiply(new Frac(Math.pow(n2, i))));
          }
          return sum;
        },
        /**
         * Returns a clone of the polynomial
         * @returns {Polynomial}
         */
        clone: function() {
          var p = new Polynomial();
          p.coeffs = this.coeffs;
          p.variable = this.variable;
          return p;
        },
        /**
         * Gets the degree of the polynomial
         * @returns {Number}
         */
        deg: function() {
          this.trim();
          return this.coeffs.length - 1;
        },
        /**
         * Returns a lead coefficient
         * @returns {Frac}
         */
        lc: function() {
          return this.coeffs[this.deg()].clone();
        },
        /**
         * Converts polynomial into a monic polynomial
         * @returns {Polynomial}
         */
        monic: function() {
          var lc = this.lc(), l = this.coeffs.length;
          for (var i = 0; i < l; i++)
            this.coeffs[i] = this.coeffs[i].divide(lc);
          return this;
        },
        /**
         * Returns the GCD of two polynomials
         * @param {Polynomial} poly
         * @returns {Polynomial}
         */
        gcd: function(poly) {
          var mp1 = this.coeffs.length - 1, mp2 = poly.coeffs.length - 1, T;
          if (mp1 < mp2) {
            return poly.gcd(this);
          }
          var a = this;
          while (!poly.isZero()) {
            var t = poly.clone();
            a = a.clone();
            T = a.divide(t);
            poly = T[1];
            a = t;
          }
          var gcd = core.Math2.QGCD.apply(null, a.coeffs);
          if (!gcd.equals(1)) {
            var l = a.coeffs.length;
            for (var i = 0; i < l; i++) {
              a.coeffs[i] = a.coeffs[i].divide(gcd);
            }
          }
          return a;
        },
        /**
         * Differentiates the polynomial
         * @returns {Polynomial}
         */
        diff: function() {
          var new_array = [], l = this.coeffs.length;
          for (var i = 1; i < l; i++)
            new_array.push(this.coeffs[i].multiply(new Frac(i)));
          this.coeffs = new_array;
          return this;
        },
        /**
         * Integrates the polynomial
         * @returns {Polynomial} 
         */
        integrate: function() {
          var new_array = [0], l = this.coeffs.length;
          for (var i = 0; i < l; i++) {
            var c = new Frac(i + 1);
            new_array[c] = this.coeffs[i].divide(c);
          }
          this.coeffs = new_array;
          return this;
        },
        /**
         * Returns the Greatest common factor of the polynomial
         * @param {bool} toPolynomial - true if a polynomial is wanted
         * @returns {Frac|Polynomial}
         */
        gcf: function(toPolynomial) {
          var fnz = function(a) {
            for (var i2 = 0; i2 < a.length; i2++)
              if (!a[i2].equals(0))
                return i2;
          }, ca = [];
          for (var i = 0; i < this.coeffs.length; i++) {
            var c = this.coeffs[i];
            if (!c.equals(0) && ca.indexOf(c) === -1)
              ca.push(c);
          }
          var p = [core.Math2.QGCD.apply(void 0, ca), fnz(this.coeffs)].toDecimal();
          if (toPolynomial) {
            var parr = [];
            parr[p[1] - 1] = p[0];
            p = Polynomial.fromArray(parr, this.variable).fill();
          }
          return p;
        },
        /**
         * Raises a polynomial P to a power p -> P^p. e.g. (x+1)^2
         * @param {bool} incl_img - Include imaginary numbers 
         */
        quad: function(incl_img) {
          var roots = [];
          if (this.coeffs.length > 3)
            throw new Error("Cannot calculate quadratic order of " + (this.coeffs.length - 1));
          if (this.coeffs.length === 0)
            throw new Error("Polynomial array has no terms");
          var a = this.coeffs[2] || 0, b = this.coeffs[1] || 0, c = this.coeffs[0];
          var dsc = b * b - 4 * a * c;
          if (dsc < 0 && !incl_img)
            return roots;
          else {
            roots[0] = (-b + Math.sqrt(dsc)) / (2 * a);
            roots[1] = (-b - Math.sqrt(dsc)) / (2 * a);
          }
          return roots;
        },
        /**
         * Makes polynomial square free
         * @returns {Array}
         */
        squareFree: function() {
          var a = this.clone(), i = 1, b = a.clone().diff(), c = a.clone().gcd(b), w = a.divide(c)[0];
          var output = Polynomial.fromArray([new Frac(1)], a.variable);
          while (!c.equalsNumber(1)) {
            var y = w.gcd(c);
            var z = w.divide(y)[0];
            if (!z.equalsNumber(1) && i > 1) {
              var t = z.clone();
              for (var j = 1; j < i; j++)
                t.multiply(z.clone());
              z = t;
            }
            output = output.multiply(z);
            i++;
            w = y;
            c = c.divide(y)[0];
          }
          return [output, w, i];
        },
        /**
         * Converts polynomial to Symbol
         * @returns {Symbol}
         */
        toSymbol: function() {
          var l = this.coeffs.length, variable = this.variable;
          if (l === 0)
            return new core.Symbol(0);
          var end = l - 1, str = "";
          for (var i = 0; i < l; i++) {
            var plus = i === end ? "" : "+", e = this.coeffs[i];
            if (!e.equals(0))
              str += e + "*" + variable + "^" + i + plus;
          }
          return _.parse(str);
        },
        /**
         * Checks if polynomial is equal to a number
         * @param {Number} x
         * @returns {Boolean}
         */
        equalsNumber: function(x) {
          this.trim();
          return this.coeffs.length === 1 && this.coeffs[0].toDecimal() === String(x);
        },
        toString: function() {
          return this.toSymbol().toString();
        }
      };
      Symbol2.prototype.coeffs = function(c, with_order) {
        if (with_order && !this.isPoly(true))
          _.error("Polynomial expected when requesting coefficients with order");
        c = c || [];
        var s = this.clone().distributeMultiplier();
        if (s.isComposite()) {
          for (var x in s.symbols) {
            var sub = s.symbols[x];
            if (sub.isComposite()) {
              sub.clone().distributeMultiplier().coeffs(c, with_order);
            } else {
              if (with_order)
                c[sub.isConstant() ? 0 : sub.power.toDecimal()] = sub.multiplier;
              else {
                c.push(sub.multiplier);
              }
            }
          }
        } else {
          if (with_order)
            c[s.isConstant(true) ? 0 : s.power.toDecimal()] = s.multiplier;
          else {
            if (s.group === CB && s.isImaginary()) {
              var m = new Symbol2(s.multiplier);
              s.each(function(x2) {
                if (x2.isConstant(true) || x2.imaginary)
                  m = _.multiply(m, x2);
              });
              c.push(m);
            } else
              c.push(s.multiplier);
          }
        }
        if (with_order) {
          for (var i = 0; i < c.length; i++)
            if (c[i] === void 0)
              c[i] = new Symbol2(0);
        }
        return c;
      };
      Symbol2.prototype.tBase = function(map) {
        if (typeof map === "undefined")
          throw new Error("Symbol.tBase requires a map object!");
        var terms = [];
        var symbols = this.collectSymbols(null, null, null, true), l = symbols.length;
        for (var i = 0; i < l; i++) {
          var symbol = symbols[i], g = symbol.group, nterm = new MVTerm(symbol.multiplier, [], map);
          if (g === CB) {
            for (var x in symbol.symbols) {
              var sym = symbol.symbols[x];
              nterm.terms[map[x]] = sym.power;
            }
          } else {
            nterm.terms[map[symbol.value]] = symbol.power;
          }
          terms.push(nterm.fill());
          nterm.updateCount();
        }
        return terms;
      };
      Symbol2.prototype.altVar = function(x) {
        var m = this.multiplier.toString(), p = this.power.toString();
        return (m === "1" ? "" : m + "*") + x + (p === "1" ? "" : "^" + p);
      };
      Symbol2.prototype.sameVars = function(symbol) {
        if (!(this.symbols || this.group === symbol.group))
          return false;
        for (var x in this.symbols) {
          var a = this.symbols[x], b = symbol.symbols[x];
          if (!b)
            return false;
          if (a.value !== b.value)
            return false;
        }
        return true;
      };
      Symbol2.prototype.groupTerms = function(x) {
        x = String(x);
        var f, p, egrouped;
        var grouped = [];
        this.each(function(e) {
          if (e.group === PL) {
            egrouped = e.groupTerms(x);
            for (var i = 0; i < egrouped.length; i++) {
              var el = egrouped[i];
              if (el)
                grouped[i] = el;
            }
          } else {
            f = core.Utils.decompose_fn(e, x, true);
            p = f.x.value === x ? Number(f.x.power) : 0;
            grouped[p] = _.add(grouped[p] || new Symbol2(0), f.a);
          }
        });
        return grouped;
      };
      Symbol2.prototype.collectFactors = function() {
        var factors = [];
        if (this.group === CB)
          this.each(function(x) {
            factors.push(x.clone());
          });
        else
          factors.push(this.clone());
        return factors;
      };
      function Factors() {
        this.factors = {};
        this.length = 0;
      }
      ;
      Factors.prototype.getNumberSymbolics = function() {
        var n2 = 0;
        this.each(function(x) {
          if (!x.isConstant(true))
            n2++;
        });
        return n2;
      };
      Factors.prototype.add = function(s) {
        if (s.equals(0))
          return this;
        if (s.equals(-1) && this.length > 0) {
          var fo = core.Utils.firstObject(this.factors, null, true);
          this.add(_.symfunction(core.Settings.PARENTHESIS, [fo.obj]).negate());
          delete this.factors[fo.key];
          this.length--;
          return this;
        }
        if (s.group === CB) {
          var factors = this;
          if (!s.multiplier.equals(1))
            factors.add(new Symbol2(s.multiplier));
          s.each(function(x) {
            factors.add(x);
          });
        } else {
          if (this.preAdd)
            s = this.preAdd(s);
          if (this.pFactor)
            s = _.pow(s, new Symbol2(this.pFactor));
          var is_constant = s.isConstant();
          if (is_constant && s.equals(1))
            return this;
          var v = is_constant ? s.value : s.text();
          if (v in this.factors) {
            this.factors[v] = _.multiply(this.factors[v], s);
            if (this.factors[v].equals(1)) {
              delete this.factors[v];
              this.length--;
            }
          } else {
            this.factors[v] = s;
            this.length++;
          }
        }
        return this;
      };
      Factors.prototype.toSymbol = function() {
        var factored = new Symbol2(1);
        var factors = Object.values(this.factors).sort(function(a, b) {
          return a.group > b.group;
        });
        for (var i = 0, l = factors.length; i < l; i++) {
          var f = factors[i];
          var factor = f.power.equals(1) && f.fname !== "" ? _.symfunction(core.PARENTHESIS, [f]) : f;
          factored = _.multiply(factored, factor);
        }
        if (factored.fname === "")
          factored = Symbol2.unwrapPARENS(factored);
        return factored;
      };
      Factors.prototype.merge = function(o) {
        for (var x in o) {
          if (x in this.factors)
            this.factors[x] = _.multiply(this.factors[x], o[x]);
          else
            this.factors[x] = o[x];
        }
        return this;
      };
      Factors.prototype.each = function(f) {
        for (var x in this.factors) {
          var factor = this.factors[x];
          if (factor.fname === core.PARENTHESIS && factor.isLinear())
            factor = factor.args[0];
          f.call(this, factor, x);
        }
        return this;
      };
      Factors.prototype.count = function() {
        return keys(this.factors).length;
      };
      Factors.prototype.clean = function() {
        try {
          var h = core.Settings.CONST_HASH;
          if (this.factors[h].lessThan(0)) {
            if (this.factors[h].equals(-1))
              delete this.factors[h];
            else
              this.factors[h].negate();
            this.each(function(x) {
              x.negate();
            });
          }
        } catch (e) {
        }
        ;
      };
      Factors.prototype.toString = function() {
        return this.toSymbol().toString();
      };
      function MVTerm(coeff, terms, map) {
        this.terms = terms || [];
        this.coeff = coeff;
        this.map = map;
        this.sum = new core.Frac(0);
        this.image = void 0;
      }
      ;
      MVTerm.prototype.updateCount = function() {
        this.count = this.count || 0;
        for (var i = 0; i < this.terms.length; i++) {
          if (!this.terms[i].equals(0))
            this.count++;
        }
        return this;
      };
      MVTerm.prototype.getVars = function() {
        var vars = [];
        for (var i = 0; i < this.terms.length; i++) {
          var term = this.terms[i], rev_map = this.getRevMap();
          if (!term.equals(0))
            vars.push(this.rev_map[i]);
        }
        return vars.join(" ");
      };
      MVTerm.prototype.len = function() {
        if (typeof this.count === "undefined") {
          this.updateCount();
        }
        return this.count;
      };
      MVTerm.prototype.toSymbol = function(rev_map) {
        rev_map = rev_map || this.getRevMap();
        var symbol = new Symbol2(this.coeff);
        for (var i = 0; i < this.terms.length; i++) {
          var v = rev_map[i], t = this.terms[i];
          if (t.equals(0) || v === CONST_HASH)
            continue;
          var mapped = new Symbol2(v);
          mapped.power = t;
          symbol = _.multiply(symbol, mapped);
        }
        return symbol;
      };
      MVTerm.prototype.getRevMap = function() {
        if (this.rev_map)
          return this.rev_map;
        var o = {};
        for (var x in this.map)
          o[this.map[x]] = x;
        this.rev_map = o;
        return o;
      };
      MVTerm.prototype.generateImage = function() {
        this.image = this.terms.join(" ");
        return this;
      }, MVTerm.prototype.getImg = function() {
        if (!this.image)
          this.generateImage();
        return this.image;
      }, MVTerm.prototype.fill = function() {
        var l = this.map.length;
        for (var i = 0; i < l; i++) {
          if (typeof this.terms[i] === "undefined")
            this.terms[i] = new core.Frac(0);
          else {
            this.sum = this.sum.add(this.terms[i]);
          }
        }
        return this;
      };
      MVTerm.prototype.divide = function(mvterm) {
        var c = this.coeff.divide(mvterm.coeff), l = this.terms.length, new_mvterm = new MVTerm(c, [], this.map);
        for (var i = 0; i < l; i++) {
          new_mvterm.terms[i] = this.terms[i].subtract(mvterm.terms[i]);
          new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);
        }
        return new_mvterm;
      };
      MVTerm.prototype.multiply = function(mvterm) {
        var c = this.coeff.multiply(mvterm.coeff), l = this.terms.length, new_mvterm = new MVTerm(c, [], this.map);
        for (var i = 0; i < l; i++) {
          new_mvterm.terms[i] = this.terms[i].add(mvterm.terms[i]);
          new_mvterm.sum = new_mvterm.sum.add(new_mvterm.terms[i]);
        }
        return new_mvterm;
      };
      MVTerm.prototype.isZero = function() {
        return this.coeff.equals(0);
      };
      MVTerm.prototype.toString = function() {
        return "{ coeff: " + this.coeff.toString() + ", terms: [" + this.terms.join(",") + "]: sum: " + this.sum.toString() + ", count: " + this.count + "}";
      };
      core.Utils.toMapObj = function(arr) {
        var c = 0, o = {};
        for (var i = 0; i < arr.length; i++) {
          var v = arr[i];
          if (typeof o[v] === "undefined") {
            o[v] = c;
            c++;
          }
        }
        o.length = c;
        return o;
      };
      core.Utils.filledArray = function(v, n2, clss) {
        var a = [];
        while (n2--) {
          a[n2] = clss ? new clss(v) : v;
        }
        return a;
      };
      core.Utils.arrSum = function(arr) {
        var sum = 0, l = arr.length;
        for (var i = 0; i < l; i++)
          sum += arr[i];
        return sum;
      };
      core.Utils.haveIntersection = function(a, b) {
        var t;
        if (b.length > a.length)
          t = b, b = a, a = t;
        return a.some(function(e) {
          return b.indexOf(e) > -1;
        });
      };
      core.Utils.subFunctions = function(symbol, map) {
        map = map || {};
        var subbed = [];
        symbol.each(function(x) {
          if (x.group === FN || x.previousGroup === FN) {
            var val = core.Utils.text(x, "hash"), tvar = map[val];
            if (!tvar) {
              var t = x.fname + keys(map).length;
              map[val] = t;
              subbed.push(x.altVar(t));
            } else
              subbed.push(x.altVar(tvar));
          } else if (x.group === CB || x.group === PL || x.group === CP) {
            subbed.push(core.Utils.subFunctions(x, map));
          } else
            subbed.push(x.text());
        });
        if (symbol.group === CP || symbol.group === PL)
          return symbol.altVar(core.Utils.inBrackets(subbed.join("+")));
        ;
        if (symbol.group === CB)
          return symbol.altVar(core.Utils.inBrackets(subbed.join("*")));
        return symbol.text();
      };
      core.Utils.getFunctionsSubs = function(map) {
        var subs = {};
        for (var x in map)
          subs[map[x]] = _.parse(x);
        return subs;
      };
      var __ = core.Algebra = {
        version: "1.4.6",
        proots: function(symbol, decp) {
          decp = decp || 7;
          var zeros = 0;
          var known_roots = [];
          var get_roots = function(rarr2, powers2, max2) {
            var roots = calcroots(rarr2, powers2, max2).concat(known_roots);
            for (var i2 = 0; i2 < zeros; i2++)
              roots.unshift(0);
            return roots;
          };
          if (symbol instanceof Symbol2 && symbol.isPoly()) {
            symbol.distributeMultiplier();
            if (symbol.group === PL) {
              var lowest_pow = core.Utils.arrayMin(keys(symbol.symbols));
              var lowest_symbol = symbol.symbols[lowest_pow].clone().toUnitMultiplier();
              symbol = _.expand(_.divide(symbol, lowest_symbol));
              known_roots.push(0);
            }
            if (symbol.group === core.groups.S) {
              return [0];
            } else if (symbol.group === core.groups.PL) {
              var powers = keys(symbol.symbols), minpower = core.Utils.arrayMin(powers), symbol = core.PARSER.divide(symbol, core.PARSER.parse(symbol.value + "^" + minpower));
            }
            var variable = keys(symbol.symbols).sort().pop(), sym = symbol.group === core.groups.PL ? symbol.symbols : symbol.symbols[variable], g = sym.group, powers = g === S ? [sym.power.toDecimal()] : keys(sym.symbols), rarr = [], max = core.Utils.arrayMax(powers);
            for (var i = 1; i <= max; i++) {
              var c = 0;
              if (powers.indexOf(i + "") !== -1) {
                if (g === S) {
                  c = sym.multiplier;
                } else {
                  c = sym.symbols[i].multiplier;
                }
              }
              rarr.unshift(c);
            }
            rarr.push(symbol.symbols[CONST_HASH].multiplier);
            if (sym.group === S)
              rarr[0] = sym.multiplier;
            return get_roots(rarr, powers, max);
          } else if (core.Utils.isArray(symbol)) {
            var parr = symbol;
            var rarr = [], powers = [], last_power = 0;
            for (var i = 0; i < parr.length; i++) {
              var coeff = parr[i][0], pow = parr[i][1], d = pow - last_power - 1;
              for (var j = 0; j < d; j++)
                rarr.unshift(0);
              rarr.unshift(coeff);
              if (pow !== 0)
                powers.push(pow);
              last_power = pow;
            }
            var max = Math.max.apply(void 0, powers);
            return get_roots(rarr, powers, max);
          } else {
            throw new core.exceptions.NerdamerTypeError("Cannot calculate roots. Symbol must be a polynomial!");
          }
          function calcroots(rarr2, powers2, max2) {
            var MAXDEGREE = 100;
            var p = rarr2.slice(0);
            rarr2.unshift(max2);
            if (max2 > MAXDEGREE) {
              throw new core.exceptions.ValueLimitExceededError("This utility accepts polynomials of degree up to " + MAXDEGREE + ". ");
            }
            var zeroi = [], degreePar = {};
            degreePar.Degree = max2;
            for (i = 0; i < max2; i++) {
              zeroi.push(0);
            }
            var zeror = zeroi.slice(0);
            function QuadSD_ak1(NN, u, v, p2, q, iPar) {
              q[0] = iPar.b = p2[0];
              q[1] = iPar.a = -(u * iPar.b) + p2[1];
              for (var i2 = 2; i2 < NN; i2++) {
                q[i2] = -(u * iPar.a + v * iPar.b) + p2[i2];
                iPar.b = iPar.a;
                iPar.a = q[i2];
              }
              return;
            }
            function calcSC_ak1(DBL_EPSILON, N2, a, b, iPar, K, u, v, qk) {
              var sdPar = new Object(), dumFlag = 3;
              sdPar.b = sdPar.a = 0;
              QuadSD_ak1(N2, u, v, K, qk, sdPar);
              iPar.c = sdPar.a;
              iPar.d = sdPar.b;
              if (Math.abs(iPar.c) <= 100 * DBL_EPSILON * Math.abs(K[N2 - 1])) {
                if (Math.abs(iPar.d) <= 100 * DBL_EPSILON * Math.abs(K[N2 - 2]))
                  return dumFlag;
              }
              iPar.h = v * b;
              if (Math.abs(iPar.d) >= Math.abs(iPar.c)) {
                dumFlag = 2;
                iPar.e = a / iPar.d;
                iPar.f = iPar.c / iPar.d;
                iPar.g = u * b;
                iPar.a3 = iPar.e * (iPar.g + a) + iPar.h * (b / iPar.d);
                iPar.a1 = -a + iPar.f * b;
                iPar.a7 = iPar.h + (iPar.f + u) * a;
              } else {
                dumFlag = 1;
                iPar.e = a / iPar.c;
                iPar.f = iPar.d / iPar.c;
                iPar.g = iPar.e * u;
                iPar.a3 = iPar.e * a + (iPar.g + iPar.h / iPar.c) * b;
                iPar.a1 = -(a * (iPar.d / iPar.c)) + b;
                iPar.a7 = iPar.g * iPar.d + iPar.h * iPar.f + a;
              }
              return dumFlag;
            }
            function nextK_ak1(DBL_EPSILON, N2, tFlag, a, b, iPar, K, qk, qp) {
              var temp;
              if (tFlag == 3) {
                K[1] = K[0] = 0;
                for (var i2 = 2; i2 < N2; i2++) {
                  K[i2] = qk[i2 - 2];
                }
                return;
              }
              temp = tFlag == 1 ? b : a;
              if (Math.abs(iPar.a1) > 10 * DBL_EPSILON * Math.abs(temp)) {
                iPar.a7 /= iPar.a1;
                iPar.a3 /= iPar.a1;
                K[0] = qp[0];
                K[1] = -(qp[0] * iPar.a7) + qp[1];
                for (var i2 = 2; i2 < N2; i2++)
                  K[i2] = -(qp[i2 - 1] * iPar.a7) + qk[i2 - 2] * iPar.a3 + qp[i2];
              } else {
                K[0] = 0;
                K[1] = -(qp[0] * iPar.a7);
                for (var i2 = 2; i2 < N2; i2++) {
                  K[i2] = -(qp[i2 - 1] * iPar.a7) + qk[i2 - 2] * iPar.a3;
                }
              }
              return;
            }
            function newest_ak1(tFlag, iPar, a, a1, a3, a7, b, c2, d2, f, g2, h, u, v, K, N2, p2) {
              var a4, a5, b1, b2, c1, c22, c3, c4, temp;
              iPar.b = iPar.a = 0;
              if (tFlag != 3) {
                if (tFlag != 2) {
                  a4 = a + u * b + h * f;
                  a5 = c2 + (u + v * f) * d2;
                } else {
                  a4 = (a + g2) * f + h;
                  a5 = (f + u) * c2 + v * d2;
                }
                b1 = -(K[N2 - 1] / p2[N2]);
                b2 = -(K[N2 - 2] + b1 * p2[N2 - 1]) / p2[N2];
                c1 = v * b2 * a1;
                c22 = b1 * a7;
                c3 = b1 * b1 * a3;
                c4 = -(c22 + c3) + c1;
                temp = -c4 + a5 + b1 * a4;
                if (temp != 0) {
                  iPar.a = -((u * (c3 + c22) + v * (b1 * a1 + b2 * a7)) / temp) + u;
                  iPar.b = v * (1 + c4 / temp);
                }
              }
              return;
            }
            function Quad_ak1(a, b1, c2, iPar) {
              var b, d2, e;
              iPar.sr = iPar.si = iPar.lr = iPar.li = 0;
              if (a == 0) {
                iPar.sr = b1 != 0 ? -(c2 / b1) : iPar.sr;
                return;
              }
              if (c2 == 0) {
                iPar.lr = -(b1 / a);
                return;
              }
              b = b1 / 2;
              if (Math.abs(b) < Math.abs(c2)) {
                e = c2 >= 0 ? a : -a;
                e = -e + b * (b / Math.abs(c2));
                d2 = Math.sqrt(Math.abs(e)) * Math.sqrt(Math.abs(c2));
              } else {
                e = -(a / b * (c2 / b)) + 1;
                d2 = Math.sqrt(Math.abs(e)) * Math.abs(b);
              }
              if (e >= 0) {
                d2 = b >= 0 ? -d2 : d2;
                iPar.lr = (-b + d2) / a;
                iPar.sr = iPar.lr != 0 ? c2 / iPar.lr / a : iPar.sr;
              } else {
                iPar.lr = iPar.sr = -(b / a);
                iPar.si = Math.abs(d2 / a);
                iPar.li = -iPar.si;
              }
              return;
            }
            function QuadIT_ak1(DBL_EPSILON, N2, iPar, uu, vv, qp, NN, sdPar, p2, qk, calcPar, K) {
              var qPar = new Object(), ee, mp, omp, relstp, t, u, ui, v, vi, zm, i2, j2 = 0, tFlag, triedFlag = 0;
              iPar.NZ = 0;
              u = uu;
              v = vv;
              do {
                qPar.li = qPar.lr = qPar.si = qPar.sr = 0;
                Quad_ak1(1, u, v, qPar);
                iPar.szr = qPar.sr;
                iPar.szi = qPar.si;
                iPar.lzr = qPar.lr;
                iPar.lzi = qPar.li;
                if (Math.abs(Math.abs(iPar.szr) - Math.abs(iPar.lzr)) > 0.01 * Math.abs(iPar.lzr))
                  break;
                QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                mp = Math.abs(-(iPar.szr * sdPar.b) + sdPar.a) + Math.abs(iPar.szi * sdPar.b);
                zm = Math.sqrt(Math.abs(v));
                ee = 2 * Math.abs(qp[0]);
                t = -(iPar.szr * sdPar.b);
                for (i2 = 1; i2 < N2; i2++) {
                  ee = ee * zm + Math.abs(qp[i2]);
                }
                ee = ee * zm + Math.abs(t + sdPar.a);
                ee = (9 * ee + 2 * Math.abs(t) - 7 * (Math.abs(sdPar.a + t) + zm * Math.abs(sdPar.b))) * DBL_EPSILON;
                if (mp <= 20 * ee) {
                  iPar.NZ = 2;
                  break;
                }
                j2++;
                if (j2 > 20)
                  break;
                if (j2 >= 2) {
                  if (relstp <= 0.01 && mp >= omp && !triedFlag) {
                    relstp = relstp < DBL_EPSILON ? Math.sqrt(DBL_EPSILON) : Math.sqrt(relstp);
                    u -= u * relstp;
                    v += v * relstp;
                    QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                    for (i2 = 0; i2 < 5; i2++) {
                      tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                      nextK_ak1(DBL_EPSILON, N2, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
                    }
                    triedFlag = 1;
                    j2 = 0;
                  }
                }
                omp = mp;
                tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                nextK_ak1(DBL_EPSILON, N2, tFlag, sdPar.a, sdPar.b, calcPar, K, qk, qp);
                tFlag = calcSC_ak1(DBL_EPSILON, N2, sdPar.a, sdPar.b, calcPar, K, u, v, qk);
                newest_ak1(tFlag, sdPar, sdPar.a, calcPar.a1, calcPar.a3, calcPar.a7, sdPar.b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N2, p2);
                ui = sdPar.a;
                vi = sdPar.b;
                if (vi != 0) {
                  relstp = Math.abs((-v + vi) / vi);
                  u = ui;
                  v = vi;
                }
              } while (vi != 0);
              return;
            }
            function RealIT_ak1(DBL_EPSILON, iPar, sdPar, N2, p2, NN, qp, K, qk) {
              var ee, kv, mp, ms, omp, pv, s, t, dumFlag, i2, j2, nm1 = N2 - 1;
              iPar.NZ = j2 = dumFlag = 0;
              s = sdPar.a;
              for (; ; ) {
                pv = p2[0];
                qp[0] = pv;
                for (i2 = 1; i2 < NN; i2++) {
                  qp[i2] = pv = pv * s + p2[i2];
                }
                mp = Math.abs(pv);
                ms = Math.abs(s);
                ee = 0.5 * Math.abs(qp[0]);
                for (i2 = 1; i2 < NN; i2++) {
                  ee = ee * ms + Math.abs(qp[i2]);
                }
                if (mp <= 20 * DBL_EPSILON * (2 * ee - mp)) {
                  iPar.NZ = 1;
                  iPar.szr = s;
                  iPar.szi = 0;
                  break;
                }
                j2++;
                if (j2 > 10)
                  break;
                if (j2 >= 2) {
                  if (Math.abs(t) <= 1e-3 * Math.abs(-t + s) && mp > omp) {
                    dumFlag = 1;
                    iPar.a = s;
                    break;
                  }
                }
                omp = mp;
                qk[0] = kv = K[0];
                for (i2 = 1; i2 < N2; i2++) {
                  qk[i2] = kv = kv * s + K[i2];
                }
                if (Math.abs(kv) > Math.abs(K[nm1]) * 10 * DBL_EPSILON) {
                  t = -(pv / kv);
                  K[0] = qp[0];
                  for (i2 = 1; i2 < N2; i2++) {
                    K[i2] = t * qk[i2 - 1] + qp[i2];
                  }
                } else {
                  K[0] = 0;
                  for (i2 = 1; i2 < N2; i2++)
                    K[i2] = qk[i2 - 1];
                }
                kv = K[0];
                for (i2 = 1; i2 < N2; i2++) {
                  kv = kv * s + K[i2];
                }
                t = Math.abs(kv) > Math.abs(K[nm1]) * 10 * DBL_EPSILON ? -(pv / kv) : 0;
                s += t;
              }
              return dumFlag;
            }
            function Fxshfr_ak1(DBL_EPSILON, MDP1, L2, sr, v, K, N2, p2, NN, qp, u, iPar) {
              var sdPar = new Object(), calcPar = new Object(), qk = new Array(MDP1), svk = new Array(MDP1), a, b, betas, betav, oss, ots, otv, ovv, s, ss, ts, tss, tv, tvv, ui, vi, vv, fflag, i2, iFlag = 1, j2, spass, stry, tFlag, vpass, vtry;
              iPar.NZ = 0;
              betav = betas = 0.25;
              oss = sr;
              ovv = v;
              sdPar.b = sdPar.a = 0;
              QuadSD_ak1(NN, u, v, p2, qp, sdPar);
              a = sdPar.a;
              b = sdPar.b;
              calcPar.h = calcPar.g = calcPar.f = calcPar.e = calcPar.d = calcPar.c = calcPar.a7 = calcPar.a3 = calcPar.a1 = 0;
              tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
              for (j2 = 0; j2 < L2; j2++) {
                fflag = 1;
                nextK_ak1(DBL_EPSILON, N2, tFlag, a, b, calcPar, K, qk, qp);
                tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
                newest_ak1(tFlag, sdPar, a, calcPar.a1, calcPar.a3, calcPar.a7, b, calcPar.c, calcPar.d, calcPar.f, calcPar.g, calcPar.h, u, v, K, N2, p2);
                ui = sdPar.a;
                vv = vi = sdPar.b;
                ss = K[N2 - 1] != 0 ? -(p2[N2] / K[N2 - 1]) : 0;
                ts = tv = 1;
                if (j2 != 0 && tFlag != 3) {
                  tv = vv != 0 ? Math.abs((vv - ovv) / vv) : tv;
                  ts = ss != 0 ? Math.abs((ss - oss) / ss) : ts;
                  tvv = tv < otv ? tv * otv : 1;
                  tss = ts < ots ? ts * ots : 1;
                  vpass = tvv < betav ? 1 : 0;
                  spass = tss < betas ? 1 : 0;
                  if (spass || vpass) {
                    for (i2 = 0; i2 < N2; i2++) {
                      svk[i2] = K[i2];
                    }
                    s = ss;
                    stry = vtry = 0;
                    for (; ; ) {
                      if (fflag && (fflag = 0) == 0 && (spass && (!vpass || tss < tvv))) {
                        ;
                      } else {
                        QuadIT_ak1(DBL_EPSILON, N2, iPar, ui, vi, qp, NN, sdPar, p2, qk, calcPar, K);
                        a = sdPar.a;
                        b = sdPar.b;
                        if (iPar.NZ > 0)
                          return;
                        iFlag = vtry = 1;
                        betav *= 0.25;
                        if (stry || !spass) {
                          iFlag = 0;
                        } else {
                          for (i2 = 0; i2 < N2; i2++)
                            K[i2] = svk[i2];
                        }
                      }
                      if (iFlag != 0) {
                        sdPar.a = s;
                        iFlag = RealIT_ak1(DBL_EPSILON, iPar, sdPar, N2, p2, NN, qp, K, qk);
                        s = sdPar.a;
                        if (iPar.NZ > 0)
                          return;
                        stry = 1;
                        betas *= 0.25;
                        if (iFlag != 0) {
                          ui = -(s + s);
                          vi = s * s;
                          continue;
                        }
                      }
                      for (i2 = 0; i2 < N2; i2++)
                        K[i2] = svk[i2];
                      if (!vpass || vtry)
                        break;
                    }
                    QuadSD_ak1(NN, u, v, p2, qp, sdPar);
                    a = sdPar.a;
                    b = sdPar.b;
                    tFlag = calcSC_ak1(DBL_EPSILON, N2, a, b, calcPar, K, u, v, qk);
                  }
                }
                ovv = vv;
                oss = ss;
                otv = tv;
                ots = ts;
              }
              return;
            }
            function rpSolve(degPar, p2, zeror2, zeroi2) {
              var N2 = degPar.Degree, RADFAC = 3.141592653589793 / 180, LB2 = Math.LN2, MDP1 = degPar.Degree + 1, K = new Array(MDP1), pt = new Array(MDP1), qp = new Array(MDP1), temp = new Array(MDP1), qPar = new Object(), Fxshfr_Par = new Object(), bnd, DBL_EPSILON, df, dx, factor, ff, moduli_max, moduli_min, sc, x, xm, aa, bb, cc, sr, t, u, xxx, j2, jj, l2, NM1, NN, zerok;
              aa = 1;
              do {
                DBL_EPSILON = aa;
                aa /= 2;
                bb = 1 + aa;
              } while (bb > 1);
              var LO = Number.MIN_VALUE / DBL_EPSILON, cosr = Math.cos(94 * RADFAC), sinr = Math.sin(94 * RADFAC), xx = Math.sqrt(0.5), yy = -xx;
              Fxshfr_Par.NZ = j2 = 0;
              Fxshfr_Par.szr = Fxshfr_Par.szi = Fxshfr_Par.lzr = Fxshfr_Par.lzi = 0;
              while (p2[N2] == 0) {
                zeror2[j2] = zeroi2[j2] = 0;
                N2--;
                j2++;
              }
              NN = N2 + 1;
              while (N2 >= 1) {
                if (N2 <= 2) {
                  if (N2 < 2) {
                    zeror2[degPar.Degree - 1] = -(p2[1] / p2[0]);
                    zeroi2[degPar.Degree - 1] = 0;
                  } else {
                    qPar.li = qPar.lr = qPar.si = qPar.sr = 0;
                    Quad_ak1(p2[0], p2[1], p2[2], qPar);
                    zeror2[degPar.Degree - 2] = qPar.sr;
                    zeroi2[degPar.Degree - 2] = qPar.si;
                    zeror2[degPar.Degree - 1] = qPar.lr;
                    zeroi2[degPar.Degree - 1] = qPar.li;
                  }
                  break;
                }
                moduli_max = 0;
                moduli_min = Number.MAX_VALUE;
                for (i2 = 0; i2 < NN; i2++) {
                  x = Math.abs(p2[i2]);
                  if (x > moduli_max)
                    moduli_max = x;
                  if (x != 0 && x < moduli_min)
                    moduli_min = x;
                }
                sc = LO / moduli_min;
                if (sc <= 1 && moduli_max >= 10 || sc > 1 && Number.MAX_VALUE / sc >= moduli_max) {
                  sc = sc == 0 ? Number.MIN_VALUE : sc;
                  l2 = Math.floor(Math.log(sc) / LB2 + 0.5);
                  factor = Math.pow(2, l2);
                  if (factor != 1) {
                    for (i2 = 0; i2 < NN; i2++)
                      p2[i2] *= factor;
                  }
                }
                for (var i2 = 0; i2 < NN; i2++)
                  pt[i2] = Math.abs(p2[i2]);
                pt[N2] = -pt[N2];
                NM1 = N2 - 1;
                x = Math.exp((Math.log(-pt[N2]) - Math.log(pt[0])) / N2);
                if (pt[NM1] != 0) {
                  xm = -pt[N2] / pt[NM1];
                  x = xm < x ? xm : x;
                }
                xm = x;
                do {
                  x = xm;
                  xm = 0.1 * x;
                  ff = pt[0];
                  for (var i2 = 1; i2 < NN; i2++) {
                    ff = ff * xm + pt[i2];
                  }
                } while (ff > 0);
                dx = x;
                do {
                  df = ff = pt[0];
                  for (var i2 = 1; i2 < N2; i2++) {
                    ff = x * ff + pt[i2];
                    df = x * df + ff;
                  }
                  ff = x * ff + pt[N2];
                  dx = ff / df;
                  x -= dx;
                } while (Math.abs(dx / x) > 5e-3);
                bnd = x;
                for (var i2 = 1; i2 < N2; i2++)
                  K[i2] = (N2 - i2) * p2[i2] / N2;
                K[0] = p2[0];
                aa = p2[N2];
                bb = p2[NM1];
                zerok = K[NM1] == 0 ? 1 : 0;
                for (jj = 0; jj < 5; jj++) {
                  cc = K[NM1];
                  if (zerok) {
                    for (var i2 = 0; i2 < NM1; i2++) {
                      j2 = NM1 - i2;
                      K[j2] = K[j2 - 1];
                    }
                    K[0] = 0;
                    zerok = K[NM1] == 0 ? 1 : 0;
                  } else {
                    t = -aa / cc;
                    for (var i2 = 0; i2 < NM1; i2++) {
                      j2 = NM1 - i2;
                      K[j2] = t * K[j2 - 1] + p2[j2];
                    }
                    K[0] = p2[0];
                    zerok = Math.abs(K[NM1]) <= Math.abs(bb) * DBL_EPSILON * 10 ? 1 : 0;
                  }
                }
                for (var i2 = 0; i2 < N2; i2++)
                  temp[i2] = K[i2];
                for (jj = 1; jj <= 20; jj++) {
                  xxx = -(sinr * yy) + cosr * xx;
                  yy = sinr * xx + cosr * yy;
                  xx = xxx;
                  sr = bnd * xx;
                  u = -(2 * sr);
                  Fxshfr_ak1(DBL_EPSILON, MDP1, 20 * jj, sr, bnd, K, N2, p2, NN, qp, u, Fxshfr_Par);
                  if (Fxshfr_Par.NZ != 0) {
                    j2 = degPar.Degree - N2;
                    zeror2[j2] = Fxshfr_Par.szr;
                    zeroi2[j2] = Fxshfr_Par.szi;
                    NN = NN - Fxshfr_Par.NZ;
                    N2 = NN - 1;
                    for (var i2 = 0; i2 < NN; i2++)
                      p2[i2] = qp[i2];
                    if (Fxshfr_Par.NZ != 1) {
                      zeror2[j2 + 1] = Fxshfr_Par.lzr;
                      zeroi2[j2 + 1] = Fxshfr_Par.lzi;
                    }
                    break;
                  } else {
                    for (var i2 = 0; i2 < N2; i2++) {
                      K[i2] = temp[i2];
                    }
                  }
                }
                if (jj > 20) {
                  degPar.Degree -= N2;
                  break;
                }
              }
              return;
            }
            rpSolve(degreePar, p, zeror, zeroi);
            var l = zeroi.length;
            for (i = 0; i < l; i++) {
              var img = round(zeroi[i], decp + 8), real = round(zeror[i], decp + 8);
              real = decp - String(real).length > 2 ? real : zeror[i];
              var sign = img < 0 ? "-" : "";
              if (real === 0) {
                real = "";
              }
              if (img === 0) {
                img = "";
              }
              img = Math.abs(img) === 1 ? sign + "i" : img ? img + "*i" : "";
              var num = real && img ? real + "+" + img : real + img;
              zeror[i] = num.replace(/\+\-/g, "-");
            }
            return zeror;
          }
        },
        roots: function(symbol) {
          if (symbol.isConstant(true, true)) {
            return core.Utils.nroots(symbol);
          }
          var roots = __.proots(symbol).map(function(x) {
            return _.parse(x);
          });
          return core.Vector.fromArray(roots);
        },
        froot: function(f, guess, dx) {
          var newtonraph = function(xn) {
            var mesh = 1e-12, df = dx ? dx : core.Utils.build(core.Calculus.diff(f.clone())), fn = f instanceof Function ? f : core.Utils.build(f), max = 1e4, done = false, safety = 0;
            while (!done) {
              var x = xn - fn(xn) / df(xn);
              var r = Math.abs(x) - Math.abs(xn), delta = Math.abs(r);
              xn = x;
              if (delta < mesh)
                done = true;
              else if (safety > max) {
                xn = null;
                done = true;
              }
              safety++;
            }
            return xn;
          };
          return newtonraph(Number(guess));
        },
        quad: function(a, b, c) {
          var q = function(a2, b2, c2, sign) {
            return _.parse("-(" + b2 + "+" + sign + "*sqrt((" + b2 + ")^2-4*(" + a2 + ")*(" + c2 + ")))/(2*" + a2 + ")");
          };
          return [q(a, b, c, 1), q(a, b, c, -1)];
        },
        sumProd: function(a, b) {
          return __.quad(-b, a, -1).map(function(x) {
            return x.invert();
          });
        },
        coeffs: function(symbol, wrt, coeffs) {
          wrt = String(wrt);
          symbol = _.expand(symbol);
          coeffs = coeffs || [new Symbol2(0)];
          if (symbol.group === EX && symbol.contains(wrt, true))
            _.error("Unable to get coefficients using expression " + symbol.toString());
          var vars = variables(symbol);
          if (vars.length === 1 && vars[0] === wrt && !symbol.isImaginary()) {
            var a = new Polynomial(symbol).coeffs.map(function(x) {
              return new Symbol2(x);
            });
            for (var i = 0, l = a.length; i < l; i++) {
              var coeff = a[i], e = coeffs[i];
              if (e)
                coeff = _.add(e, coeff);
              coeffs[i] = coeff;
            }
          } else {
            if (!wrt)
              _.error("Polynomial contains more than one variable. Please specify which variable is to be used!");
            if (vars.indexOf(wrt) === -1) {
              coeffs[0] = _.add(symbol, coeffs[0]);
            } else {
              coeffs = coeffs || [new Symbol2(0)];
              if (symbol.group === CB) {
                var s = symbol.symbols[wrt];
                if (!s)
                  _.error("Expression is not a polynomial!");
                var p = Number(s.power);
                coeff = _.divide(symbol.clone(), s.clone());
                if (coeff.contains(wrt, true) || p < 0 || !isInt(p))
                  _.error("Expression is not a polynomial!");
                var e = coeffs[p];
                if (e)
                  coeff = _.add(e, coeff);
                coeffs[p] = coeff;
              } else if (symbol.group === CP) {
                symbol.each(function(x) {
                  __.coeffs(x.clone(), wrt, coeffs);
                }, true);
              }
            }
          }
          for (var i = 0, l = coeffs.length; i < l; i++)
            if (typeof coeffs[i] === "undefined")
              coeffs[i] = new Symbol2(0);
          return coeffs;
        },
        /**
         * Get's all the powers of a particular polynomial including the denominators. The denominators powers
         * are returned as negative. All remaining polynomials are returned as zero order polynomials.
         * for example polyPowers(x^2+1/x+y+t) will return [ '-1', 0, '2' ]
         * @param {Symbol} e
         * @param {String} for_variable
         * @param {Array} powers
         * @returns {Array} An array of the powers
         */
        //assumes you've already verified that it's a polynomial
        polyPowers: function(e, for_variable, powers) {
          powers = powers || [];
          var g = g = e.group;
          if (g === PL && for_variable === e.value) {
            powers = powers.concat(keys(e.symbols));
          } else if (g === CP) {
            for (var s in e.symbols) {
              var symbol = e.symbols[s];
              var g = symbol.group, v = symbol.value;
              if (g === S && for_variable === v)
                powers.push(symbol.power);
              else if (g === PL || g === CP)
                powers = __.polyPowers(symbol, for_variable, powers);
              else if (g === CB && symbol.contains(for_variable)) {
                var t = symbol.symbols[for_variable];
                if (t)
                  powers.push(t.power);
              } else if (g === N || for_variable !== v)
                powers.push(0);
            }
          } else if (g === CB && e.contains(for_variable)) {
            powers.push(core.Utils.decompose_fn(e, for_variable, true).x.power);
          }
          return core.Utils.arrayUnique(powers).sort();
        },
        //The factor object
        Factor: {
          //splits the symbol in symbol and constant
          split: function(symbol) {
            var c = new Symbol2(1);
            var s = new Symbol2(1);
            __.Factor.factor(symbol, new Factors()).each(function(x) {
              var t = _.parse(x);
              if (x.isConstant(true)) {
                c = _.multiply(c, t);
              } else {
                s = _.multiply(s, t);
              }
            });
            return [c, s];
          },
          mix: function(o, include_negatives) {
            var factors = keys(o);
            var l = factors.length;
            var m = [];
            for (var i = 0; i < l; i++) {
              var factor = factors[i], p = o[factor];
              var ll = m.length;
              for (var j = 0; j < ll; j++) {
                var t = m[j] * factor;
                m.push(t);
                if (include_negatives)
                  m.push(-t);
              }
              for (var j = 1; j <= p; j++)
                m.push(Math.pow(factor, j));
            }
            return m;
          },
          //TODO: this method is to replace common factoring
          common: function(symbol, factors) {
            try {
              if (symbol.group === CP) {
                var symbols = _.expand(symbol.clone(), true).collectSymbols(null, null, function(a, b) {
                  return (b.length || 1) - (a.length || 1);
                });
                var map = {};
                var coeffs = [];
                for (var i = 0; i < symbols.length; i++) {
                  var sym = symbols[i];
                  coeffs.push(sym.multiplier.clone());
                  sym.each(function(x2) {
                    var p = Number(x2.power);
                    if (isNaN(p))
                      throw new Error("exiting");
                    if (x2.value in map) {
                      if (p < map[x2.value][0])
                        map[x2.value][0] = p;
                      map[x2.value][1].push(x2);
                    } else
                      map[x2.value] = [p, [x2]];
                  });
                }
                var factor = new Symbol2(1);
                for (var x in map) {
                  if (map[x][1].length === symbols.length) {
                    factor = _.multiply(factor, _.pow(new Symbol2(x), new Symbol2(map[x][0])));
                  }
                }
                var c = core.Math2.QGCD.apply(null, coeffs);
                if (!c.equals(1)) {
                  factors.add(new Symbol2(c));
                  for (var i = 0; i < symbols.length; i++) {
                    symbols[i].multiplier = symbols[i].multiplier.divide(c);
                  }
                }
                if (!factor.equals(1)) {
                  factors.add(factor);
                  symbol = new Symbol2(0);
                  for (var i = 0; i < symbols.length; i++) {
                    symbol = _.add(symbol, _.divide(symbols[i], factor.clone()));
                  }
                }
              }
            } catch (e) {
              ;
            }
            return symbol;
          },
          zeroes: function(symbol, factors) {
            var exit = function() {
              throw new core.exceptions.ValueLimitExceededError("Exiting");
            };
            try {
              var vars, term, sum, p, e;
              symbol = _.expand(symbol.clone());
              e = symbol.toString();
              vars = variables(symbol);
              sum = new Symbol2(0);
              var terms = [];
              var powers = [];
              for (var i = 0, l = vars.length; i < vars.length; i++) {
                var subs = {};
                for (var j = 0; j < l; j++)
                  if (i !== j)
                    subs[vars[j]] = 0;
                term = _.parse(e, subs);
                var tp = term.power;
                if (!isInt(tp))
                  exit();
                terms.push(term);
                powers.push(term.power);
              }
              if (core.Utils.allSame(powers)) {
                var n_terms = symbol.length;
                var n_zeroes = terms.length;
                if (n_zeroes === 2) {
                  p = new Frac(powers[0] / (n_terms - 1));
                }
                if (n_zeroes === 3) {
                  p = new Frac(powers[0] / Math.round((Math.sqrt(8 * n_terms - 1) - 3) / 2));
                }
              } else
                p = core.Math2.QGCD.apply(null, powers);
              if (!isInt(p))
                exit();
              for (var i = 0; i < terms.length; i++) {
                var t = terms[i];
                var n2 = t.power.clone().divide(p);
                t.multiplier = new Frac(Math.pow(t.multiplier, 1 / n2));
                t.power = p.clone();
                sum = _.add(sum, t);
              }
              if (sum.group !== CP)
                return symbol;
              while (true) {
                var d = __.div(symbol.clone(), sum.clone());
                if (d[1].equals(0)) {
                  symbol = d[0];
                  factors.add(sum.clone());
                  if (symbol.equals(1))
                    break;
                } else
                  break;
              }
            } catch (e2) {
            }
            ;
            return symbol;
          },
          factor: function(symbol, factors) {
            if (symbol.isConstant()) {
              return core.Math2.factor(symbol);
            }
            var _symbol2 = _.parse(symbol);
            var retval = __.Factor._factor(_symbol2, factors);
            if (retval.equals(symbol)) {
              return retval;
            }
            if (retval.group === CB) {
              var t = new Symbol2(1);
              var p = _.parse(retval.power);
              var m = _.parse(retval.multiplier);
              retval.toUnitMultiplier();
              if (retval.multiplier.lessThan(0)) {
                t.negate();
                retval.negate();
              }
              retval.each(function(x) {
                var factored = _.parse(__.Factor._factor(x));
                if (factored.group === CB) {
                  m = _.multiply(m, Symbol2.create(factored.multiplier));
                  factored.each(function(y) {
                    var _factored = _.parse(__.Factor._factor(y));
                    t = _.multiply(t, _factored);
                    if (_factored.group === CB) {
                      m = _.multiply(m, Symbol2.create(_factored.multiplier));
                    }
                  });
                } else {
                  t = _.multiply(t, factored);
                }
              });
              retval = _.pow(_.multiply(m, t), p);
            }
            return retval;
          },
          quadFactor: function(symbol, factors) {
            if (symbol.isPoly() && __.degree(symbol.equals(2))) {
              var v = core.Utils.variables(symbol)[0];
              var coeffs = __.coeffs(symbol, v);
              var cf = __.Factor._factor(coeffs[2].clone());
              if (cf.group === CB) {
                var symbols = cf.collectSymbols();
                if (symbols.length > 2)
                  return symbol;
                var c = _.multiply(_.parse(coeffs[0]), _.parse(symbols[0]));
                var b = _.parse(coeffs[1]).negate();
                var a = _.parse(symbols[1]);
                var root = __.quad(a, b, c).filter(function(x) {
                  if (core.Utils.isInt(x))
                    return x;
                });
                if (root.length === 1) {
                  var root1 = root[0];
                  var root2 = _.divide(coeffs[0], _.parse(root1));
                  if (core.Utils.isInt(root2)) {
                    factors.add(_.parse(format("({0})*({1})+({2})", symbols[1], v, root2)));
                    factors.add(_.parse(format("({0})*({1})+({2})", symbols[0], v, root1)));
                    symbol = new Symbol2(1);
                  }
                }
              }
            }
            return symbol;
          },
          cubeFactor: function(symbol, factors) {
            if (symbol.isComposite()) {
              var symbols = symbol.collectSymbols();
              if (symbols.length === 2) {
                var sign_a = symbols[0].sign();
                var a = symbols[0].clone().abs();
                var sign_b = symbols[1].sign();
                var b = symbols[1].clone().abs();
                if (a.isCube() && b.isCube()) {
                  if (sign_a < sign_b) {
                    [sign_a, sign_b] = [sign_b, sign_a];
                    [a, b] = [b, a];
                  }
                  var m_root_a = _.parse(a.getNth(3));
                  var m_root_b = _.parse(b.getNth(3));
                  var x = _.multiply(_.expand(_.pow(a.clone().toUnitMultiplier(), _.parse("1/3"))), m_root_a);
                  var y = _.multiply(_.expand(_.pow(b.clone().toUnitMultiplier(), _.parse("1/3"))), m_root_b);
                  if (sign_a === 1 && sign_b === -1) {
                    factors.add(_.parse(format("(({0})-({1}))", x, y)));
                    factors.add(_.parse(format("(({0})^2+({0})*({1})+({1})^2)", x, y)));
                    symbol = Symbol2(1);
                  } else if (sign_a === 1 && sign_b === 1) {
                    factors.add(_.parse(format("(({0})+({1}))", x, y)));
                    factors.add(_.parse(format("(({0})^2-({0})*({1})+({1})^2)", x, y)));
                    symbol = Symbol2(1);
                  }
                }
              }
            }
            return symbol;
          },
          _factor: function(symbol, factors) {
            var g = symbol.group;
            if (symbol.group === FN) {
              var arg = symbol.args[0];
              if (arg.group === S && arg.isSimple()) {
                return symbol;
              }
            } else if (symbol.group === S && symbol.isSimple()) {
              return symbol;
            }
            if (symbol.group === CP) {
              symbol.distributeMultiplier(true);
              var t = new Symbol2(0);
              symbol.each(function(x2) {
                if (x2.group === CP && x2.power.greaterThan(1) || x2.group === CB)
                  x2 = _.expand(x2);
                t = _.add(t, x2);
              });
              t.power = symbol.power;
              symbol = t;
            }
            if (symbol.group === FN && symbol.fname !== "sqrt") {
              symbol = core.Utils.evaluate(symbol);
            }
            var untouched = symbol.clone();
            try {
              if (symbol.group === CB) {
                var p = _.parse(symbol.power);
                var den_array, num_array, den, num, dfact, nfact;
                den_array = __.Simplify.strip(symbol.getDenom());
                num_array = __.Simplify.strip(symbol.getNum());
                den = den_array.pop();
                num = num_array.pop();
                if (num.equals(symbol)) {
                  return symbol;
                }
                nfact = __.Factor.factor(num);
                dfact = __.Factor.factor(den);
                var n2 = __.Simplify.unstrip(num_array, nfact);
                var d = __.Simplify.unstrip(den_array, dfact);
                var retval = _.divide(n2, d);
                return retval;
              }
              if (symbol.group === S) {
                return symbol;
              }
              if (symbol.isConstant()) {
                if (symbol.equals(1))
                  return symbol.clone();
                var ret = core.Math2.factor(symbol);
                return ret;
              }
              var p = symbol.power.clone();
              if (isInt(p) && !(p.lessThan(0) && symbol.group === FN)) {
                var sign = p.sign();
                symbol.toLinear();
                factors = factors || new Factors();
                var map = {};
                symbol = _.parse(core.Utils.subFunctions(symbol, map));
                if (keys(map).length > 0) {
                  factors.preAdd = function(factor) {
                    var ret2 = _.parse(factor, core.Utils.getFunctionsSubs(map));
                    return ret2;
                  };
                }
                if (!symbol.isLinear()) {
                  factors.pFactor = symbol.power.toString();
                  symbol.toLinear();
                }
                var vars = variables(symbol);
                if (symbol.isImaginary()) {
                  vars.push(core.Settings.IMAGINARY);
                }
                var multiVar = vars.length > 1;
                if (multiVar) {
                  var all_S = true, all_unit = true;
                  symbol.each(function(x2) {
                    if (x2.group !== S)
                      all_S = false;
                    if (!x2.multiplier.equals(1))
                      all_unit = false;
                  });
                  if (all_S && all_unit) {
                    return _.pow(_.parse(symbol, core.Utils.getFunctionsSubs(map)), _.parse(p));
                  }
                }
                var coeff_factors = new Factors();
                symbol = __.Factor.coeffFactor(symbol, coeff_factors);
                coeff_factors.each(function(x2) {
                  if (even(p) && x2.lessThan(0)) {
                    x2.negate();
                  }
                  if (sign < 0)
                    x2.invert();
                  factors.add(x2);
                });
                var power_factors = new Factors();
                symbol = __.Factor.powerFactor(symbol, power_factors);
                power_factors.each(function(x2) {
                  if (sign < 0)
                    x2.invert();
                  factors.add(x2);
                });
                if (!multiVar) {
                  var v = vars[0];
                  symbol = __.Factor.squareFree(symbol, factors, v);
                  var t_factors = new Factors();
                  symbol = __.Factor.trialAndError(symbol, t_factors, v);
                  var tf_symbol = t_factors.toSymbol();
                  if (tf_symbol.equals(untouched)) {
                    return tf_symbol;
                  }
                  for (var x in t_factors.factors) {
                    var t_factor = t_factors.factors[x];
                    factors.add(_.pow(t_factor, _.parse(p)));
                  }
                  if (symbol.equals(untouched)) {
                    symbol = __.Factor.quadFactor(symbol, factors);
                  }
                } else {
                  symbol = __.Factor.cubeFactor(symbol, factors);
                  symbol = __.Factor.mfactor(symbol, factors);
                  factors.each(function(x2) {
                    if (sign < 0)
                      x2.power.negate();
                  });
                }
                symbol = _.parse(symbol, core.Utils.getFunctionsSubs(map));
                var addPower = factors.length === 1;
                factors.add(_.pow(symbol, _.parse(p)));
                var retval = factors.toSymbol();
                if (addPower && symbol.equals(1) && retval.isLinear()) {
                  retval = _.pow(retval, _.parse(p));
                }
                return retval;
              }
              return symbol;
            } catch (e) {
              return untouched;
            }
          },
          reduce: function(symbol, factors) {
            if (symbol.group === CP && symbol.length === 2) {
              var symbols = symbol.collectSymbols().sort(function(a2, b2) {
                return b2.multiplier - a2.multiplier;
              });
              if (symbols[0].power.equals(symbols[1].power)) {
                var n2 = _.parse(symbols[0].power), a = symbols[0].clone().toLinear(), b = symbols[1].clone().toLinear();
                factors.add(_.add(a.clone(), b.clone()));
                b.negate();
                var nn = Number(n2);
                var result = new Symbol2(0);
                for (var i = 1; i <= nn; i++) {
                  var aa = _.pow(a.clone(), _.subtract(n2.clone(), new Symbol2(i))), bb = _.pow(b.clone(), _.subtract(new Symbol2(i), new Symbol2(1)));
                  result = _.add(result, _.multiply(aa, bb));
                }
                return result;
              }
            }
            return symbol;
          },
          /**
           * Makes Symbol square free
           * @param {Symbol} symbol
           * @param {Factors} factors
           * @@param {String} variable The variable which is being factored 
           * @returns {[Symbol, Factor]}
           */
          squareFree: function(symbol, factors, variable) {
            if (symbol.isConstant() || symbol.group === S)
              return symbol;
            var poly = new Polynomial(symbol, variable);
            var sqfr = poly.squareFree();
            var p = sqfr[2];
            if (p !== 1) {
              var t = sqfr[1].toSymbol();
              t.power = t.power.multiply(new Frac(p));
              factors.add(__.Factor.factor(t));
              var retval = __.Factor.squareFree(sqfr[0].toSymbol(), factors);
              return retval;
            }
            return symbol;
          },
          /**
           * Factors the powers such that the lowest power is a constant
           * @param {Symbol} symbol
           * @param {Factors} factors
           * @returns {[Symbol, Factor]}
           */
          powerFactor: function(symbol, factors) {
            if (symbol.group !== PL || symbol.previousGroup === EX)
              return symbol;
            var k = keys(symbol.symbols);
            if (!core.Utils.allNumeric(k))
              return symbol;
            var d = core.Utils.arrayMin(k);
            var retval = new Symbol2(0);
            var q = _.parse(symbol.value + "^" + d);
            symbol.each(function(x) {
              x = _.divide(x, q.clone());
              retval = _.add(retval, x);
            });
            factors.add(q);
            return retval;
          },
          /**
           * Removes GCD from coefficients
           * @param {Symbol} symbol
           * @param {Factor} factors
           * @returns {Symbol}
           */
          coeffFactor: function(symbol, factors) {
            if (symbol.isComposite()) {
              var gcd = core.Math2.QGCD.apply(null, symbol.coeffs());
              if (!gcd.equals(1)) {
                symbol.each(function(x) {
                  if (x.isComposite()) {
                    x.each(function(y) {
                      y.multiplier = y.multiplier.divide(gcd);
                    });
                  } else
                    x.multiplier = x.multiplier.divide(gcd);
                });
                symbol.updateHash();
              } else {
                var power = function(symbol2) {
                  var p;
                  if (symbol2.group === CB) {
                    p = 0;
                    symbol2.each(function(x) {
                      p += x.power;
                    });
                  } else {
                    p = Number(symbol2.power);
                  }
                  return p;
                };
                var terms = symbol.collectSymbols(null, null, null, true).sort(function(a, b) {
                  if (a.isConstant(true))
                    return 1;
                  return b.power - a.power;
                });
                var LT = terms[0];
                if (power(LT) > power(terms[1]) || terms[1].isConstant(true)) {
                  if (LT.multiplier.lessThan(0)) {
                    factors.add(new Symbol2(-1));
                    symbol.each(function(x) {
                      x.negate();
                    }, true);
                  }
                }
              }
              if (factors) {
                factors.add(new Symbol2(gcd));
              }
            }
            return symbol;
          },
          /**
           * The name says it all :)
           * @param {Symbol} symbol
           * @param {Factor} factors
           * @@param {String} variable 
           * @returns {Symbol}
           */
          trialAndError: function(symbol, factors, variable) {
            var untouched = symbol.clone();
            try {
              var factor_array = [];
              if (symbol.isConstant() || symbol.group === S)
                return symbol;
              var poly = new Polynomial(symbol, variable), cnst = poly.coeffs[0], cfactors = core.Math2.ifactor(cnst), roots = __.proots(symbol);
              for (var i = 0; i < roots.length; i++) {
                var r = roots[i], p = 1;
                if (!isNaN(r)) {
                  for (var x in cfactors) {
                    var n2 = core.Utils.round(Math.log(x) / Math.log(Math.abs(r)), 8);
                    if (isInt(n2)) {
                      r = x;
                      p = n2;
                      break;
                    }
                  }
                  var root = new Frac(r), terms = [new Frac(root.num).negate()];
                  terms[p] = new Frac(root.den);
                  var div = Polynomial.fromArray(terms, poly.variable).fill(), t = poly.divide(div);
                  if (t[1].equalsNumber(0)) {
                    poly = t[0];
                    factor_array.push(div.toSymbol());
                  }
                }
              }
              if (!poly.equalsNumber(1)) {
                poly = __.Factor.search(poly, factors);
              }
              factor_array.forEach(function(x2) {
                factors.add(x2);
              });
              return poly.toSymbol();
            } catch (e) {
              return untouched;
            }
          },
          search: function(poly, factors, base) {
            base = base || 10;
            var v = poly.variable;
            var check2 = function(c1, c2, n2, p) {
              var candidate = Polynomial.fit(c1, c2, n2, base, p, v);
              if (candidate && candidate.coeffs.length > 1) {
                var t = poly.divide(candidate);
                if (t[1].equalsNumber(0)) {
                  factors.add(candidate.toSymbol());
                  return [t[0], candidate];
                }
              }
              return null;
            };
            var cnst = poly.coeffs[0];
            var cfactors = core.Math2.ifactor(cnst);
            var lc = poly.lc();
            var ltfactors = core.Math2.ifactor(lc);
            var subbed = poly.sub(base);
            var isubbed = core.Math2.ifactor(subbed);
            var nfactors = __.Factor.mix(isubbed, subbed < 0);
            var cp = Math.ceil(poly.coeffs.length / 2);
            var lc_is_neg = lc.lessThan(0);
            var cnst_is_neg = cnst.lessThan(0);
            ltfactors["1"] = 1;
            cfactors["1"] = 1;
            while (cp--) {
              for (var x in ltfactors) {
                for (var y in cfactors) {
                  for (var i = 0; i < nfactors.length; i++) {
                    var factor_found = check2(x, y, nfactors[i], cp);
                    if (factor_found) {
                      poly = factor_found[0];
                      if (!core.Utils.isPrime(poly.sub(base)))
                        poly = __.Factor.search(poly, factors);
                      return poly;
                    } else if (!factor_found) {
                      if (lc_is_neg && cnst_is_neg)
                        factor_found = check2(-x, -y, nfactors[i], cp);
                      else if (lc_is_neg)
                        factor_found = check2(-x, y, nfactors[i], cp);
                      else if (cnst_is_neg)
                        factor_found = check2(x, -y, nfactors[i], cp);
                    }
                  }
                }
              }
            }
            return poly;
          },
          /**
           * Equivalent of square free factor for multivariate polynomials
           * @param {type} symbol
           * @param {type} factors
           * @returns {AlgebraL#18.Factor.mSqfrFactor.symbol|Array|AlgebraL#18.__.Factor.mSqfrFactor.d}
           */
          mSqfrFactor: function(symbol, factors) {
            if (symbol.group !== FN) {
              var vars = variables(symbol).reverse();
              for (var i = 0; i < vars.length; i++) {
                do {
                  if (vars[i] === symbol.value) {
                    factors.add(symbol);
                    symbol = new Symbol2(1);
                    continue;
                  }
                  var diff = core.Calculus.diff(symbol, vars[i]);
                  var d = __.Factor.coeffFactor(diff);
                  if (d.equals(0))
                    break;
                  var can_divide = true;
                  if (d.isConstant() && symbol.isComposite()) {
                    symbol.each(function(x) {
                      if (x.multiplier % d !== 0)
                        can_divide = false;
                    }, true);
                  }
                  if (can_divide) {
                    var div = __.div(symbol, d.clone()), is_factor = div[1].equals(0);
                    if (symbol.equals(div[0]) && div[1].equals(0)) {
                      break;
                    }
                    if (div[0].isConstant()) {
                      factors.add(div[0]);
                      break;
                    }
                  } else
                    is_factor = false;
                  if (is_factor) {
                    factors.add(div[0]);
                    symbol = d;
                  }
                } while (is_factor);
              }
            }
            return symbol;
          },
          //difference of squares factorization
          sqdiff: function(symbol, factors) {
            if (symbol.isConstant("all")) {
              return symbol;
            }
            try {
              var remove_square = function(x2) {
                return core.Utils.block("POSITIVE_MULTIPLIERS", function() {
                  return Symbol2.unwrapPARENS(math.sqrt(math.abs(x2)));
                }, true);
              };
              var separated = core.Utils.separate(symbol.clone());
              var obj_array = [];
              for (var x in separated) {
                if (x !== "constants") {
                  obj_array.push(separated[x]);
                }
              }
              obj_array.sort(function(a2, b2) {
                return b2.power - a2.power;
              });
              if (obj_array.length === 2) {
                var a, b;
                a = obj_array.pop();
                b = obj_array.pop();
                if (even(a.power) && even(b.power) && a.sign() === b.sign() && a.group === S && b.group === S) {
                  throw new Error("Unable to factor");
                }
                ;
                if (a.isComposite() && b.power.equals(2)) {
                  b = remove_square(b);
                  var f = __.Factor.factor(_.add(a, separated.constants));
                  if (f.power.equals(2)) {
                    f.toLinear();
                    factors.add(_.subtract(f.clone(), b.clone()));
                    factors.add(_.add(f, b));
                    symbol = new Symbol2(1);
                  }
                } else {
                  a = a.powSimp();
                  b = b.powSimp();
                  if ((a.group === S || a.fname === "") && a.power.equals(2) && (b.group === S || b.fname === "") && b.power.equals(2) && !separated.constants) {
                    if (a.multiplier.lessThan(0)) {
                      var t = b;
                      b = a;
                      a = t;
                    }
                    if (a.multiplier.greaterThan(0)) {
                      a = remove_square(a);
                      b = remove_square(b);
                    }
                    factors.add(_.subtract(a.clone(), b.clone()));
                    factors.add(_.add(a, b));
                    symbol = new Symbol2(1);
                  }
                }
              }
            } catch (e) {
              ;
            }
            return symbol;
          },
          //factoring for multivariate
          mfactor: function(symbol, factors) {
            if (symbol.group === FN) {
              if (symbol.fname === "sqrt") {
                var factors2 = new Factors(), arg = __.Factor.common(symbol.args[0].clone(), factors2);
                arg = __.Factor.coeffFactor(arg, factors2);
                symbol = _.multiply(_.symfunction("sqrt", [arg]), _.parse(symbol.multiplier));
                factors2.each(function(x2) {
                  symbol = _.multiply(symbol, _.parse(core.Utils.format("sqrt({0})", x2)));
                });
              } else
                factors.add(symbol);
            } else {
              symbol = __.Factor.mSqfrFactor(symbol, factors);
              var vars = variables(symbol), symbols = symbol.collectSymbols().map(function(x2) {
                return Symbol2.unwrapSQRT(x2);
              }), sorted = {}, maxes = {}, l = vars.length, n2 = symbols.length;
              for (var i = 0; i < l; i++) {
                var v = vars[i];
                sorted[v] = new Symbol2(0);
                for (var j = 0; j < n2; j++) {
                  var s = symbols[j];
                  if (s.contains(v)) {
                    var p = s.value === v ? s.power.toDecimal() : s.symbols[v].power.toDecimal();
                    if (!maxes[v] || p < maxes[v])
                      maxes[v] = p;
                    sorted[v] = _.add(sorted[v], s.clone());
                  }
                }
              }
              for (var x in sorted) {
                var r = _.parse(x + "^" + maxes[x]);
                var div = _.divide(sorted[x], r);
                var new_factor = _.expand(div);
                if (new_factor.equals(1))
                  break;
                var divided = __.div(symbol.clone(), new_factor);
                if (divided[0].equals(0)) {
                  break;
                }
                if (divided[1].equals(0)) {
                  var has_fractions = false;
                  divided[0].each(function(x2) {
                    if (!isInt(x2.multiplier)) {
                      has_fractions = true;
                    }
                  });
                  if (has_fractions) {
                    divided[1] = _.expand(_.multiply(divided[1], new_factor));
                    break;
                  }
                }
                var neg_numeric_factor = isInt(new_factor) && new_factor.lessThan(0);
                if (divided[1].equals(0) && !neg_numeric_factor) {
                  var d = __.div(symbol.clone(), divided[0].clone());
                  var r = d[0];
                  if (r.equals(0)) {
                    return symbol;
                  }
                  symbol = d[1];
                  if (r.equals(-1) && !symbol.equals(0))
                    return symbol;
                  var factor = divided[0];
                  if (symbol.equals(factor)) {
                    var rem = __.Factor.reduce(factor, factors);
                    if (!symbol.equals(rem))
                      return __.Factor.mfactor(rem, factors);
                    return rem;
                  } else {
                    factors.add(factor);
                    if (symbol.equals(0))
                      return r;
                  }
                  if (r.isConstant("all")) {
                    factors.add(r);
                    return r;
                  }
                  return __.Factor.mfactor(r, factors);
                }
              }
            }
            symbol = __.Factor.sqdiff(symbol, factors);
            symbol = __.Factor.zeroes(symbol, factors);
            return symbol;
          }
        },
        /**
         * Checks to see if a set of "equations" is linear. 
         * @param {type} set
         * @returns {Boolean}
         */
        allLinear: function(set) {
          var l = set.length;
          for (var i = 0; i < l; i++) {
            if (!__.isLinear(set[i]))
              return false;
          }
          return true;
        },
        /*
         * Checks to see if the "equation" is linear
         * @param {Symbol} e
         * @returns {boolean}
         */
        isLinear: function(e) {
          var status = false, g = e.group;
          if (g === PL || g === CP) {
            status = true;
            for (var s in e.symbols) {
              var symbol = e.symbols[s], sg = symbol.group;
              if (sg === FN || sg === EX) {
                status = false;
              }
              if (sg === CB) {
                status = variables(symbol).length === 1;
              } else {
                if (sg === PL || sg === CP)
                  status = __.isLinear(symbol);
                else {
                  if (symbol.group !== N && symbol.power.toString() !== "1") {
                    status = false;
                    break;
                  }
                }
              }
            }
          } else if (g === S && e.power === 1)
            status = true;
          return status;
        },
        gcd: function() {
          var args;
          if (arguments.length === 1 && arguments[0] instanceof core.Vector)
            args = arguments[0].elements;
          else
            args = core.Utils.arguments2Array(arguments);
          if (args.length === 0)
            return new Symbol2(1);
          else if (args.length === 1)
            return args[0];
          var appeared = [], evaluate2 = false;
          for (var i = 0; i < args.length; i++) {
            if (args[i].group === FN && args[i].fname === "gcd") {
              args = args.concat(arguments[i].args);
              args.splice(i, 1);
            } else {
              var vars = variables(args[i]);
              if (core.Utils.haveIntersection(vars, appeared)) {
                evaluate2 = true;
                break;
              } else
                appeared = appeared.concat(vars);
            }
          }
          if (evaluate2 || appeared.length === 0) {
            if (args.every(function(symbol) {
              return symbol.getDenom().equals(1);
            })) {
              var aggregate = args[0];
              for (var i = 1; i < args.length; i++) {
                aggregate = __.gcd_(args[i], aggregate);
              }
              return aggregate;
            } else {
              return _.divide(
                __.gcd.apply(null, args.map(function(symbol) {
                  return symbol.getNum();
                })),
                __.lcm.apply(null, args.map(function(symbol) {
                  return symbol.getDenom();
                }))
              );
            }
          } else
            return _.symfunction("gcd", args);
        },
        gcd_: function(a, b) {
          if (a.group === FN || a.group === P)
            a = core.Utils.block("PARSE2NUMBER", function() {
              return _.parse(a);
            });
          if (b.group === FN)
            b = core.Utils.block("PARSE2NUMBER", function() {
              return _.parse(b);
            });
          if (a.isConstant() && b.isConstant()) {
            return new Symbol2(core.Math2.QGCD(new Frac(+a), new Frac(+b)));
          }
          var den = _.multiply(a.getDenom() || new Symbol2(1), b.getDenom() || new Symbol2(1)).invert();
          a = _.multiply(a.clone(), den.clone());
          b = _.multiply(b.clone(), den.clone());
          a = _.expand(a);
          b = _.expand(b);
          if (a.group === CB || b.group === CB) {
            var q = _.divide(a.clone(), b.clone());
            var t = _.multiply(b.clone(), q.getDenom().invert());
            if (!t.equals(1))
              return t;
          }
          if (a.group === EX || b.group === EX) {
            var gcd_m = new Symbol2(core.Math2.GCD(a.multiplier, b.multiplier));
            var gcd_v = __.gcd_(a.value === CONST_HASH ? new Symbol2(1) : _.parse(a.value), b.value === CONST_HASH ? new Symbol2(1) : _.parse(b.value));
            var gcd_p = __.gcd_(_.parse(a.power), _.parse(b.power));
            return _.multiply(gcd_m, _.pow(gcd_v, gcd_p));
          }
          if (a.length < b.length) {
            var t = a;
            a = b;
            b = t;
          }
          var vars_a = variables(a), vars_b = variables(b);
          if (vars_a.length === vars_b.length && vars_a.length === 1 && vars_a[0] === vars_b[0] || vars_a.length === 1 && vars_b.length === 0 || vars_a.length === 0 && vars_b.length === 1) {
            a = new Polynomial(a);
            b = new Polynomial(b);
            return _.divide(a.gcd(b).toSymbol(), den);
          } else {
            var multipliers = [];
            a.each(function(x) {
              multipliers.push(x.multiplier);
            });
            b.each(function(x) {
              multipliers.push(x.multiplier);
            });
            var T;
            while (!b.equals(0)) {
              var t = b.clone();
              a = a.clone();
              T = __.div(a, t);
              b = T[1];
              if (T[0].equals(0)) {
                return _.divide(new Symbol2(core.Math2.QGCD(a.multiplier, b.multiplier)), den);
              }
              a = t;
            }
            var gcd = core.Math2.QGCD.apply(void 0, multipliers);
            if (!gcd.equals(1)) {
              a.each(function(x) {
                x.multiplier = x.multiplier.divide(gcd);
              });
            }
            if (a.equals(1) && !a.isConstant() && !b.isConstant())
              return _.divide(_.symfunction("gcd", arguments), den);
            return _.divide(a, den);
          }
        },
        lcm: function() {
          var args;
          if (arguments.length === 1)
            if (arguments[0] instanceof core.Vector)
              args = arguments[0].elements;
            else
              _.error("lcm expects either 1 vector or 2 or more arguments");
          else
            args = core.Utils.arguments2Array(arguments);
          var numer = args.reduce(function(prev, curr) {
            return _.multiply(prev, curr.clone());
          }, new Symbol2(1));
          var denom_args = (
            //https://stackoverflow.com/a/18223072
            //take all complementary terms, e.g.
            //[a,b,c] => [a*b, b*c, a*c]
            //[a,b,c,d] => [a*b*c, a*b*d, a*c*d, b*c*d]
            (function(input, size) {
              size = Number(size);
              var results = [], result, mask, i, total = Math.pow(2, input.length);
              for (mask = size; mask < total; mask++) {
                result = [];
                i = input.length - 1;
                do {
                  if ((mask & 1 << i) !== 0) {
                    result.push(input[i]);
                  }
                } while (i--);
                if (result.length === size) {
                  results.push(result);
                }
              }
              return results;
            })(arguments, arguments.length - 1).map(function(x) {
              return x.reduce(function(prev, curr) {
                return _.multiply(prev, curr.clone());
              }, new Symbol2(1));
            })
          );
          var denom;
          if (args.every(function(x) {
            return core.Utils.isVariableSymbol(x);
          }))
            denom = _.symfunction("gcd", core.Utils.arrayUnique(denom_args));
          else
            denom = __.gcd.apply(null, denom_args);
          var div = _.divide(numer, denom);
          return div;
        },
        /**
         * Divides one expression by another
         * @param {Symbol} symbol1
         * @param {Symbol} symbol2
         * @returns {Array}
         */
        divide: function(symbol1, symbol2) {
          var result, remainder, factored, den;
          factored = core.Algebra.Factor.factor(symbol1.clone());
          den = factored.getDenom();
          if (!den.isConstant("all")) {
            symbol1 = _.expand(Symbol2.unwrapPARENS(_.multiply(factored, den.clone())));
          } else
            den = new Symbol2(1);
          result = __.div(symbol1, symbol2);
          remainder = _.divide(result[1], symbol2);
          return _.divide(_.add(result[0], remainder), den);
        },
        div: function(symbol1, symbol2) {
          var fail = [new Symbol2(0), symbol1.clone()];
          try {
            if (symbol2.isConstant("all")) {
              symbol1.each(function(x2) {
                x2.multiplier = x2.multiplier.divide(symbol2.multiplier);
              });
              return [symbol1, new Symbol2(0)];
            }
            symbol1 = _.expand(symbol1);
            symbol2 = _.expand(symbol2);
            if (symbol1.group === S && symbol2.group === CP) {
              var x = symbol1.value;
              var f = core.Utils.decompose_fn(symbol2.clone(), x, true);
              if (symbol1.isLinear() && f.x && f.x.isLinear() && symbol2.isLinear()) {
                var k = Symbol2.create(symbol1.multiplier);
                return [_.divide(k.clone(), f.a.clone()), _.divide(_.multiply(k, f.b), f.a).negate()];
              }
            }
            if (symbol1.group === S && symbol2.group === S) {
              var r = _.divide(symbol1.clone(), symbol2.clone());
              if (r.isConstant())
                return [r, new Symbol2(0)];
              return [new Symbol2(0), symbol1.clone()];
            }
            var symbol1_has_func = symbol1.hasFunc(), symbol2_has_func = symbol2.hasFunc(), parse_funcs = false;
            if (symbol1_has_func || symbol2_has_func) {
              parse_funcs = true;
              var map = {}, symbol1 = _.parse(core.Utils.subFunctions(symbol1, map)), symbol2 = _.parse(core.Utils.subFunctions(symbol2, map)), subs = core.Utils.getFunctionsSubs(map);
            }
            var vars = core.Utils.arrayUnique(variables(symbol1).concat(variables(symbol2))), quot, rem;
            if (symbol1.isImaginary() || symbol2.isImaginary()) {
              vars.push(core.Settings.IMAGINARY);
            }
            if (vars.length === 1) {
              var q = new Polynomial(symbol1).divide(new Polynomial(symbol2));
              quot = q[0].toSymbol();
              rem = q[1].toSymbol();
            } else {
              vars.push(CONST_HASH);
              var reconvert = function(arr) {
                var symbol = new Symbol2(0);
                for (var i2 = 0; i2 < arr.length; i2++) {
                  var x2 = arr[i2].toSymbol();
                  symbol = _.add(symbol, x2);
                }
                return symbol;
              };
              var get_unique_max = function(term, any) {
                var max2 = Math.max.apply(null, term.terms), count = 0, idx;
                if (!any) {
                  for (var i2 = 0; i2 < term.terms.length; i2++) {
                    if (term.terms[i2].equals(max2)) {
                      idx = i2;
                      count++;
                    }
                    if (count > 1)
                      return;
                  }
                }
                if (any) {
                  for (i2 = 0; i2 < term.terms.length; i2++)
                    if (term.terms[i2].equals(max2)) {
                      idx = i2;
                      break;
                    }
                }
                return [max2, idx, term];
              };
              var get_det = function(s, lookat) {
                lookat = lookat || 0;
                var det2 = s[lookat], l = s.length;
                if (!det2)
                  return;
                var umax = get_unique_max(det2);
                for (var i2 = lookat + 1; i2 < l; i2++) {
                  var term = s[i2], is_equal = det2.sum.equals(term.sum);
                  if (!is_equal && umax) {
                    break;
                  }
                  if (is_equal) {
                    var max1, max2, idx1, idx2, l22 = det2.terms.length;
                    for (var j2 = 0; j2 < l22; j2++) {
                      var item1 = det2.terms[j2], item2 = term.terms[j2];
                      if (typeof max1 === "undefined" || item1.greaterThan(max1)) {
                        max1 = item1;
                        idx1 = j2;
                      }
                      if (typeof max2 === "undefined" || item2.greaterThan(max2)) {
                        max2 = item2;
                        idx2 = j2;
                      }
                    }
                    var d1 = max1.subtract(term.terms[idx1]), d2 = max2.subtract(det2.terms[idx2]);
                    if (d2 > d1) {
                      umax = [max2, idx2, term];
                      break;
                    }
                    if (d1 > d2) {
                      umax = [max1, idx1, det2];
                      break;
                    }
                  } else {
                    umax = get_unique_max(term);
                    if (umax)
                      break;
                  }
                  umax = get_unique_max(term);
                }
                if (!umax)
                  return get_unique_max(s[0], true);
                var e, idx;
                for (var i2 = 0; i2 < s2.length; i2++) {
                  var cterm = s2[i2].terms;
                  idx = umax[1];
                  if (idx === cterm.length - 1)
                    return;
                  e = cterm[idx];
                  if (!e.equals(0))
                    break;
                }
                if (e.equals(0))
                  return get_det(s, ++lookat);
                return umax;
              };
              var t_map = core.Utils.toMapObj(vars);
              var init_sort = function(a, b) {
                return b.sum.subtract(a.sum);
              };
              var is_larger = function(a, b) {
                if (!a || !b)
                  return false;
                for (var i2 = 0; i2 < a.terms.length; i2++) {
                  if (a.terms[i2].lessThan(b.terms[i2]))
                    return false;
                }
                return true;
              };
              var s1 = symbol1.tBase(t_map).sort(init_sort), s2 = symbol2.tBase(t_map).sort(init_sort);
              var target = is_larger(s1[0], s2[0]) && s1[0].count > s2[0].count ? s2 : s1;
              var det = get_det(target);
              var quotient = [];
              if (det) {
                var lead_var = det[1];
                var can_divide = function(a, b) {
                  if (a[0].sum.equals(b[0].sum))
                    return a.length >= b.length;
                  return true;
                };
                var try_better_lead_var = function(s12, s22, lead_var2) {
                  var checked = [];
                  for (var i2 = 0; i2 < s12.length; i2++) {
                    var t2 = s12[i2];
                    for (var j2 = 0; j2 < t2.terms.length; j2++) {
                      var cf = checked[j2], tt = t2.terms[j2];
                      if (i2 === 0)
                        checked[j2] = tt;
                      else if (cf && !cf.equals(tt))
                        checked[j2] = void 0;
                    }
                  }
                  for (var i2 = 0; i2 < checked.length; i2++) {
                    var t2 = checked[i2];
                    if (t2 && !t2.equals(0))
                      return i2;
                  }
                  return lead_var2;
                };
                var sf = function(a, b) {
                  var l1 = a.len(), l22 = b.len();
                  var blv = b.terms[lead_var], alv = a.terms[lead_var];
                  if (l22 > l1 && blv.greaterThan(alv))
                    return l22 - l1;
                  return blv.subtract(alv);
                };
                lead_var = try_better_lead_var(s1, s2, lead_var);
                s1.sort(sf);
                s2.sort(sf);
                var fdt = s2[0], fnt = s1[0];
                var den = new MVTerm(new Frac(1), [], fnt.map);
                if (fdt.sum.greaterThan(fnt.sum) && fnt.len() > 1) {
                  for (var i = 0; i < fnt.terms.length; i++) {
                    var d = fdt.terms[i].subtract(fnt.terms[i]);
                    if (!d.equals(0)) {
                      var nd = d.add(new Frac(1));
                      den.terms[i] = d;
                      for (var j = 0; j < s1.length; j++) {
                        s1[j].terms[i] = s1[j].terms[i].add(nd);
                      }
                    } else
                      den.terms[i] = new Frac(0);
                  }
                }
                var dividend_larger = is_larger(s1[0], s2[0]);
                var safety = 0;
                var max = 200;
                while (dividend_larger && can_divide(s1, s2)) {
                  if (safety++ > max) {
                    throw new core.exceptions.InfiniteLoopError("Unable to compute!");
                  }
                  var q = s1[0].divide(s2[0]);
                  quotient.push(q);
                  s1.shift();
                  for (var i = 1; i < s2.length; i++) {
                    var t = s2[i].multiply(q).generateImage(), l2 = s1.length;
                    if (l2 === 0) {
                      t.coeff = t.coeff.neg();
                      s1.push(t);
                      s1.sort(sf);
                    }
                    for (var j = 0; j < l2; j++) {
                      var cur = s1[j];
                      if (cur.getImg() === t.getImg()) {
                        cur.coeff = cur.coeff.subtract(t.coeff);
                        if (cur.coeff.equals(0)) {
                          core.Utils.remove(s1, j);
                          j--;
                        }
                        break;
                      }
                      if (j === l2 - 1) {
                        t.coeff = t.coeff.neg();
                        s1.push(t);
                        s1.sort(sf);
                      }
                    }
                  }
                  dividend_larger = is_larger(s1[0], s2[0]);
                  if (!dividend_larger && s1.length >= s2.length) {
                    for (var i = 1; i < s1.length; i++) {
                      dividend_larger = is_larger(s1[i], s2[0]);
                      if (dividend_larger) {
                        s1.unshift(core.Utils.remove(s1, i));
                        break;
                      }
                    }
                  }
                }
              }
              quot = reconvert(quotient);
              rem = reconvert(s1);
              if (typeof den !== "undefined") {
                den = den.toSymbol();
                quot = _.divide(quot, den.clone());
                rem = _.divide(rem, den);
              }
            }
            if (parse_funcs) {
              quot = _.parse(quot.text(), subs);
              rem = _.parse(rem.text(), subs);
            }
            return [quot, rem];
          } catch (e) {
            return fail;
          }
        },
        line: function(v1, v2, x) {
          if (core.Utils.isArray(v1))
            v1 = core.Utils.convertToVector(v1);
          if (core.Utils.isArray(v2))
            v2 = core.Utils.convertToVector(v2);
          x = _.parse(x || "x");
          if (!core.Utils.isVector(v1) || !core.Utils.isVector(v2))
            _.error('Line expects a vector! Received "' + v1 + '" & "' + v2 + '"');
          var dx = _.subtract(v2.e(1).clone(), v1.e(1).clone()), dy = _.subtract(v2.e(2).clone(), v1.e(2).clone()), m = _.divide(dy, dx), a = _.multiply(x, m.clone()), b = _.multiply(v1.e(1).clone(), m);
          return _.add(_.subtract(a, b), v1.e(2).clone());
        },
        PartFrac: {
          createTemplate: function(den, denom_factors, f_array, v) {
            den = __.Factor.factor(den);
            den.each(function(x, key) {
              if (x.group === FN && x.fname === "" && x.args[0].group === S) {
                var y = x.args[0];
                if (this.symbols) {
                  delete this.symbols[key];
                  this.symbols[y.value] = y;
                } else {
                  den = x.args[0];
                }
              }
            });
            var factors, factors_vec, f, p, deg, degrees, m;
            factors = denom_factors.collectFactors();
            factors_vec = [];
            degrees = [];
            m = new Symbol2(1);
            for (var i = 0; i < factors.length; i++) {
              var factor = Symbol2.unwrapPARENS(factors[i]);
              if (factor.power.greaterThan(1)) {
                p = Number(factor.power);
                f = factor.clone().toLinear();
                deg = Number(__.degree(f, v));
                for (var j = 0; j < p; j++) {
                  var efactor = _.pow(f.clone(), new Symbol2(j + 1));
                  f_array.push(efactor.clone());
                  var d = _.divide(den.clone(), efactor.clone());
                  degrees.push(deg);
                  factors_vec.push(d);
                }
              } else {
                deg = Number(__.degree(factor, v));
                f_array.push(factor);
                var d = _.divide(den.clone(), factor.clone());
                d = _.expand(Symbol2.unwrapPARENS(d));
                degrees.push(deg);
                factors_vec.push(d);
              }
            }
            f_array = f_array.map(function(x) {
              return _.multiply(x, m.clone());
            });
            return [f_array, factors_vec, degrees];
          },
          partfrac: function(symbol, v, as_array) {
            var vars = variables(symbol);
            v = v || _.parse(vars[0]);
            try {
              var num, den, factors, tfactors, ofactors, nterms, degrees, dterms, max, M, c, powers, div, r, factors_vec, ks, template, tfactors;
              num = _.expand(symbol.getNum());
              den = _.expand(symbol.getDenom().toUnitMultiplier());
              num.multiplier = symbol.multiplier;
              nterms = num.groupTerms(v);
              if (Number(__.degree(num, v)) >= Number(__.degree(den, v))) {
                div = __.div(num.clone(), _.expand(den.clone()));
                r = div[0];
                num = div[1];
                nterms = num.groupTerms(v);
              } else
                r = new Symbol2(0);
              if (Number(__.degree(den, v)) === 1) {
                var q = _.divide(num, den);
                if (as_array)
                  return [r, q];
                return _.add(r, q);
              }
              ofactors = __.Factor.factor(den);
              template = __.PartFrac.createTemplate(den.clone(), ofactors, [], v);
              tfactors = template[0];
              factors_vec = template[1];
              degrees = template[2];
              powers = [nterms.length];
              dterms = [];
              factors = [];
              ks = [];
              var factor, deg;
              factors_vec.map(function(x2, idx) {
                factor = tfactors[idx];
                deg = degrees[idx];
                for (var i2 = 0; i2 < deg; i2++) {
                  factors.push(factor.clone());
                  var k = Symbol2.create(v, i2);
                  var t2 = _.expand(_.multiply(x2, k.clone())).groupTerms(v);
                  var p = t2.length;
                  powers.push(p);
                  dterms.push(t2);
                  ks.push(k.clone());
                }
              });
              max = core.Utils.arrayMax(powers);
              c = new core.Matrix(core.Utils.fillHoles(nterms, max)).transpose();
              M = new core.Matrix();
              for (var i = 0; i < dterms.length; i++) {
                M.elements.push(core.Utils.fillHoles(dterms[i], max));
              }
              var partials = _.multiply(M.transpose().invert(), c);
              var retval = as_array ? [r] : r;
              partials.each(function(e, i2) {
                var term = _.multiply(ks[i2], _.divide(e, factors[i2]));
                if (as_array)
                  retval.push(term);
                else
                  retval = _.add(retval, term);
              });
              return retval;
            } catch (e) {
              try {
                if (symbol.isComposite()) {
                  var denominators = {};
                  symbol.each(function(x2) {
                    var d = x2.getDenom();
                    var n2 = x2.getNum();
                    var e2 = denominators[d];
                    denominators[d] = e2 ? _.add(e2, n2) : n2;
                  });
                  var t = new Symbol2(0);
                  for (var x in denominators) {
                    t = _.add(t, _.divide(denominators[x], _.parse(x)));
                  }
                  symbol = t;
                }
              } catch (e2) {
              }
              ;
            }
            ;
            return symbol;
          }
        },
        degree: function(symbol, v, o) {
          o = o || {
            nd: [],
            //numeric
            sd: [],
            //symbolic
            depth: 0
            //call depth
          };
          if (!v) {
            var vars = variables(symbol);
            if (vars.length > 1)
              throw new Error("You must specify the variable for multivariate polynomials!");
            if (vars.length === 0)
              return new Symbol2(0);
            v = _.parse(vars[0]);
          }
          var g = symbol.group;
          if (symbol.isComposite()) {
            symbol = symbol.clone();
            symbol.distributeExponent();
            symbol.each(function(x) {
              o.depth++;
              __.degree(x, v, o);
              o.depth--;
            });
          } else if (symbol.group === CB) {
            symbol.each(function(x) {
              o.depth++;
              __.degree(x, v, o);
              o.depth++;
            });
          } else if (g === EX && symbol.value === v.value) {
            o.sd.push(symbol.power.clone());
          } else if (g === S && symbol.value === v.value) {
            o.nd.push(_.parse(symbol.power));
          } else
            o.nd.push(new Symbol2(0));
          var deg = o.nd.length > 0 ? core.Utils.arrayMax(o.nd) : void 0;
          if (o.depth === 0 && o.sd.length > 0) {
            if (deg !== void 0)
              o.sd.unshift(deg);
            return _.symfunction("max", o.sd);
          }
          if (!core.Utils.isSymbol(deg))
            deg = _.parse(deg);
          return deg;
        },
        /**
         * Attempts to complete the square of a polynomial
         * @param {type} symbol
         * @param {type} v
         * @param {type} raw
         * @throws {Error} 
         * @returns {Object|Symbol[]}
         */
        sqComplete: function(symbol, v, raw) {
          if (!core.Utils.isSymbol(v))
            v = _.parse(v);
          var stop = function(msg) {
            msg = msg || "Stopping";
            throw new core.exceptions.ValueLimitExceededError(msg);
          };
          if (!symbol.isPoly(true))
            stop("Must be a polynomial!");
          var deg, a, b, c, d, e, coeffs, sign, br, sym, sqrt_a;
          br = core.Utils.inBrackets;
          symbol = symbol.clone();
          deg = core.Algebra.degree(symbol, v);
          if (!deg.equals(2))
            stop("Cannot complete square for degree " + deg);
          coeffs = core.Algebra.coeffs(symbol, v);
          a = coeffs[2];
          sign = coeffs[1].sign();
          b = _.divide(coeffs[1], new Symbol2(2));
          c = _.pow(b.clone(), new Symbol2(2));
          if (raw)
            return [a, b, d];
          sqrt_a = math.sqrt(a);
          e = _.divide(math.sqrt(c), sqrt_a.clone());
          d = _.subtract(coeffs[0], _.pow(e.clone(), new Symbol2(2)));
          sym = _.parse(br(sqrt_a.clone() + "*" + v + (sign < 0 ? "-" : "+") + e));
          return {
            a: sym,
            c: d,
            f: _.add(_.pow(sym.clone(), new Symbol2(2)), d.clone())
          };
        },
        Simplify: {
          strip: function(symbol) {
            var c = _.parse(symbol.multiplier);
            symbol.toUnitMultiplier();
            var p = _.parse(symbol.power);
            symbol.toLinear();
            return [c, p, symbol];
          },
          unstrip: function(cp, symbol) {
            var c = cp[0];
            var p = cp[1];
            return _.multiply(c, _.pow(symbol, p));
          },
          complexSimp: function(num, den) {
            var ac, bd, bc, ad, cd, r1, r2, i1, i2;
            r1 = num.realpart();
            i1 = num.imagpart();
            r2 = den.realpart();
            i2 = den.imagpart();
            ac = _.multiply(r1.clone(), r2.clone());
            bd = _.multiply(i1.clone(), i2.clone());
            bc = _.multiply(r2.clone(), i1);
            ad = _.multiply(r1, i2.clone());
            cd = _.add(_.pow(r2, new Symbol2(2)), _.pow(i2, new Symbol2(2)));
            return _.divide(_.add(_.add(ac, bd), _.multiply(_.subtract(bc, ad), Symbol2.imaginary())), cd);
          },
          trigSimp: function(symbol) {
            if (symbol.containsFunction(["cos", "sin", "tan"])) {
              symbol = symbol.clone();
              var sym_array = __.Simplify.strip(symbol);
              symbol = sym_array.pop();
              var retval = symbol.clone();
              if (symbol.group === CP) {
                var sym = new Symbol2(0);
                symbol.each(function(x) {
                  var tr = __.Simplify.trigSimp(x.fnTransform());
                  sym = _.add(sym, tr);
                }, true);
                retval = _.pow(_.multiply(new Symbol2(symbol.multiplier), sym), new Symbol2(symbol.power));
              } else if (symbol.group === CB) {
                var n2 = symbol.getNum();
                var d = symbol.getDenom();
                if (n2.fname === "sin" && d.fname === "cos" && n2.args[0].equals(d.args[0]) && n2.power.equals(d.power)) {
                  retval = _.parse(core.Utils.format("({0})*({1})*tan({2})^({3})", d.multiplier, n2.multiplier, n2.args[0], n2.power));
                }
                if (retval.group === CB) {
                  var t = new Symbol2(1);
                  retval.each(function(x) {
                    if (x.fname === "tan") {
                      x = _.parse(core.Utils.format("({0})*sin({1})^({2})/cos({1})^({2})", x.multiplier, __.Simplify.simplify(x.args[0]), x.power));
                    }
                    t = _.multiply(t, x);
                  });
                  retval = t;
                }
              }
              retval = __.Simplify.unstrip(sym_array, retval).distributeMultiplier();
              symbol = retval;
            }
            return symbol;
          },
          fracSimp: function(symbol) {
            var den = symbol.getDenom();
            var num = symbol.getNum();
            if (num.isImaginary() && den.isImaginary())
              symbol = __.Simplify.complexSimp(num, den);
            if (symbol.isComposite()) {
              if (symbol.power > 1) {
                symbol = _.expand(symbol);
              }
              var symbols = symbol.collectSymbols();
              var retval, a, b, d1, d2, n1, n2, s, x, y, c, den, num;
              a = symbols.pop();
              while (symbols.length) {
                b = symbols.pop();
                d1 = _.parse(a.getDenom());
                d2 = _.parse(b.getDenom());
                n1 = a.getNum();
                n2 = b.getNum();
                c = _.multiply(d1.clone(), d2.clone());
                x = _.multiply(n1, d2);
                y = _.multiply(n2, d1);
                s = _.add(x, y);
                a = _.divide(s, c);
              }
              den = _.expand(a.getDenom());
              num = _.expand(a.getNum());
              if (num.isImaginary() && den.isImaginary()) {
                retval = __.Simplify.complexSimp(num, den);
              } else {
                retval = _.divide(num, den);
              }
              if (retval.equals(symbol)) {
                return symbol;
              }
              return __.Simplify.simplify(retval);
            }
            return symbol;
          },
          ratSimp: function(symbol) {
            if (symbol.group === CB) {
              var den = symbol.getDenom();
              var num = symbol.getNum().distributeMultiplier();
              var d = __.Simplify.fracSimp(den);
              var n2 = __.Simplify.fracSimp(num);
              symbol = _.divide(n2, d);
            }
            return symbol;
          },
          sqrtSimp: function(symbol, sym_array) {
            var retval;
            if (symbol.isSQRT()) {
              var factored = __.Factor.factor(symbol.args[0].clone());
              var m = _.parse(factored.multiplier);
              var sign = m.sign();
              var retval = _.sqrt(m.abs());
              var arg;
              if (isInt(retval)) {
                if (factored.group === CB) {
                  var rem = new Symbol2(1);
                  factored.each(function(x) {
                    if (x.group === N) {
                      var trial = _.sqrt(x.clone());
                      if (isInt(trial)) {
                        retval = _.multiply(retval, trial);
                      } else {
                        rem = _.multiply(rem, x);
                      }
                    } else {
                      rem = _.multiply(rem, x);
                    }
                  });
                  var t = _.multiply(rem, _.parse(sign));
                  arg = _.sqrt(t.clone());
                  if (arg.isImaginary) {
                    arg = _.sqrt(_.expand(t.clone()));
                  }
                } else {
                  arg = _.sqrt(factored.clone().toUnitMultiplier());
                }
                return _.multiply(retval, arg);
              }
            } else if (symbol.isComposite() && symbol.isLinear()) {
              retval = new Symbol2(0);
              symbol.each(function(x) {
                retval = _.add(retval, __.Simplify.sqrtSimp(x));
              }, true);
              retval = _.multiply(retval, _.parse(symbol.multiplier));
            } else if (symbol.group === CB) {
              retval = _.parse(symbol.multiplier);
              symbol.each(function(x) {
                var simp = __.Simplify.sqrtSimp(x);
                retval = _.multiply(retval, simp);
              }, true);
              retval = _.pow(retval, _.parse(symbol.power));
            }
            return retval ? retval : _.parse(symbol);
          },
          /**
           * Unused. The goal is to substitute out patterns but it currently doesn't work.
           * @param {Symbol} symbol
           * @return {Array} The symbol and the matched patterns
           */
          patternSub: function(symbol) {
            var patterns = {};
            var has_CP = function(symbol2) {
              var found = false;
              symbol2.each(function(x) {
                if (x.group === CP) {
                  found = true;
                } else if (x.symbols) {
                  found = has_CP(x);
                }
              });
              return found;
            };
            var collect = function(sym) {
              sym.each(function(x) {
                if (!x.symbols && x.group !== FN) {
                  return;
                }
                if (has_CP(x)) {
                  collect(x);
                } else {
                  if (!patterns[x.value]) {
                    var u = core.Utils.getU(symbol);
                    patterns[x.value] = u;
                    symbol = symbol.sub(x.value, u);
                  }
                }
              }, true);
            };
            collect(symbol);
            return [symbol, patterns];
          },
          simplify: function(symbol) {
            var sym_array = __.Simplify.strip(symbol);
            symbol = sym_array.pop();
            symbol = __.Simplify.fracSimp(symbol);
            if (symbol.isConstant() || symbol.group === core.groups.S) {
              sym_array.push(symbol);
              var ret = __.Simplify.unstrip(sym_array, symbol);
              return ret;
            }
            var simplified = symbol.clone();
            simplified = __.Simplify.trigSimp(simplified);
            simplified = __.Simplify.ratSimp(simplified);
            simplified = __.Factor.factor(simplified);
            if (simplified.group === core.groups.CP && simplified.isLinear()) {
              var m = simplified.multiplier.clone();
              simplified.toUnitMultiplier();
              var r = new Symbol2(0);
              simplified.each(function(x) {
                var s = __.Simplify.simplify(x);
                r = _.add(r, s);
              });
              simplified = r;
              r.multiplier = r.multiplier.multiply(m);
            }
            var retval = __.Simplify.unstrip(sym_array, simplified);
            return retval;
          }
        },
        Classes: {
          Polynomial,
          Factors,
          MVTerm
        }
      };
      core.Expression.prototype.simplify = function() {
        return __.Simplify.simplify(this.symbol);
      };
      nerdamer3.useAlgebraDiv = function() {
        var divide = __.divideFn = _.divide;
        var calls = 0;
        _.divide = function(a, b) {
          calls++;
          var ans;
          if (calls === 1)
            ans = core.Algebra.divide(a, b);
          else
            ans = divide(a, b);
          calls = 0;
          return ans;
        };
      };
      nerdamer3.useParserDiv = function() {
        if (__.divideFn)
          _.divide = __.divideFn;
        delete __.divideFn;
      };
      nerdamer3.register([
        {
          name: "factor",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Factor.factor;
          }
        },
        {
          name: "simplify",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Simplify.simplify;
          }
        },
        {
          name: "gcd",
          visible: true,
          numargs: [1],
          build: function() {
            return __.gcd;
          }
        },
        {
          name: "lcm",
          visible: true,
          numargs: [1],
          build: function() {
            return __.lcm;
          }
        },
        {
          name: "roots",
          visible: true,
          numargs: -1,
          build: function() {
            return __.roots;
          }
        },
        {
          name: "divide",
          visible: true,
          numargs: 2,
          build: function() {
            return __.divide;
          }
        },
        {
          name: "div",
          visible: true,
          numargs: 2,
          build: function() {
            return __.div;
          }
        },
        {
          name: "partfrac",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.PartFrac.partfrac;
          }
        },
        {
          name: "deg",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.degree;
          }
        },
        {
          name: "coeffs",
          visible: true,
          numargs: [1, 2],
          build: function() {
            var f = function() {
              var coeffs = __.coeffs.apply(__, arguments);
              return new core.Vector(coeffs);
            };
            return f;
          }
        },
        {
          name: "line",
          visible: true,
          numargs: [2, 3],
          build: function() {
            return __.line;
          }
        },
        {
          name: "sqcomp",
          visible: true,
          numargs: [1, 2],
          build: function() {
            var f = function(x, v) {
              try {
                v = v || variables(x)[0];
                var sq = __.sqComplete(x.clone(), v);
                return sq.f;
              } catch (e) {
                return x;
              }
            };
            return f;
          }
        }
      ]);
      nerdamer3.updateAPI();
    })();
  }
});

// node_modules/nerdamer/Calculus.js
var require_Calculus = __commonJS({
  "node_modules/nerdamer/Calculus.js"(exports2, module2) {
    if (typeof module2 !== "undefined" && typeof nerdamer3 === "undefined") {
      nerdamer3 = require_nerdamer_core();
      require_Algebra();
    }
    var nerdamer3;
    (function() {
      "use strict";
      var core = nerdamer3.getCore(), _ = core.PARSER, Frac = core.Frac, Settings = core.Settings, isSymbol = core.Utils.isSymbol, FN = core.groups.FN, Symbol2 = core.Symbol, text = core.Utils.text, inBrackets = core.Utils.inBrackets, isInt = core.Utils.isInt, format = core.Utils.format, even = core.Utils.even, evaluate = core.Utils.evaluate, N = core.groups.N, S = core.groups.S, FN = core.groups.FN, PL = core.groups.PL, CP = core.groups.CP, CB = core.groups.CB, EX = core.groups.EX, P = core.groups.P, LOG = Settings.LOG, EXP = "exp", ABS = "abs", SQRT = "sqrt", SIN = "sin", COS = "cos", TAN = "tan", SEC = "sec", CSC = "csc", COT = "cot", ASIN = "asin", ACOS = "acos", ATAN = "atan", ASEC = "asec", ACSC = "acsc", ACOT = "acot", SINH = "sinh", COSH = "cosh", TANH = "tanh", CSCH = "csch", SECH = "sech", COTH = "coth", ASECH = "asech", ACSCH = "acsch", ACOTH = "acoth";
      function NoIntegralFound(msg) {
        this.message = msg || "";
      }
      NoIntegralFound.prototype = new Error();
      Symbol2.prototype.hasIntegral = function() {
        return this.containsFunction("integrate");
      };
      Symbol2.prototype.fnTransform = function() {
        if (this.group !== FN)
          return this;
        var retval, a = this.args[0];
        var m = new Symbol2(this.multiplier);
        var sym = this.clone().toUnitMultiplier();
        if (this.isLinear()) {
          switch (this.fname) {
            case SINH:
              retval = _.parse(format("(e^({0})-e^(-({0})))/2", a));
              break;
            case COSH:
              retval = _.parse(format("(e^({0})+e^(-({0})))/2", a));
              break;
            case TANH:
              retval = _.parse(format("(e^({0})-e^(-({0})))/(e^({0})+e^(-({0})))", a));
              break;
            case TAN:
              retval = _.parse(format("sin({0})/cos({0})", a));
              break;
            case CSC:
              retval = _.parse(format("1/sin({0})", a));
              break;
            case SEC:
              retval = _.parse(format("1/cos({0})", a));
              break;
            default:
              retval = sym;
          }
        } else if (this.power.equals(2)) {
          switch (this.fname) {
            case SIN:
              retval = _.parse(format("1/2-cos(2*({0}))/2", a));
              break;
            case COS:
              retval = _.parse(format("1/2+cos(2*({0}))/2", a));
              break;
            case TAN:
              retval = _.parse(format("sin({0})^2/cos({0})^2", a));
              break;
            case COSH:
              retval = _.parse(format("1/2+cosh(2*({0}))/2", a));
              break;
            case SINH:
              retval = _.parse(format("-1/2+cosh(2*({0}))/2", a));
              break;
            case TANH:
              retval = _.parse(format("(1+cosh(2*({0})))/(-1+cosh(2*({0})))", a));
              break;
            case SEC:
              retval = _.parse(format("(1-cos(2*({0})))/(1+cos(2*({0})))+1", a));
              break;
            default:
              retval = sym;
          }
        } else if (this.fname === SEC) {
          retval = _.parse(format("1/cos({0})^({1})", this.args[0], this.power));
        } else if (this.fname === CSC) {
          retval = _.parse(format("1/sin({0})^({1})", this.args[0], this.power));
        } else if (this.fname === TAN) {
          if (this.power.lessThan(0)) {
            retval = _.parse(format("cos({0})^(-({1}))/sin({0})^({1})", this.args[0], this.power.negate()));
          } else {
            retval = _.parse(format("sin({0})^({1})/cos({0})^({1})", this.args[0], this.power));
          }
        } else if (this.fname === SIN && this.power.lessThan(0)) {
          retval = _.parse(format("csc({0})^(-({1}))", this.args[0], this.power.negate()));
        } else if (this.fname === COS && this.power.lessThan(0)) {
          retval = _.parse(format("sec({0})^(-({1}))", this.args[0], this.power.negate()));
        } else if (this.fname === SIN && this.power.equals(3)) {
          retval = _.parse(format("(3*sin({0})-sin(3*({0})))/4", this.args[0]));
        } else if (this.fname === COS && this.power.equals(3)) {
          retval = _.parse(format("(cos(3*({0}))+3*cos({0}))/4", this.args[0]));
        } else if ((this.fname === COS || this.fname === SIN) && even(this.power)) {
          var n2 = this.power / 2;
          var double_angle = _.pow(this.clone().toLinear(), _.parse(2)).fnTransform();
          var transformed = _.expand(_.pow(double_angle, _.parse(n2)));
          retval = new Symbol2(0);
          transformed.each(function(s) {
            var t = s.fnTransform();
            retval = _.add(retval, t);
          }, true);
        } else
          retval = sym;
        return _.multiply(retval, m);
      };
      Symbol2.prototype.hasTrig = function() {
        if (this.isConstant(true) || this.group === S)
          return false;
        if (this.fname && (core.Utils.in_trig(this.fname) || core.Utils.in_inverse_trig(this.fname)))
          return true;
        if (this.symbols) {
          for (var x in this.symbols)
            if (this.symbols[x].hasTrig())
              return true;
        }
        return false;
      };
      core.Expression.prototype.hasIntegral = function() {
        return this.symbol.hasIntegral();
      };
      core.Utils.toCommonDenominator = function(symbol) {
        if (symbol.isComposite() && symbol.isLinear()) {
          var m = new Symbol2(symbol.multiplier);
          var denominator = new Symbol2(1);
          var numerator = new Symbol2(0);
          symbol.each(function(x) {
            denominator = _.multiply(denominator, x.getDenom());
          }, true);
          symbol.each(function(x) {
            var num = x.getNum();
            var den = x.getDenom();
            var factor = _.multiply(num, _.divide(denominator.clone(), den));
            numerator = _.add(numerator, factor);
          });
          var retval = _.multiply(m, core.Algebra.divide(_.expand(numerator), _.expand(denominator)));
          return retval;
        }
        return symbol;
      };
      core.Utils.in_inverse_trig = function(x) {
        var inv_trig_fns = [ASIN, ACOS, ATAN, ACSC, ASEC, ACOT];
        return inv_trig_fns.indexOf(x) !== -1;
      };
      core.Utils.in_trig = function(x) {
        var trig_fns = [COS, SIN, TAN, SEC, CSC, COT];
        return trig_fns.indexOf(x) !== -1;
      };
      core.Utils.in_htrig = function(x) {
        var trig_fns = [SINH, COSH, TANH, ACSCH, ASECH, ACOTH];
        return trig_fns.indexOf(x) !== -1;
      };
      core.Matrix.jacobian = function(eqns, vars) {
        var jacobian = new core.Matrix();
        if (!vars) {
          vars = core.Utils.arrayGetVariables(eqns);
        }
        vars.forEach(function(v, i) {
          eqns.forEach(function(eq, j) {
            var e = core.Calculus.diff(eq.clone(), v);
            jacobian.set(j, i, e);
          });
        });
        return jacobian;
      };
      core.Matrix.prototype.max = function() {
        var max = new Symbol2(0);
        this.each(function(x) {
          var e = x.abs();
          if (e.gt(max))
            max = e;
        });
        return max;
      };
      core.Matrix.cMatrix = function(value, vars) {
        var m = new core.Matrix();
        vars.forEach(function(v, i) {
          m.set(i, 0, _.parse(value));
        });
        return m;
      };
      var all_functions = core.Utils.all_functions = function(arr) {
        for (var i = 0, l = arr.length; i < l; i++)
          if (arr[i].group !== FN)
            return false;
        return true;
      }, cosAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) {
        var a, b;
        a = symbol1.args[0];
        b = symbol2.args[0];
        return _.parse(format("(sin(({0})+({1}))-sin(({0})-({1})))/2", a, b));
      }, cosAsinAtransform = core.Utils.cosAsinAtranform = function(symbol1, symbol2) {
        if (Number(symbol2.power) !== 1)
          return _.multiply(symbol1, symbol2);
        var a;
        a = symbol1.args[0];
        return _.parse(format("(sin(2*({0})))/2", a));
      }, sinAsinBtransform = core.Utils.cosAsinBtranform = function(symbol1, symbol2) {
        var a, b;
        a = symbol1.args[0];
        b = symbol2.args[0];
        return _.parse(format("(cos(({0})+({1}))-cos(({0})-({1})))/2", a, b));
      }, trigTransform = core.Utils.trigTransform = function(arr) {
        var map = {}, symbol, t, retval = new Symbol2(1);
        for (var i = 0, l = arr.length; i < l; i++) {
          symbol = arr[i];
          if (symbol.group === FN) {
            var fname = symbol.fname;
            if (fname === COS && map[SIN]) {
              if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {
                t = cosAsinBtransform(symbol, map[SIN]);
              } else {
                t = cosAsinAtransform(symbol, map[SIN]);
              }
              delete map[SIN];
              retval = _.multiply(retval, t);
            } else if (fname === SIN && map[COS]) {
              if (map[COS].args[0].toString() !== symbol.args[0].toString()) {
                t = cosAsinBtransform(symbol, map[COS]);
              } else {
                t = cosAsinAtransform(symbol, map[COS]);
              }
              delete map[COS];
              retval = _.multiply(retval, t);
            } else if (fname === SIN && map[SIN]) {
              if (map[SIN].args[0].toString() !== symbol.args[0].toString()) {
                t = sinAsinBtransform(symbol, map[SIN]);
                delete map[SIN];
              } else {
                t = _.multiply(symbol, map[SIN]);
                delete map[SIN];
              }
              retval = t;
            } else {
              map[fname] = symbol;
            }
          } else
            retval = _.multiply(retval, symbol);
        }
        for (var x in map)
          retval = _.multiply(retval, map[x]);
        return retval;
      };
      core.Settings.integration_depth = 10;
      core.Settings.max_lim_depth = 10;
      var __ = core.Calculus = {
        version: "1.4.6",
        sum: function(fn, index, start, end) {
          if (!(index.group === core.groups.S))
            throw new core.exceptions.NerdamerTypeError("Index must be symbol. " + text(index) + " provided");
          index = index.value;
          var retval;
          if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {
            var modifier = end - start < 200 ? "" : "PARSE2NUMBER";
            start = Number(start);
            end = Number(end);
            retval = core.Utils.block(modifier, function() {
              var f = fn.text(), subs = { "~": true }, retval2 = new core.Symbol(0);
              for (var i = start; i <= end; i++) {
                subs[index] = new Symbol2(i);
                var ans = _.parse(f, subs);
                retval2 = _.add(retval2, ans);
              }
              return retval2;
            });
          } else {
            retval = _.symfunction("sum", arguments);
          }
          return retval;
        },
        product: function(fn, index, start, end) {
          if (!(index.group === core.groups.S))
            throw new core.exceptions.NerdamerTypeError("Index must be symbol. " + text(index) + " provided");
          index = index.value;
          var retval;
          if (core.Utils.isNumericSymbol(start) && core.Utils.isNumericSymbol(end)) {
            var modifier = end - start < 200 ? "" : "PARSE2NUMBER";
            retval = core.Utils.block(modifier, function() {
              start = Number(start);
              end = Number(end.multiplier);
              var f = fn.text(), subs = {}, retval2 = new core.Symbol(1);
              for (var i = start; i <= end; i++) {
                subs[index] = new Symbol2(i);
                retval2 = _.multiply(retval2, _.parse(f, subs));
              }
              return retval2;
            });
          } else {
            retval = _.symfunction("product", arguments);
          }
          return retval;
        },
        diff: function(symbol, wrt, nth) {
          if (core.Utils.isVector(symbol)) {
            var vector = new core.Vector([]);
            symbol.each(function(x) {
              vector.elements.push(__.diff(x, wrt, nth));
            });
            return vector;
          } else if (core.Utils.isMatrix(symbol)) {
            var matrix = new core.Matrix();
            symbol.each(function(x, i, j) {
              matrix.set(i, j, __.diff(x, wrt, nth));
            });
            return matrix;
          }
          var d = isSymbol(wrt) ? wrt.text() : wrt;
          nth = isSymbol(nth) ? nth.multiplier : nth || 1;
          if (d === void 0)
            d = core.Utils.variables(symbol)[0];
          if (symbol.group === FN && symbol.fname === SQRT) {
            var s = symbol.args[0], sp = symbol.power.clone();
            if (s.group !== N || s.group !== P) {
              s.power = isSymbol(s.power) ? _.multiply(s.power, _.multiply(new Symbol2(1 / 2)), sp) : s.power.multiply(new Frac(0.5)).multiply(sp);
              s.multiplier = s.multiplier.multiply(symbol.multiplier);
            }
            symbol = s;
          }
          if (symbol.group === FN && !isSymbol(symbol.power)) {
            var a = derive(_.parse(symbol));
            var b = __.diff(symbol.args[0].clone(), d);
            symbol = _.multiply(a, b);
          } else {
            symbol = derive(symbol);
          }
          if (nth > 1) {
            nth--;
            symbol = __.diff(symbol, wrt, nth);
          }
          return symbol;
          function polydiff(symbol2) {
            if (symbol2.value === d || symbol2.contains(d, true)) {
              symbol2.multiplier = symbol2.multiplier.multiply(symbol2.power);
              symbol2.power = symbol2.power.subtract(new Frac(1));
              if (symbol2.power.equals(0)) {
                symbol2 = Symbol2(symbol2.multiplier);
              }
            }
            return symbol2;
          }
          function derive(symbol2) {
            var g = symbol2.group, a2, b2, cp;
            if (g === N || g === S && symbol2.value !== d || g === P) {
              symbol2 = Symbol2(0);
            } else if (g === S) {
              symbol2 = polydiff(symbol2);
            } else if (g === CB) {
              var m = symbol2.multiplier.clone();
              symbol2.toUnitMultiplier();
              var retval = _.multiply(product_rule(symbol2), polydiff(symbol2));
              retval.multiplier = retval.multiplier.multiply(m);
              return retval;
            } else if (g === FN && symbol2.power.equals(1)) {
              switch (symbol2.fname) {
                case LOG:
                  cp = symbol2.clone();
                  symbol2 = symbol2.args[0].clone();
                  symbol2.power = symbol2.power.negate();
                  symbol2.multiplier = cp.multiplier.divide(symbol2.multiplier);
                  break;
                case COS:
                  symbol2.fname = SIN;
                  symbol2.multiplier.negate();
                  break;
                case SIN:
                  symbol2.fname = COS;
                  break;
                case TAN:
                  symbol2.fname = SEC;
                  symbol2.power = new Frac(2);
                  break;
                case SEC:
                  symbol2 = qdiff(symbol2, TAN);
                  break;
                case CSC:
                  symbol2 = qdiff(symbol2, "-cot");
                  break;
                case COT:
                  symbol2.fname = CSC;
                  symbol2.multiplier.negate();
                  symbol2.power = new Frac(2);
                  break;
                case ASIN:
                  symbol2 = _.parse("(sqrt(1-(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case ACOS:
                  symbol2 = _.parse("-(sqrt(1-(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case ATAN:
                  symbol2 = _.parse("(1+(" + text(symbol2.args[0]) + ")^2)^(-1)");
                  break;
                case ABS:
                  m = symbol2.multiplier.clone();
                  symbol2.toUnitMultiplier();
                  b2 = symbol2.args[0].clone();
                  b2.toUnitMultiplier();
                  symbol2 = _.parse(inBrackets(text(symbol2.args[0])) + "/abs" + inBrackets(text(b2)));
                  symbol2.multiplier = m;
                  break;
                case "parens":
                  symbol2 = Symbol2(1);
                  break;
                case "cosh":
                  symbol2.fname = "sinh";
                  break;
                case "sinh":
                  symbol2.fname = "cosh";
                  break;
                case TANH:
                  symbol2.fname = SECH;
                  symbol2.power = new Frac(2);
                  break;
                case SECH:
                  symbol2 = qdiff(symbol2, "-tanh");
                  break;
                case CSCH:
                  var arg = String(symbol2.args[0]);
                  return _.parse("-coth(" + arg + ")*csch(" + arg + ")");
                  break;
                case COTH:
                  var arg = String(symbol2.args[0]);
                  return _.parse("-csch(" + arg + ")^2");
                  break;
                case "asinh":
                  symbol2 = _.parse("(sqrt(1+(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case "acosh":
                  symbol2 = _.parse("(sqrt(-1+(" + text(symbol2.args[0]) + ")^2))^(-1)");
                  break;
                case "atanh":
                  symbol2 = _.parse("(1-(" + text(symbol2.args[0]) + ")^2)^(-1)");
                  break;
                case ASECH:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1/(" + arg + ")^2-1)*(" + arg + ")^2)");
                  break;
                case ACOTH:
                  symbol2 = _.parse("-1/((" + symbol2.args[0] + ")^2-1)");
                  break;
                case ACSCH:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1/(" + arg + ")^2+1)*(" + arg + ")^2)");
                  break;
                case ASEC:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("1/(sqrt(1-1/(" + arg + ")^2)*(" + arg + ")^2)");
                  break;
                case ACSC:
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("-1/(sqrt(1-1/(" + arg + ")^2)*(" + arg + ")^2)");
                  break;
                case ACOT:
                  symbol2 = _.parse("-1/((" + symbol2.args[0] + ")^2+1)");
                  break;
                case "S":
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("sin((pi*(" + arg + ")^2)/2)");
                  break;
                case "C":
                  var arg = String(symbol2.args[0]);
                  symbol2 = _.parse("cos((pi*(" + arg + ")^2)/2)");
                  break;
                case "Si":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("sin(" + arg + ")/(" + arg + ")");
                  break;
                case "Shi":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("sinh(" + arg + ")/(" + arg + ")");
                  break;
                case "Ci":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("cos(" + arg + ")/(" + arg + ")");
                  break;
                case "Chi":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("cosh(" + arg + ")/(" + arg + ")");
                  break;
                case "Ei":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("e^(" + arg + ")/(" + arg + ")");
                  break;
                case "Li":
                  var arg = symbol2.args[0];
                  symbol2 = _.parse("1/" + Settings.LOG + "(" + arg + ")");
                  break;
                case "erf":
                  symbol2 = _.parse("(2*e^(-(" + symbol2.args[0] + ")^2))/sqrt(pi)");
                  break;
                case "atan2":
                  var x_ = String(symbol2.args[0]), y_ = String(symbol2.args[1]);
                  symbol2 = _.parse("(" + y_ + ")/((" + y_ + ")^2+(" + x_ + ")^2)");
                  break;
                case "sign":
                  symbol2 = new Symbol2(0);
                  break;
                case "sinc":
                  symbol2 = _.parse(format("(({0})*cos({0})-sin({0}))*({0})^(-2)", symbol2.args[0]));
                  break;
                case Settings.LOG10:
                  symbol2 = _.parse("1/((" + symbol2.args[0] + ")*" + Settings.LOG + "(10))");
                  break;
                default:
                  symbol2 = _.symfunction("diff", [symbol2, wrt]);
              }
            } else if (g === EX || g === FN && isSymbol(symbol2.power)) {
              var value;
              if (g === EX) {
                value = symbol2.value;
              } else if (g === FN && symbol2.contains(d)) {
                value = symbol2.fname + inBrackets(text(symbol2.args[0]));
              } else {
                value = symbol2.value + inBrackets(text(symbol2.args[0]));
              }
              a2 = _.multiply(_.parse(LOG + inBrackets(value)), symbol2.power.clone());
              b2 = __.diff(_.multiply(_.parse(LOG + inBrackets(value)), symbol2.power.clone()), d);
              symbol2 = _.multiply(symbol2, b2);
            } else if (g === FN && !symbol2.power.equals(1)) {
              b2 = symbol2.clone();
              b2.toLinear();
              b2.toUnitMultiplier();
              symbol2 = _.multiply(polydiff(symbol2.clone()), derive(b2));
            } else if (g === CP || g === PL) {
              var c = symbol2.clone();
              var result = new Symbol2(0);
              for (var x in symbol2.symbols) {
                result = _.add(result, __.diff(symbol2.symbols[x].clone(), d));
              }
              symbol2 = _.multiply(polydiff(c), result);
            }
            symbol2.updateHash();
            return symbol2;
          }
          ;
          function qdiff(symbol2, val, altVal) {
            return _.multiply(symbol2, _.parse(val + inBrackets(altVal || text(symbol2.args[0]))));
          }
          ;
          function product_rule(symbol2) {
            var symbols = symbol2.collectSymbols(), result = new Symbol2(0), l = symbols.length;
            for (var i = 0; i < l; i++) {
              var df = __.diff(symbols[i].clone(), d);
              for (var j = 0; j < l; j++) {
                if (i !== j) {
                  df = _.multiply(df, symbols[j].clone());
                }
              }
              result = _.add(result, df);
            }
            return result;
          }
          ;
        },
        integration: {
          u_substitution: function(symbols, dx) {
            function try_combo(a2, b2, f3) {
              var d = __.diff(b2, dx);
              var q = f3 ? f3(a2, b2) : _.divide(a2.clone(), d);
              if (!q.contains(dx, true))
                return q;
              return null;
            }
            function do_fn_sub(fname, arg2) {
              var subbed = __.integrate(_.symfunction(fname, [new Symbol2(u)]), u, 0);
              subbed = subbed.sub(new Symbol2(u), arg2);
              subbed.updateHash();
              return subbed;
            }
            var a = symbols[0].clone(), b = symbols[1].clone(), g1 = a.group, g2 = b.group, u = "__u__", Q;
            if (g1 === FN && g2 !== FN) {
              var arg = a.args[0];
              Q = try_combo(b, arg.clone());
              if (Q)
                return _.multiply(Q, do_fn_sub(a.fname, arg));
              Q = try_combo(b, a);
              if (Q) {
                return __.integration.poly_integrate(a);
              }
            } else if (g2 === FN && g1 !== FN) {
              var arg = b.args[0];
              Q = try_combo(a, arg.clone());
              if (Q)
                return _.multiply(Q, do_fn_sub(b.fname, arg));
            } else if (g1 === FN && g2 === FN) {
              Q = try_combo(a.clone(), b.clone());
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
              Q = try_combo(b.clone(), a.clone());
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
            } else if (g1 === EX && g2 !== EX) {
              var p = a.power;
              Q = try_combo(b, p.clone());
              if (!Q) {
                var dc = __.integration.decompose_arg(p.clone(), dx);
                var xp = __.diff(dc[2].clone(), dx);
                var dc2 = __.integration.decompose_arg(xp.clone(), dx);
                if (_.multiply(dc[1], dc2[1]).power.equals(b.power)) {
                  var m = _.divide(dc[0].clone(), dc2[0].clone());
                  var new_val = _.multiply(m.clone(), _.pow(new Symbol2(a.value), _.multiply(dc[0], new Symbol2(u))));
                  new_val = _.multiply(new_val, new Symbol2(u));
                  return __.integration.by_parts(new_val, u, 0, {}).sub(u, dc[1].clone());
                }
              }
              var integrated = __.integrate(a.sub(p.clone(), new Symbol2(u)), u, 0), retval = _.multiply(integrated.sub(new Symbol2(u), p), Q);
              return retval;
            } else if (g2 === EX && g1 !== EX) {
              var p = b.power;
              Q = try_combo(a, p.clone());
              var integrated = __.integrate(b.sub(p, new Symbol2(u)), u, 0);
              return _.multiply(integrated.sub(new Symbol2(u), p), Q);
            } else if (a.isComposite() || b.isComposite()) {
              var f = function(a2, b2) {
                var d = __.diff(b2, dx);
                var A = core.Algebra.Factor.factor(a2), B = core.Algebra.Factor.factor(d);
                var q = _.divide(A, B);
                return q;
              };
              var f1 = a.isComposite() ? a.clone().toLinear() : a.clone(), f2 = b.isComposite() ? b.clone().toLinear() : b.clone();
              Q = try_combo(f1.clone(), f2.clone(), f);
              if (Q)
                return _.multiply(__.integration.poly_integrate(b), Q);
              Q = try_combo(f2.clone(), f1.clone(), f);
              if (Q)
                return _.multiply(__.integration.poly_integrate(a), Q);
            }
          },
          //simple integration of a single polynomial x^(n+1)/(n+1)
          poly_integrate: function(x) {
            var p = x.power.toString(), m = x.multiplier.toDecimal(), s = x.toUnitMultiplier().toLinear();
            if (Number(p) === -1) {
              return _.multiply(new Symbol2(m), _.symfunction(LOG, [s]));
            }
            return _.parse(format("({0})*({1})^(({2})+1)/(({2})+1)", m, s, p));
          },
          //If we're just spinning wheels we want to stop. This is why we 
          //wrap integration in a try catch block and call this to stop.
          stop: function(msg) {
            msg = msg || "Unable to compute integral!";
            core.Utils.warn(msg);
            throw new NoIntegralFound(msg);
          },
          partial_fraction: function(input, dx, depth, opt) {
            if (!isSymbol(dx))
              dx = _.parse(dx);
            var result, partial_fractions;
            result = new Symbol2(0);
            partial_fractions = core.Algebra.PartFrac.partfrac(input, dx);
            if (partial_fractions.group === CB && partial_fractions.isLinear()) {
              partial_fractions.each(function(x) {
                if (!x.isLinear())
                  __.integration.stop();
              });
              partial_fractions.each(function(x) {
                result = _.add(result, __.integrate(x, dx, depth, opt));
              });
            } else {
              result = _.add(result, __.integrate(partial_fractions, dx, depth, opt));
            }
            return result;
          },
          get_udv: function(symbol) {
            var parts = [[
              /*L*/
            ], [
              /*I*/
            ], [
              /*A*/
            ], [
              /*T*/
            ], [
              /*E*/
            ]];
            var setSymbol = function(x) {
              var g = x.group;
              if (g === FN) {
                var fname = x.fname;
                if (core.Utils.in_trig(fname) || core.Utils.in_htrig(fname))
                  parts[3].push(x);
                else if (core.Utils.in_inverse_trig(fname))
                  parts[1].push(x);
                else if (fname === LOG)
                  parts[0].push(x);
                else {
                  __.integration.stop();
                }
              } else if (g === S || x.isComposite() && x.isLinear() || g === CB && x.isLinear()) {
                parts[2].push(x);
              } else if (g === EX || x.isComposite() && !x.isLinear())
                parts[4].push(x);
              else
                __.integration.stop();
            };
            if (symbol.group === CB)
              symbol.each(function(x) {
                setSymbol(Symbol2.unwrapSQRT(x, true));
              });
            else
              setSymbol(symbol);
            var u, dv = new Symbol2(1);
            for (var i = 0; i < 5; i++) {
              var part = parts[i], t, l = part.length;
              if (l > 0) {
                if (l > 1) {
                  t = new Symbol2(1);
                  for (var j = 0; j < l; j++)
                    t = _.multiply(t, part[j].clone());
                } else
                  t = part[0].clone();
                if (!u) {
                  u = t;
                  u.multiplier = u.multiplier.multiply(symbol.multiplier);
                } else
                  dv = _.multiply(dv, t);
              }
            }
            return [u, dv];
          },
          trig_sub: function(symbol, dx, depth, opt, parts, symbols) {
            parts = parts || __.integration.decompose_arg(symbol.clone().toLinear(), dx);
            var b = parts[3], ax = parts[2], a = parts[0], x = parts[1];
            if (x.power.equals(2) && a.greaterThan(0)) {
              var t = core.Utils.getU(symbol), u = _.parse(TAN + inBrackets(t)), du = _.parse(SEC + inBrackets(t) + "^2"), f = _.multiply(symbol.sub(x, u), du);
              var integral = __.integrate(f, t, depth, opt).sub(u, x);
              core.Utils.clearU(u);
              return integral;
            }
          },
          by_parts: function(symbol, dx, depth, o) {
            o.previous = o.previous || [];
            var udv, u, dv, du, v, vdu, uv, retval, integral_vdu, m, c, vdu_s;
            udv = __.integration.get_udv(symbol);
            u = udv[0];
            dv = udv[1];
            du = Symbol2.unwrapSQRT(_.expand(__.diff(u.clone(), dx)), true);
            c = du.clone().stripVar(dx);
            du = _.divide(du, c.clone());
            v = __.integrate(dv.clone(), dx, depth || 0);
            vdu = _.multiply(v.clone(), du);
            vdu_s = vdu.toString();
            if (o.previous.indexOf(vdu_s) !== -1 && core.Utils.in_trig(u.fname) && dv.isE()) {
              o.is_cyclic = true;
              return new Symbol2(1);
            } else
              o.previous.push(vdu_s);
            uv = _.multiply(u, v);
            m = vdu.multiplier.clone();
            vdu.toUnitMultiplier();
            integral_vdu = _.multiply(__.integrate(vdu.clone(), dx, depth, o), c);
            integral_vdu.multiplier = integral_vdu.multiplier.multiply(m);
            retval = _.subtract(uv, integral_vdu);
            if (o.is_cyclic) {
              o.previous.pop();
              if (o.previous.length === 0) {
                retval = _.expand(retval);
                var rem = new Symbol2(0);
                retval.each(function(x) {
                  if (!x.contains(dx))
                    rem = _.add(rem, x.clone());
                });
                retval = _.divide(_.subtract(retval, rem.clone()), _.subtract(new Symbol2(1), rem));
              }
            }
            return retval;
          },
          /*
           * dependents: [Solve, integrate]
           */
          decompose_arg: core.Utils.decompose_fn
        },
        //TODO: nerdamer.integrate('-e^(-a*t)*sin(t)', 't') -> gives incorrect output
        integrate: function(original_symbol, dt, depth, opt) {
          if (!dt) {
            var vars = core.Utils.variables(original_symbol);
            if (vars.length === 1)
              dt = vars[0];
            dt = dt || "x";
          }
          if (core.Utils.isVector(original_symbol)) {
            var vector = new core.Vector([]);
            original_symbol.each(function(x) {
              vector.elements.push(__.integrate(x, dt));
            });
            return vector;
          }
          if (!isNaN(dt))
            _.error("variable expected but received " + dt);
          if (original_symbol.isConstant(true))
            return _.multiply(original_symbol.clone(), _.parse(dt));
          opt = opt || {};
          return core.Utils.block("PARSE2NUMBER", function() {
            depth = depth || 0;
            var dx = isSymbol(dt) ? dt.toString() : dt, symbol = Symbol2.unwrapSQRT(original_symbol.clone(), true), g = symbol.group, retval;
            try {
              if (++depth > core.Settings.integration_depth)
                __.integration.stop("Maximum depth reached. Exiting!");
              if (!symbol.contains(dx, true)) {
                retval = _.multiply(symbol.clone(), _.parse(dx));
              } else if (g === S) {
                retval = __.integration.poly_integrate(symbol, dx, depth);
              } else if (g === EX) {
                if (symbol.previousGroup === FN && !(symbol.fname === "sqrt" || symbol.fname === Settings.PARENTHESIS))
                  __.integration.stop();
                if (symbol.contains(dx) && symbol.previousGroup !== FN) {
                  if (symbol.power.contains(dx))
                    __.integration.stop();
                  else {
                    var t = __.diff(symbol.clone().toLinear(), dx);
                    if (t.contains(dx))
                      __.integration.stop();
                    retval = __.integration.poly_integrate(symbol, dx, depth);
                  }
                } else {
                  var a = __.diff(symbol.power.clone(), dx);
                  if (a.contains(dx)) {
                    var aa = a.stripVar(dx), x = _.divide(a.clone(), aa.clone());
                    if (x.group === S && x.isLinear()) {
                      aa.multiplier = aa.multiplier.divide(new Frac(2));
                      return _.parse(format("({2})*(sqrt(pi)*erf(sqrt(-{0})*{1}))/(2*sqrt(-{0}))", aa, dx, symbol.multiplier));
                    } else
                      __.integration.stop();
                  }
                  if (symbol.isE()) {
                    if (a.isLinear())
                      retval = symbol;
                    else {
                      if (a.isE() && a.power.group === S && a.power.power.equals(1))
                        retval = _.multiply(_.symfunction("Ei", [symbol.power.clone()]), symbol.power);
                      else
                        __.integration.stop();
                    }
                  } else {
                    var d = _.symfunction(LOG, [_.parse(symbol.value)]);
                    retval = _.divide(symbol, d);
                  }
                  retval = _.divide(retval, a);
                }
              } else if (symbol.isComposite() && symbol.isLinear()) {
                var m = _.parse(symbol.multiplier);
                symbol.toUnitMultiplier();
                retval = new Symbol2(0);
                symbol.each(function(x2) {
                  retval = _.add(retval, __.integrate(x2, dx, depth));
                });
                retval = _.multiply(m, retval);
              } else if (g === CP) {
                if (symbol.power.greaterThan(1))
                  symbol = _.expand(symbol);
                if (symbol.power.equals(1)) {
                  retval = new Symbol2(0);
                  symbol.each(function(x2) {
                    retval = _.add(retval, __.integrate(x2, dx, depth));
                  }, true);
                } else {
                  var p = Number(symbol.power), m = symbol.multiplier.clone();
                  symbol.toUnitMultiplier();
                  var fn = symbol.clone().toLinear(), decomp = __.integration.decompose_arg(fn, dx), b = decomp[3], ax = decomp[2], a = decomp[0], x = decomp[1];
                  if (p === -1 && x.group !== PL && x.power.equals(2)) {
                    var b_is_positive = isInt(b) ? b > 0 : true;
                    if (x.group === S && x.power.equals(2) && b_is_positive) {
                      var unwrapAbs = function(s) {
                        var result = new Symbol2(1);
                        s.each(function(x2) {
                          result = _.multiply(result, x2.fname === "abs" ? x2.args[0] : x2);
                        });
                        return result;
                      };
                      var A = a.clone(), B = b.clone();
                      A = _.pow(A, new Symbol2(1 / 2));
                      B = _.pow(B, new Symbol2(1 / 2));
                      var d = _.multiply(unwrapAbs(B), unwrapAbs(A)), f = _.symfunction(ATAN, [_.divide(_.multiply(a, x.toLinear()), d.clone())]);
                      retval = _.divide(f, d);
                    } else if (x.group === S && x.isLinear()) {
                      retval = _.divide(__.integration.poly_integrate(symbol), a);
                    } else {
                      if (x.power.equals(4)) {
                        var A, B, C, D, E, F, f1, f2, f3, f4, L1, L2;
                        var br = inBrackets;
                        A = _.parse(SQRT + br(a) + "*" + dx + "^2");
                        B = _.parse(SQRT + br(2) + "*" + br(a) + "^" + br("1/4") + "*" + br(b) + "^" + br("1/4") + "*" + dx);
                        C = _.parse(SQRT + br(b));
                        f1 = _.add(_.add(A.clone(), B.clone()), C.clone());
                        f2 = _.add(_.subtract(A, B), C);
                        D = _.parse(SQRT + br(2) + "*" + br(b) + "^" + br("3/4"));
                        E = _.parse(SQRT + br(b) + "*" + br(b) + "^" + br("1/4") + "*" + dx);
                        F = _.parse("2*" + br(b) + "*" + SQRT + br(2) + "*" + br(b) + "^" + br("1/4"));
                        L1 = _.divide(_.subtract(D.clone(), E.clone()), _.multiply(F.clone(), f2));
                        L2 = _.divide(_.add(D, E), _.multiply(F, f1.clone()));
                        retval = _.add(
                          __.integrate(L1, dx, depth, opt),
                          __.integrate(L2, dx, depth, opt)
                        );
                      } else
                        retval = __.integration.partial_fraction(symbol, dx, depth);
                    }
                  } else if (p === -1 / 2) {
                    if (x.group === S && x.power.equals(2)) {
                      if (ax.multiplier.lessThan(0) && !b.multiplier.lessThan(0)) {
                        a.negate();
                        if (b.isConstant() && a.isConstant()) {
                          var d = _.symfunction(SQRT, [a.clone()]), d2 = _.symfunction(SQRT, [_.multiply(a.clone(), b)]);
                          retval = _.divide(_.symfunction(ASIN, [_.divide(ax.toLinear(), d2)]), d);
                        } else {
                          var sqrt_a = _.symfunction(SQRT, [a]), sqrt_ax = _.multiply(sqrt_a.clone(), x.clone().toLinear());
                          retval = _.divide(_.symfunction(ATAN, [_.divide(sqrt_ax, _.symfunction(SQRT, [fn.clone()]))]), sqrt_a);
                        }
                      } else {
                        __.integration.stop();
                      }
                    } else {
                      __.integration.stop();
                    }
                  } else if (p === 1 / 2 && x.power.equals(2) && a.greaterThan(0)) {
                    __.integration.stop();
                  } else {
                    if (x.isLinear() && x.group !== PL)
                      retval = _.divide(__.integration.poly_integrate(symbol), a);
                    else if (x.power.equals(2) && a.greaterThan(0)) {
                      var sqa, sqb, aob, bsqi, n2, integral, u, v, uv;
                      sqa = _.parse(SQRT + inBrackets(a));
                      sqb = _.parse(SQRT + inBrackets(b));
                      aob = _.multiply(sqa.clone(), sqb.clone()).invert();
                      bsqi = _.pow(b, new Symbol2(symbol.power));
                      uv = core.Utils.getU(symbol);
                      u = _.multiply(aob, x.clone().toLinear());
                      v = _.parse(ATAN + inBrackets(u));
                      var n2 = (Math.abs(symbol.power) - 1) * 2;
                      var integral = __.integrate(_.parse(COS + inBrackets(uv) + "^" + n2));
                      core.Utils.clearU(uv);
                      return _.multiply(integral.sub(uv, v), bsqi);
                    } else {
                      if (symbol.group !== CB && !symbol.power.lessThan(0)) {
                        retval = __.integration.by_parts(symbol, dx, depth, opt);
                      } else {
                        var f = symbol.clone().toLinear();
                        var factored = core.Algebra.Factor.factor(f);
                        var was_factored = factored.toString() !== f.toString();
                        if (core.Algebra.degree(f, _.parse(dx)).equals(2) && !was_factored) {
                          try {
                            var f1, fx, u, sq;
                            sq = core.Algebra.sqComplete(f, dx);
                            u = core.Utils.getU(f);
                            f1 = sq.f.sub(sq.a, u);
                            fx = _.pow(f1, _.parse(symbol.power));
                            retval = __.integrate(fx, u).sub(u, sq.a);
                          } catch (e) {
                            __.integration.stop();
                          }
                        } else
                          retval = __.integration.partial_fraction(symbol, dx, depth, opt);
                      }
                    }
                  }
                  retval.multiplier = retval.multiplier.multiply(m);
                }
              } else if (g === FN) {
                var arg = symbol.args[0], m = symbol.multiplier.clone();
                symbol.toUnitMultiplier();
                var decomp = __.integration.decompose_arg(arg, dx);
                var a = decomp[0], x = decomp[1], fname = symbol.fname;
                if (fname === LOG || (fname === ASIN || fname === ACOS || fname === ATAN && x.isLinear())) {
                  var p = symbol.power.toString();
                  if (isInt(p))
                    depth = depth - p;
                  if (!arg.isComposite())
                    retval = _.multiply(_.parse(m), __.integration.by_parts(symbol, dx, depth, opt));
                  else {
                    var u = core.Utils.getU(symbol);
                    var f = _.pow(_.parse(LOG + inBrackets(u)), new Symbol2(p));
                    var du = __.diff(arg, dx);
                    var u_du = _.multiply(f, du);
                    var integral = __.integrate(u_du, u, depth, opt);
                    retval = _.multiply(_.parse(m), integral.sub(u, arg));
                  }
                } else if (fname === TAN && symbol.power.lessThan(0)) {
                  var sym = symbol.clone();
                  sym.power.negate();
                  sym.fname = COT;
                  return _.multiply(_.parse(m), __.integrate(sym, dx, depth));
                } else {
                  if (!a.contains(dx, true) && symbol.isLinear()) {
                    if (fname === ABS) {
                      var x = _.divide(arg.clone(), a.clone());
                      if (x.group === S && !x.power.lessThan(0)) {
                        if (core.Utils.even(x.power)) {
                          retval = __.integrate(arg, dx, depth);
                        } else {
                          var integrated = __.integrate(x, dx, depth);
                          integrated.power = integrated.power.subtract(new Frac(1));
                          retval = _.multiply(_.multiply(_.symfunction(ABS, [x.toLinear()]), integrated), a);
                        }
                      } else
                        __.integration.stop();
                    } else {
                      var ag = symbol.args[0].group, decomposed = __.integration.decompose_arg(arg, dx);
                      if (!(ag === CP || ag === S || ag === CB) || !decomposed[1].power.equals(1) || arg.hasFunc())
                        __.integration.stop();
                      switch (fname) {
                        case COS:
                          retval = _.symfunction(SIN, [arg]);
                          break;
                        case SIN:
                          retval = _.symfunction(COS, [arg]);
                          retval.negate();
                          break;
                        case TAN:
                          retval = _.parse(format(Settings.LOG + "(sec({0}))", arg));
                          break;
                        case SEC:
                          retval = _.parse(format(Settings.LOG + "(tan({0})+sec({0}))", arg));
                          break;
                        case CSC:
                          retval = _.parse(format("-" + Settings.LOG + "(csc({0})+cot({0}))", arg));
                          break;
                        case COT:
                          retval = _.parse(format(Settings.LOG + "(sin({0}))", arg));
                          break;
                        case SINH:
                          retval = _.symfunction(COSH, [arg]);
                          break;
                        case COSH:
                          retval = _.symfunction(SINH, [arg]);
                          break;
                        case TANH:
                          retval = _.parse(format(Settings.LOG + "(cosh({0}))", arg));
                          break;
                        case ASEC:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACSC:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACOT:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        //inverse htrig
                        case ASECH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACSCH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        case ACOTH:
                          retval = __.integration.by_parts(symbol, dx, depth, opt);
                          break;
                        //end inverse htrig
                        //htrigh
                        case SECH:
                          retval = _.parse(format("atan(sinh({0}))", arg));
                          break;
                        case CSCH:
                          retval = _.parse(format(Settings.LOG + "(tanh(({0})/2))", arg));
                          break;
                        case COTH:
                          retval = _.parse(format(Settings.LOG + "(sinh({0}))", arg));
                          break;
                        //end htrig
                        case EXP:
                          retval = __.integrate(_.parse(format("e^({0})", arg)), dx, depth);
                          break;
                        case "S":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          var b_ = dc[3];
                          retval = _.parse(format("(cos((1/2)*pi*(({1})+({0})*({2}))^2)+pi*(({1})+({0})*({2}))*S(({1})+({0})*({2})))/(({0})*pi)", a_, b_, x));
                          break;
                        case "C":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          var b_ = dc[3];
                          retval = _.parse(format("(pi*(({1})+({0})*({2}))*C(({1})+({0})*({2}))-sin((1/2)*pi*(({1})+({0})*({2}))^2))/(({0})*pi)", a_, b_, x_));
                          break;
                        case "erf":
                          var arg = symbol.args[0].clone(), dc = __.integration.decompose_arg(arg, dx), x_ = dc[1], a_ = dc[0];
                          retval = _.parse(format("e^(-(({2}))^2)/(({0})*sqrt(pi))+(1/({0})+({1}))*erf(({2}))", a_, x_, arg));
                          break;
                        case "sign":
                          retval = _.multiply(symbol.clone(), arg.clone());
                          break;
                        default:
                          __.integration.stop();
                      }
                      retval = _.divide(retval, a);
                    }
                  } else if (x.isLinear()) {
                    if (fname === COS || fname === SIN) {
                      var p = Number(symbol.power);
                      if (p < 0) {
                        symbol.fname = fname === SIN ? CSC : SEC;
                        symbol.invert().updateHash();
                        retval = __.integrate(symbol, dx, depth);
                      } else {
                        var arg = symbol.args[0], rd = symbol.clone(), rd2 = symbol.clone(), q = new Symbol2((p - 1) / p), na = _.multiply(a.clone(), new Symbol2(p)).invert();
                        rd.power = rd.power.subtract(new Frac(1));
                        rd2.power = rd2.power.subtract(new Frac(2));
                        var t = _.symfunction(fname === COS ? SIN : COS, [arg.clone()]);
                        if (fname === SIN)
                          t.negate();
                        retval = _.add(_.multiply(_.multiply(na, rd), t), _.multiply(q, __.integrate(_.parse(rd2), dx, depth)));
                      }
                    } else if (fname === TAN || fname === COT) {
                      if (symbol.args[0].isLinear(dx)) {
                        var n2 = symbol.power.subtract(new Frac(1)).toString(), r = symbol.clone().toUnitMultiplier(), w = _.parse(format((fname === COT ? "-" : "") + "1/({2}*{0})*{3}({1})^({0})", n2, arg, a, fname));
                        r.power = r.power.subtract(new Frac(2));
                        if (r.power.equals(0))
                          r = _.parse(r);
                        retval = _.subtract(w, __.integrate(r, dx, depth));
                      }
                    } else if (fname === SEC || fname === CSC) {
                      var n1 = symbol.power.subtract(new Frac(1)).toString(), n22 = symbol.power.subtract(new Frac(2)).toString(), f2 = fname === SEC ? TAN : COT, r = symbol.clone().toUnitMultiplier(), parse_str = format((fname === CSC ? "-" : "") + "1/({0}*{1})*{4}({3})^({2})*{5}({3})", a, n1, n22, arg, fname, f2), w = _.parse(parse_str);
                      r.power = r.power.subtract(new Frac(2));
                      if (r.power.equals(0))
                        r = _.parse(r);
                      retval = _.add(w, _.multiply(new Symbol2(n22 / n1), __.integrate(r, dx, depth)));
                    } else if ((fname === COSH || fname === SINH) && symbol.power.equals(2)) {
                      retval = __.integrate(symbol.fnTransform(), dx, depth);
                    } else
                      __.integration.stop();
                  } else
                    __.integration.stop();
                  retval.multiplier = retval.multiplier.multiply(m);
                }
              } else if (g === PL) {
                retval = __.integration.partial_fraction(symbol, dx, depth);
              } else if (g === CB) {
                var den = symbol.getDenom();
                if (den.group === S)
                  symbol = _.expand(symbol);
                var coeff = symbol.stripVar(dx);
                var cfsymbol = _.divide(symbol.clone(), coeff.clone());
                if (coeff.contains(dx)) {
                  cfsymbol = _.multiply(cfsymbol, coeff);
                  coeff = new Symbol2(1);
                }
                if (cfsymbol.group !== CB) {
                  if (cfsymbol.equals(1)) {
                    return __.integrate(_.expand(symbol), dx, depth);
                  }
                  if (cfsymbol.clone().toLinear().isPoly(true) && core.Utils.variables(cfsymbol).length > 1) {
                    cfsymbol = core.Algebra.Factor.factor(cfsymbol);
                  }
                  retval = __.integrate(cfsymbol, dx, depth);
                } else {
                  var symbols = cfsymbol.collectSymbols().sort(function(a2, b2) {
                    if (a2.group === b2.group) {
                      if (Number(a2.power) === Number(b2.power))
                        if (a2 < b2)
                          return 1;
                        else
                          return -1;
                      return b2.power - a2.power;
                    }
                    return b2.group - a2.group;
                  }).map(function(x2) {
                    var unwrapped = Symbol2.unwrapSQRT(x2, true);
                    if (unwrapped.fname === EXP) {
                      return _.parse(format("({1})*e^({0})", unwrapped.args[0], unwrapped.multiplier));
                    }
                    return unwrapped;
                  });
                  var l = symbols.length;
                  if (symbol.power < 0) {
                    if (l === 2) {
                      return __.integrate(_.expand(symbol), dx, depth, opt);
                    }
                  } else {
                    if (l === 2) {
                      try {
                        retval = __.integration.u_substitution(symbols, dx);
                      } catch (e) {
                        ;
                      }
                      if (!retval) {
                        var g1 = symbols[0].group, g2 = symbols[1].group, sym1 = symbols[0], sym2 = symbols[1], fn1 = sym1.fname, fn2 = sym2.fname;
                        symbol = _.multiply(sym1.clone(), sym2.clone());
                        if (g1 === FN && g2 === FN) {
                          if (fn1 === LOG || fn2 === LOG) {
                            retval = __.integration.by_parts(symbol.clone(), dx, depth, opt);
                          } else {
                            symbols.sort(function(a2, b2) {
                              return b2.fname > a2.fname;
                            });
                            var arg1 = sym1.args[0];
                            if (!arg1.isLinear() || !(arg1.group === CP || arg1.group === CB || arg1.group === S))
                              __.integration.stop();
                            var decomp = __.integration.decompose_arg(arg1, dx);
                            x = decomp[1], a = decomp[0];
                            if (!x.isLinear())
                              __.integration.stop();
                            var arg2 = sym2.args[0];
                            if (arg1.equals(arg2)) {
                              if (fn1 === SIN && fn2 === COS || fn1 === COS && fn2 === SIN) {
                                if (sym1.power.lessThan(0))
                                  __.integration.stop();
                                if (fn1 === SIN && sym1.power.add(sym2.power).equals(0)) {
                                  sym1.fname = TAN;
                                  sym1.updateHash();
                                  retval = __.integrate(sym1, dx, depth);
                                } else {
                                  if (even(sym1.power) && fn2 === COS && sym2.power.lessThan(0)) {
                                    var n2 = Number(sym1.power) / 2, new_sym = _.parse(format("(1-cos({0})^2)^({1})", sym1.args[0], n2));
                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);
                                  } else if (even(sym1.power) && fn2 === SIN && sym2.power.lessThan(0)) {
                                    var n2 = Number(sym1.power) / 2, new_sym = _.parse(format("(1-sin({0})^2)^({1})", sym1.args[0], n2));
                                    retval = __.integrate(_.expand(_.multiply(new_sym, sym2.clone())), dx, depth, opt);
                                  } else {
                                    var p1_even = core.Utils.even(sym1.power), p2_even = core.Utils.even(sym2.power);
                                    retval = new Symbol2(0);
                                    if (!p1_even || !p2_even) {
                                      var u, r, trans;
                                      if (!p1_even) {
                                        u = sym2;
                                        r = sym1;
                                      } else {
                                        u = sym1;
                                        r = sym2;
                                      }
                                      var sign = u.fname === COS ? -1 : 1, n2 = r.power, k = (n2 - 1) / 2, trans = _.parse("(1-" + u.fname + core.Utils.inBrackets(arg1) + "^2)^" + k), sym = _.expand(_.multiply(new Symbol2(sign), _.multiply(u.clone(), trans)));
                                      sym.each(function(x2) {
                                        retval = _.add(retval, __.integration.poly_integrate(x2.clone()));
                                      });
                                    } else {
                                      var double_angle = function(symbol2) {
                                        var p3 = symbol2.power, k2 = p3 / 2, e;
                                        if (symbol2.fname === COS)
                                          e = "((1/2)+(cos(2*(" + symbol2.args[0] + "))/2))^" + k2;
                                        else
                                          e = "((1/2)-(cos(2*(" + symbol2.args[0] + "))/2))^" + k2;
                                        return _.parse(e);
                                      };
                                      var a = double_angle(sym1), b = double_angle(sym2), t = _.multiply(a, b);
                                      var sym = _.expand(t);
                                      sym.each(function(x2) {
                                        retval = _.add(retval, __.integrate(x2, dx, depth));
                                      });
                                      return _.multiply(retval, coeff);
                                    }
                                  }
                                }
                              } else if (fn1 === SEC && fn2 === TAN && x.isLinear() && sym2.isLinear()) {
                                retval = _.parse(format("sec({0})^({1})/({1})", sym1.args[0], sym1.power));
                              } else if (fn1 === TAN && fn2 === SEC && x.isLinear()) {
                                if (sym1.isLinear() && sym2.isLinear()) {
                                  retval = _.divide(_.symfunction(SEC, [arg1.clone()]), a);
                                } else if (even(sym1.power)) {
                                  var p = Number(sym1.power) / 2;
                                  var t = _.parse(format("(sec({0})^2-1)^({1})", sym1.args[0], p));
                                  retval = __.integrate(_.expand(_.multiply(t, sym2)), dx, depth);
                                } else
                                  __.integration.stop();
                              } else if (fn1 === SEC && fn2 === COS) {
                                sym1.fname = COS;
                                sym1.invert().updateHash();
                                retval = __.integrate(_.multiply(sym1, sym2), dx, depth);
                              } else if (fn1 === SIN && fn2 === CSC) {
                                sym2.fname = SIN;
                                sym2.invert().updateHash();
                                retval = __.integrate(_.multiply(sym1, sym2), dx, depth);
                              } else if (fn1 === TAN && (fn2 === COS || fn2 === SIN) && sym2.power.lessThan(0)) {
                                var t = _.multiply(sym1.fnTransform(), sym2);
                                retval = __.integrate(_.expand(t), dx, depth);
                              } else {
                                var t = _.multiply(sym1.fnTransform(), sym2.fnTransform());
                                retval = __.integrate(_.expand(t), dx, depth);
                              }
                            } else if ((fn1 === SIN || fn1 === COS) && (fn2 === SIN || fn2 === COS)) {
                              if (sym1.isLinear() && sym2.isLinear()) {
                                if (sym1.args[0].isLinear() && sym2.args[0].isLinear()) {
                                  var ax, bx;
                                  if (fn2 === SIN) {
                                    ax = sym1.args[0];
                                    bx = sym2.args[0];
                                  } else {
                                    bx = sym1.args[0];
                                    ax = sym2.args[0];
                                  }
                                  f = _.parse(format("(sin(({1})+({0}))+sin(({1})-({0})))/2", ax.toString(), bx.toString()));
                                  retval = __.integrate(f, dx, depth);
                                } else {
                                  var transformed = trigTransform(symbols);
                                  retval = __.integrate(_.expand(transformed), dx, depth);
                                }
                              } else {
                                var transformed = new Symbol2(1);
                                symbols.map(function(sym3) {
                                  var s = sym3.fnTransform();
                                  transformed = _.multiply(transformed, s);
                                });
                                var t = _.expand(transformed);
                                retval = __.integrate(t, dx, depth);
                                if (retval.hasIntegral()) {
                                  retval = __.integrate(trigTransform(transformed.collectSymbols()), dx, depth);
                                }
                              }
                            } else {
                              __.integration.stop();
                            }
                          }
                        } else if (g1 === FN && g2 === S) {
                          var sym1_is_linear = sym1.isLinear();
                          if (sym1.fname === COS && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Ci", [sym1.args[0]]);
                          else if (sym1.fname === COS && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === COSH && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Chi", [sym1.args[0]]);
                          else if (sym1.fname === COSH && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === SIN && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Si", [sym1.args[0]]);
                          else if (sym1.fname === SIN && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === SINH && sym1_is_linear && sym2.power.equals(-1))
                            retval = _.symfunction("Shi", [sym1.args[0]]);
                          else if (sym1.fname === SINH && sym2.power.equals(-1)) {
                            retval = __.integrate(_.multiply(sym1.fnTransform(), sym2.clone()), dx, depth);
                          } else if (sym1.fname === LOG && sym2.power.equals(-1)) {
                            retval = __.integration.poly_integrate(sym1, dx, depth);
                          } else if (sym1.fname === "erf") {
                            if (sym2.power.equals(1)) {
                              var dc = __.integration.decompose_arg(sym1.args[0], dx), a_ = dc[0], x_ = dc[1], arg = sym1.args[0].toString();
                              retval = _.parse(format("(e^(-(({2}))^2)*(sqrt(pi)*e^((({2}))^2)*(2*({0})^2*({1})^2-3)*erf(({2}))+2*({0})*({1})-2))/(4*sqrt(pi)*({0})^2)", a_, x_, arg));
                            }
                          } else {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          }
                        } else if (g1 === EX && g2 === S) {
                          var x = fn1 === LOG ? __.integration.decompose_arg(sym1.args[0], dx)[1] : null;
                          if (sym1.isE() && (sym1.power.group === S || sym1.power.group === CB) && sym2.power.equals(-1)) {
                            retval = _.symfunction("Ei", [sym1.power.clone()]);
                          } else if (fn1 === LOG && x.value === sym2.value) {
                            retval = __.integration.poly_integrate(sym1, dx, depth);
                          } else
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                        } else if (g1 === PL && g2 === S) {
                          if (sym2.value === sym1.value && sym1.power.equals(-1)) {
                            var pd = Math.min.apply(null, core.Utils.keys(sym1.symbols));
                            var pc = Math.min(pd, sym2.power);
                            var factor = sym2.clone();
                            factor.power = new Frac(pc);
                            sym2 = _.divide(sym2, factor.clone());
                            var t = new Symbol2(0);
                            sym1.each(function(x2) {
                              t = _.add(t, _.divide(x2.clone(), factor.clone()));
                            });
                            t.multiplier = sym1.multiplier;
                            symbol = _.divide(sym2, t);
                          } else {
                            symbol = _.expand(symbol);
                          }
                          retval = __.integration.partial_fraction(symbol, dx, depth);
                        } else if (g1 === CP && g2 === S) {
                          var f = sym1.clone().toLinear(), f_is_linear = core.Algebra.degree(f, _.parse(dx)).equals(1);
                          if (sym1.power.equals(-1 / 2)) {
                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx);
                            var a = decomp[0].negate(), x = decomp[1], b = decomp[3], p1 = Number(sym1.power), p2 = Number(sym2.power);
                            if (isInt(p2) && core.Utils.even(p2) && x.power.equals(2)) {
                              var c = _.divide(
                                _.multiply(
                                  _.pow(b.clone(), new Symbol2(2)),
                                  _.symfunction(SQRT, [_.divide(b.clone(), a.clone())])
                                ),
                                _.pow(a.clone(), new Symbol2(2))
                              );
                              c = _.multiply(c, _.symfunction(SQRT, [b]).invert());
                              var dummy = _.parse("sin(u)");
                              dummy.power = dummy.power.multiply(sym2.power);
                              var integral = __.integrate(dummy, "u", depth);
                              var bksub = _.parse(ASIN + "(" + SQRT + "(" + a + "/" + b + ")*" + dx + ")");
                              retval = _.multiply(c, integral.sub(new Symbol2("u"), bksub));
                            } else if (p1 === -1 / 2) {
                              var u_transform = function(f5, u2) {
                                var integral2 = _.parse(__.integrate(f5, dx, depth, opt).sub(dx, format(u2, dx)));
                                if (!integral2.hasIntegral())
                                  return integral2;
                              };
                              if (p2 === -1) {
                                retval = u_transform(
                                  _.expand(_.expand(_.pow(_.multiply(sym1.invert(), sym2.invert()), new Symbol2(2)))).invert(),
                                  "sqrt(1-1/({0})^2)"
                                );
                              } else if (p2 === -2) {
                                retval = u_transform(
                                  _.sqrt(_.expand(_.divide(_.pow(symbol, new Symbol2(2)).invert(), _.pow(new Symbol2(dx), new Symbol2(2))).negate())).invert(),
                                  "sqrt(1-1/({0})^2)"
                                );
                              }
                            }
                          } else if (sym1.power.equals(-1) && sym2.isLinear() && f_is_linear) {
                            retval = __.integration.partial_fraction(symbol, dx, depth);
                          } else if (!sym1.power.lessThan(0) && isInt(sym1.power)) {
                            var expanded = _.expand(sym1);
                            retval = new Symbol2(0);
                            expanded.each(function(x2) {
                              if (x2.group === PL) {
                                x2.each(function(y) {
                                  retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), y), dx, depth));
                                });
                              } else
                                retval = _.add(retval, __.integrate(_.multiply(sym2.clone(), x2), dx, depth));
                            });
                          } else if (sym1.power.lessThan(-2)) {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          } else if (sym1.power.lessThan(0) && sym2.power.greaterThan(1)) {
                            var decomp = __.integration.decompose_arg(sym1.clone().toLinear(), dx), a = decomp[0].negate(), x = decomp[1], b = decomp[3], fn = sym1.clone().toLinear();
                            if (x.group !== PL && x.isLinear()) {
                              var p = Number(sym2.power), du = "_u_", u = new Symbol2(du), U = _.expand(_.divide(_.pow(_.subtract(u.clone(), b.clone()), new Symbol2(p)), u.clone())), scope = {};
                              scope[du] = fn;
                              var U2 = _.parse(U, scope);
                              retval = __.integrate(U2, dx, 0);
                            } else if (sym2.power.greaterThan(x.power) || sym2.power.equals(x.power)) {
                              var factors = new core.Algebra.Classes.Factors();
                              sym1 = core.Algebra.Factor.coeffFactor(sym1.invert(), factors);
                              var div = core.Algebra.divide(sym2, sym1);
                              if (div.group !== CB) {
                                retval = new Symbol2(0);
                                div.each(function(t2) {
                                  retval = _.add(retval, __.integrate(t2, dx, depth));
                                });
                                factors.each(function(factor2) {
                                  retval = _.divide(retval, factor2);
                                });
                                retval = _.expand(retval);
                              } else {
                                retval = __.integration.by_parts(symbol, dx, depth, opt);
                              }
                            } else
                              retval = __.integration.partial_fraction(symbol, dx, depth);
                          } else {
                            if (sym1.power.den.equals(2)) {
                              var dc = __.integration.decompose_arg(sym1.clone().toLinear(), dx), a = dc[3], x = dc[1], b = dc[0], bx = dc[2];
                              if (x.power.equals(2) && b.lessThan(0)) {
                                if (!a.equals(1)) {
                                  coeff = _.multiply(coeff, _.pow(a, new Symbol2(2)));
                                }
                                var u = dx;
                                var c = _.divide(_.pow(b.clone().negate(), new Symbol2(1 / 2)), _.pow(a, new Symbol2(1 / 2))), du = _.symfunction(COS, [new Symbol2(u)]), cosn = _.pow(_.symfunction(COS, [new Symbol2(u)]), new Symbol2(sym1.power.num)), X = _.pow(_.symfunction(SIN, [new Symbol2(u)]), new Symbol2(sym2.power)), val = _.multiply(_.multiply(cosn, du), X), integral = __.integrate(val, u, depth);
                                retval = integral.sub(u, _.symfunction(ASIN, [_.multiply(new Symbol2(dx), c)]));
                              } else {
                                retval = __.integration.partial_fraction(symbol, dx, depth, opt);
                              }
                            } else if (f_is_linear) {
                              retval = __.integration.partial_fraction(symbol, dx, depth);
                            }
                          }
                        } else if (sym1.isComposite() && sym2.isComposite()) {
                          retval = new Symbol2(0);
                          if (sym1.power.greaterThan(0) && sym2.power.greaterThan(0)) {
                            var sym = _.expand(symbol);
                            sym.each(function(x2) {
                              retval = _.add(retval, __.integrate(x2, dx, depth));
                            }, true);
                          } else {
                            var p1 = Number(sym1.power), p2 = Number(sym2.power);
                            if (p1 < 0 && p2 > 0) {
                              var t = sym1;
                              sym1 = sym2;
                              sym2 = t;
                            }
                            if (p1 === -1 && p2 === -1) {
                              retval = __.integration.partial_fraction(symbol, dx);
                            } else {
                              sym1.each(function(x2) {
                                var k2 = _.multiply(x2, sym2.clone());
                                var integral2 = __.integrate(k2, dx, depth);
                                retval = _.add(retval, integral2);
                              });
                            }
                          }
                        } else if (g1 === CP && symbols[0].power.greaterThan(0)) {
                          sym1 = _.expand(sym1);
                          retval = new Symbol2(0);
                          sym1.each(function(x2) {
                            retval = _.add(retval, __.integrate(_.multiply(x2, sym2.clone()), dx, depth));
                          }, true);
                        } else if (g1 === FN && g2 === EX && core.Utils.in_htrig(sym1.fname)) {
                          sym1 = sym1.fnTransform();
                          retval = __.integrate(_.expand(_.multiply(sym1, sym2)), dx, depth);
                        } else if (g1 === FN && g2 === CP || g2 === FN && g1 === CP) {
                          if (g2 === FN && g1 === CP) {
                            var t = sym1;
                            sym1 = sym2;
                            sym2 = t;
                          }
                          var du, sym2_clone, p, q, sa, sb;
                          du = Symbol2.unwrapSQRT(__.diff(sym1.clone(), dx), true);
                          sym2_clone = Symbol2.unwrapSQRT(sym2, true);
                          if (du.power.equals(sym2_clone.power)) {
                            p = new Symbol2(sym2.power);
                            sa = du.clone().toLinear();
                            sb = sym2.clone().toLinear();
                            q = core.Algebra.divide(sa.toLinear(), sb);
                            if (q.isConstant()) {
                              var nq = _.pow(q, p.negate());
                              retval = _.multiply(nq, __.integration.poly_integrate(sym1.clone()));
                            }
                          } else {
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                          }
                        } else {
                          var syma = sym1.clone().toLinear();
                          var symb = sym2.clone().toLinear();
                          if (g1 === EX && g2 === EX && sym1.power.contains(dx) && sym2.power.contains(dx) && !syma.contains(dx) && !symb.contains(dx)) {
                            retval = _.parse(format(
                              "(({0})^(({2})*({4}))*({1})^(({3})*({4})))/(log(({0})^({2}))+log(({1})^({3})))",
                              syma.toString(),
                              symb.toString(),
                              sym1.power.multiplier.toString(),
                              sym2.power.multiplier.toString(),
                              dx
                            ));
                          } else
                            retval = __.integration.by_parts(symbol, dx, depth, opt);
                        }
                      }
                    } else if (l === 3 && (symbols[2].group === S && symbols[2].power.lessThan(2) || symbols[0].group === CP)) {
                      var first = symbols[0];
                      if (first.group === CP) {
                        if (first.power.greaterThan(1))
                          first = _.expand(first);
                        var r = _.multiply(symbols[1], symbols[2]);
                        retval = new Symbol2(0);
                        first.each(function(x2) {
                          var t2 = _.multiply(x2, r.clone());
                          var intg = __.integrate(t2, dx, depth);
                          retval = _.add(retval, intg);
                        }, true);
                      } else {
                        retval = __.integration.by_parts(symbol, dx, depth, opt);
                      }
                    } else if (all_functions(symbols)) {
                      var t = new Symbol2(1);
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        t = _.multiply(t, symbols[i].fnTransform());
                      }
                      t = _.expand(t);
                      retval = __.integrate(t, dx, depth);
                    } else {
                      var transformed = trigTransform(symbols);
                      retval = __.integrate(_.expand(transformed), dx, depth);
                    }
                  }
                }
                retval = _.multiply(retval, coeff);
              }
              if (retval)
                return retval;
            } catch (error) {
              if (!(error instanceof NoIntegralFound || error instanceof core.exceptions.DivisionByZero))
                throw error;
            }
            return _.symfunction("integrate", [original_symbol, dt]);
          }, false);
        },
        defint: function(symbol, from, to, dx) {
          dx = dx || "x";
          var get_value = function(integral2, vars2, point) {
            try {
              return _.parse(integral2, vars2);
            } catch (e) {
              var lim = __.Limit.limit(integral2, dx, point);
              return lim;
            }
          };
          var vars = core.Utils.variables(symbol), hasTrig = symbol.hasTrig();
          var retval, integral;
          if (vars.length === 1 && !dx)
            dx = vars[0];
          if (!hasTrig) {
            integral = __.integrate(symbol, dx);
          }
          if (!hasTrig && !integral.hasIntegral()) {
            var upper = {}, lower = {}, a, b;
            upper[dx] = to;
            lower[dx] = from;
            a = get_value(integral, upper, to, dx);
            b = get_value(integral, lower, from, dx);
            retval = _.subtract(a, b);
          } else if (vars.length === 1 && from.isConstant() && to.isConstant()) {
            var f = core.Utils.build(symbol);
            retval = new Symbol2(core.Math2.num_integrate(f, Number(from), Number(to)));
          } else
            retval = _.symfunction("defint", [symbol, from, to, dx]);
          return retval;
        },
        Limit: {
          interval: function(start, end) {
            return _.parse(format("[{0}, {1}]", start, end));
          },
          diverges: function() {
            return __.Limit.interval("-Infinity", "Infinity");
          },
          divide: function(f, g, x, lim, depth) {
            if (depth++ > Settings.max_lim_depth) {
              return;
            }
            var fin = f.clone(), gin = g.clone();
            if (g.fname === ABS) {
              var sign = f.sign();
              var lim_sign = lim.sign();
              if (lim.isInfinity)
                return _.multiply(new Symbol2(sign), new Symbol2(lim_sign));
              else if (lim.equals(0)) {
                var fm = _.parse(f.multiplier);
                var gm = _.parse(g.multiplier);
                return _.divide(_.multiply(fm, __.Limit.interval("-1", "1")), gm);
              } else {
                __.Limit.diverges();
              }
            }
            var isInfinity = function(L) {
              if (core.Utils.isVector(L)) {
                for (var i = 0; i < L.elements.length; i++)
                  if (!L.elements[i].isInfinity)
                    return false;
                return true;
              }
              return L.isInfinity;
            };
            var equals = function(L, v) {
              if (core.Utils.isVector(L)) {
                return false;
              }
              return L.equals(v);
            };
            var retval;
            do {
              var lim1 = evaluate(__.Limit.limit(f.clone(), x, lim, depth));
              var lim2 = evaluate(__.Limit.limit(g.clone(), x, lim, depth));
              var indeterminate = isInfinity(lim1) && isInfinity(lim2) || equals(lim1, 0) && equals(lim2, 0);
              if (indeterminate) {
                var ft = __.diff(f.clone(), x);
                var gt = __.diff(g.clone(), x);
                var t_symbol = _.expand(_.divide(ft, gt));
                f = t_symbol.getNum();
                g = t_symbol.getDenom();
              }
            } while (indeterminate);
            var den_is_zero = lim2.equals(0);
            var p = Number(gin.power);
            if (lim.isConstant(true) && den_is_zero) {
              retval = Symbol2.infinity(core.Utils.even(p) && lim1.lessThan(0) ? -1 : void 0);
            } else if (den_is_zero) {
              retval = __.Limit.diverges();
            } else {
              retval = _.divide(lim1, lim2);
            }
            return retval;
          },
          rewriteToLog: function(symbol) {
            var p = symbol.power.clone();
            symbol.toLinear();
            return _.pow(new Symbol2("e"), _.multiply(p, _.symfunction(Settings.LOG + "", [symbol])));
          },
          getSubbed: function(f, x, lim) {
            var retval;
            if (f.group === EX) {
              f = __.rewriteToLog(f);
            }
            try {
              retval = f.sub(x, lim);
            } catch (e) {
              retval = f;
            }
            return retval;
          },
          isInterval: function(limit) {
            return core.Utils.isVector(limit);
          },
          isConvergent: function(limit) {
            if (
              //It lies on the interval -Infinity to Infinity
              __.Limit.isInterval(limit) && limit.elements[0].isInfinity && limit.elements[1].isInfinity || //We weren't able to calculate the limit
              limit.containsFunction("limit")
            ) {
              return false;
            }
            return true;
          },
          limit: function(symbol, x, lim, depth) {
            if (symbol.isLinear() && symbol.isComposite()) {
              var limit = new Symbol2(0);
              symbol.each(function(s) {
                limit = _.add(limit, __.Limit.limit(s, x, lim, depth));
              }, true);
              return limit;
            }
            ;
            symbol = core.Algebra.Simplify.simplify(symbol);
            depth = depth || 1;
            if (depth++ > Settings.max_lim_depth) {
              return;
            }
            var m = _.parse(symbol.multiplier);
            symbol.toUnitMultiplier();
            try {
              var retval;
              if (symbol.isConstant(true)) {
                retval = symbol;
              } else {
                var point = {};
                point[x] = lim;
                try {
                  var t = _.parse(symbol.sub(x, lim), point);
                  if (t.isConstant(true) || t.isInfinity)
                    retval = t;
                } catch (e) {
                }
                ;
                if (!retval) {
                  var num = symbol.getNum();
                  var den = symbol.getDenom();
                  if (den.isConstant(true)) {
                    if (symbol.group === EX) {
                      var f = symbol.clone().toLinear();
                      var p = symbol.power.clone();
                      var _num = f.getNum();
                      var _den = f.getDenom();
                      var fn = core.Utils.decompose_fn(_den, x, true);
                      if (_num.group === S && _num.multiplier.isOne() && fn.ax.group === S && fn.b.isConstant(true) && fn.a.isOne() && fn.b.isConstant(true)) {
                        retval = _.parse(format("(1/e^({0}))", fn.b));
                      } else {
                        var symbol_ = __.Limit.rewriteToLog(symbol.clone());
                        var pow = symbol_.power.clone();
                        var base = symbol_.clone().toLinear();
                        var lim_base = __.Limit.limit(base, x, lim, depth);
                        var lim_pow = __.Limit.limit(pow, x, lim, depth);
                        retval = _.pow(lim_base, lim_pow);
                      }
                    } else if (symbol.group === FN && symbol.args.length === 1) {
                      var evaluates;
                      var arg = __.Limit.limit(symbol.args[0], x, lim, depth);
                      if (core.Utils.isVector(arg)) {
                        retval = arg.map(function(e) {
                          var clone2 = symbol.clone();
                          clone2.args[0] = e;
                          return __.Limit.limit(_.symfunction(symbol.fname, [e]), x, lim, depth);
                        });
                        return _.multiply(m, retval);
                      } else if (arg.isConstant(true)) {
                        var trial = _.symfunction(symbol.fname, [arg]);
                        try {
                          evaluate(trial);
                          evaluates = true;
                        } catch (e) {
                          evaluates = false;
                        }
                      }
                      if (evaluates) {
                        retval = trial;
                      } else {
                        if (__.Limit.isConvergent(arg)) {
                          if (symbol.fname === LOG) {
                            switch (arg.toString()) {
                              //lim -> 0
                              case "0":
                                retval = Symbol2.infinity().negate();
                                break;
                              case "Infinity":
                                retval = Symbol2.infinity();
                                break;
                              case "-Infinity":
                                retval = Symbol2.infinity();
                                break;
                            }
                          } else if ((symbol.fname === COS || symbol.fname === SIN) && lim.isInfinity) {
                            retval = __.Limit.interval(-1, 1);
                          } else if (symbol.fname === TAN) {
                            var s_arg = symbol.args[0];
                            var n2 = s_arg.getNum();
                            var d = s_arg.getDenom();
                            var pi = n2.toUnitMultiplier();
                            if (lim.isInfinity || pi.equals("pi") && d.equals(2)) {
                              retval = divergent();
                            }
                          } else if (symbol.fname === Settings.FACTORIAL) {
                            if (arg.isInfinity)
                              return Symbol2.infinity();
                          }
                        }
                      }
                    } else if (symbol.group === S) {
                      if (symbol.power > 0)
                        return _.parse(symbol, point);
                      else {
                        if (core.Utils.even(symbol.power)) {
                          retval = Symbol2.infinity();
                        } else {
                          retval = __.Limit.diverges();
                        }
                      }
                    } else if (symbol.group === CB) {
                      var lim1, lim2;
                      var symbols = symbol.collectSymbols().sort(function(a, b) {
                        return a.group - b.group;
                      });
                      var f = symbols.pop();
                      lim1 = evaluate(__.Limit.limit(f, x, lim, depth));
                      while (symbols.length) {
                        var g = symbols.pop();
                        lim2 = evaluate(__.Limit.limit(g, x, lim, depth));
                        if (lim1.isInfinity || !__.Limit.isConvergent(lim1) && lim2.equals(0) || lim1.equals(0) && __.Limit.isConvergent(lim2)) {
                          if (g.containsFunction(LOG)) {
                            g = [f, f = g][0];
                          }
                          g.invert();
                          if (lim1.isInfinity && lim2.isInfinity) {
                            lim1 = Symbol2.infinity();
                          } else {
                            lim1 = __.Limit.divide(f, g, x, lim, depth);
                          }
                        } else {
                          lim1 = _.multiply(lim1, lim2);
                          f = _.multiply(f, g);
                        }
                      }
                      retval = lim1;
                    } else if (symbol.isComposite()) {
                      var _lim;
                      if (!symbol.isLinear())
                        symbol = _.expand(symbol);
                      retval = new Symbol2(0);
                      var symbols = symbol.collectSymbols().sort(function(a, b) {
                        return b.group - a.group;
                      });
                      var _symbols = [];
                      var fns = new Symbol2(0);
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        var sym = symbols[i].clone();
                        if (sym.group === FN || sym.group === CB && sym.hasFunc()) {
                          fns = _.add(fns, sym);
                        } else
                          _symbols.push(sym);
                      }
                      _symbols.unshift(fns);
                      if (_symbols.length !== 1) {
                        symbols = _symbols;
                      }
                      for (var i = 0, l = symbols.length; i < l; i++) {
                        var sym = symbols[i];
                        try {
                          _lim = __.Limit.limit(sym, x, lim, depth);
                        } catch (e) {
                          _lim = __.Limit.diverges();
                        }
                        try {
                          retval = _.add(retval, _lim);
                        } catch (e) {
                          if (depth++ > Settings.max_lim_depth) {
                            return;
                          }
                          ;
                          retval = __.Limit.limit(__.diff(symbol, x), x, lim, depth);
                        }
                      }
                    }
                  } else {
                    retval = __.Limit.divide(num, den, x, lim, depth);
                  }
                }
              }
              if (!retval)
                retval = _.symfunction("limit", [symbol, x, lim]);
            } catch (e) {
              retval = _.symfunction("limit", [symbol, x, lim]);
            }
            return _.multiply(m, retval);
          }
        },
        Fresnel: {
          S: function(x) {
            if (x.isConstant(true)) {
              return __.defint(_.parse("sin(pi*x^2/2)"), Symbol2(0), x, "x");
            }
            return _.symfunction("S", arguments);
          },
          C: function(x) {
            if (x.isConstant(true)) {
              return __.defint(_.parse("cos(pi*x^2/2)"), Symbol2(0), x, "x");
            }
            return _.symfunction("C", arguments);
          }
        }
      };
      nerdamer3.register([
        {
          name: "diff",
          visible: true,
          numargs: [1, 3],
          build: function() {
            return __.diff;
          }
        },
        {
          name: "sum",
          visible: true,
          numargs: 4,
          build: function() {
            return __.sum;
          }
        },
        {
          name: "product",
          visible: true,
          numargs: 4,
          build: function() {
            return __.product;
          }
        },
        {
          name: "integrate",
          visible: true,
          numargs: [1, 2],
          build: function() {
            return __.integrate;
          }
        },
        {
          name: "defint",
          visible: true,
          numargs: [3, 4],
          build: function() {
            return __.defint;
          }
        },
        {
          name: "S",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Fresnel.S;
          }
        },
        {
          name: "C",
          visible: true,
          numargs: 1,
          build: function() {
            return __.Fresnel.C;
          }
        },
        {
          name: "limit",
          visible: true,
          numargs: [3, 4],
          build: function() {
            return __.Limit.limit;
          }
        }
      ]);
      nerdamer3.updateAPI();
    })();
  }
});

// node_modules/nerdamer/Solve.js
var require_Solve = __commonJS({
  "node_modules/nerdamer/Solve.js"(exports2, module2) {
    if (typeof module2 !== "undefined") {
      nerdamer3 = require_nerdamer_core();
      require_Calculus();
      require_Algebra();
    }
    var nerdamer3;
    (function() {
      var core = nerdamer3.getCore(), _ = core.PARSER, _A = core.Algebra, _C = core.Calculus, explode = _C.integration.decompose_arg, evaluate = core.Utils.evaluate, remove = core.Utils.remove, format = core.Utils.format, build = core.Utils.build, knownVariable = core.Utils.knownVariable, Symbol2 = core.Symbol, isSymbol = core.Utils.isSymbol, variables = core.Utils.variables, S = core.groups.S, PL = core.groups.PL, CB = core.groups.CB, CP = core.groups.CP, FN = core.groups.FN, Settings = core.Settings, range = core.Utils.range, isArray = core.Utils.isArray;
      core.Settings.SOLVE_RADIUS = 1e3;
      core.Settings.ROOTS_PER_SIDE = 10;
      core.Settings.make_pi_conversions = false;
      core.Settings.STEP_SIZE = 0.1;
      core.Settings.EPSILON = 1e-13;
      core.Settings.MAX_NEWTON_ITERATIONS = 200;
      core.Settings.MAX_NON_LINEAR_TRIES = 12;
      core.Settings.NON_LINEAR_JUMP_AT = 50;
      core.Settings.NON_LINEAR_JUMP_SIZE = 100;
      core.Settings.NON_LINEAR_START = 0.01;
      core.Settings.NEWTON_SLICES = 200;
      core.Settings.NEWTON_EPSILON = Number.EPSILON * 2;
      core.Settings.SOLUTION_PROXIMITY = 1e-14;
      core.Settings.FILTER_SOLUTIONS = true;
      core.Settings.MAX_SOLVE_DEPTH = 10;
      core.Settings.ZERO_EPSILON = 1e-9;
      core.Settings.MAX_BISECTION_ITER = 2e3;
      core.Settings.BI_SECTION_EPSILON = 1e-12;
      core.Symbol.prototype.hasTrig = function() {
        return this.containsFunction(["cos", "sin", "tan", "cot", "csc", "sec"]);
      };
      core.Symbol.prototype.hasNegativeTerms = function() {
        if (this.isComposite()) {
          for (var x in this.symbols) {
            var sym = this.symbols[x];
            if (sym.group === PL && sym.hasNegativeTerms() || this.symbols[x].power.lessThan(0))
              return true;
          }
        }
        return false;
      };
      function Equation(lhs, rhs) {
        if (rhs.isConstant() && lhs.isConstant() && !lhs.equals(rhs) || lhs.equals(core.Settings.IMAGINARY) && rhs.isConstant(true) || rhs.equals(core.Settings.IMAGINARY) && lhs.isConstant(true))
          throw new core.exceptions.NerdamerValueError(lhs.toString() + " does not equal " + rhs.toString());
        this.LHS = lhs;
        this.RHS = rhs;
      }
      ;
      Equation.prototype = {
        toString: function() {
          return this.LHS.toString() + "=" + this.RHS.toString();
        },
        text: function(option) {
          return this.LHS.text(option) + "=" + this.RHS.text(option);
        },
        toLHS: function(expand) {
          expand = typeof expand === "undefined" ? true : false;
          var eqn;
          if (!expand) {
            eqn = this.clone();
          } else {
            eqn = this.removeDenom();
          }
          var a = eqn.LHS;
          var b = eqn.RHS;
          if (a.isConstant(true) && !b.isConstant(true)) {
            [a, b] = [b, a];
          }
          var _t = _.subtract(a, b);
          var retval = expand ? _.expand(_t) : _t;
          retval = new Equation(retval, new Symbol2(0)).removeDenom().LHS;
          return retval;
        },
        removeDenom: function() {
          var a = this.LHS.clone();
          var b = this.RHS.clone();
          var den = _.multiply(a.getDenom(), b.getDenom());
          a = _.expand(_.multiply(a, den.clone()));
          b = _.expand(_.multiply(b, den));
          if (b.group === CP && b.group !== CP) {
            var t = a;
            a = b;
            b = t;
          }
          if (a.group === CB) {
            var t = new Symbol2(a.multiplier), newRHS = b.clone();
            a.each(function(y2) {
              if (y2.power.lessThan(0))
                newRHS = _.divide(newRHS, y2);
              else
                t = _.multiply(t, y2);
            });
            a = t;
            b = newRHS;
          } else if (a.group === CP) {
            for (var x in a.symbols) {
              var sym = a.symbols[x];
              if (sym.group === CB) {
                for (var y in sym.symbols) {
                  var sym2 = sym.symbols[y];
                  if (sym2.power.lessThan(0)) {
                    return new Equation(
                      _.expand(_.multiply(sym2.clone().toLinear(), a)),
                      _.expand(_.multiply(sym2.clone().toLinear(), b))
                    );
                  }
                }
              }
            }
          }
          return new Equation(a, b);
        },
        clone: function() {
          return new Equation(this.LHS.clone(), this.RHS.clone());
        },
        sub: function(x, y) {
          var clone2 = this.clone();
          clone2.LHS = clone2.LHS.sub(x.clone(), y.clone());
          clone2.RHS = clone2.RHS.sub(x.clone(), y.clone());
          return clone2;
        },
        isZero: function() {
          return core.Utils.evaluate(this.toLHS()).equals(0);
        },
        latex: function(option) {
          return [this.LHS.latex(option), this.RHS.latex(option)].join("=");
        }
      };
      _.equals = function(a, b) {
        return new Equation(a, b);
      };
      (function() {
        var simplify = _.functions.simplify[0];
        _.functions.simplify[0] = function(symbol) {
          if (symbol instanceof Equation) {
            symbol.LHS = simplify(symbol.LHS);
            symbol.RHS = simplify(symbol.RHS);
            return symbol;
          }
          return simplify(symbol);
        };
      })();
      core.Expression.prototype.equals = function(symbol) {
        if (symbol instanceof core.Expression)
          symbol = symbol.symbol;
        var eq = new Equation(this.symbol, symbol);
        return eq;
      };
      core.Expression.prototype.solveFor = function(x) {
        var symbol;
        if (this.symbol instanceof Equation) {
          if (this.symbol.LHS.isConstant() && this.symbol.RHS.equals(x))
            return new core.Expression(this.symbol.LHS);
          if (this.symbol.RHS.isConstant() && this.symbol.LHS.equals(x))
            return new core.Expression(this.symbol.RHS);
          symbol = this.symbol.toLHS();
        } else {
          symbol = this.symbol;
        }
        return solve(symbol, x).map(function(x2) {
          return new core.Expression(x2);
        });
      };
      core.Expression.prototype.expand = function() {
        if (this.symbol instanceof Equation) {
          var clone2 = this.symbol.clone();
          clone2.RHS = _.expand(clone2.RHS);
          clone2.LHS = _.expand(clone2.LHS);
          return new core.Expression(clone2);
        }
        return new core.Expression(_.expand(this.symbol));
      };
      core.Expression.prototype.variables = function() {
        if (this.symbol instanceof Equation)
          return core.Utils.arrayUnique(variables(this.symbol.LHS).concat(variables(this.symbol.RHS)));
        return variables(this.symbol);
      };
      var setEq = function(a, b) {
        return _.equals(a, b);
      };
      core.Equation = Equation;
      var checkAll = core.Utils.checkAll = function(args, test) {
        for (var i = 0; i < args.length; i++)
          if (test(args[i]))
            return false;
        return true;
      };
      var __ = core.Solve = {
        version: "2.0.3",
        solutions: [],
        solve: function(eq, variable) {
          var solution = solve(eq, String(variable));
          return new core.Vector(solution);
        },
        /**
         * Brings the equation to LHS. A string can be supplied which will be converted to an Equation
         * @param {Equation|String} eqn
         * @returns {Symbol}
         */
        toLHS: function(eqn, expand) {
          if (isSymbol(eqn))
            return eqn;
          if (!(eqn instanceof Equation)) {
            var es = eqn.split("=");
            es[1] = es[1] || "0";
            eqn = new Equation(_.parse(es[0]), _.parse(es[1]));
          }
          return eqn.toLHS(expand);
        },
        //        getSystemVariables: function(eqns) {
        //            vars = variables(eqns[0], null, null, true);
        //
        //            //get all variables
        //            for (var i = 1, l=eqns.length; i < l; i++)
        //                vars = vars.concat(variables(eqns[i]));
        //            //remove duplicates
        //            vars = core.Utils.arrayUnique(vars).sort();
        //            
        //            //done
        //            return vars;
        //        },
        /**
         * Solve a set of circle equations. 
         * @param {Symbol[]} eqns
         * @returns {Array}
         */
        solveCircle: function(eqns, vars) {
          var svars = vars.map(function(x2) {
            return _.parse(x2);
          });
          var deg = [];
          var solutions = [];
          for (var i = 0; i < eqns.length; i++) {
            var d = [];
            for (var j = 0; j < svars.length; j++) {
              d.push(Number(core.Algebra.degree(eqns[i], svars[j])));
            }
            d.push(core.Utils.arraySum(d, true));
            deg.push(d);
          }
          var a = eqns[0];
          var b = eqns[1];
          if (deg[0][2] > deg[1][2]) {
            [b, a] = [a, b];
            [deg[1], deg[0]] = [deg[0], deg[1]];
          }
          if (deg[0][0] === 1 && deg[0][2] === 2 && deg[1][0] === 2 && deg[1][2] === 4) {
            var x = vars[0];
            var y = vars[1];
            var y_points = solve(_.parse(b, knownVariable(x, solve(_.parse(a), x)[0])), y).map(function(x2) {
              return x2.toString();
            });
            var x_points = [
              solve(_.parse(a, knownVariable(y, y_points[0])))[0].toString()
            ];
            if (y_points[1]) {
              x_points.push(solve(_.parse(a, knownVariable(y, y_points[1])))[0].toString());
            }
            if (Settings.SOLUTIONS_AS_OBJECT) {
              var solutions = {};
              solutions[x] = x_points;
              solutions[y] = y_points;
            } else {
              y_points.unshift(y);
              x_points.unshift(x);
              solutions = [x_points, y_points];
            }
          }
          return solutions;
        },
        /**
         * Solve a system of nonlinear equations
         * @param {Symbol[]} eqns The array of equations
         * @param {number} tries The maximum number of tries
         * @param {number} start The starting point where to start looking for solutions
         * @returns {Array}
         */
        solveNonLinearSystem: function(eqns, tries, start) {
          if (tries < 0) {
            return [];
          }
          start = typeof start === "undefined" ? core.Settings.NON_LINEAR_START : start;
          var max_tries = core.Settings.MAX_NON_LINEAR_TRIES;
          var halfway = Math.floor(max_tries / 2);
          tries = typeof tries === "undefined" ? max_tries : tries;
          var jump_at = core.Settings.NON_LINEAR_JUMP_AT;
          var jump = core.Settings.NON_LINEAR_JUMP_SIZE;
          var found = true;
          var create_subs = function(vars2, matrix) {
            return vars2.map(function(x, i) {
              return Number(matrix.get(i, 0));
            });
          };
          var vars = core.Utils.arrayGetVariables(eqns);
          var jacobian = core.Matrix.jacobian(eqns, vars, function(x) {
            return build(x, vars);
          }, true);
          var max_iter = core.Settings.MAX_NEWTON_ITERATIONS;
          var o, y, iters, xn1, norm, lnorm, xn, d;
          var f_eqns = eqns.map(function(eq) {
            return build(eq, vars);
          });
          var J = jacobian.map(function(e) {
            return build(e, vars);
          }, true);
          xn1 = core.Matrix.cMatrix(0, vars);
          var c = core.Matrix.cMatrix(start, vars);
          iters = 0;
          do {
            if (iters > max_iter) {
              break;
              found = false;
            }
            o = create_subs(vars, c);
            xn = c.clone();
            f_eqns.forEach(function(f, i) {
              c.set(i, 0, f.apply(null, o));
            });
            var m = new core.Matrix();
            J.each(function(fn, i, j) {
              var ans = fn.apply(null, o);
              m.set(i, j, ans);
            });
            m = m.invert();
            y = _.multiply(m, c).negate();
            d = y.subtract(xn1, function(x) {
              return _.parse(Number(x));
            });
            xn1 = xn.add(y, function(x) {
              return _.parse(Number(x));
            });
            c = xn1;
            if (iters >= jump_at) {
              if (norm > 1) {
                if (tries === halfway)
                  start = 0;
                var sign = tries > halfway ? 1 : -1;
                n = tries % Math.floor(halfway) + 1;
                start += sign * n * jump;
                return __.solveNonLinearSystem(eqns, --tries, start);
              }
            }
            lnorm = norm;
            iters++;
            norm = d.max();
            if (Number(norm) === Number(lnorm)) {
              break;
            }
          } while (Number(norm) >= Number.EPSILON);
          if (!found)
            return [];
          return __.systemSolutions(c, vars, true, function(x) {
            return core.Utils.round(Number(x), 14);
          });
        },
        systemSolutions: function(result, vars, expand_result, callback) {
          var solutions = core.Settings.SOLUTIONS_AS_OBJECT ? {} : [];
          result.each(function(e, idx) {
            var solution = (expand_result ? _.expand(e) : e).valueOf();
            if (callback)
              solution = callback.call(e, solution);
            var variable = vars[idx];
            if (core.Settings.SOLUTIONS_AS_OBJECT) {
              solutions[variable] = solution;
            } else
              solutions.push([variable, solution]);
          });
          return solutions;
        },
        /**
         * Solves a system of equations by substitution. This is useful when
         * no distinct solution exists. e.g. a line, plane, etc.
         * @param {Array} eqns
         * @returns {Array}
         */
        solveSystemBySubstitution: function(eqns) {
          var vars_a = variables(eqns[0]);
          var vars_b = variables(eqns[1]);
          if (eqns.length === 2 && vars_a.length === 2 && core.Utils.arrayEqual(vars_a, vars_b)) {
            return __.solveCircle(eqns, vars_a);
          }
          return [];
        },
        //https://www.lakeheadu.ca/sites/default/files/uploads/77/docs/RemaniFinal.pdf
        /**
         * Solves a systems of equations
         * @param {Array} eqns An array of equations
         * @param {Array} var_array An array of variables
         * @returns {Array|object}
         */
        solveSystem: function(eqns, var_array) {
          for (var i = 0; i < eqns.length; i++)
            eqns[i] = __.toLHS(eqns[i]);
          var l = eqns.length, m = new core.Matrix(), c = new core.Matrix(), expand_result = false, vars;
          if (typeof var_array === "undefined") {
            if (!_A.allLinear(eqns)) {
              try {
                return __.solveNonLinearSystem(eqns);
              } catch (e2) {
                if (e2 instanceof core.exceptions.DivisionByZero) {
                  return __.solveSystemBySubstitution(eqns);
                }
              }
            }
            vars = core.Utils.arrayGetVariables(eqns);
            if (vars.length === 1) {
              var n2 = 0, sol, e;
              do {
                var e = eqns[n2].clone();
                if (n2 > 0) {
                  e = e.sub(vars[0], sol[0]);
                }
                sol = solve(e, vars[0]);
                if (n2 === 0)
                  continue;
              } while (++n2 < eqns.length);
              var solutions;
              if (Settings.SOLUTIONS_AS_OBJECT) {
                solutions = {};
                solutions[vars[0]] = sol;
              } else if (sol.length === 0) {
                solutions = sol;
              } else {
                solutions = [vars[0], sol];
              }
              return solutions;
            }
            if (vars.length < eqns.length) {
              var reduced = [];
              var n2 = eqns.length;
              for (var i = 0; i < n2 - 1; i++) {
                reduced.push(_.parse(eqns[i]));
              }
              var knowns = {};
              var solutions = __.solveSystem(reduced, vars);
              if (Array.isArray(solutions)) {
                solutions.forEach(function(sol2) {
                  knowns[sol2[0]] = sol2[1];
                });
              } else {
                knowns = solutions;
              }
              var all_zero = true;
              for (var i = n2 - 1; i < n2; i++) {
                if (!_.parse(eqns[i], knowns).equals(0)) {
                  all_zero = false;
                }
              }
              if (all_zero) {
                return solutions;
              }
            }
            for (var i = 0; i < vars.length; i++) {
              nerdamer3.setVar(vars[i], "delete");
            }
            for (var i = 0; i < l; i++) {
              var e = eqns[i];
              for (var j = 0; j < vars.length; j++) {
                var v = vars[j];
                var coeffs = [];
                e.each(function(x) {
                  if (x.contains(v)) {
                    coeffs = coeffs.concat(x.coeffs());
                  }
                });
                var cf = core.Utils.arraySum(coeffs);
                m.set(i, j, cf);
              }
              var num = e.clone();
              vars.map(function(e2) {
                num = num.stripVar(e2, true);
              });
              c.set(i, 0, num.negate());
            }
          } else {
            vars = var_array;
            expand_result = true;
            for (i = 0; i < l; i++) {
              c.set(i, 0, new Symbol2(0));
              var e = _.expand(eqns[i]).collectSymbols();
              for (var j = 0; j < var_array.length; j++) {
                m.set(i, j, new Symbol2(0));
                var v = var_array[j];
                for (var k = 0; k < e.length; k++) {
                  var term = e[k], check2 = false;
                  for (var z = 0; z < var_array.length; z++) {
                    if (term.contains(var_array[z])) {
                      if (check2)
                        core.err("Multiple variables found for term " + term);
                      check2 = true;
                    }
                  }
                  if (term.contains(v)) {
                    var tparts = explode(remove(e, k), v);
                    m.set(i, j, _.add(m.get(i, j), tparts[0]));
                  }
                }
              }
              for (k = 0; k < e.length; k++) {
                c.set(i, 0, _.add(c.get(i, 0), e[k]));
              }
            }
          }
          if (vars.length !== eqns.length || m.determinant().equals(0)) {
            throw new core.exceptions.SolveError("System does not have a distinct solution");
          }
          m = m.invert();
          var result = m.multiply(c);
          if (core.Utils.isArray(var_array))
            result.each(function(x) {
              return x.negate();
            });
          return __.systemSolutions(result, vars, expand_result);
        },
        /**
         * The quadratic function but only one side.
         * @param {Symbol} c
         * @param {Symbol} b
         * @param {Symbol} a
         * @returns {Symbol}
         */
        quad: function(c, b, a) {
          var discriminant = _.subtract(_.pow(b.clone(), Symbol2(2)), _.multiply(_.multiply(a.clone(), c.clone()), Symbol2(4)));
          discriminant = _.expand(discriminant);
          var det = _.pow(discriminant, Symbol2(0.5));
          var den = _.parse(_.multiply(new Symbol2(2), a.clone()));
          var retval = [
            _.parse(format("(-({0})+({1}))/({2})", b, det, den)),
            _.parse(format("(-({0})-({1}))/({2})", b, det, den))
          ];
          return retval;
        },
        /**
         * The cubic equation
         * http://math.stackexchange.com/questions/61725/is-there-a-systematic-way-of-solving-cubic-equations
         * @param {Symbol} d_o
         * @param {Symbol} c_o
         * @param {Symbol} b_o
         * @param {Symbol} a_o
         * @returns {Array}
         */
        cubic: function(d_o, c_o, b_o, a_o) {
          var a = a_o.text(), b = b_o.text(), c = c_o.text(), d = d_o.text();
          var t = `(-(${b})^3/(27*(${a})^3)+(${b})*(${c})/(6*(${a})^2)-(${d})/(2*(${a})))`;
          var u = `((${c})/(3*(${a}))-(${b})^2/(9*(${a})^2))`;
          var v = `(${b})/(3*(${a}))`;
          var x = `((${t})+sqrt((${t})^2+(${u})^3))^(1/3)+((${t})-sqrt((${t})^2+(${u})^3))^(1/3)-(${v})`;
          var w = "1/2+sqrt(3)/2*i";
          return [
            _.parse(x),
            _.parse(`(${x})(${w})`),
            _.parse(`(${x})(${w})^2`)
          ];
        },
        /**
         * The quartic equation
         * @param {Symbol} e
         * @param {Symbol} d
         * @param {Symbol} c
         * @param {Symbol} b
         * @param {Symbol} a
         * @returns {Array}
         */
        quartic: function(e, d, c, b, a) {
          var scope = {};
          core.Utils.arrayUnique(variables(a).concat(variables(b)).concat(variables(c)).concat(variables(d)).concat(variables(e))).map(function(x) {
            scope[x] = 1;
          });
          a = a.toString();
          b = b.toString();
          c = c.toString();
          d = d.toString();
          e = e.toString();
          var p, q, D, D0, D1, Q, x1, x2, x3, x4;
          p = _.parse(format("(8*({0})*({2})-3*({1})^2)/(8*({0})^2)", a, b, c)).toString();
          q = _.parse(format("(({1})^3-4*({0})*({1})*({2})+8*({0})^2*({3}))/(8*({0})^3)", a, b, c, d)).toString();
          D0 = _.parse(format("12*({0})*({4})-3*({1})*({3})+({2})^2", a, b, c, d, e)).toString();
          D1 = _.parse(format("2*({2})^3-9*({1})*({2})*({3})+27*({1})^2*({4})+27*({0})*({3})^2-72*({0})*({2})*({4})", a, b, c, d, e)).toString();
          Q = _.parse(format("((({1})+(({1})^2-4*({0})^3)^(1/2))/2)^(1/3)", D0, D1)).toString();
          S = _.parse(format("(1/2)*(-(2/3)*({1})+(1/(3*({0}))*(({2})+(({3})/({2})))))^(1/2)", a, p, Q, D0)).toString();
          x1 = _.parse(format("-(({1})/(4*({0})))-({4})+(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))", a, b, p, q, S));
          x2 = _.parse(format("-(({1})/(4*({0})))-({4})-(1/2)*sqrt(-4*({4})^2-2*({2})+(({3})/({4})))", a, b, p, q, S));
          x3 = _.parse(format("-(({1})/(4*({0})))+({4})+(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))", a, b, p, q, S));
          x4 = _.parse(format("-(({1})/(4*({0})))+({4})-(1/2)*sqrt(-4*({4})^2-2*({2})-(({3})/({4})))", a, b, p, q, S));
          return [x1, x2, x3, x4];
        },
        /**
         * Breaks the equation up in its factors and tries to solve the smaller parts
         * @param {Symbol} symbol
         * @param {String} solve_for
         * @returns {Array}
         */
        divideAndConquer: function(symbol, solve_for) {
          var sols = [];
          var factors = core.Algebra.Factor.factor(symbol);
          if (factors.group === CB) {
            factors.each(function(x) {
              x = Symbol2.unwrapPARENS(x);
              sols = sols.concat(solve(x, solve_for));
            });
          }
          return sols;
        },
        /**
         * Attempts to solve the equation assuming it's a polynomial with numeric coefficients
         * @param {Symbol} eq
         * @param {String} solve_for
         * @returns {Array}
         */
        csolve: function(eq, solve_for) {
          return core.Utils.block("IGNORE_E", function() {
            var f, p, pn, n2, pf, r, theta, sr, sp, roots;
            roots = [];
            f = core.Utils.decompose_fn(eq, solve_for, true);
            if (f.x.group === S) {
              p = _.parse(f.x.power);
              pn = Number(p);
              n2 = _.pow(_.divide(f.b.negate(), f.a), p.invert());
              pf = Symbol2.toPolarFormArray(n2);
              r = pf[0];
              theta = pf[1];
              sr = r.toString();
              sp = p.toString();
              var k, root, str;
              for (var i = 0; i < pn; i++) {
                k = i;
                str = format("({0})*e^(2*{1}*pi*{2}*{3})", sr, k, p, core.Settings.IMAGINARY);
                root = _.parse(str);
                roots.push(root);
              }
            }
            return roots;
          }, true);
        },
        /**
         * Generates starting points for the Newton solver given an expression at zero.
         * It beings by check if zero is a good point and starts expanding by a provided step size. 
         * Builds on the fact that if the sign changes over an interval then a zero
         * must exist on that interval
         * @param {Symbol} symbol
         * @param {Number} step
         * @param {Array} points
         * @returns {Array}
         */
        getPoints: function(symbol, step, points) {
          step = step || 0.01;
          points = points || [];
          var f = build(symbol);
          var x0 = 0;
          var start = Math.round(x0), last = f(start), last_sign = last / Math.abs(last), rside = core.Settings.ROOTS_PER_SIDE, lside = rside;
          points.push(Math.floor(start / 2));
          points.push(Math.abs(start));
          points.push(start);
          symbol.each(function(x) {
            if (x.containsFunction(core.Settings.LOG))
              points.push(0.1);
          });
          var left = range(-core.Settings.SOLVE_RADIUS, start, step), right = range(start, core.Settings.SOLVE_RADIUS, step);
          var test_side = function(side, num_roots) {
            var xi, val, sign;
            var hits = [];
            for (var i = 0, l = side.length; i < l; i++) {
              xi = side[i];
              val = f(xi);
              sign = val / Math.abs(val);
              if (isNaN(val) || !isFinite(val) || hits.length > num_roots) {
                continue;
              }
              if (sign !== last_sign) {
                hits.push(xi);
              }
              last_sign = sign;
            }
            points = points.concat(hits);
          };
          test_side(left, lside);
          test_side(right, rside);
          return points;
        },
        /**
         * Implements the bisection method. Returns undefined in no solution is found
         * @param {number} point
         * @param {function} f
         * @returns {undefined | number}
         */
        bisection: function(point, f) {
          var left = point - 1;
          var right = point + 1;
          if (Math.sign(f(left)) !== Math.sign(f(right))) {
            var safety = 0;
            var epsilon, middle;
            do {
              epsilon = Math.abs(right - left);
              if (safety++ > core.Settings.MAX_BISECTION_ITER || isNaN(epsilon)) {
                return;
              }
              middle = (left + right) / 2;
              if (f(left) * f(middle) > 0) {
                left = middle;
              } else {
                right = middle;
              }
            } while (epsilon >= Settings.EPSILON);
            var solution = (left + right) / 2;
            var x_point = f(solution);
            if (!isNaN(x_point) && Math.abs(x_point) <= core.Settings.BI_SECTION_EPSILON) {
              return core.Utils.round(solution, 13);
            }
          }
        },
        /**
         * Implements Newton's iterations. Returns undefined if no solutions if found
         * @param {number} point
         * @param {function} f
         * @param {function} fp
         * @returns {undefined|number}
         */
        Newton: function(point, f, fp) {
          var maxiter = core.Settings.MAX_NEWTON_ITERATIONS, iter = 0;
          var x0 = point, x;
          do {
            var fx0 = f(x0);
            if (x0 === 0 && fx0 === 0) {
              x = 0;
              break;
            }
            iter++;
            if (iter > maxiter)
              return;
            x = x0 - fx0 / fp(x0);
            var e = Math.abs(x - x0);
            x0 = x;
          } while (e > Settings.NEWTON_EPSILON);
          if (Math.abs(f(x)) <= Settings.EPSILON)
            return x;
        },
        rewrite: function(rhs, lhs, for_variable) {
          lhs = lhs || new Symbol2(0);
          if (rhs.isComposite() && rhs.isLinear()) {
            var sqrts = [];
            var rem = [];
            rhs.each(function(x) {
              x = x.clone();
              if (x.fname === "sqrt" && x.contains(for_variable)) {
                sqrts.push(x);
              } else {
                rem.push(x);
              }
            }, true);
            if (sqrts.length === 1) {
              lhs = _.expand(_.pow(_.subtract(lhs, core.Utils.arraySum(rem)), new Symbol2(2)));
              rhs = _.expand(_.pow(Symbol2.unwrapSQRT(sqrts[0]), new Symbol2(2)));
            }
          } else {
            rhs = Symbol2.unwrapSQRT(_.expand(rhs));
          }
          var c = 0, l = rhs.length;
          if (rhs.group === CP && rhs.contains(for_variable) && rhs.isLinear()) {
            rhs.distributeMultiplier();
            var t = new Symbol2(0);
            rhs.each(function(x) {
              if (x.contains(for_variable)) {
                c++;
                t = _.add(t, x.clone());
              } else
                lhs = _.subtract(lhs, x.clone());
            });
            rhs = t;
            if (c !== l) {
              return __.rewrite(rhs, lhs, for_variable);
            } else {
              return [rhs, lhs];
            }
          } else if (rhs.group === CB && rhs.contains(for_variable) && rhs.isLinear()) {
            if (rhs.multiplier.lessThan(0)) {
              rhs.multiplier = rhs.multiplier.multiply(new core.Frac(-1));
              lhs.multiplier = lhs.multiplier.multiply(new core.Frac(-1));
            }
            if (lhs.equals(0))
              return new Symbol2(0);
            else {
              var t = new Symbol2(1);
              rhs.each(function(x) {
                if (x.contains(for_variable))
                  t = _.multiply(t, x.clone());
                else
                  lhs = _.divide(lhs, x.clone());
              });
              rhs = t;
              return __.rewrite(rhs, lhs, for_variable);
            }
          } else if (!rhs.isLinear() && rhs.contains(for_variable)) {
            var p = _.parse(rhs.power.clone().invert());
            rhs = _.pow(rhs, p.clone());
            lhs = _.pow(_.expand(lhs), p.clone());
            return __.rewrite(rhs, lhs, for_variable);
          } else if (rhs.group === FN || rhs.group === S || rhs.group === PL) {
            return [rhs, lhs];
          }
        },
        sqrtSolve: function(symbol, v) {
          var sqrts = new Symbol2(0);
          var rem = new Symbol2(0);
          if (symbol.isComposite()) {
            symbol.each(function(x) {
              if (x.fname === "sqrt" && x.contains(v)) {
                sqrts = _.add(sqrts, x.clone());
              } else {
                rem = _.add(rem, x.clone());
              }
            });
            if (!sqrts.equals(0)) {
              var t = _.expand(_.multiply(_.parse(symbol.multiplier), _.subtract(_.pow(rem, new Symbol2(2)), _.pow(sqrts, new Symbol2(2)))));
              var solutions = solve(t, v);
              solutions = solutions.filter(function(e) {
                if (e.isImaginary())
                  return e;
                var subs = {};
                subs[v] = e;
                var point = evaluate(symbol, subs);
                if (point.equals(0))
                  return e;
              });
              return solutions;
            }
          }
        }
      };
      var solve = function(eqns, solve_for, solutions, depth, fn) {
        depth = depth || 0;
        if (depth++ > Settings.MAX_SOLVE_DEPTH) {
          return solutions;
        }
        if (eqns instanceof Equation) {
          if (eqns.isZero()) {
            return [new Symbol2(0)];
          }
          if (eqns.LHS.equals(solve_for) && !eqns.RHS.contains(solve_for)) {
            return [eqns.RHS];
          }
          if (eqns.RHS.equals(solve_for) && !eqns.LHS.contains(solve_for)) {
            return [eqns.LHS];
          }
        }
        if (eqns instanceof core.Vector)
          eqns = eqns.elements;
        solve_for = solve_for || "x";
        if (isArray(eqns)) {
          return __.solveSystem.apply(void 0, arguments);
        }
        solutions = solutions || [];
        var existing = {};
        var known = {};
        known[solve_for] = 0;
        if (isSymbol(eqns) && evaluate(eqns.getDenom(), known).equals(0) === true) {
          return solutions;
        }
        var add_to_result = function(r, has_trig2) {
          var r_is_symbol = isSymbol(r);
          if (r === void 0 || typeof r === "number" && isNaN(r))
            return;
          if (isArray(r)) {
            r.forEach(function(sol) {
              add_to_result(sol);
            });
          } else {
            if (r.valueOf() !== "null") {
              if (typeof core.Settings.PRE_ADD_SOLUTION === "function") {
                r = core.Settings.PRE_ADD_SOLUTION(r);
              }
              if (!r_is_symbol) {
                r = _.parse(r);
              }
              if (core.Settings.make_pi_conversions && has_trig2) {
                var temp = _.divide(r.clone(), new Symbol2(Math.PI)), m = temp.multiplier, a = Math.abs(m.num), b = Math.abs(m.den);
                if (a < 10 && b < 10)
                  r = _.multiply(temp, new Symbol2("pi"));
              }
              var r_str = r.toString();
              if (!existing[r_str]) {
                solutions.push(r);
              }
              existing[r_str] = true;
            }
          }
        };
        if (eqns.group === S && eqns.contains(solve_for)) {
          try {
            var o = {};
            o[solve_for] = 0;
            evaluate(fn, o, "numer");
            add_to_result(new Symbol2(0));
          } catch (e) {
          }
          return solutions;
        }
        if (eqns.group === CB) {
          var num = eqns.getNum();
          if (num.group === CB) {
            var sf = String(solve_for);
            num.each(function(x2) {
              if (x2.contains(sf))
                solve(x2, solve_for, solutions, depth, eqns);
            });
            return solutions;
          }
          return solve(num, solve_for, solutions, depth, fn);
        }
        if (eqns.group === FN && eqns.fname === "sqrt") {
          eqns = _.pow(Symbol2.unwrapSQRT(eqns), new Symbol2(2));
        }
        var eq = (core.Utils.isSymbol(eqns) ? eqns : __.toLHS(eqns, false)).getNum(), vars = core.Utils.variables(eq), numvars = vars.length;
        if (core.Utils.isInt(eq.power) && eq.power > 0) {
          eq = _.parse(eq).toLinear();
        }
        if (eq.group === S || eq.group === CB && eq.contains(solve_for)) {
          return [new Symbol2(0)];
        }
        var fractionals = {}, cfact;
        var correct_denom = function(symbol) {
          symbol = _.expand(symbol, {
            expand_denominator: true,
            expand_functions: true
          });
          var original = symbol.clone();
          if (symbol.symbols) {
            for (var x2 in symbol.symbols) {
              var sym = symbol.symbols[x2];
              var den = sym.getDenom();
              if (!den.isConstant(true) && symbol.isComposite()) {
                var t = new Symbol2(0);
                symbol.each(function(e) {
                  t = _.add(t, _.multiply(e, den.clone()));
                });
                return correct_denom(_.multiply(_.parse(symbol.multiplier), t));
              }
              var parts2 = explode(sym, solve_for);
              var is_sqrt = parts2[1].fname === core.Settings.SQRT;
              var v = Symbol2.unwrapSQRT(parts2[1]);
              var p2 = v.power.clone();
              if (!isSymbol(p2) && !p2.equals(1 / 2)) {
                if (p2.den.gt(1)) {
                  if (is_sqrt) {
                    symbol = _.subtract(symbol, sym.clone());
                    symbol = _.add(symbol, _.multiply(parts2[0].clone(), v));
                    return correct_denom(symbol);
                  }
                  var c = fractionals[p2.den];
                  fractionals[p2.den] = c ? c++ : 1;
                } else if (p2.sign() === -1) {
                  var factor = _.parse(solve_for + "^" + Math.abs(p2));
                  symbol.each(function(y, index) {
                    if (y.contains(solve_for)) {
                      symbol.symbols[index] = _.multiply(y, factor.clone());
                    }
                  });
                  fractionals = {};
                  return correct_denom(_.parse(symbol));
                } else if (sym.group === PL) {
                  var min_p = core.Utils.arrayMin(core.Utils.keys(sym.symbols));
                  if (min_p < 0) {
                    var factor = _.parse(solve_for + "^" + Math.abs(min_p));
                    var corrected = new Symbol2(0);
                    original.each(function(x3) {
                      corrected = _.add(corrected, _.multiply(x3.clone(), factor.clone()));
                    }, true);
                    return corrected;
                  }
                }
              }
            }
          }
          return symbol;
        };
        var separate = function(eq2) {
          var lhs2 = new Symbol2(0), rhs2 = new Symbol2(0);
          eq2.each(function(x2) {
            if (x2.contains(solve_for, true))
              lhs2 = _.add(lhs2, x2.clone());
            else
              rhs2 = _.subtract(rhs2, x2.clone());
          });
          return [lhs2, rhs2];
        };
        __.inverseFunctionSolve = function(name, lhs2, rhs2) {
          var parts2 = explode(lhs2.args[0], solve_for);
          var x2 = parts2[1];
          if (x2.group === S) {
            return _.divide(_.symfunction(name, [_.divide(rhs2, _.parse(lhs2.multiplier))]), parts2[0]);
          }
        };
        eq = correct_denom(eq);
        if (eq.equals(0))
          return [eq];
        var fkeys = core.Utils.keys(fractionals);
        if (fkeys.length === 1) {
          cfact = fkeys[0];
          eq.each(function(x2, index) {
            if (x2.contains(solve_for)) {
              var parts2 = explode(x2, solve_for);
              var v = parts2[1];
              var p2 = v.power;
              if (p2.den.gt(1)) {
                v.power = p2.multiply(new core.Frac(cfact));
                eq.symbols[index] = _.multiply(v, parts2[0]);
              }
            }
          });
          eq = _.parse(eq);
        }
        add_to_result(__.sqrtSolve(eq, solve_for));
        if (numvars === 1) {
          if (eq.isPoly(true)) {
            var factors = new core.Algebra.Classes.Factors();
            core.Algebra.Factor.factor(eq, factors);
            if (factors.getNumberSymbolics() > 1) {
              for (var x in factors.factors) {
                add_to_result(solve(factors.factors[x], solve_for));
              }
            } else {
              var coeffs = core.Utils.getCoeffs(eq, solve_for), deg = coeffs.length - 1, was_calculated = false;
              if (vars[0] === solve_for) {
                if (checkAll(coeffs, function(x2) {
                  return x2.group !== core.groups.N;
                })) {
                  var roots = core.Algebra.proots(eq);
                  if (checkAll(roots, function(x2) {
                    return !core.Utils.isInt(x2);
                  })) {
                    was_calculated = true;
                    roots.map(function(x2) {
                      add_to_result(new Symbol2(x2));
                    });
                  }
                }
                if (!was_calculated) {
                  eqns = _.parse(eqns);
                  if (eqns instanceof core.Equation)
                    eqns = eqns.toLHS();
                  if (deg === 1)
                    add_to_result(_.divide(coeffs[0], coeffs[1].negate()));
                  else if (deg === 2) {
                    add_to_result(_.expand(__.quad.apply(void 0, coeffs)));
                  } else if (deg === 3) {
                    var solutions = [];
                    var factored = core.Algebra.Factor.factor(eqns);
                    var solutions = [];
                    if (solutions.length > 0)
                      add_to_result(solutions);
                    else
                      add_to_result(__.cubic.apply(void 0, coeffs));
                  } else {
                    _A.proots(eq).map(add_to_result);
                  }
                }
              }
            }
          } else {
            try {
              var has_trig = eq.hasTrig();
              var points1 = __.getPoints(eq, 0.1);
              var points2 = __.getPoints(eq, 0.05);
              var points3 = __.getPoints(eq, 0.01);
              var points = core.Utils.arrayUnique(points1.concat(points2).concat(points3)).sort(function(a, b) {
                return a - b;
              });
              var i, point, solution;
              var f = build(eq.clone());
              var t_points = [];
              for (i = 0; i < points.length; i++) {
                point = points[i];
                solution = __.bisection(point, f);
                if (typeof solution === "undefined") {
                  t_points.push(point);
                  continue;
                }
                add_to_result(solution, has_trig);
              }
              points = t_points;
              var d = _C.diff(eq.clone());
              var fp = build(d);
              for (i = 0; i < points.length; i++) {
                point = points[i];
                add_to_result(__.Newton(point, f, fp), has_trig);
              }
              solutions.sort();
            } catch (e) {
              console.log(e);
            }
          }
        } else {
          if (!eq.hasFunc(solve_for) && eq.isComposite()) {
            try {
              var factored = core.Algebra.Factor.factor(eq.clone());
              if (factored.group === CB) {
                factored.each(function(x2) {
                  add_to_result(solve(x2, solve_for));
                });
              } else {
                var coeffs = core.Utils.getCoeffs(eq, solve_for);
                var l = coeffs.length, deg = l - 1;
                switch (deg) {
                  case 0:
                    var separated = separate(eq);
                    var lhs = separated[0], rhs = separated[1];
                    if (lhs.group === core.groups.EX) {
                      var log = core.Settings.LOG;
                      var expr_str = `${log}((${rhs})/(${lhs.multiplier}))/${log}(${lhs.value})/${lhs.power.multiplier}`;
                      add_to_result(_.parse(expr_str));
                    }
                    break;
                  case 1:
                    add_to_result(_.divide(coeffs[0], coeffs[1].negate()));
                    break;
                  case 2:
                    add_to_result(__.quad.apply(void 0, coeffs));
                    break;
                  case 3:
                    add_to_result(__.cubic.apply(void 0, coeffs));
                    break;
                  case 4:
                    add_to_result(__.quartic.apply(void 0, coeffs));
                    break;
                  default:
                    add_to_result(__.csolve(eq, solve_for));
                    if (solutions.length === 0)
                      add_to_result(__.divideAndConquer(eq, solve_for));
                }
                if (solutions.length === 0) {
                  add_to_result(solve(factored, solve_for, solutions, depth));
                }
              }
            } catch (e) {
              ;
            }
          } else {
            try {
              var rw = __.rewrite(eq, null, solve_for);
              var lhs = rw[0];
              var rhs = rw[1];
              if (lhs.group === FN) {
                if (lhs.fname === "abs") {
                  add_to_result([rhs.clone(), rhs.negate()]);
                } else if (lhs.fname === "sin") {
                  add_to_result(__.inverseFunctionSolve("asin", lhs, rhs));
                } else if (lhs.fname === "cos") {
                  add_to_result(__.inverseFunctionSolve("acos", lhs, rhs));
                } else if (lhs.fname === "tan") {
                  add_to_result(__.inverseFunctionSolve("atan", lhs, rhs));
                } else if (lhs.fname === core.Settings.LOG) {
                  var parts = explode(lhs.args[0], solve_for);
                  var x = parts[1];
                  if (x.group === S) {
                    rhs = _.divide(_.subtract(_.pow(lhs.args.length > 1 ? lhs.args[1] : new Symbol2("e"), _.divide(rhs, _.parse(lhs.multiplier))), parts[3]), parts[0]);
                    var eq = new Equation(x, rhs).toLHS();
                    add_to_result(solve(eq, solve_for));
                  }
                } else
                  add_to_result(_.subtract(lhs, rhs));
              } else {
                var neq = new Equation(lhs, rhs).toLHS();
                if (neq.equals(eq))
                  throw new Error("Stopping. No stop condition exists");
                add_to_result(solve(neq, solve_for));
              }
            } catch (error) {
              try {
                if (eq.group === CB)
                  add_to_result(0);
                else if (eq.group === CP) {
                  var separated = separate(eq);
                  var lhs = separated[0], rhs = separated[1];
                  if (lhs.group === core.groups.EX && lhs.value === solve_for) {
                    var p = lhs.power.clone().invert();
                    add_to_result(_.pow(rhs, p));
                  }
                }
              } catch (error2) {
                ;
              }
            }
          }
        }
        if (cfact) {
          solutions = solutions.map(function(x2) {
            return _.pow(x2, new Symbol2(cfact));
          });
        }
        if (isSymbol(eqns)) {
          var knowns = {};
          solutions = solutions.filter(function(x2) {
            try {
              knowns[solve_for] = x2;
              var zero = Number(evaluate(eqns, knowns));
              if (isNaN(zero)) {
                return true;
              }
              return true;
            } catch (e) {
              return false;
            }
          });
        }
        return solutions;
      };
      nerdamer3.register([
        {
          name: "solveEquations",
          parent: "nerdamer",
          numargs: -1,
          visible: true,
          build: function() {
            return solve;
          }
        },
        {
          name: "solve",
          parent: "Solve",
          numargs: 2,
          visible: true,
          build: function() {
            return core.Solve.solve;
          }
        },
        {
          name: "setEquation",
          parent: "Solve",
          visible: true,
          build: function() {
            return setEq;
          }
        }
      ]);
      nerdamer3.updateAPI();
    })();
  }
});

// dist/engine/magic/aura.js
var aura_exports = {};
__export(aura_exports, {
  applyAuraEffect: () => applyAuraEffect,
  calculateDistance: () => calculateDistance,
  checkAuraDuration: () => checkAuraDuration,
  checkAuraEffectsForTarget: () => checkAuraEffectsForTarget,
  createAura: () => createAura,
  endAura: () => endAura,
  endAurasByOwner: () => endAurasByOwner,
  expireOldAuras: () => expireOldAuras,
  getActiveAuras: () => getActiveAuras,
  getAurasAtPosition: () => getAurasAtPosition,
  isInAuraRange: () => isInAuraRange,
  rollDice: () => rollDice2,
  rollSave: () => rollSave,
  shouldAffectTarget: () => shouldAffectTarget
});
function calculateDistance(pos1, pos2) {
  const dx = pos1.x - pos2.x;
  const dy = pos1.y - pos2.y;
  const squares = Math.sqrt(dx * dx + dy * dy);
  return Math.round(squares * 5);
}
function isInAuraRange(auraCenter, targetPosition, radius) {
  const distance = calculateDistance(auraCenter, targetPosition);
  return distance <= radius;
}
function createAura(request, auraRepo) {
  const aura = {
    id: (0, import_crypto10.randomUUID)(),
    ownerId: request.ownerId,
    spellName: request.spellName,
    spellLevel: request.spellLevel,
    radius: request.radius,
    affectsAllies: request.affectsAllies,
    affectsEnemies: request.affectsEnemies,
    affectsSelf: request.affectsSelf,
    effects: request.effects,
    startedAt: request.currentRound,
    maxDuration: request.maxDuration,
    requiresConcentration: request.requiresConcentration
  };
  auraRepo.create(aura);
  return aura;
}
function endAura(auraId, auraRepo) {
  return auraRepo.delete(auraId);
}
function endAurasByOwner(ownerId, auraRepo) {
  return auraRepo.deleteByOwnerId(ownerId);
}
function getActiveAuras(auraRepo) {
  return auraRepo.findAll();
}
function getAurasAtPosition(tokens, targetPosition, auraRepo) {
  const allAuras = auraRepo.findAll();
  const aurasAtPosition = [];
  for (const aura of allAuras) {
    const owner = tokens.find((t) => t.id === aura.ownerId);
    if (!owner || !owner.position) {
      continue;
    }
    if (isInAuraRange(owner.position, targetPosition, aura.radius)) {
      aurasAtPosition.push(aura);
    }
  }
  return aurasAtPosition;
}
function shouldAffectTarget(aura, target, ownerIsAlly) {
  if (target.id === aura.ownerId) {
    return aura.affectsSelf;
  }
  if (ownerIsAlly && !aura.affectsAllies) {
    return false;
  }
  if (!ownerIsAlly && !aura.affectsEnemies) {
    return false;
  }
  return true;
}
function rollSave(abilityModifier) {
  const roll = Math.floor(Math.random() * 20) + 1;
  const total = roll + abilityModifier;
  return { roll, total };
}
function rollDice2(dice) {
  const match = dice.match(/^(\d+)d(\d+)(?:\+(\d+))?$/);
  if (!match) {
    throw new Error(`Invalid dice notation: ${dice}`);
  }
  const [, numDiceStr, diceSizeStr, bonusStr] = match;
  const numDice = parseInt(numDiceStr, 10);
  const diceSize = parseInt(diceSizeStr, 10);
  const bonus = bonusStr ? parseInt(bonusStr, 10) : 0;
  let total = bonus;
  for (let i = 0; i < numDice; i++) {
    total += Math.floor(Math.random() * diceSize) + 1;
  }
  return total;
}
function applyAuraEffect(aura, effect, target, trigger) {
  const result = {
    auraId: aura.id,
    auraName: aura.spellName,
    targetId: target.id,
    trigger,
    effectType: effect.type,
    succeeded: false
  };
  if (effect.saveType && effect.saveDC) {
    const abilityModifier = getAbilityModifier3(target, effect.saveType);
    const saveResult = rollSave(abilityModifier);
    result.saveRoll = saveResult.roll;
    result.saveDC = effect.saveDC;
    result.saveTotal = saveResult.total;
    result.succeeded = saveResult.total >= effect.saveDC;
    if (result.succeeded && (effect.type === "damage" || effect.type === "condition")) {
      return result;
    }
  } else {
    result.succeeded = true;
  }
  switch (effect.type) {
    case "damage":
      if (effect.dice) {
        result.damageDealt = rollDice2(effect.dice);
        result.damageType = effect.damageType;
      }
      break;
    case "healing":
      if (effect.dice) {
        result.healingDone = rollDice2(effect.dice);
      }
      break;
    case "condition":
      if (effect.conditions) {
        result.conditionsApplied = effect.conditions;
      }
      break;
    case "buff":
    case "debuff":
    case "custom":
      result.description = effect.description;
      break;
  }
  return result;
}
function getAbilityModifier3(token, ability) {
  if (!token.abilityScores) {
    return 0;
  }
  const abilityMap = {
    strength: "strength",
    dexterity: "dexterity",
    constitution: "constitution",
    intelligence: "intelligence",
    wisdom: "wisdom",
    charisma: "charisma"
  };
  const abilityKey = abilityMap[ability.toLowerCase()];
  if (!abilityKey) {
    return 0;
  }
  const score = token.abilityScores[abilityKey];
  return Math.floor((score - 10) / 2);
}
function checkAuraEffectsForTarget(tokens, targetId, trigger, auraRepo) {
  const target = tokens.find((t) => t.id === targetId);
  if (!target || !target.position) {
    return [];
  }
  const aurasAtPosition = getAurasAtPosition(tokens, target.position, auraRepo);
  const results = [];
  for (const aura of aurasAtPosition) {
    const owner = tokens.find((t) => t.id === aura.ownerId);
    if (!owner)
      continue;
    const ownerIsAlly = target.isEnemy === owner.isEnemy;
    if (!shouldAffectTarget(aura, target, ownerIsAlly)) {
      continue;
    }
    for (const effect of aura.effects) {
      if (effect.trigger === trigger) {
        const result = applyAuraEffect(aura, effect, target, trigger);
        results.push(result);
      }
    }
  }
  return results;
}
function checkAuraDuration(aura, currentRound) {
  if (!aura.maxDuration) {
    return false;
  }
  const roundsElapsed = currentRound - aura.startedAt;
  return roundsElapsed >= aura.maxDuration;
}
function expireOldAuras(currentRound, auraRepo) {
  const allAuras = auraRepo.findAll();
  const expiredIds = [];
  for (const aura of allAuras) {
    if (checkAuraDuration(aura, currentRound)) {
      auraRepo.delete(aura.id);
      expiredIds.push(aura.id);
    }
  }
  return expiredIds;
}
var import_crypto10;
var init_aura = __esm({
  "dist/engine/magic/aura.js"() {
    "use strict";
    import_crypto10 = require("crypto");
  }
});

// node_modules/yaml/dist/nodes/identity.js
var require_identity = __commonJS({
  "node_modules/yaml/dist/nodes/identity.js"(exports2) {
    "use strict";
    var ALIAS = Symbol.for("yaml.alias");
    var DOC = Symbol.for("yaml.document");
    var MAP = Symbol.for("yaml.map");
    var PAIR = Symbol.for("yaml.pair");
    var SCALAR = Symbol.for("yaml.scalar");
    var SEQ = Symbol.for("yaml.seq");
    var NODE_TYPE = Symbol.for("yaml.node.type");
    var isAlias = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === ALIAS;
    var isDocument = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === DOC;
    var isMap = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === MAP;
    var isPair = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === PAIR;
    var isScalar = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SCALAR;
    var isSeq = (node) => !!node && typeof node === "object" && node[NODE_TYPE] === SEQ;
    function isCollection(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case MAP:
          case SEQ:
            return true;
        }
      return false;
    }
    function isNode(node) {
      if (node && typeof node === "object")
        switch (node[NODE_TYPE]) {
          case ALIAS:
          case MAP:
          case SCALAR:
          case SEQ:
            return true;
        }
      return false;
    }
    var hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;
    exports2.ALIAS = ALIAS;
    exports2.DOC = DOC;
    exports2.MAP = MAP;
    exports2.NODE_TYPE = NODE_TYPE;
    exports2.PAIR = PAIR;
    exports2.SCALAR = SCALAR;
    exports2.SEQ = SEQ;
    exports2.hasAnchor = hasAnchor;
    exports2.isAlias = isAlias;
    exports2.isCollection = isCollection;
    exports2.isDocument = isDocument;
    exports2.isMap = isMap;
    exports2.isNode = isNode;
    exports2.isPair = isPair;
    exports2.isScalar = isScalar;
    exports2.isSeq = isSeq;
  }
});

// node_modules/yaml/dist/visit.js
var require_visit = __commonJS({
  "node_modules/yaml/dist/visit.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove node");
    function visit(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        visit_(null, node, visitor_, Object.freeze([]));
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    function visit_(key, node, visitor, path) {
      const ctrl = callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = visit_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = visit_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = visit_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    async function visitAsync(node, visitor) {
      const visitor_ = initVisitor(visitor);
      if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
          node.contents = null;
      } else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
    }
    visitAsync.BREAK = BREAK;
    visitAsync.SKIP = SKIP;
    visitAsync.REMOVE = REMOVE;
    async function visitAsync_(key, node, visitor, path) {
      const ctrl = await callVisitor(key, node, visitor, path);
      if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
      }
      if (typeof ctrl !== "symbol") {
        if (identity.isCollection(node)) {
          path = Object.freeze(path.concat(node));
          for (let i = 0; i < node.items.length; ++i) {
            const ci = await visitAsync_(i, node.items[i], visitor, path);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              node.items.splice(i, 1);
              i -= 1;
            }
          }
        } else if (identity.isPair(node)) {
          path = Object.freeze(path.concat(node));
          const ck = await visitAsync_("key", node.key, visitor, path);
          if (ck === BREAK)
            return BREAK;
          else if (ck === REMOVE)
            node.key = null;
          const cv = await visitAsync_("value", node.value, visitor, path);
          if (cv === BREAK)
            return BREAK;
          else if (cv === REMOVE)
            node.value = null;
        }
      }
      return ctrl;
    }
    function initVisitor(visitor) {
      if (typeof visitor === "object" && (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
          Alias: visitor.Node,
          Map: visitor.Node,
          Scalar: visitor.Node,
          Seq: visitor.Node
        }, visitor.Value && {
          Map: visitor.Value,
          Scalar: visitor.Value,
          Seq: visitor.Value
        }, visitor.Collection && {
          Map: visitor.Collection,
          Seq: visitor.Collection
        }, visitor);
      }
      return visitor;
    }
    function callVisitor(key, node, visitor, path) {
      if (typeof visitor === "function")
        return visitor(key, node, path);
      if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
      if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
      if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
      if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
      if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
      return void 0;
    }
    function replaceNode(key, path, node) {
      const parent = path[path.length - 1];
      if (identity.isCollection(parent)) {
        parent.items[key] = node;
      } else if (identity.isPair(parent)) {
        if (key === "key")
          parent.key = node;
        else
          parent.value = node;
      } else if (identity.isDocument(parent)) {
        parent.contents = node;
      } else {
        const pt = identity.isAlias(parent) ? "alias" : "scalar";
        throw new Error(`Cannot replace node with ${pt} parent`);
      }
    }
    exports2.visit = visit;
    exports2.visitAsync = visitAsync;
  }
});

// node_modules/yaml/dist/doc/directives.js
var require_directives = __commonJS({
  "node_modules/yaml/dist/doc/directives.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    var escapeChars = {
      "!": "%21",
      ",": "%2C",
      "[": "%5B",
      "]": "%5D",
      "{": "%7B",
      "}": "%7D"
    };
    var escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, (ch) => escapeChars[ch]);
    var Directives = class _Directives {
      constructor(yaml2, tags) {
        this.docStart = null;
        this.docEnd = false;
        this.yaml = Object.assign({}, _Directives.defaultYaml, yaml2);
        this.tags = Object.assign({}, _Directives.defaultTags, tags);
      }
      clone() {
        const copy = new _Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
      }
      /**
       * During parsing, get a Directives instance for the current document and
       * update the stream state according to the current version's spec.
       */
      atDocument() {
        const res = new _Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
          case "1.1":
            this.atNextDocument = true;
            break;
          case "1.2":
            this.atNextDocument = false;
            this.yaml = {
              explicit: _Directives.defaultYaml.explicit,
              version: "1.2"
            };
            this.tags = Object.assign({}, _Directives.defaultTags);
            break;
        }
        return res;
      }
      /**
       * @param onError - May be called even if the action was successful
       * @returns `true` on success
       */
      add(line, onError) {
        if (this.atNextDocument) {
          this.yaml = { explicit: _Directives.defaultYaml.explicit, version: "1.1" };
          this.tags = Object.assign({}, _Directives.defaultTags);
          this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
          case "%TAG": {
            if (parts.length !== 2) {
              onError(0, "%TAG directive should contain exactly two parts");
              if (parts.length < 2)
                return false;
            }
            const [handle, prefix] = parts;
            this.tags[handle] = prefix;
            return true;
          }
          case "%YAML": {
            this.yaml.explicit = true;
            if (parts.length !== 1) {
              onError(0, "%YAML directive should contain exactly one part");
              return false;
            }
            const [version2] = parts;
            if (version2 === "1.1" || version2 === "1.2") {
              this.yaml.version = version2;
              return true;
            } else {
              const isValid2 = /^\d+\.\d+$/.test(version2);
              onError(6, `Unsupported YAML version ${version2}`, isValid2);
              return false;
            }
          }
          default:
            onError(0, `Unknown directive ${name}`, true);
            return false;
        }
      }
      /**
       * Resolves a tag, matching handles to those defined in %TAG directives.
       *
       * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
       *   `'!local'` tag, or `null` if unresolvable.
       */
      tagName(source, onError) {
        if (source === "!")
          return "!";
        if (source[0] !== "!") {
          onError(`Not a valid tag: ${source}`);
          return null;
        }
        if (source[1] === "<") {
          const verbatim = source.slice(2, -1);
          if (verbatim === "!" || verbatim === "!!") {
            onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
            return null;
          }
          if (source[source.length - 1] !== ">")
            onError("Verbatim tags must end with a >");
          return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
          onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
          try {
            return prefix + decodeURIComponent(suffix);
          } catch (error) {
            onError(String(error));
            return null;
          }
        }
        if (handle === "!")
          return source;
        onError(`Could not resolve tag: ${source}`);
        return null;
      }
      /**
       * Given a fully resolved tag, returns its printable string form,
       * taking into account current tag prefixes and defaults.
       */
      tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
          if (tag.startsWith(prefix))
            return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === "!" ? tag : `!<${tag}>`;
      }
      toString(doc) {
        const lines = this.yaml.explicit ? [`%YAML ${this.yaml.version || "1.2"}`] : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
          const tags = {};
          visit.visit(doc.contents, (_key, node) => {
            if (identity.isNode(node) && node.tag)
              tags[node.tag] = true;
          });
          tagNames = Object.keys(tags);
        } else
          tagNames = [];
        for (const [handle, prefix] of tagEntries) {
          if (handle === "!!" && prefix === "tag:yaml.org,2002:")
            continue;
          if (!doc || tagNames.some((tn) => tn.startsWith(prefix)))
            lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join("\n");
      }
    };
    Directives.defaultYaml = { explicit: false, version: "1.2" };
    Directives.defaultTags = { "!!": "tag:yaml.org,2002:" };
    exports2.Directives = Directives;
  }
});

// node_modules/yaml/dist/doc/anchors.js
var require_anchors = __commonJS({
  "node_modules/yaml/dist/doc/anchors.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var visit = require_visit();
    function anchorIsValid(anchor) {
      if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
      }
      return true;
    }
    function anchorNames(root) {
      const anchors = /* @__PURE__ */ new Set();
      visit.visit(root, {
        Value(_key, node) {
          if (node.anchor)
            anchors.add(node.anchor);
        }
      });
      return anchors;
    }
    function findNewAnchor(prefix, exclude) {
      for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
          return name;
      }
    }
    function createNodeAnchors(doc, prefix) {
      const aliasObjects = [];
      const sourceObjects = /* @__PURE__ */ new Map();
      let prevAnchors = null;
      return {
        onAnchor: (source) => {
          aliasObjects.push(source);
          prevAnchors ?? (prevAnchors = anchorNames(doc));
          const anchor = findNewAnchor(prefix, prevAnchors);
          prevAnchors.add(anchor);
          return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
          for (const source of aliasObjects) {
            const ref = sourceObjects.get(source);
            if (typeof ref === "object" && ref.anchor && (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
              ref.node.anchor = ref.anchor;
            } else {
              const error = new Error("Failed to resolve repeated object (this should not happen)");
              error.source = source;
              throw error;
            }
          }
        },
        sourceObjects
      };
    }
    exports2.anchorIsValid = anchorIsValid;
    exports2.anchorNames = anchorNames;
    exports2.createNodeAnchors = createNodeAnchors;
    exports2.findNewAnchor = findNewAnchor;
  }
});

// node_modules/yaml/dist/doc/applyReviver.js
var require_applyReviver = __commonJS({
  "node_modules/yaml/dist/doc/applyReviver.js"(exports2) {
    "use strict";
    function applyReviver(reviver, obj, key, val) {
      if (val && typeof val === "object") {
        if (Array.isArray(val)) {
          for (let i = 0, len = val.length; i < len; ++i) {
            const v0 = val[i];
            const v1 = applyReviver(reviver, val, String(i), v0);
            if (v1 === void 0)
              delete val[i];
            else if (v1 !== v0)
              val[i] = v1;
          }
        } else if (val instanceof Map) {
          for (const k of Array.from(val.keys())) {
            const v0 = val.get(k);
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              val.delete(k);
            else if (v1 !== v0)
              val.set(k, v1);
          }
        } else if (val instanceof Set) {
          for (const v0 of Array.from(val)) {
            const v1 = applyReviver(reviver, val, v0, v0);
            if (v1 === void 0)
              val.delete(v0);
            else if (v1 !== v0) {
              val.delete(v0);
              val.add(v1);
            }
          }
        } else {
          for (const [k, v0] of Object.entries(val)) {
            const v1 = applyReviver(reviver, val, k, v0);
            if (v1 === void 0)
              delete val[k];
            else if (v1 !== v0)
              val[k] = v1;
          }
        }
      }
      return reviver.call(obj, key, val);
    }
    exports2.applyReviver = applyReviver;
  }
});

// node_modules/yaml/dist/nodes/toJS.js
var require_toJS = __commonJS({
  "node_modules/yaml/dist/nodes/toJS.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function toJS(value, arg, ctx) {
      if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
      if (value && typeof value.toJSON === "function") {
        if (!ctx || !identity.hasAnchor(value))
          return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: void 0 };
        ctx.anchors.set(value, data);
        ctx.onCreate = (res2) => {
          data.res = res2;
          delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
          ctx.onCreate(res);
        return res;
      }
      if (typeof value === "bigint" && !ctx?.keep)
        return Number(value);
      return value;
    }
    exports2.toJS = toJS;
  }
});

// node_modules/yaml/dist/nodes/Node.js
var require_Node = __commonJS({
  "node_modules/yaml/dist/nodes/Node.js"(exports2) {
    "use strict";
    var applyReviver = require_applyReviver();
    var identity = require_identity();
    var toJS = require_toJS();
    var NodeBase = class {
      constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
      }
      /** Create a copy of this node.  */
      clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** A plain JavaScript representation of this node. */
      toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
          throw new TypeError("A document argument is required");
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc,
          keep: true,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
    };
    exports2.NodeBase = NodeBase;
  }
});

// node_modules/yaml/dist/nodes/Alias.js
var require_Alias = __commonJS({
  "node_modules/yaml/dist/nodes/Alias.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var visit = require_visit();
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var Alias = class extends Node.NodeBase {
      constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, "tag", {
          set() {
            throw new Error("Alias nodes cannot have tags");
          }
        });
      }
      /**
       * Resolve the value of this alias within `doc`, finding the last
       * instance of the `source` anchor before this node.
       */
      resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
          nodes = ctx.aliasResolveCache;
        } else {
          nodes = [];
          visit.visit(doc, {
            Node: (_key, node) => {
              if (identity.isAlias(node) || identity.hasAnchor(node))
                nodes.push(node);
            }
          });
          if (ctx)
            ctx.aliasResolveCache = nodes;
        }
        let found = void 0;
        for (const node of nodes) {
          if (node === this)
            break;
          if (node.anchor === this.source)
            found = node;
        }
        return found;
      }
      toJSON(_arg, ctx) {
        if (!ctx)
          return { source: this.source };
        const { anchors: anchors2, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
          const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
          throw new ReferenceError(msg);
        }
        let data = anchors2.get(source);
        if (!data) {
          toJS.toJS(source, null, ctx);
          data = anchors2.get(source);
        }
        if (data?.res === void 0) {
          const msg = "This should not happen: Alias anchor was not resolved?";
          throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
          data.count += 1;
          if (data.aliasCount === 0)
            data.aliasCount = getAliasCount(doc, source, anchors2);
          if (data.count * data.aliasCount > maxAliasCount) {
            const msg = "Excessive alias count indicates a resource exhaustion attack";
            throw new ReferenceError(msg);
          }
        }
        return data.res;
      }
      toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
          anchors.anchorIsValid(this.source);
          if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new Error(msg);
          }
          if (ctx.implicitKey)
            return `${src} `;
        }
        return src;
      }
    };
    function getAliasCount(doc, node, anchors2) {
      if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors2 && source && anchors2.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
      } else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
          const c = getAliasCount(doc, item, anchors2);
          if (c > count)
            count = c;
        }
        return count;
      } else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors2);
        const vc = getAliasCount(doc, node.value, anchors2);
        return Math.max(kc, vc);
      }
      return 1;
    }
    exports2.Alias = Alias;
  }
});

// node_modules/yaml/dist/nodes/Scalar.js
var require_Scalar = __commonJS({
  "node_modules/yaml/dist/nodes/Scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Node = require_Node();
    var toJS = require_toJS();
    var isScalarValue = (value) => !value || typeof value !== "function" && typeof value !== "object";
    var Scalar = class extends Node.NodeBase {
      constructor(value) {
        super(identity.SCALAR);
        this.value = value;
      }
      toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
      }
      toString() {
        return String(this.value);
      }
    };
    Scalar.BLOCK_FOLDED = "BLOCK_FOLDED";
    Scalar.BLOCK_LITERAL = "BLOCK_LITERAL";
    Scalar.PLAIN = "PLAIN";
    Scalar.QUOTE_DOUBLE = "QUOTE_DOUBLE";
    Scalar.QUOTE_SINGLE = "QUOTE_SINGLE";
    exports2.Scalar = Scalar;
    exports2.isScalarValue = isScalarValue;
  }
});

// node_modules/yaml/dist/doc/createNode.js
var require_createNode = __commonJS({
  "node_modules/yaml/dist/doc/createNode.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var defaultTagPrefix = "tag:yaml.org,2002:";
    function findTagObject(value, tagName, tags) {
      if (tagName) {
        const match = tags.filter((t) => t.tag === tagName);
        const tagObj = match.find((t) => !t.format) ?? match[0];
        if (!tagObj)
          throw new Error(`Tag ${tagName} not found`);
        return tagObj;
      }
      return tags.find((t) => t.identify?.(value) && !t.format);
    }
    function createNode(value, tagName, ctx) {
      if (identity.isDocument(value))
        value = value.contents;
      if (identity.isNode(value))
        return value;
      if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
      }
      if (value instanceof String || value instanceof Number || value instanceof Boolean || typeof BigInt !== "undefined" && value instanceof BigInt) {
        value = value.valueOf();
      }
      const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
      let ref = void 0;
      if (aliasDuplicateObjects && value && typeof value === "object") {
        ref = sourceObjects.get(value);
        if (ref) {
          ref.anchor ?? (ref.anchor = onAnchor(value));
          return new Alias.Alias(ref.anchor);
        } else {
          ref = { anchor: null, node: null };
          sourceObjects.set(value, ref);
        }
      }
      if (tagName?.startsWith("!!"))
        tagName = defaultTagPrefix + tagName.slice(2);
      let tagObj = findTagObject(value, tagName, schema.tags);
      if (!tagObj) {
        if (value && typeof value.toJSON === "function") {
          value = value.toJSON();
        }
        if (!value || typeof value !== "object") {
          const node2 = new Scalar.Scalar(value);
          if (ref)
            ref.node = node2;
          return node2;
        }
        tagObj = value instanceof Map ? schema[identity.MAP] : Symbol.iterator in Object(value) ? schema[identity.SEQ] : schema[identity.MAP];
      }
      if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
      }
      const node = tagObj?.createNode ? tagObj.createNode(ctx.schema, value, ctx) : typeof tagObj?.nodeClass?.from === "function" ? tagObj.nodeClass.from(ctx.schema, value, ctx) : new Scalar.Scalar(value);
      if (tagName)
        node.tag = tagName;
      else if (!tagObj.default)
        node.tag = tagObj.tag;
      if (ref)
        ref.node = node;
      return node;
    }
    exports2.createNode = createNode;
  }
});

// node_modules/yaml/dist/nodes/Collection.js
var require_Collection = __commonJS({
  "node_modules/yaml/dist/nodes/Collection.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var identity = require_identity();
    var Node = require_Node();
    function collectionFromPath(schema, path, value) {
      let v = value;
      for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === "number" && Number.isInteger(k) && k >= 0) {
          const a = [];
          a[k] = v;
          v = a;
        } else {
          v = /* @__PURE__ */ new Map([[k, v]]);
        }
      }
      return createNode.createNode(v, void 0, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
          throw new Error("This should not happen, please report a bug.");
        },
        schema,
        sourceObjects: /* @__PURE__ */ new Map()
      });
    }
    var isEmptyPath = (path) => path == null || typeof path === "object" && !!path[Symbol.iterator]().next().done;
    var Collection = class extends Node.NodeBase {
      constructor(type, schema) {
        super(type);
        Object.defineProperty(this, "schema", {
          value: schema,
          configurable: true,
          enumerable: false,
          writable: true
        });
      }
      /**
       * Create a copy of this collection.
       *
       * @param schema - If defined, overwrites the original's schema
       */
      clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
          copy.schema = schema;
        copy.items = copy.items.map((it) => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /**
       * Adds a value to the collection. For `!!map` and `!!omap` the value must
       * be a Pair instance or a `{ key, value }` object, which may not have a key
       * that already exists in the map.
       */
      addIn(path, value) {
        if (isEmptyPath(path))
          this.add(value);
        else {
          const [key, ...rest] = path;
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.addIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
      /**
       * Removes a value from the collection.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
          return node.deleteIn(rest);
        else
          throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
          return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
          return identity.isCollection(node) ? node.getIn(rest, keepScalar) : void 0;
      }
      hasAllNullValues(allowScalar) {
        return this.items.every((node) => {
          if (!identity.isPair(node))
            return false;
          const n2 = node.value;
          return n2 == null || allowScalar && identity.isScalar(n2) && n2.value == null && !n2.commentBefore && !n2.comment && !n2.tag;
        });
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       */
      hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
          return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
          this.set(key, value);
        } else {
          const node = this.get(key, true);
          if (identity.isCollection(node))
            node.setIn(rest, value);
          else if (node === void 0 && this.schema)
            this.set(key, collectionFromPath(this.schema, rest, value));
          else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
      }
    };
    exports2.Collection = Collection;
    exports2.collectionFromPath = collectionFromPath;
    exports2.isEmptyPath = isEmptyPath;
  }
});

// node_modules/yaml/dist/stringify/stringifyComment.js
var require_stringifyComment = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyComment.js"(exports2) {
    "use strict";
    var stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, "#");
    function indentComment(comment, indent) {
      if (/^\n+$/.test(comment))
        return comment.substring(1);
      return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
    }
    var lineComment = (str, indent, comment) => str.endsWith("\n") ? indentComment(comment, indent) : comment.includes("\n") ? "\n" + indentComment(comment, indent) : (str.endsWith(" ") ? "" : " ") + comment;
    exports2.indentComment = indentComment;
    exports2.lineComment = lineComment;
    exports2.stringifyComment = stringifyComment;
  }
});

// node_modules/yaml/dist/stringify/foldFlowLines.js
var require_foldFlowLines = __commonJS({
  "node_modules/yaml/dist/stringify/foldFlowLines.js"(exports2) {
    "use strict";
    var FOLD_FLOW = "flow";
    var FOLD_BLOCK = "block";
    var FOLD_QUOTED = "quoted";
    function foldFlowLines(text, indent, mode = "flow", { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
      if (!lineWidth || lineWidth < 0)
        return text;
      if (lineWidth < minContentWidth)
        minContentWidth = 0;
      const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
      if (text.length <= endStep)
        return text;
      const folds = [];
      const escapedFolds = {};
      let end = lineWidth - indent.length;
      if (typeof indentAtStart === "number") {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
          folds.push(0);
        else
          end = lineWidth - indentAtStart;
      }
      let split = void 0;
      let prev = void 0;
      let overflow = false;
      let i = -1;
      let escStart = -1;
      let escEnd = -1;
      if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
          end = i + endStep;
      }
      for (let ch; ch = text[i += 1]; ) {
        if (mode === FOLD_QUOTED && ch === "\\") {
          escStart = i;
          switch (text[i + 1]) {
            case "x":
              i += 3;
              break;
            case "u":
              i += 5;
              break;
            case "U":
              i += 9;
              break;
            default:
              i += 1;
          }
          escEnd = i;
        }
        if (ch === "\n") {
          if (mode === FOLD_BLOCK)
            i = consumeMoreIndentedLines(text, i, indent.length);
          end = i + indent.length + endStep;
          split = void 0;
        } else {
          if (ch === " " && prev && prev !== " " && prev !== "\n" && prev !== "	") {
            const next = text[i + 1];
            if (next && next !== " " && next !== "\n" && next !== "	")
              split = i;
          }
          if (i >= end) {
            if (split) {
              folds.push(split);
              end = split + endStep;
              split = void 0;
            } else if (mode === FOLD_QUOTED) {
              while (prev === " " || prev === "	") {
                prev = ch;
                ch = text[i += 1];
                overflow = true;
              }
              const j = i > escEnd + 1 ? i - 2 : escStart - 1;
              if (escapedFolds[j])
                return text;
              folds.push(j);
              escapedFolds[j] = true;
              end = j + endStep;
              split = void 0;
            } else {
              overflow = true;
            }
          }
        }
        prev = ch;
      }
      if (overflow && onOverflow)
        onOverflow();
      if (folds.length === 0)
        return text;
      if (onFold)
        onFold();
      let res = text.slice(0, folds[0]);
      for (let i2 = 0; i2 < folds.length; ++i2) {
        const fold = folds[i2];
        const end2 = folds[i2 + 1] || text.length;
        if (fold === 0)
          res = `
${indent}${text.slice(0, end2)}`;
        else {
          if (mode === FOLD_QUOTED && escapedFolds[fold])
            res += `${text[fold]}\\`;
          res += `
${indent}${text.slice(fold + 1, end2)}`;
        }
      }
      return res;
    }
    function consumeMoreIndentedLines(text, i, indent) {
      let end = i;
      let start = i + 1;
      let ch = text[start];
      while (ch === " " || ch === "	") {
        if (i < start + indent) {
          ch = text[++i];
        } else {
          do {
            ch = text[++i];
          } while (ch && ch !== "\n");
          end = i;
          start = i + 1;
          ch = text[start];
        }
      }
      return end;
    }
    exports2.FOLD_BLOCK = FOLD_BLOCK;
    exports2.FOLD_FLOW = FOLD_FLOW;
    exports2.FOLD_QUOTED = FOLD_QUOTED;
    exports2.foldFlowLines = foldFlowLines;
  }
});

// node_modules/yaml/dist/stringify/stringifyString.js
var require_stringifyString = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyString.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var foldFlowLines = require_foldFlowLines();
    var getFoldOptions = (ctx, isBlock) => ({
      indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
      lineWidth: ctx.options.lineWidth,
      minContentWidth: ctx.options.minContentWidth
    });
    var containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
    function lineLengthOverLimit(str, lineWidth, indentLength) {
      if (!lineWidth || lineWidth < 0)
        return false;
      const limit = lineWidth - indentLength;
      const strLen = str.length;
      if (strLen <= limit)
        return false;
      for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === "\n") {
          if (i - start > limit)
            return true;
          start = i + 1;
          if (strLen - start <= limit)
            return false;
        }
      }
      return true;
    }
    function doubleQuotedString(value, ctx) {
      const json = JSON.stringify(value);
      if (ctx.options.doubleQuotedAsJSON)
        return json;
      const { implicitKey } = ctx;
      const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      let str = "";
      let start = 0;
      for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === " " && json[i + 1] === "\\" && json[i + 2] === "n") {
          str += json.slice(start, i) + "\\ ";
          i += 1;
          start = i;
          ch = "\\";
        }
        if (ch === "\\")
          switch (json[i + 1]) {
            case "u":
              {
                str += json.slice(start, i);
                const code = json.substr(i + 2, 4);
                switch (code) {
                  case "0000":
                    str += "\\0";
                    break;
                  case "0007":
                    str += "\\a";
                    break;
                  case "000b":
                    str += "\\v";
                    break;
                  case "001b":
                    str += "\\e";
                    break;
                  case "0085":
                    str += "\\N";
                    break;
                  case "00a0":
                    str += "\\_";
                    break;
                  case "2028":
                    str += "\\L";
                    break;
                  case "2029":
                    str += "\\P";
                    break;
                  default:
                    if (code.substr(0, 2) === "00")
                      str += "\\x" + code.substr(2);
                    else
                      str += json.substr(i, 6);
                }
                i += 5;
                start = i + 1;
              }
              break;
            case "n":
              if (implicitKey || json[i + 2] === '"' || json.length < minMultiLineLength) {
                i += 1;
              } else {
                str += json.slice(start, i) + "\n\n";
                while (json[i + 2] === "\\" && json[i + 3] === "n" && json[i + 4] !== '"') {
                  str += "\n";
                  i += 2;
                }
                str += indent;
                if (json[i + 2] === " ")
                  str += "\\";
                i += 1;
                start = i + 1;
              }
              break;
            default:
              i += 1;
          }
      }
      str = start ? str + json.slice(start) : json;
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
    }
    function singleQuotedString(value, ctx) {
      if (ctx.options.singleQuote === false || ctx.implicitKey && value.includes("\n") || /[ \t]\n|\n[ \t]/.test(value))
        return doubleQuotedString(value, ctx);
      const indent = ctx.indent || (containsDocumentMarker(value) ? "  " : "");
      const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&
${indent}`) + "'";
      return ctx.implicitKey ? res : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function quotedString(value, ctx) {
      const { singleQuote } = ctx.options;
      let qs;
      if (singleQuote === false)
        qs = doubleQuotedString;
      else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
          qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
          qs = doubleQuotedString;
        else
          qs = singleQuote ? singleQuotedString : doubleQuotedString;
      }
      return qs(value, ctx);
    }
    var blockEndNewlines;
    try {
      blockEndNewlines = new RegExp("(^|(?<!\n))\n+(?!\n|$)", "g");
    } catch {
      blockEndNewlines = /\n+(?!\n|$)/g;
    }
    function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
      const { blockQuote, commentString, lineWidth } = ctx.options;
      if (!blockQuote || /\n[\t ]+$/.test(value)) {
        return quotedString(value, ctx);
      }
      const indent = ctx.indent || (ctx.forceBlockIndent || containsDocumentMarker(value) ? "  " : "");
      const literal2 = blockQuote === "literal" ? true : blockQuote === "folded" || type === Scalar.Scalar.BLOCK_FOLDED ? false : type === Scalar.Scalar.BLOCK_LITERAL ? true : !lineLengthOverLimit(value, lineWidth, indent.length);
      if (!value)
        return literal2 ? "|\n" : ">\n";
      let chomp;
      let endStart;
      for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== "\n" && ch !== "	" && ch !== " ")
          break;
      }
      let end = value.substring(endStart);
      const endNlPos = end.indexOf("\n");
      if (endNlPos === -1) {
        chomp = "-";
      } else if (value === end || endNlPos !== end.length - 1) {
        chomp = "+";
        if (onChompKeep)
          onChompKeep();
      } else {
        chomp = "";
      }
      if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === "\n")
          end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
      }
      let startWithSpace = false;
      let startEnd;
      let startNlPos = -1;
      for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === " ")
          startWithSpace = true;
        else if (ch === "\n")
          startNlPos = startEnd;
        else
          break;
      }
      let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
      if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
      }
      const indentSize = indent ? "2" : "1";
      let header = (startWithSpace ? indentSize : "") + chomp;
      if (comment) {
        header += " " + commentString(comment.replace(/ ?[\r\n]+/g, " "));
        if (onComment)
          onComment();
      }
      if (!literal2) {
        const foldedValue = value.replace(/\n+/g, "\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, "$1$2").replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== "folded" && type !== Scalar.Scalar.BLOCK_FOLDED) {
          foldOptions.onOverflow = () => {
            literalFallback = true;
          };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
          return `>${header}
${indent}${body}`;
      }
      value = value.replace(/\n+/g, `$&${indent}`);
      return `|${header}
${indent}${start}${value}${end}`;
    }
    function plainString(item, ctx, onComment, onChompKeep) {
      const { type, value } = item;
      const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
      if (implicitKey && value.includes("\n") || inFlow && /[[\]{},]/.test(value)) {
        return quotedString(value, ctx);
      }
      if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        return implicitKey || inFlow || !value.includes("\n") ? quotedString(value, ctx) : blockString(item, ctx, onComment, onChompKeep);
      }
      if (!implicitKey && !inFlow && type !== Scalar.Scalar.PLAIN && value.includes("\n")) {
        return blockString(item, ctx, onComment, onChompKeep);
      }
      if (containsDocumentMarker(value)) {
        if (indent === "") {
          ctx.forceBlockIndent = true;
          return blockString(item, ctx, onComment, onChompKeep);
        } else if (implicitKey && indent === indentStep) {
          return quotedString(value, ctx);
        }
      }
      const str = value.replace(/\n+/g, `$&
${indent}`);
      if (actualString) {
        const test = (tag) => tag.default && tag.tag !== "tag:yaml.org,2002:str" && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
          return quotedString(value, ctx);
      }
      return implicitKey ? str : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
    }
    function stringifyString(item, ctx, onComment, onChompKeep) {
      const { implicitKey, inFlow } = ctx;
      const ss = typeof item.value === "string" ? item : Object.assign({}, item, { value: String(item.value) });
      let { type } = item;
      if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
          type = Scalar.Scalar.QUOTE_DOUBLE;
      }
      const _stringify = (_type) => {
        switch (_type) {
          case Scalar.Scalar.BLOCK_FOLDED:
          case Scalar.Scalar.BLOCK_LITERAL:
            return implicitKey || inFlow ? quotedString(ss.value, ctx) : blockString(ss, ctx, onComment, onChompKeep);
          case Scalar.Scalar.QUOTE_DOUBLE:
            return doubleQuotedString(ss.value, ctx);
          case Scalar.Scalar.QUOTE_SINGLE:
            return singleQuotedString(ss.value, ctx);
          case Scalar.Scalar.PLAIN:
            return plainString(ss, ctx, onComment, onChompKeep);
          default:
            return null;
        }
      };
      let res = _stringify(type);
      if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = implicitKey && defaultKeyType || defaultStringType;
        res = _stringify(t);
        if (res === null)
          throw new Error(`Unsupported default string type ${t}`);
      }
      return res;
    }
    exports2.stringifyString = stringifyString;
  }
});

// node_modules/yaml/dist/stringify/stringify.js
var require_stringify = __commonJS({
  "node_modules/yaml/dist/stringify/stringify.js"(exports2) {
    "use strict";
    var anchors = require_anchors();
    var identity = require_identity();
    var stringifyComment = require_stringifyComment();
    var stringifyString = require_stringifyString();
    function createStringifyContext(doc, options) {
      const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: "PLAIN",
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: "false",
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: "null",
        simpleKeys: false,
        singleQuote: null,
        trueStr: "true",
        verifyAliasOrder: true
      }, doc.schema.toStringOptions, options);
      let inFlow;
      switch (opt.collectionStyle) {
        case "block":
          inFlow = false;
          break;
        case "flow":
          inFlow = true;
          break;
        default:
          inFlow = null;
      }
      return {
        anchors: /* @__PURE__ */ new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? " " : "",
        indent: "",
        indentStep: typeof opt.indent === "number" ? " ".repeat(opt.indent) : "  ",
        inFlow,
        options: opt
      };
    }
    function getTagObject(tags, item) {
      if (item.tag) {
        const match = tags.filter((t) => t.tag === item.tag);
        if (match.length > 0)
          return match.find((t) => t.format === item.format) ?? match[0];
      }
      let tagObj = void 0;
      let obj;
      if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter((t) => t.identify?.(obj));
        if (match.length > 1) {
          const testMatch = match.filter((t) => t.test);
          if (testMatch.length > 0)
            match = testMatch;
        }
        tagObj = match.find((t) => t.format === item.format) ?? match.find((t) => !t.format);
      } else {
        obj = item;
        tagObj = tags.find((t) => t.nodeClass && obj instanceof t.nodeClass);
      }
      if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? "null" : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
      }
      return tagObj;
    }
    function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
      if (!doc.directives)
        return "";
      const props = [];
      const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
      if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
      }
      const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
      if (tag)
        props.push(doc.directives.tagString(tag));
      return props.join(" ");
    }
    function stringify(item, ctx, onComment, onChompKeep) {
      if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
      if (identity.isAlias(item)) {
        if (ctx.doc.directives)
          return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
          throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        } else {
          if (ctx.resolvedAliases)
            ctx.resolvedAliases.add(item);
          else
            ctx.resolvedAliases = /* @__PURE__ */ new Set([item]);
          item = item.resolve(ctx.doc);
        }
      }
      let tagObj = void 0;
      const node = identity.isNode(item) ? item : ctx.doc.createNode(item, { onTagObj: (o) => tagObj = o });
      tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
      const props = stringifyProps(node, tagObj, ctx);
      if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
      const str = typeof tagObj.stringify === "function" ? tagObj.stringify(node, ctx, onComment, onChompKeep) : identity.isScalar(node) ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep) : node.toString(ctx, onComment, onChompKeep);
      if (!props)
        return str;
      return identity.isScalar(node) || str[0] === "{" || str[0] === "[" ? `${props} ${str}` : `${props}
${ctx.indent}${str}`;
    }
    exports2.createStringifyContext = createStringifyContext;
    exports2.stringify = stringify;
  }
});

// node_modules/yaml/dist/stringify/stringifyPair.js
var require_stringifyPair = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyPair.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
      const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
      let keyComment = identity.isNode(key) && key.comment || null;
      if (simpleKeys) {
        if (keyComment) {
          throw new Error("With simple keys, key nodes cannot have comments");
        }
        if (identity.isCollection(key) || !identity.isNode(key) && typeof key === "object") {
          const msg = "With simple keys, collection cannot be used as a key value";
          throw new Error(msg);
        }
      }
      let explicitKey = !simpleKeys && (!key || keyComment && value == null && !ctx.inFlow || identity.isCollection(key) || (identity.isScalar(key) ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL : typeof key === "object"));
      ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
      });
      let keyCommentDone = false;
      let chompKeep = false;
      let str = stringify.stringify(key, ctx, () => keyCommentDone = true, () => chompKeep = true);
      if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
          throw new Error("With simple keys, single line scalar must not span more than 1024 characters");
        explicitKey = true;
      }
      if (ctx.inFlow) {
        if (allNullValues || value == null) {
          if (keyCommentDone && onComment)
            onComment();
          return str === "" ? "?" : explicitKey ? `? ${str}` : str;
        }
      } else if (allNullValues && !simpleKeys || value == null && explicitKey) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        } else if (chompKeep && onChompKeep)
          onChompKeep();
        return str;
      }
      if (keyCommentDone)
        keyComment = null;
      if (explicitKey) {
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}
${indent}:`;
      } else {
        str = `${str}:`;
        if (keyComment)
          str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
      }
      let vsb, vcb, valueComment;
      if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
      } else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === "object")
          value = doc.createNode(value);
      }
      ctx.implicitKey = false;
      if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
      chompKeep = false;
      if (!indentSeq && indentStep.length >= 2 && !ctx.inFlow && !explicitKey && identity.isSeq(value) && !value.flow && !value.tag && !value.anchor) {
        ctx.indent = ctx.indent.substring(2);
      }
      let valueCommentDone = false;
      const valueStr = stringify.stringify(value, ctx, () => valueCommentDone = true, () => chompKeep = true);
      let ws = " ";
      if (keyComment || vsb || vcb) {
        ws = vsb ? "\n" : "";
        if (vcb) {
          const cs = commentString(vcb);
          ws += `
${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === "" && !ctx.inFlow) {
          if (ws === "\n" && valueComment)
            ws = "\n\n";
        } else {
          ws += `
${ctx.indent}`;
        }
      } else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf("\n");
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
          let hasPropsLine = false;
          if (hasNewline && (vs0 === "&" || vs0 === "!")) {
            let sp0 = valueStr.indexOf(" ");
            if (vs0 === "&" && sp0 !== -1 && sp0 < nl0 && valueStr[sp0 + 1] === "!") {
              sp0 = valueStr.indexOf(" ", sp0 + 1);
            }
            if (sp0 === -1 || nl0 < sp0)
              hasPropsLine = true;
          }
          if (!hasPropsLine)
            ws = `
${ctx.indent}`;
        }
      } else if (valueStr === "" || valueStr[0] === "\n") {
        ws = "";
      }
      str += ws + valueStr;
      if (ctx.inFlow) {
        if (valueCommentDone && onComment)
          onComment();
      } else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
      } else if (chompKeep && onChompKeep) {
        onChompKeep();
      }
      return str;
    }
    exports2.stringifyPair = stringifyPair;
  }
});

// node_modules/yaml/dist/log.js
var require_log = __commonJS({
  "node_modules/yaml/dist/log.js"(exports2) {
    "use strict";
    var node_process = require("process");
    function debug(logLevel, ...messages) {
      if (logLevel === "debug")
        console.log(...messages);
    }
    function warn(logLevel, warning) {
      if (logLevel === "debug" || logLevel === "warn") {
        if (typeof node_process.emitWarning === "function")
          node_process.emitWarning(warning);
        else
          console.warn(warning);
      }
    }
    exports2.debug = debug;
    exports2.warn = warn;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/merge.js
var require_merge = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/merge.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var MERGE_KEY = "<<";
    var merge2 = {
      identify: (value) => value === MERGE_KEY || typeof value === "symbol" && value.description === MERGE_KEY,
      default: "key",
      tag: "tag:yaml.org,2002:merge",
      test: /^<<$/,
      resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
      }),
      stringify: () => MERGE_KEY
    };
    var isMergeKey = (ctx, key) => (merge2.identify(key) || identity.isScalar(key) && (!key.type || key.type === Scalar.Scalar.PLAIN) && merge2.identify(key.value)) && ctx?.doc.schema.tags.some((tag) => tag.tag === merge2.tag && tag.default);
    function addMergeToJSMap(ctx, map, value) {
      value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (identity.isSeq(value))
        for (const it of value.items)
          mergeValue(ctx, map, it);
      else if (Array.isArray(value))
        for (const it of value)
          mergeValue(ctx, map, it);
      else
        mergeValue(ctx, map, value);
    }
    function mergeValue(ctx, map, value) {
      const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
      if (!identity.isMap(source))
        throw new Error("Merge sources must be maps or map aliases");
      const srcMap = source.toJSON(null, ctx, Map);
      for (const [key, value2] of srcMap) {
        if (map instanceof Map) {
          if (!map.has(key))
            map.set(key, value2);
        } else if (map instanceof Set) {
          map.add(key);
        } else if (!Object.prototype.hasOwnProperty.call(map, key)) {
          Object.defineProperty(map, key, {
            value: value2,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }
      return map;
    }
    exports2.addMergeToJSMap = addMergeToJSMap;
    exports2.isMergeKey = isMergeKey;
    exports2.merge = merge2;
  }
});

// node_modules/yaml/dist/nodes/addPairToJSMap.js
var require_addPairToJSMap = __commonJS({
  "node_modules/yaml/dist/nodes/addPairToJSMap.js"(exports2) {
    "use strict";
    var log = require_log();
    var merge2 = require_merge();
    var stringify = require_stringify();
    var identity = require_identity();
    var toJS = require_toJS();
    function addPairToJSMap(ctx, map, { key, value }) {
      if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
      else if (merge2.isMergeKey(ctx, key))
        merge2.addMergeToJSMap(ctx, map, value);
      else {
        const jsKey = toJS.toJS(key, "", ctx);
        if (map instanceof Map) {
          map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        } else if (map instanceof Set) {
          map.add(jsKey);
        } else {
          const stringKey = stringifyKey(key, jsKey, ctx);
          const jsValue = toJS.toJS(value, stringKey, ctx);
          if (stringKey in map)
            Object.defineProperty(map, stringKey, {
              value: jsValue,
              writable: true,
              enumerable: true,
              configurable: true
            });
          else
            map[stringKey] = jsValue;
        }
      }
      return map;
    }
    function stringifyKey(key, jsKey, ctx) {
      if (jsKey === null)
        return "";
      if (typeof jsKey !== "object")
        return String(jsKey);
      if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = /* @__PURE__ */ new Set();
        for (const node of ctx.anchors.keys())
          strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
          let jsonStr = JSON.stringify(strKey);
          if (jsonStr.length > 40)
            jsonStr = jsonStr.substring(0, 36) + '..."';
          log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
          ctx.mapKeyWarned = true;
        }
        return strKey;
      }
      return JSON.stringify(jsKey);
    }
    exports2.addPairToJSMap = addPairToJSMap;
  }
});

// node_modules/yaml/dist/nodes/Pair.js
var require_Pair = __commonJS({
  "node_modules/yaml/dist/nodes/Pair.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyPair = require_stringifyPair();
    var addPairToJSMap = require_addPairToJSMap();
    var identity = require_identity();
    function createPair(key, value, ctx) {
      const k = createNode.createNode(key, void 0, ctx);
      const v = createNode.createNode(value, void 0, ctx);
      return new Pair(k, v);
    }
    var Pair = class _Pair {
      constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
      }
      clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
          key = key.clone(schema);
        if (identity.isNode(value))
          value = value.clone(schema);
        return new _Pair(key, value);
      }
      toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
      }
      toString(ctx, onComment, onChompKeep) {
        return ctx?.doc ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep) : JSON.stringify(this);
      }
    };
    exports2.Pair = Pair;
    exports2.createPair = createPair;
  }
});

// node_modules/yaml/dist/stringify/stringifyCollection.js
var require_stringifyCollection = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyCollection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyCollection(collection, ctx, options) {
      const flow = ctx.inFlow ?? collection.flow;
      const stringify2 = flow ? stringifyFlowCollection : stringifyBlockCollection;
      return stringify2(collection, ctx, options);
    }
    function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
      const { indent, options: { commentString } } = ctx;
      const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
      let chompKeep = false;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment2 = null;
        if (identity.isNode(item)) {
          if (!chompKeep && item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
          if (item.comment)
            comment2 = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (!chompKeep && ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
          }
        }
        chompKeep = false;
        let str2 = stringify.stringify(item, itemCtx, () => comment2 = null, () => chompKeep = true);
        if (comment2)
          str2 += stringifyComment.lineComment(str2, itemIndent, commentString(comment2));
        if (chompKeep && comment2)
          chompKeep = false;
        lines.push(blockItemPrefix + str2);
      }
      let str;
      if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
      } else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
          const line = lines[i];
          str += line ? `
${indent}${line}` : "\n";
        }
      }
      if (comment) {
        str += "\n" + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
          onComment();
      } else if (chompKeep && onChompKeep)
        onChompKeep();
      return str;
    }
    function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
      const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
      itemIndent += indentStep;
      const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
      });
      let reqNewline = false;
      let linesAtValue = 0;
      const lines = [];
      for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
          if (item.spaceBefore)
            lines.push("");
          addCommentBefore(ctx, lines, item.commentBefore, false);
          if (item.comment)
            comment = item.comment;
        } else if (identity.isPair(item)) {
          const ik = identity.isNode(item.key) ? item.key : null;
          if (ik) {
            if (ik.spaceBefore)
              lines.push("");
            addCommentBefore(ctx, lines, ik.commentBefore, false);
            if (ik.comment)
              reqNewline = true;
          }
          const iv = identity.isNode(item.value) ? item.value : null;
          if (iv) {
            if (iv.comment)
              comment = iv.comment;
            if (iv.commentBefore)
              reqNewline = true;
          } else if (item.value == null && ik?.comment) {
            comment = ik.comment;
          }
        }
        if (comment)
          reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => comment = null);
        if (i < items.length - 1)
          str += ",";
        if (comment)
          str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes("\n")))
          reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
      }
      const { start, end } = flowChars;
      if (lines.length === 0) {
        return start + end;
      } else {
        if (!reqNewline) {
          const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
          reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
          let str = start;
          for (const line of lines)
            str += line ? `
${indentStep}${indent}${line}` : "\n";
          return `${str}
${indent}${end}`;
        } else {
          return `${start}${fcPadding}${lines.join(" ")}${fcPadding}${end}`;
        }
      }
    }
    function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
      if (comment && chompKeep)
        comment = comment.replace(/^\n+/, "");
      if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart());
      }
    }
    exports2.stringifyCollection = stringifyCollection;
  }
});

// node_modules/yaml/dist/nodes/YAMLMap.js
var require_YAMLMap = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLMap.js"(exports2) {
    "use strict";
    var stringifyCollection = require_stringifyCollection();
    var addPairToJSMap = require_addPairToJSMap();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    function findPair(items, key) {
      const k = identity.isScalar(key) ? key.value : key;
      for (const it of items) {
        if (identity.isPair(it)) {
          if (it.key === key || it.key === k)
            return it;
          if (identity.isScalar(it.key) && it.key.value === k)
            return it;
        }
      }
      return void 0;
    }
    var YAMLMap = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:map";
      }
      constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
      }
      /**
       * A generic collection parsing method that can be extended
       * to other node classes that inherit from YAMLMap
       */
      static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
          if (typeof replacer === "function")
            value = replacer.call(obj, key, value);
          else if (Array.isArray(replacer) && !replacer.includes(key))
            return;
          if (value !== void 0 || keepUndefined)
            map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
          for (const [key, value] of obj)
            add(key, value);
        } else if (obj && typeof obj === "object") {
          for (const key of Object.keys(obj))
            add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === "function") {
          map.items.sort(schema.sortMapEntries);
        }
        return map;
      }
      /**
       * Adds a value to the collection.
       *
       * @param overwrite - If not set `true`, using a key that is already in the
       *   collection will throw. Otherwise, overwrites the previous value.
       */
      add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
          _pair = pair;
        else if (!pair || typeof pair !== "object" || !("key" in pair)) {
          _pair = new Pair.Pair(pair, pair?.value);
        } else
          _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
          if (!overwrite)
            throw new Error(`Key ${_pair.key} already set`);
          if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
            prev.value.value = _pair.value;
          else
            prev.value = _pair.value;
        } else if (sortEntries) {
          const i = this.items.findIndex((item) => sortEntries(_pair, item) < 0);
          if (i === -1)
            this.items.push(_pair);
          else
            this.items.splice(i, 0, _pair);
        } else {
          this.items.push(_pair);
        }
      }
      delete(key) {
        const it = findPair(this.items, key);
        if (!it)
          return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? void 0;
      }
      has(key) {
        return !!findPair(this.items, key);
      }
      set(key, value) {
        this.add(new Pair.Pair(key, value), true);
      }
      /**
       * @param ctx - Conversion context, originally set in Document#toJS()
       * @param {Class} Type - If set, forces the returned collection type
       * @returns Instance of Type, Map, or Object
       */
      toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? /* @__PURE__ */ new Map() : {};
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const item of this.items)
          addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        for (const item of this.items) {
          if (!identity.isPair(item))
            throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
          ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "",
          flowChars: { start: "{", end: "}" },
          itemIndent: ctx.indent || "",
          onChompKeep,
          onComment
        });
      }
    };
    exports2.YAMLMap = YAMLMap;
    exports2.findPair = findPair;
  }
});

// node_modules/yaml/dist/schema/common/map.js
var require_map = __commonJS({
  "node_modules/yaml/dist/schema/common/map.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLMap = require_YAMLMap();
    var map = {
      collection: "map",
      default: true,
      nodeClass: YAMLMap.YAMLMap,
      tag: "tag:yaml.org,2002:map",
      resolve(map2, onError) {
        if (!identity.isMap(map2))
          onError("Expected a mapping for this tag");
        return map2;
      },
      createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
    };
    exports2.map = map;
  }
});

// node_modules/yaml/dist/nodes/YAMLSeq.js
var require_YAMLSeq = __commonJS({
  "node_modules/yaml/dist/nodes/YAMLSeq.js"(exports2) {
    "use strict";
    var createNode = require_createNode();
    var stringifyCollection = require_stringifyCollection();
    var Collection = require_Collection();
    var identity = require_identity();
    var Scalar = require_Scalar();
    var toJS = require_toJS();
    var YAMLSeq = class extends Collection.Collection {
      static get tagName() {
        return "tag:yaml.org,2002:seq";
      }
      constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
      }
      add(value) {
        this.items.push(value);
      }
      /**
       * Removes a value from the collection.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       *
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
      }
      get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          return void 0;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
      }
      /**
       * Checks if the collection includes a value with the key `key`.
       *
       * `key` must contain a representation of an integer for this to succeed.
       * It may be wrapped in a `Scalar`.
       */
      has(key) {
        const idx = asItemIndex(key);
        return typeof idx === "number" && idx < this.items.length;
      }
      /**
       * Sets a value in this collection. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       *
       * If `key` does not contain a representation of an integer, this will throw.
       * It may be wrapped in a `Scalar`.
       */
      set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== "number")
          throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
          prev.value = value;
        else
          this.items[idx] = value;
      }
      toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
          ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
          seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
          blockItemPrefix: "- ",
          flowChars: { start: "[", end: "]" },
          itemIndent: (ctx.indent || "") + "  ",
          onChompKeep,
          onComment
        });
      }
      static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
          let i = 0;
          for (let it of obj) {
            if (typeof replacer === "function") {
              const key = obj instanceof Set ? it : String(i++);
              it = replacer.call(obj, key, it);
            }
            seq.items.push(createNode.createNode(it, void 0, ctx));
          }
        }
        return seq;
      }
    };
    function asItemIndex(key) {
      let idx = identity.isScalar(key) ? key.value : key;
      if (idx && typeof idx === "string")
        idx = Number(idx);
      return typeof idx === "number" && Number.isInteger(idx) && idx >= 0 ? idx : null;
    }
    exports2.YAMLSeq = YAMLSeq;
  }
});

// node_modules/yaml/dist/schema/common/seq.js
var require_seq = __commonJS({
  "node_modules/yaml/dist/schema/common/seq.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var YAMLSeq = require_YAMLSeq();
    var seq = {
      collection: "seq",
      default: true,
      nodeClass: YAMLSeq.YAMLSeq,
      tag: "tag:yaml.org,2002:seq",
      resolve(seq2, onError) {
        if (!identity.isSeq(seq2))
          onError("Expected a sequence for this tag");
        return seq2;
      },
      createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
    };
    exports2.seq = seq;
  }
});

// node_modules/yaml/dist/schema/common/string.js
var require_string = __commonJS({
  "node_modules/yaml/dist/schema/common/string.js"(exports2) {
    "use strict";
    var stringifyString = require_stringifyString();
    var string3 = {
      identify: (value) => typeof value === "string",
      default: true,
      tag: "tag:yaml.org,2002:str",
      resolve: (str) => str,
      stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
      }
    };
    exports2.string = string3;
  }
});

// node_modules/yaml/dist/schema/common/null.js
var require_null = __commonJS({
  "node_modules/yaml/dist/schema/common/null.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var nullTag = {
      identify: (value) => value == null,
      createNode: () => new Scalar.Scalar(null),
      default: true,
      tag: "tag:yaml.org,2002:null",
      test: /^(?:~|[Nn]ull|NULL)?$/,
      resolve: () => new Scalar.Scalar(null),
      stringify: ({ source }, ctx) => typeof source === "string" && nullTag.test.test(source) ? source : ctx.options.nullStr
    };
    exports2.nullTag = nullTag;
  }
});

// node_modules/yaml/dist/schema/core/bool.js
var require_bool = __commonJS({
  "node_modules/yaml/dist/schema/core/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var boolTag = {
      identify: (value) => typeof value === "boolean",
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
      resolve: (str) => new Scalar.Scalar(str[0] === "t" || str[0] === "T"),
      stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
          const sv = source[0] === "t" || source[0] === "T";
          if (value === sv)
            return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
      }
    };
    exports2.boolTag = boolTag;
  }
});

// node_modules/yaml/dist/stringify/stringifyNumber.js
var require_stringifyNumber = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyNumber.js"(exports2) {
    "use strict";
    function stringifyNumber({ format, minFractionDigits, tag, value }) {
      if (typeof value === "bigint")
        return String(value);
      const num = typeof value === "number" ? value : Number(value);
      if (!isFinite(num))
        return isNaN(num) ? ".nan" : num < 0 ? "-.inf" : ".inf";
      let n2 = Object.is(value, -0) ? "-0" : JSON.stringify(value);
      if (!format && minFractionDigits && (!tag || tag === "tag:yaml.org,2002:float") && /^\d/.test(n2)) {
        let i = n2.indexOf(".");
        if (i < 0) {
          i = n2.length;
          n2 += ".";
        }
        let d = minFractionDigits - (n2.length - i - 1);
        while (d-- > 0)
          n2 += "0";
      }
      return n2;
    }
    exports2.stringifyNumber = stringifyNumber;
  }
});

// node_modules/yaml/dist/schema/core/float.js
var require_float = __commonJS({
  "node_modules/yaml/dist/schema/core/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf(".");
        if (dot !== -1 && str[str.length - 1] === "0")
          node.minFractionDigits = str.length - dot - 1;
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/core/int.js
var require_int = __commonJS({
  "node_modules/yaml/dist/schema/core/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    var intResolve = (str, offset, radix, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix);
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
      return stringifyNumber.stringifyNumber(node);
    }
    var intOct = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^0o[0-7]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
      stringify: (node) => intStringify(node, 8, "0o")
    };
    var int2 = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: (value) => intIdentify(value) && value >= 0,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^0x[0-9a-fA-F]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int2;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/core/schema.js
var require_schema = __commonJS({
  "node_modules/yaml/dist/schema/core/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null3 = require_null();
    var seq = require_seq();
    var string3 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int2 = require_int();
    var schema = [
      map.map,
      seq.seq,
      string3.string,
      _null3.nullTag,
      bool.boolTag,
      int2.intOct,
      int2.int,
      int2.intHex,
      float.floatNaN,
      float.floatExp,
      float.float
    ];
    exports2.schema = schema;
  }
});

// node_modules/yaml/dist/schema/json/schema.js
var require_schema2 = __commonJS({
  "node_modules/yaml/dist/schema/json/schema.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var map = require_map();
    var seq = require_seq();
    function intIdentify(value) {
      return typeof value === "bigint" || Number.isInteger(value);
    }
    var stringifyJSON = ({ value }) => JSON.stringify(value);
    var jsonScalars = [
      {
        identify: (value) => typeof value === "string",
        default: true,
        tag: "tag:yaml.org,2002:str",
        resolve: (str) => str,
        stringify: stringifyJSON
      },
      {
        identify: (value) => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: "tag:yaml.org,2002:null",
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
      },
      {
        identify: (value) => typeof value === "boolean",
        default: true,
        tag: "tag:yaml.org,2002:bool",
        test: /^true$|^false$/,
        resolve: (str) => str === "true",
        stringify: stringifyJSON
      },
      {
        identify: intIdentify,
        default: true,
        tag: "tag:yaml.org,2002:int",
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
      },
      {
        identify: (value) => typeof value === "number",
        default: true,
        tag: "tag:yaml.org,2002:float",
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: (str) => parseFloat(str),
        stringify: stringifyJSON
      }
    ];
    var jsonError = {
      default: true,
      tag: "",
      test: /^/,
      resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
      }
    };
    var schema = [map.map, seq.seq].concat(jsonScalars, jsonError);
    exports2.schema = schema;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/binary.js
var require_binary = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/binary.js"(exports2) {
    "use strict";
    var node_buffer = require("buffer");
    var Scalar = require_Scalar();
    var stringifyString = require_stringifyString();
    var binary = {
      identify: (value) => value instanceof Uint8Array,
      // Buffer inherits from Uint8Array
      default: false,
      tag: "tag:yaml.org,2002:binary",
      /**
       * Returns a Buffer in node and an Uint8Array in browsers
       *
       * To use the resulting buffer as an image, you'll want to do something like:
       *
       *   const blob = new Blob([buffer], { type: 'image/jpeg' })
       *   document.querySelector('#photo').src = URL.createObjectURL(blob)
       */
      resolve(src, onError) {
        if (typeof node_buffer.Buffer === "function") {
          return node_buffer.Buffer.from(src, "base64");
        } else if (typeof atob === "function") {
          const str = atob(src.replace(/[\n\r]/g, ""));
          const buffer = new Uint8Array(str.length);
          for (let i = 0; i < str.length; ++i)
            buffer[i] = str.charCodeAt(i);
          return buffer;
        } else {
          onError("This environment does not support reading binary tags; either Buffer or atob is required");
          return src;
        }
      },
      stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
          return "";
        const buf = value;
        let str;
        if (typeof node_buffer.Buffer === "function") {
          str = buf instanceof node_buffer.Buffer ? buf.toString("base64") : node_buffer.Buffer.from(buf.buffer).toString("base64");
        } else if (typeof btoa === "function") {
          let s = "";
          for (let i = 0; i < buf.length; ++i)
            s += String.fromCharCode(buf[i]);
          str = btoa(s);
        } else {
          throw new Error("This environment does not support writing binary tags; either Buffer or btoa is required");
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
          const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
          const n2 = Math.ceil(str.length / lineWidth);
          const lines = new Array(n2);
          for (let i = 0, o = 0; i < n2; ++i, o += lineWidth) {
            lines[i] = str.substr(o, lineWidth);
          }
          str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? "\n" : " ");
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
      }
    };
    exports2.binary = binary;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/pairs.js
var require_pairs = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/pairs.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLSeq = require_YAMLSeq();
    function resolvePairs(seq, onError) {
      if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
          let item = seq.items[i];
          if (identity.isPair(item))
            continue;
          else if (identity.isMap(item)) {
            if (item.items.length > 1)
              onError("Each pair must have its own sequence indicator");
            const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
            if (item.commentBefore)
              pair.key.commentBefore = pair.key.commentBefore ? `${item.commentBefore}
${pair.key.commentBefore}` : item.commentBefore;
            if (item.comment) {
              const cn = pair.value ?? pair.key;
              cn.comment = cn.comment ? `${item.comment}
${cn.comment}` : item.comment;
            }
            item = pair;
          }
          seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
      } else
        onError("Expected a sequence for this tag");
      return seq;
    }
    function createPairs(schema, iterable, ctx) {
      const { replacer } = ctx;
      const pairs2 = new YAMLSeq.YAMLSeq(schema);
      pairs2.tag = "tag:yaml.org,2002:pairs";
      let i = 0;
      if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
          if (typeof replacer === "function")
            it = replacer.call(iterable, String(i++), it);
          let key, value;
          if (Array.isArray(it)) {
            if (it.length === 2) {
              key = it[0];
              value = it[1];
            } else
              throw new TypeError(`Expected [key, value] tuple: ${it}`);
          } else if (it && it instanceof Object) {
            const keys = Object.keys(it);
            if (keys.length === 1) {
              key = keys[0];
              value = it[key];
            } else {
              throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
            }
          } else {
            key = it;
          }
          pairs2.items.push(Pair.createPair(key, value, ctx));
        }
      return pairs2;
    }
    var pairs = {
      collection: "seq",
      default: false,
      tag: "tag:yaml.org,2002:pairs",
      resolve: resolvePairs,
      createNode: createPairs
    };
    exports2.createPairs = createPairs;
    exports2.pairs = pairs;
    exports2.resolvePairs = resolvePairs;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/omap.js
var require_omap = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/omap.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var toJS = require_toJS();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var pairs = require_pairs();
    var YAMLOMap = class _YAMLOMap extends YAMLSeq.YAMLSeq {
      constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = _YAMLOMap.tag;
      }
      /**
       * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
       * but TypeScript won't allow widening the signature of a child method.
       */
      toJSON(_, ctx) {
        if (!ctx)
          return super.toJSON(_);
        const map = /* @__PURE__ */ new Map();
        if (ctx?.onCreate)
          ctx.onCreate(map);
        for (const pair of this.items) {
          let key, value;
          if (identity.isPair(pair)) {
            key = toJS.toJS(pair.key, "", ctx);
            value = toJS.toJS(pair.value, key, ctx);
          } else {
            key = toJS.toJS(pair, "", ctx);
          }
          if (map.has(key))
            throw new Error("Ordered maps must not include duplicate keys");
          map.set(key, value);
        }
        return map;
      }
      static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap2 = new this();
        omap2.items = pairs$1.items;
        return omap2;
      }
    };
    YAMLOMap.tag = "tag:yaml.org,2002:omap";
    var omap = {
      collection: "seq",
      identify: (value) => value instanceof Map,
      nodeClass: YAMLOMap,
      default: false,
      tag: "tag:yaml.org,2002:omap",
      resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
          if (identity.isScalar(key)) {
            if (seenKeys.includes(key.value)) {
              onError(`Ordered maps must not include duplicate keys: ${key.value}`);
            } else {
              seenKeys.push(key.value);
            }
          }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
      },
      createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
    };
    exports2.YAMLOMap = YAMLOMap;
    exports2.omap = omap;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/bool.js
var require_bool2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/bool.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function boolStringify({ value, source }, ctx) {
      const boolObj = value ? trueTag : falseTag;
      if (source && boolObj.test.test(source))
        return source;
      return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
    var trueTag = {
      identify: (value) => value === true,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
      resolve: () => new Scalar.Scalar(true),
      stringify: boolStringify
    };
    var falseTag = {
      identify: (value) => value === false,
      default: true,
      tag: "tag:yaml.org,2002:bool",
      test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
      resolve: () => new Scalar.Scalar(false),
      stringify: boolStringify
    };
    exports2.falseTag = falseTag;
    exports2.trueTag = trueTag;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/float.js
var require_float2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/float.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var stringifyNumber = require_stringifyNumber();
    var floatNaN = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
      resolve: (str) => str.slice(-3).toLowerCase() === "nan" ? NaN : str[0] === "-" ? Number.NEGATIVE_INFINITY : Number.POSITIVE_INFINITY,
      stringify: stringifyNumber.stringifyNumber
    };
    var floatExp = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "EXP",
      test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
      resolve: (str) => parseFloat(str.replace(/_/g, "")),
      stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
      }
    };
    var float = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
      resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, "")));
        const dot = str.indexOf(".");
        if (dot !== -1) {
          const f = str.substring(dot + 1).replace(/_/g, "");
          if (f[f.length - 1] === "0")
            node.minFractionDigits = f.length;
        }
        return node;
      },
      stringify: stringifyNumber.stringifyNumber
    };
    exports2.float = float;
    exports2.floatExp = floatExp;
    exports2.floatNaN = floatNaN;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/int.js
var require_int2 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/int.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    var intIdentify = (value) => typeof value === "bigint" || Number.isInteger(value);
    function intResolve(str, offset, radix, { intAsBigInt }) {
      const sign = str[0];
      if (sign === "-" || sign === "+")
        offset += 1;
      str = str.substring(offset).replace(/_/g, "");
      if (intAsBigInt) {
        switch (radix) {
          case 2:
            str = `0b${str}`;
            break;
          case 8:
            str = `0o${str}`;
            break;
          case 16:
            str = `0x${str}`;
            break;
        }
        const n3 = BigInt(str);
        return sign === "-" ? BigInt(-1) * n3 : n3;
      }
      const n2 = parseInt(str, radix);
      return sign === "-" ? -1 * n2 : n2;
    }
    function intStringify(node, radix, prefix) {
      const { value } = node;
      if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? "-" + prefix + str.substr(1) : prefix + str;
      }
      return stringifyNumber.stringifyNumber(node);
    }
    var intBin = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "BIN",
      test: /^[-+]?0b[0-1_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
      stringify: (node) => intStringify(node, 2, "0b")
    };
    var intOct = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "OCT",
      test: /^[-+]?0[0-7_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
      stringify: (node) => intStringify(node, 8, "0")
    };
    var int2 = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      test: /^[-+]?[0-9][0-9_]*$/,
      resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
      stringify: stringifyNumber.stringifyNumber
    };
    var intHex = {
      identify: intIdentify,
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "HEX",
      test: /^[-+]?0x[0-9a-fA-F_]+$/,
      resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
      stringify: (node) => intStringify(node, 16, "0x")
    };
    exports2.int = int2;
    exports2.intBin = intBin;
    exports2.intHex = intHex;
    exports2.intOct = intOct;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/set.js
var require_set = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/set.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSet = class _YAMLSet extends YAMLMap.YAMLMap {
      constructor(schema) {
        super(schema);
        this.tag = _YAMLSet.tag;
      }
      add(key) {
        let pair;
        if (identity.isPair(key))
          pair = key;
        else if (key && typeof key === "object" && "key" in key && "value" in key && key.value === null)
          pair = new Pair.Pair(key.key, null);
        else
          pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
          this.items.push(pair);
      }
      /**
       * If `keepPair` is `true`, returns the Pair matching `key`.
       * Otherwise, returns the value of that Pair's key.
       */
      get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair) ? identity.isScalar(pair.key) ? pair.key.value : pair.key : pair;
      }
      set(key, value) {
        if (typeof value !== "boolean")
          throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
          this.items.splice(this.items.indexOf(prev), 1);
        } else if (!prev && value) {
          this.items.push(new Pair.Pair(key));
        }
      }
      toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
      }
      toString(ctx, onComment, onChompKeep) {
        if (!ctx)
          return JSON.stringify(this);
        if (this.hasAllNullValues(true))
          return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
          throw new Error("Set items must all have null values");
      }
      static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set2 = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
          for (let value of iterable) {
            if (typeof replacer === "function")
              value = replacer.call(iterable, value, value);
            set2.items.push(Pair.createPair(value, null, ctx));
          }
        return set2;
      }
    };
    YAMLSet.tag = "tag:yaml.org,2002:set";
    var set = {
      collection: "map",
      identify: (value) => value instanceof Set,
      nodeClass: YAMLSet,
      default: false,
      tag: "tag:yaml.org,2002:set",
      createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
      resolve(map, onError) {
        if (identity.isMap(map)) {
          if (map.hasAllNullValues(true))
            return Object.assign(new YAMLSet(), map);
          else
            onError("Set items must all have null values");
        } else
          onError("Expected a mapping for this tag");
        return map;
      }
    };
    exports2.YAMLSet = YAMLSet;
    exports2.set = set;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/timestamp.js"(exports2) {
    "use strict";
    var stringifyNumber = require_stringifyNumber();
    function parseSexagesimal(str, asBigInt) {
      const sign = str[0];
      const parts = sign === "-" || sign === "+" ? str.substring(1) : str;
      const num = (n2) => asBigInt ? BigInt(n2) : Number(n2);
      const res = parts.replace(/_/g, "").split(":").reduce((res2, p) => res2 * num(60) + num(p), num(0));
      return sign === "-" ? num(-1) * res : res;
    }
    function stringifySexagesimal(node) {
      let { value } = node;
      let num = (n2) => n2;
      if (typeof value === "bigint")
        num = (n2) => BigInt(n2);
      else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
      let sign = "";
      if (value < 0) {
        sign = "-";
        value *= num(-1);
      }
      const _60 = num(60);
      const parts = [value % _60];
      if (value < 60) {
        parts.unshift(0);
      } else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60);
        if (value >= 60) {
          value = (value - parts[0]) / _60;
          parts.unshift(value);
        }
      }
      return sign + parts.map((n2) => String(n2).padStart(2, "0")).join(":").replace(/000000\d*$/, "");
    }
    var intTime = {
      identify: (value) => typeof value === "bigint" || Number.isInteger(value),
      default: true,
      tag: "tag:yaml.org,2002:int",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
      resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
      stringify: stringifySexagesimal
    };
    var floatTime = {
      identify: (value) => typeof value === "number",
      default: true,
      tag: "tag:yaml.org,2002:float",
      format: "TIME",
      test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
      resolve: (str) => parseSexagesimal(str, false),
      stringify: stringifySexagesimal
    };
    var timestamp = {
      identify: (value) => value instanceof Date,
      default: true,
      tag: "tag:yaml.org,2002:timestamp",
      // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
      // may be omitted altogether, resulting in a date format. In such a case, the time part is
      // assumed to be 00:00:00Z (start of day, UTC).
      test: RegExp("^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?$"),
      resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
          throw new Error("!!timestamp expects a date, starting with yyyy-mm-dd");
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + "00").substr(1, 3)) : 0;
        let date3 = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== "Z") {
          let d = parseSexagesimal(tz, false);
          if (Math.abs(d) < 30)
            d *= 60;
          date3 -= 6e4 * d;
        }
        return new Date(date3);
      },
      stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, "") ?? ""
    };
    exports2.floatTime = floatTime;
    exports2.intTime = intTime;
    exports2.timestamp = timestamp;
  }
});

// node_modules/yaml/dist/schema/yaml-1.1/schema.js
var require_schema3 = __commonJS({
  "node_modules/yaml/dist/schema/yaml-1.1/schema.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null3 = require_null();
    var seq = require_seq();
    var string3 = require_string();
    var binary = require_binary();
    var bool = require_bool2();
    var float = require_float2();
    var int2 = require_int2();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var set = require_set();
    var timestamp = require_timestamp();
    var schema = [
      map.map,
      seq.seq,
      string3.string,
      _null3.nullTag,
      bool.trueTag,
      bool.falseTag,
      int2.intBin,
      int2.intOct,
      int2.int,
      int2.intHex,
      float.floatNaN,
      float.floatExp,
      float.float,
      binary.binary,
      merge2.merge,
      omap.omap,
      pairs.pairs,
      set.set,
      timestamp.intTime,
      timestamp.floatTime,
      timestamp.timestamp
    ];
    exports2.schema = schema;
  }
});

// node_modules/yaml/dist/schema/tags.js
var require_tags = __commonJS({
  "node_modules/yaml/dist/schema/tags.js"(exports2) {
    "use strict";
    var map = require_map();
    var _null3 = require_null();
    var seq = require_seq();
    var string3 = require_string();
    var bool = require_bool();
    var float = require_float();
    var int2 = require_int();
    var schema = require_schema();
    var schema$1 = require_schema2();
    var binary = require_binary();
    var merge2 = require_merge();
    var omap = require_omap();
    var pairs = require_pairs();
    var schema$2 = require_schema3();
    var set = require_set();
    var timestamp = require_timestamp();
    var schemas = /* @__PURE__ */ new Map([
      ["core", schema.schema],
      ["failsafe", [map.map, seq.seq, string3.string]],
      ["json", schema$1.schema],
      ["yaml11", schema$2.schema],
      ["yaml-1.1", schema$2.schema]
    ]);
    var tagsByName = {
      binary: binary.binary,
      bool: bool.boolTag,
      float: float.float,
      floatExp: float.floatExp,
      floatNaN: float.floatNaN,
      floatTime: timestamp.floatTime,
      int: int2.int,
      intHex: int2.intHex,
      intOct: int2.intOct,
      intTime: timestamp.intTime,
      map: map.map,
      merge: merge2.merge,
      null: _null3.nullTag,
      omap: omap.omap,
      pairs: pairs.pairs,
      seq: seq.seq,
      set: set.set,
      timestamp: timestamp.timestamp
    };
    var coreKnownTags = {
      "tag:yaml.org,2002:binary": binary.binary,
      "tag:yaml.org,2002:merge": merge2.merge,
      "tag:yaml.org,2002:omap": omap.omap,
      "tag:yaml.org,2002:pairs": pairs.pairs,
      "tag:yaml.org,2002:set": set.set,
      "tag:yaml.org,2002:timestamp": timestamp.timestamp
    };
    function getTags(customTags, schemaName, addMergeTag) {
      const schemaTags = schemas.get(schemaName);
      if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge2.merge) ? schemaTags.concat(merge2.merge) : schemaTags.slice();
      }
      let tags = schemaTags;
      if (!tags) {
        if (Array.isArray(customTags))
          tags = [];
        else {
          const keys = Array.from(schemas.keys()).filter((key) => key !== "yaml11").map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
      }
      if (Array.isArray(customTags)) {
        for (const tag of customTags)
          tags = tags.concat(tag);
      } else if (typeof customTags === "function") {
        tags = customTags(tags.slice());
      }
      if (addMergeTag)
        tags = tags.concat(merge2.merge);
      return tags.reduce((tags2, tag) => {
        const tagObj = typeof tag === "string" ? tagsByName[tag] : tag;
        if (!tagObj) {
          const tagName = JSON.stringify(tag);
          const keys = Object.keys(tagsByName).map((key) => JSON.stringify(key)).join(", ");
          throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags2.includes(tagObj))
          tags2.push(tagObj);
        return tags2;
      }, []);
    }
    exports2.coreKnownTags = coreKnownTags;
    exports2.getTags = getTags;
  }
});

// node_modules/yaml/dist/schema/Schema.js
var require_Schema = __commonJS({
  "node_modules/yaml/dist/schema/Schema.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var map = require_map();
    var seq = require_seq();
    var string3 = require_string();
    var tags = require_tags();
    var sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
    var Schema = class _Schema {
      constructor({ compat, customTags, merge: merge2, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat) ? tags.getTags(compat, "compat") : compat ? tags.getTags(null, compat) : null;
        this.name = typeof schema === "string" && schema || "core";
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge2);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string3.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        this.sortMapEntries = typeof sortMapEntries === "function" ? sortMapEntries : sortMapEntries === true ? sortMapEntriesByKey : null;
      }
      clone() {
        const copy = Object.create(_Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
      }
    };
    exports2.Schema = Schema;
  }
});

// node_modules/yaml/dist/stringify/stringifyDocument.js
var require_stringifyDocument = __commonJS({
  "node_modules/yaml/dist/stringify/stringifyDocument.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var stringify = require_stringify();
    var stringifyComment = require_stringifyComment();
    function stringifyDocument(doc, options) {
      const lines = [];
      let hasDirectives = options.directives === true;
      if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
          lines.push(dir);
          hasDirectives = true;
        } else if (doc.directives.docStart)
          hasDirectives = true;
      }
      if (hasDirectives)
        lines.push("---");
      const ctx = stringify.createStringifyContext(doc, options);
      const { commentString } = ctx.options;
      if (doc.commentBefore) {
        if (lines.length !== 1)
          lines.unshift("");
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ""));
      }
      let chompKeep = false;
      let contentComment = null;
      if (doc.contents) {
        if (identity.isNode(doc.contents)) {
          if (doc.contents.spaceBefore && hasDirectives)
            lines.push("");
          if (doc.contents.commentBefore) {
            const cs = commentString(doc.contents.commentBefore);
            lines.push(stringifyComment.indentComment(cs, ""));
          }
          ctx.forceBlockIndent = !!doc.comment;
          contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? void 0 : () => chompKeep = true;
        let body = stringify.stringify(doc.contents, ctx, () => contentComment = null, onChompKeep);
        if (contentComment)
          body += stringifyComment.lineComment(body, "", commentString(contentComment));
        if ((body[0] === "|" || body[0] === ">") && lines[lines.length - 1] === "---") {
          lines[lines.length - 1] = `--- ${body}`;
        } else
          lines.push(body);
      } else {
        lines.push(stringify.stringify(doc.contents, ctx));
      }
      if (doc.directives?.docEnd) {
        if (doc.comment) {
          const cs = commentString(doc.comment);
          if (cs.includes("\n")) {
            lines.push("...");
            lines.push(stringifyComment.indentComment(cs, ""));
          } else {
            lines.push(`... ${cs}`);
          }
        } else {
          lines.push("...");
        }
      } else {
        let dc = doc.comment;
        if (dc && chompKeep)
          dc = dc.replace(/^\n+/, "");
        if (dc) {
          if ((!chompKeep || contentComment) && lines[lines.length - 1] !== "")
            lines.push("");
          lines.push(stringifyComment.indentComment(commentString(dc), ""));
        }
      }
      return lines.join("\n") + "\n";
    }
    exports2.stringifyDocument = stringifyDocument;
  }
});

// node_modules/yaml/dist/doc/Document.js
var require_Document = __commonJS({
  "node_modules/yaml/dist/doc/Document.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var Collection = require_Collection();
    var identity = require_identity();
    var Pair = require_Pair();
    var toJS = require_toJS();
    var Schema = require_Schema();
    var stringifyDocument = require_stringifyDocument();
    var anchors = require_anchors();
    var applyReviver = require_applyReviver();
    var createNode = require_createNode();
    var directives = require_directives();
    var Document = class _Document {
      constructor(value, replacer, options) {
        this.commentBefore = null;
        this.comment = null;
        this.errors = [];
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === "function" || Array.isArray(replacer)) {
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const opt = Object.assign({
          intAsBigInt: false,
          keepSourceTokens: false,
          logLevel: "warn",
          prettyErrors: true,
          strict: true,
          stringKeys: false,
          uniqueKeys: true,
          version: "1.2"
        }, options);
        this.options = opt;
        let { version: version2 } = opt;
        if (options?._directives) {
          this.directives = options._directives.atDocument();
          if (this.directives.yaml.explicit)
            version2 = this.directives.yaml.version;
        } else
          this.directives = new directives.Directives({ version: version2 });
        this.setSchema(version2, options);
        this.contents = value === void 0 ? null : this.createNode(value, _replacer, options);
      }
      /**
       * Create a deep copy of this Document and its contents.
       *
       * Custom Node values that inherit from `Object` still refer to their original instances.
       */
      clone() {
        const copy = Object.create(_Document.prototype, {
          [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
          copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        copy.contents = identity.isNode(this.contents) ? this.contents.clone(copy.schema) : this.contents;
        if (this.range)
          copy.range = this.range.slice();
        return copy;
      }
      /** Adds a value to the document. */
      add(value) {
        if (assertCollection(this.contents))
          this.contents.add(value);
      }
      /** Adds a value to the document. */
      addIn(path, value) {
        if (assertCollection(this.contents))
          this.contents.addIn(path, value);
      }
      /**
       * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
       *
       * If `node` already has an anchor, `name` is ignored.
       * Otherwise, the `node.anchor` value will be set to `name`,
       * or if an anchor with that name is already present in the document,
       * `name` will be used as a prefix for a new unique anchor.
       * If `name` is undefined, the generated anchor will use 'a' as a prefix.
       */
      createAlias(node, name) {
        if (!node.anchor) {
          const prev = anchors.anchorNames(this);
          node.anchor = // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          !name || prev.has(name) ? anchors.findNewAnchor(name || "a", prev) : name;
        }
        return new Alias.Alias(node.anchor);
      }
      createNode(value, replacer, options) {
        let _replacer = void 0;
        if (typeof replacer === "function") {
          value = replacer.call({ "": value }, "", value);
          _replacer = replacer;
        } else if (Array.isArray(replacer)) {
          const keyToStr = (v) => typeof v === "number" || v instanceof String || v instanceof Number;
          const asStr = replacer.filter(keyToStr).map(String);
          if (asStr.length > 0)
            replacer = replacer.concat(asStr);
          _replacer = replacer;
        } else if (options === void 0 && replacer) {
          options = replacer;
          replacer = void 0;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(
          this,
          // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
          anchorPrefix || "a"
        );
        const ctx = {
          aliasDuplicateObjects: aliasDuplicateObjects ?? true,
          keepUndefined: keepUndefined ?? false,
          onAnchor,
          onTagObj,
          replacer: _replacer,
          schema: this.schema,
          sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
          node.flow = true;
        setAnchors();
        return node;
      }
      /**
       * Convert a key and a value into a `Pair` using the current schema,
       * recursively wrapping all values as `Scalar` or `Collection` nodes.
       */
      createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
      }
      /**
       * Removes a value from the document.
       * @returns `true` if the item was found and removed.
       */
      deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
          if (this.contents == null)
            return false;
          this.contents = null;
          return true;
        }
        return assertCollection(this.contents) ? this.contents.deleteIn(path) : false;
      }
      /**
       * Returns item at `key`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      get(key, keepScalar) {
        return identity.isCollection(this.contents) ? this.contents.get(key, keepScalar) : void 0;
      }
      /**
       * Returns item at `path`, or `undefined` if not found. By default unwraps
       * scalar values from their surrounding node; to disable set `keepScalar` to
       * `true` (collections are always returned intact).
       */
      getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
          return !keepScalar && identity.isScalar(this.contents) ? this.contents.value : this.contents;
        return identity.isCollection(this.contents) ? this.contents.getIn(path, keepScalar) : void 0;
      }
      /**
       * Checks if the document includes a value with the key `key`.
       */
      has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
      }
      /**
       * Checks if the document includes a value at `path`.
       */
      hasIn(path) {
        if (Collection.isEmptyPath(path))
          return this.contents !== void 0;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      set(key, value) {
        if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, [key], value);
        } else if (assertCollection(this.contents)) {
          this.contents.set(key, value);
        }
      }
      /**
       * Sets a value in this document. For `!!set`, `value` needs to be a
       * boolean to add/remove the item from the set.
       */
      setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
          this.contents = value;
        } else if (this.contents == null) {
          this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        } else if (assertCollection(this.contents)) {
          this.contents.setIn(path, value);
        }
      }
      /**
       * Change the YAML version and schema used by the document.
       * A `null` version disables support for directives, explicit tags, anchors, and aliases.
       * It also requires the `schema` option to be given as a `Schema` instance value.
       *
       * Overrides all previously set schema options.
       */
      setSchema(version2, options = {}) {
        if (typeof version2 === "number")
          version2 = String(version2);
        let opt;
        switch (version2) {
          case "1.1":
            if (this.directives)
              this.directives.yaml.version = "1.1";
            else
              this.directives = new directives.Directives({ version: "1.1" });
            opt = { resolveKnownTags: false, schema: "yaml-1.1" };
            break;
          case "1.2":
          case "next":
            if (this.directives)
              this.directives.yaml.version = version2;
            else
              this.directives = new directives.Directives({ version: version2 });
            opt = { resolveKnownTags: true, schema: "core" };
            break;
          case null:
            if (this.directives)
              delete this.directives;
            opt = null;
            break;
          default: {
            const sv = JSON.stringify(version2);
            throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
          }
        }
        if (options.schema instanceof Object)
          this.schema = options.schema;
        else if (opt)
          this.schema = new Schema.Schema(Object.assign(opt, options));
        else
          throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
      }
      // json & jsonArg are only used from toJSON()
      toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
          anchors: /* @__PURE__ */ new Map(),
          doc: this,
          keep: !json,
          mapAsMap: mapAsMap === true,
          mapKeyWarned: false,
          maxAliasCount: typeof maxAliasCount === "number" ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? "", ctx);
        if (typeof onAnchor === "function")
          for (const { count, res: res2 } of ctx.anchors.values())
            onAnchor(res2, count);
        return typeof reviver === "function" ? applyReviver.applyReviver(reviver, { "": res }, "", res) : res;
      }
      /**
       * A JSON representation of the document `contents`.
       *
       * @param jsonArg Used by `JSON.stringify` to indicate the array index or
       *   property name.
       */
      toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
      }
      /** A YAML representation of the document. */
      toString(options = {}) {
        if (this.errors.length > 0)
          throw new Error("Document with errors cannot be stringified");
        if ("indent" in options && (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
          const s = JSON.stringify(options.indent);
          throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
      }
    };
    function assertCollection(contents) {
      if (identity.isCollection(contents))
        return true;
      throw new Error("Expected a YAML collection as document contents");
    }
    exports2.Document = Document;
  }
});

// node_modules/yaml/dist/errors.js
var require_errors2 = __commonJS({
  "node_modules/yaml/dist/errors.js"(exports2) {
    "use strict";
    var YAMLError = class extends Error {
      constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
      }
    };
    var YAMLParseError = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLParseError", pos, code, message);
      }
    };
    var YAMLWarning = class extends YAMLError {
      constructor(pos, code, message) {
        super("YAMLWarning", pos, code, message);
      }
    };
    var prettifyError2 = (src, lc) => (error) => {
      if (error.pos[0] === -1)
        return;
      error.linePos = error.pos.map((pos) => lc.linePos(pos));
      const { line, col } = error.linePos[0];
      error.message += ` at line ${line}, column ${col}`;
      let ci = col - 1;
      let lineStr = src.substring(lc.lineStarts[line - 1], lc.lineStarts[line]).replace(/[\n\r]+$/, "");
      if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = "\u2026" + lineStr.substring(trimStart);
        ci -= trimStart - 1;
      }
      if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + "\u2026";
      if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
          prev = prev.substring(0, 79) + "\u2026\n";
        lineStr = prev + lineStr;
      }
      if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end?.line === line && end.col > col) {
          count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = " ".repeat(ci) + "^".repeat(count);
        error.message += `:

${lineStr}
${pointer}
`;
      }
    };
    exports2.YAMLError = YAMLError;
    exports2.YAMLParseError = YAMLParseError;
    exports2.YAMLWarning = YAMLWarning;
    exports2.prettifyError = prettifyError2;
  }
});

// node_modules/yaml/dist/compose/resolve-props.js
var require_resolve_props = __commonJS({
  "node_modules/yaml/dist/compose/resolve-props.js"(exports2) {
    "use strict";
    function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
      let spaceBefore = false;
      let atNewline = startOnNewline;
      let hasSpace = startOnNewline;
      let comment = "";
      let commentSep = "";
      let hasNewline = false;
      let reqSpace = false;
      let tab = null;
      let anchor = null;
      let tag = null;
      let newlineAfterProp = null;
      let comma = null;
      let found = null;
      let start = null;
      for (const token of tokens) {
        if (reqSpace) {
          if (token.type !== "space" && token.type !== "newline" && token.type !== "comma")
            onError(token.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
          reqSpace = false;
        }
        if (tab) {
          if (atNewline && token.type !== "comment" && token.type !== "newline") {
            onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
          }
          tab = null;
        }
        switch (token.type) {
          case "space":
            if (!flow && (indicator !== "doc-start" || next?.type !== "flow-collection") && token.source.includes("	")) {
              tab = token;
            }
            hasSpace = true;
            break;
          case "comment": {
            if (!hasSpace)
              onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
            const cb = token.source.substring(1) || " ";
            if (!comment)
              comment = cb;
            else
              comment += commentSep + cb;
            commentSep = "";
            atNewline = false;
            break;
          }
          case "newline":
            if (atNewline) {
              if (comment)
                comment += token.source;
              else if (!found || indicator !== "seq-item-ind")
                spaceBefore = true;
            } else
              commentSep += token.source;
            atNewline = true;
            hasNewline = true;
            if (anchor || tag)
              newlineAfterProp = token;
            hasSpace = true;
            break;
          case "anchor":
            if (anchor)
              onError(token, "MULTIPLE_ANCHORS", "A node can have at most one anchor");
            if (token.source.endsWith(":"))
              onError(token.offset + token.source.length - 1, "BAD_ALIAS", "Anchor ending in : is ambiguous", true);
            anchor = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          case "tag": {
            if (tag)
              onError(token, "MULTIPLE_TAGS", "A node can have at most one tag");
            tag = token;
            start ?? (start = token.offset);
            atNewline = false;
            hasSpace = false;
            reqSpace = true;
            break;
          }
          case indicator:
            if (anchor || tag)
              onError(token, "BAD_PROP_ORDER", `Anchors and tags must be after the ${token.source} indicator`);
            if (found)
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.source} in ${flow ?? "collection"}`);
            found = token;
            atNewline = indicator === "seq-item-ind" || indicator === "explicit-key-ind";
            hasSpace = false;
            break;
          case "comma":
            if (flow) {
              if (comma)
                onError(token, "UNEXPECTED_TOKEN", `Unexpected , in ${flow}`);
              comma = token;
              atNewline = false;
              hasSpace = false;
              break;
            }
          // else fallthrough
          default:
            onError(token, "UNEXPECTED_TOKEN", `Unexpected ${token.type} token`);
            atNewline = false;
            hasSpace = false;
        }
      }
      const last = tokens[tokens.length - 1];
      const end = last ? last.offset + last.source.length : offset;
      if (reqSpace && next && next.type !== "space" && next.type !== "newline" && next.type !== "comma" && (next.type !== "scalar" || next.source !== "")) {
        onError(next.offset, "MISSING_CHAR", "Tags and anchors must be separated from the next token by white space");
      }
      if (tab && (atNewline && tab.indent <= parentIndent || next?.type === "block-map" || next?.type === "block-seq"))
        onError(tab, "TAB_AS_INDENT", "Tabs are not allowed as indentation");
      return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
      };
    }
    exports2.resolveProps = resolveProps;
  }
});

// node_modules/yaml/dist/compose/util-contains-newline.js
var require_util_contains_newline = __commonJS({
  "node_modules/yaml/dist/compose/util-contains-newline.js"(exports2) {
    "use strict";
    function containsNewline(key) {
      if (!key)
        return null;
      switch (key.type) {
        case "alias":
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          if (key.source.includes("\n"))
            return true;
          if (key.end) {
            for (const st of key.end)
              if (st.type === "newline")
                return true;
          }
          return false;
        case "flow-collection":
          for (const it of key.items) {
            for (const st of it.start)
              if (st.type === "newline")
                return true;
            if (it.sep) {
              for (const st of it.sep)
                if (st.type === "newline")
                  return true;
            }
            if (containsNewline(it.key) || containsNewline(it.value))
              return true;
          }
          return false;
        default:
          return true;
      }
    }
    exports2.containsNewline = containsNewline;
  }
});

// node_modules/yaml/dist/compose/util-flow-indent-check.js
var require_util_flow_indent_check = __commonJS({
  "node_modules/yaml/dist/compose/util-flow-indent-check.js"(exports2) {
    "use strict";
    var utilContainsNewline = require_util_contains_newline();
    function flowIndentCheck(indent, fc, onError) {
      if (fc?.type === "flow-collection") {
        const end = fc.end[0];
        if (end.indent === indent && (end.source === "]" || end.source === "}") && utilContainsNewline.containsNewline(fc)) {
          const msg = "Flow end indicator should be more indented than parent";
          onError(end, "BAD_INDENT", msg, true);
        }
      }
    }
    exports2.flowIndentCheck = flowIndentCheck;
  }
});

// node_modules/yaml/dist/compose/util-map-includes.js
var require_util_map_includes = __commonJS({
  "node_modules/yaml/dist/compose/util-map-includes.js"(exports2) {
    "use strict";
    var identity = require_identity();
    function mapIncludes(ctx, items, search) {
      const { uniqueKeys } = ctx.options;
      if (uniqueKeys === false)
        return false;
      const isEqual = typeof uniqueKeys === "function" ? uniqueKeys : (a, b) => a === b || identity.isScalar(a) && identity.isScalar(b) && a.value === b.value;
      return items.some((pair) => isEqual(pair.key, search));
    }
    exports2.mapIncludes = mapIncludes;
  }
});

// node_modules/yaml/dist/compose/resolve-block-map.js
var require_resolve_block_map = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-map.js"(exports2) {
    "use strict";
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    var utilMapIncludes = require_util_map_includes();
    var startColMsg = "All mapping items must start at the same column";
    function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
      const map = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      let offset = bm.offset;
      let commentEnd = null;
      for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        const keyProps = resolveProps.resolveProps(start, {
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: bm.indent,
          startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
          if (key) {
            if (key.type === "block-seq")
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "A block sequence may not be used as an implicit map key");
            else if ("indent" in key && key.indent !== bm.indent)
              onError(offset, "BAD_INDENT", startColMsg);
          }
          if (!keyProps.anchor && !keyProps.tag && !sep) {
            commentEnd = keyProps.end;
            if (keyProps.comment) {
              if (map.comment)
                map.comment += "\n" + keyProps.comment;
              else
                map.comment = keyProps.comment;
            }
            continue;
          }
          if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
            onError(key ?? start[start.length - 1], "MULTILINE_IMPLICIT_KEY", "Implicit keys need to be on a single line");
          }
        } else if (keyProps.found?.indent !== bm.indent) {
          onError(offset, "BAD_INDENT", startColMsg);
        }
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key ? composeNode(ctx, key, keyProps, onError) : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
          onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
        const valueProps = resolveProps.resolveProps(sep ?? [], {
          indicator: "map-value-ind",
          next: value,
          offset: keyNode.range[2],
          onError,
          parentIndent: bm.indent,
          startOnNewline: !key || key.type === "block-scalar"
        });
        offset = valueProps.end;
        if (valueProps.found) {
          if (implicitKey) {
            if (value?.type === "block-map" && !valueProps.hasNewline)
              onError(offset, "BLOCK_AS_IMPLICIT_KEY", "Nested mappings are not allowed in compact mappings");
            if (ctx.options.strict && keyProps.start < valueProps.found.offset - 1024)
              onError(keyNode.range, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit block mapping key");
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
          if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
          offset = valueNode.range[2];
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        } else {
          if (implicitKey)
            onError(keyNode.range, "MISSING_CHAR", "Implicit map keys need to be followed by map values");
          if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          map.items.push(pair);
        }
      }
      if (commentEnd && commentEnd < offset)
        onError(commentEnd, "IMPOSSIBLE", "Map comment with trailing content");
      map.range = [bm.offset, offset, commentEnd ?? offset];
      return map;
    }
    exports2.resolveBlockMap = resolveBlockMap;
  }
});

// node_modules/yaml/dist/compose/resolve-block-seq.js
var require_resolve_block_seq = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-seq.js"(exports2) {
    "use strict";
    var YAMLSeq = require_YAMLSeq();
    var resolveProps = require_resolve_props();
    var utilFlowIndentCheck = require_util_flow_indent_check();
    function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
      const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
      const seq = new NodeClass(ctx.schema);
      if (ctx.atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = bs.offset;
      let commentEnd = null;
      for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
          indicator: "seq-item-ind",
          next: value,
          offset,
          onError,
          parentIndent: bs.indent,
          startOnNewline: true
        });
        if (!props.found) {
          if (props.anchor || props.tag || value) {
            if (value?.type === "block-seq")
              onError(props.end, "BAD_INDENT", "All sequence items must start at the same column");
            else
              onError(offset, "MISSING_CHAR", "Sequence item without - indicator");
          } else {
            commentEnd = props.end;
            if (props.comment)
              seq.comment = props.comment;
            continue;
          }
        }
        const node = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
          utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
      }
      seq.range = [bs.offset, offset, commentEnd ?? offset];
      return seq;
    }
    exports2.resolveBlockSeq = resolveBlockSeq;
  }
});

// node_modules/yaml/dist/compose/resolve-end.js
var require_resolve_end = __commonJS({
  "node_modules/yaml/dist/compose/resolve-end.js"(exports2) {
    "use strict";
    function resolveEnd(end, offset, reqSpace, onError) {
      let comment = "";
      if (end) {
        let hasSpace = false;
        let sep = "";
        for (const token of end) {
          const { source, type } = token;
          switch (type) {
            case "space":
              hasSpace = true;
              break;
            case "comment": {
              if (reqSpace && !hasSpace)
                onError(token, "MISSING_CHAR", "Comments must be separated from other tokens by white space characters");
              const cb = source.substring(1) || " ";
              if (!comment)
                comment = cb;
              else
                comment += sep + cb;
              sep = "";
              break;
            }
            case "newline":
              if (comment)
                sep += source;
              hasSpace = true;
              break;
            default:
              onError(token, "UNEXPECTED_TOKEN", `Unexpected ${type} at node end`);
          }
          offset += source.length;
        }
      }
      return { comment, offset };
    }
    exports2.resolveEnd = resolveEnd;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-collection.js
var require_resolve_flow_collection = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Pair = require_Pair();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    var utilContainsNewline = require_util_contains_newline();
    var utilMapIncludes = require_util_map_includes();
    var blockMsg = "Block collections are not allowed within flow collections";
    var isBlock = (token) => token && (token.type === "block-map" || token.type === "block-seq");
    function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
      const isMap = fc.start.source === "{";
      const fcName = isMap ? "flow map" : "flow sequence";
      const NodeClass = tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq);
      const coll = new NodeClass(ctx.schema);
      coll.flow = true;
      const atRoot = ctx.atRoot;
      if (atRoot)
        ctx.atRoot = false;
      if (ctx.atKey)
        ctx.atKey = false;
      let offset = fc.offset + fc.start.source.length;
      for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
          flow: fcName,
          indicator: "explicit-key-ind",
          next: key ?? sep?.[0],
          offset,
          onError,
          parentIndent: fc.indent,
          startOnNewline: false
        });
        if (!props.found) {
          if (!props.anchor && !props.tag && !sep && !value) {
            if (i === 0 && props.comma)
              onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
            else if (i < fc.items.length - 1)
              onError(props.start, "UNEXPECTED_TOKEN", `Unexpected empty item in ${fcName}`);
            if (props.comment) {
              if (coll.comment)
                coll.comment += "\n" + props.comment;
              else
                coll.comment = props.comment;
            }
            offset = props.end;
            continue;
          }
          if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
            onError(
              key,
              // checked by containsNewline()
              "MULTILINE_IMPLICIT_KEY",
              "Implicit keys of flow sequence pairs need to be on a single line"
            );
        }
        if (i === 0) {
          if (props.comma)
            onError(props.comma, "UNEXPECTED_TOKEN", `Unexpected , in ${fcName}`);
        } else {
          if (!props.comma)
            onError(props.start, "MISSING_CHAR", `Missing , between ${fcName} items`);
          if (props.comment) {
            let prevItemComment = "";
            loop: for (const st of start) {
              switch (st.type) {
                case "comma":
                case "space":
                  break;
                case "comment":
                  prevItemComment = st.source.substring(1);
                  break loop;
                default:
                  break loop;
              }
            }
            if (prevItemComment) {
              let prev = coll.items[coll.items.length - 1];
              if (identity.isPair(prev))
                prev = prev.value ?? prev.key;
              if (prev.comment)
                prev.comment += "\n" + prevItemComment;
              else
                prev.comment = prevItemComment;
              props.comment = props.comment.substring(prevItemComment.length + 1);
            }
          }
        }
        if (!isMap && !sep && !props.found) {
          const valueNode = value ? composeNode(ctx, value, props, onError) : composeEmptyNode(ctx, props.end, sep, null, props, onError);
          coll.items.push(valueNode);
          offset = valueNode.range[2];
          if (isBlock(value))
            onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
        } else {
          ctx.atKey = true;
          const keyStart = props.end;
          const keyNode = key ? composeNode(ctx, key, props, onError) : composeEmptyNode(ctx, keyStart, start, null, props, onError);
          if (isBlock(key))
            onError(keyNode.range, "BLOCK_IN_FLOW", blockMsg);
          ctx.atKey = false;
          const valueProps = resolveProps.resolveProps(sep ?? [], {
            flow: fcName,
            indicator: "map-value-ind",
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
          });
          if (valueProps.found) {
            if (!isMap && !props.found && ctx.options.strict) {
              if (sep)
                for (const st of sep) {
                  if (st === valueProps.found)
                    break;
                  if (st.type === "newline") {
                    onError(st, "MULTILINE_IMPLICIT_KEY", "Implicit keys of flow sequence pairs need to be on a single line");
                    break;
                  }
                }
              if (props.start < valueProps.found.offset - 1024)
                onError(valueProps.found, "KEY_OVER_1024_CHARS", "The : indicator must be at most 1024 chars after the start of an implicit flow sequence key");
            }
          } else if (value) {
            if ("source" in value && value.source?.[0] === ":")
              onError(value, "MISSING_CHAR", `Missing space after : in ${fcName}`);
            else
              onError(valueProps.start, "MISSING_CHAR", `Missing , or : between ${fcName} items`);
          }
          const valueNode = value ? composeNode(ctx, value, valueProps, onError) : valueProps.found ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError) : null;
          if (valueNode) {
            if (isBlock(value))
              onError(valueNode.range, "BLOCK_IN_FLOW", blockMsg);
          } else if (valueProps.comment) {
            if (keyNode.comment)
              keyNode.comment += "\n" + valueProps.comment;
            else
              keyNode.comment = valueProps.comment;
          }
          const pair = new Pair.Pair(keyNode, valueNode);
          if (ctx.options.keepSourceTokens)
            pair.srcToken = collItem;
          if (isMap) {
            const map = coll;
            if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
              onError(keyStart, "DUPLICATE_KEY", "Map keys must be unique");
            map.items.push(pair);
          } else {
            const map = new YAMLMap.YAMLMap(ctx.schema);
            map.flow = true;
            map.items.push(pair);
            const endRange = (valueNode ?? keyNode).range;
            map.range = [keyNode.range[0], endRange[1], endRange[2]];
            coll.items.push(map);
          }
          offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
      }
      const expectedEnd = isMap ? "}" : "]";
      const [ce, ...ee] = fc.end;
      let cePos = offset;
      if (ce?.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
      else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot ? `${name} must end with a ${expectedEnd}` : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? "MISSING_CHAR" : "BAD_INDENT", msg);
        if (ce && ce.source.length !== 1)
          ee.unshift(ce);
      }
      if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
          if (coll.comment)
            coll.comment += "\n" + end.comment;
          else
            coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
      } else {
        coll.range = [fc.offset, cePos, cePos];
      }
      return coll;
    }
    exports2.resolveFlowCollection = resolveFlowCollection;
  }
});

// node_modules/yaml/dist/compose/compose-collection.js
var require_compose_collection = __commonJS({
  "node_modules/yaml/dist/compose/compose-collection.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var resolveBlockMap = require_resolve_block_map();
    var resolveBlockSeq = require_resolve_block_seq();
    var resolveFlowCollection = require_resolve_flow_collection();
    function resolveCollection(CN, ctx, token, onError, tagName, tag) {
      const coll = token.type === "block-map" ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag) : token.type === "block-seq" ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag) : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
      const Coll = coll.constructor;
      if (tagName === "!" || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
      }
      if (tagName)
        coll.tag = tagName;
      return coll;
    }
    function composeCollection(CN, ctx, token, props, onError) {
      const tagToken = props.tag;
      const tagName = !tagToken ? null : ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg));
      if (token.type === "block-seq") {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken ? anchor.offset > tagToken.offset ? anchor : tagToken : anchor ?? tagToken;
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
          const message = "Missing newline after block sequence props";
          onError(lastProp, "MISSING_CHAR", message);
        }
      }
      const expType = token.type === "block-map" ? "map" : token.type === "block-seq" ? "seq" : token.start.source === "{" ? "map" : "seq";
      if (!tagToken || !tagName || tagName === "!" || tagName === YAMLMap.YAMLMap.tagName && expType === "map" || tagName === YAMLSeq.YAMLSeq.tagName && expType === "seq") {
        return resolveCollection(CN, ctx, token, onError, tagName);
      }
      let tag = ctx.schema.tags.find((t) => t.tag === tagName && t.collection === expType);
      if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt?.collection === expType) {
          ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
          tag = kt;
        } else {
          if (kt) {
            onError(tagToken, "BAD_COLLECTION_TYPE", `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? "scalar"}`, true);
          } else {
            onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, true);
          }
          return resolveCollection(CN, ctx, token, onError, tagName);
        }
      }
      const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
      const res = tag.resolve?.(coll, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg), ctx.options) ?? coll;
      const node = identity.isNode(res) ? res : new Scalar.Scalar(res);
      node.range = coll.range;
      node.tag = tagName;
      if (tag?.format)
        node.format = tag.format;
      return node;
    }
    exports2.composeCollection = composeCollection;
  }
});

// node_modules/yaml/dist/compose/resolve-block-scalar.js
var require_resolve_block_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-block-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    function resolveBlockScalar(ctx, scalar, onError) {
      const start = scalar.offset;
      const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
      if (!header)
        return { value: "", type: null, comment: "", range: [start, start, start] };
      const type = header.mode === ">" ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
      const lines = scalar.source ? splitLines(scalar.source) : [];
      let chompStart = lines.length;
      for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === "" || content === "\r")
          chompStart = i;
        else
          break;
      }
      if (chompStart === 0) {
        const value2 = header.chomp === "+" && lines.length > 0 ? "\n".repeat(Math.max(1, lines.length - 1)) : "";
        let end2 = start + header.length;
        if (scalar.source)
          end2 += scalar.source.length;
        return { value: value2, type, comment: header.comment, range: [start, end2, end2] };
      }
      let trimIndent = scalar.indent + header.indent;
      let offset = scalar.offset + header.length;
      let contentStart = 0;
      for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === "" || content === "\r") {
          if (header.indent === 0 && indent.length > trimIndent)
            trimIndent = indent.length;
        } else {
          if (indent.length < trimIndent) {
            const message = "Block scalars with more-indented leading empty lines must use an explicit indentation indicator";
            onError(offset + indent.length, "MISSING_CHAR", message);
          }
          if (header.indent === 0)
            trimIndent = indent.length;
          contentStart = i;
          if (trimIndent === 0 && !ctx.atRoot) {
            const message = "Block scalar values in collections must be indented";
            onError(offset, "BAD_INDENT", message);
          }
          break;
        }
        offset += indent.length + content.length + 1;
      }
      for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
          chompStart = i + 1;
      }
      let value = "";
      let sep = "";
      let prevMoreIndented = false;
      for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + "\n";
      for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === "\r";
        if (crlf)
          content = content.slice(0, -1);
        if (content && indent.length < trimIndent) {
          const src = header.indent ? "explicit indentation indicator" : "first line";
          const message = `Block scalar lines must not be less indented than their ${src}`;
          onError(offset - content.length - (crlf ? 2 : 1), "BAD_INDENT", message);
          indent = "";
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
        } else if (indent.length > trimIndent || content[0] === "	") {
          if (sep === " ")
            sep = "\n";
          else if (!prevMoreIndented && sep === "\n")
            sep = "\n\n";
          value += sep + indent.slice(trimIndent) + content;
          sep = "\n";
          prevMoreIndented = true;
        } else if (content === "") {
          if (sep === "\n")
            value += "\n";
          else
            sep = "\n";
        } else {
          value += sep + content;
          sep = " ";
          prevMoreIndented = false;
        }
      }
      switch (header.chomp) {
        case "-":
          break;
        case "+":
          for (let i = chompStart; i < lines.length; ++i)
            value += "\n" + lines[i][0].slice(trimIndent);
          if (value[value.length - 1] !== "\n")
            value += "\n";
          break;
        default:
          value += "\n";
      }
      const end = start + header.length + scalar.source.length;
      return { value, type, comment: header.comment, range: [start, end, end] };
    }
    function parseBlockScalarHeader({ offset, props }, strict, onError) {
      if (props[0].type !== "block-scalar-header") {
        onError(props[0], "IMPOSSIBLE", "Block scalar header not found");
        return null;
      }
      const { source } = props[0];
      const mode = source[0];
      let indent = 0;
      let chomp = "";
      let error = -1;
      for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === "-" || ch === "+"))
          chomp = ch;
        else {
          const n2 = Number(ch);
          if (!indent && n2)
            indent = n2;
          else if (error === -1)
            error = offset + i;
        }
      }
      if (error !== -1)
        onError(error, "UNEXPECTED_TOKEN", `Block scalar header includes extra characters: ${source}`);
      let hasSpace = false;
      let comment = "";
      let length = source.length;
      for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
          case "space":
            hasSpace = true;
          // fallthrough
          case "newline":
            length += token.source.length;
            break;
          case "comment":
            if (strict && !hasSpace) {
              const message = "Comments must be separated from other tokens by white space characters";
              onError(token, "MISSING_CHAR", message);
            }
            length += token.source.length;
            comment = token.source.substring(1);
            break;
          case "error":
            onError(token, "UNEXPECTED_TOKEN", token.message);
            length += token.source.length;
            break;
          /* istanbul ignore next should not happen */
          default: {
            const message = `Unexpected token in block scalar header: ${token.type}`;
            onError(token, "UNEXPECTED_TOKEN", message);
            const ts = token.source;
            if (ts && typeof ts === "string")
              length += ts.length;
          }
        }
      }
      return { mode, indent, chomp, comment, length };
    }
    function splitLines(source) {
      const split = source.split(/\n( *)/);
      const first = split[0];
      const m = first.match(/^( *)/);
      const line0 = m?.[1] ? [m[1], first.slice(m[1].length)] : ["", first];
      const lines = [line0];
      for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
      return lines;
    }
    exports2.resolveBlockScalar = resolveBlockScalar;
  }
});

// node_modules/yaml/dist/compose/resolve-flow-scalar.js
var require_resolve_flow_scalar = __commonJS({
  "node_modules/yaml/dist/compose/resolve-flow-scalar.js"(exports2) {
    "use strict";
    var Scalar = require_Scalar();
    var resolveEnd = require_resolve_end();
    function resolveFlowScalar(scalar, strict, onError) {
      const { offset, type, source, end } = scalar;
      let _type;
      let value;
      const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
      switch (type) {
        case "scalar":
          _type = Scalar.Scalar.PLAIN;
          value = plainValue(source, _onError);
          break;
        case "single-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_SINGLE;
          value = singleQuotedValue(source, _onError);
          break;
        case "double-quoted-scalar":
          _type = Scalar.Scalar.QUOTE_DOUBLE;
          value = doubleQuotedValue(source, _onError);
          break;
        /* istanbul ignore next should not happen */
        default:
          onError(scalar, "UNEXPECTED_TOKEN", `Expected a flow scalar value, but found: ${type}`);
          return {
            value: "",
            type: null,
            comment: "",
            range: [offset, offset + source.length, offset + source.length]
          };
      }
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
      return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
      };
    }
    function plainValue(source, onError) {
      let badChar = "";
      switch (source[0]) {
        /* istanbul ignore next should not happen */
        case "	":
          badChar = "a tab character";
          break;
        case ",":
          badChar = "flow indicator character ,";
          break;
        case "%":
          badChar = "directive indicator character %";
          break;
        case "|":
        case ">": {
          badChar = `block scalar indicator ${source[0]}`;
          break;
        }
        case "@":
        case "`": {
          badChar = `reserved character ${source[0]}`;
          break;
        }
      }
      if (badChar)
        onError(0, "BAD_SCALAR_START", `Plain value cannot start with ${badChar}`);
      return foldLines(source);
    }
    function singleQuotedValue(source, onError) {
      if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, "MISSING_CHAR", "Missing closing 'quote");
      return foldLines(source.slice(1, -1)).replace(/''/g, "'");
    }
    function foldLines(source) {
      let first, line;
      try {
        first = new RegExp("(.*?)(?<![ 	])[ 	]*\r?\n", "sy");
        line = new RegExp("[ 	]*(.*?)(?:(?<![ 	])[ 	]*)?\r?\n", "sy");
      } catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
      }
      let match = first.exec(source);
      if (!match)
        return source;
      let res = match[1];
      let sep = " ";
      let pos = first.lastIndex;
      line.lastIndex = pos;
      while (match = line.exec(source)) {
        if (match[1] === "") {
          if (sep === "\n")
            res += sep;
          else
            sep = "\n";
        } else {
          res += sep + match[1];
          sep = " ";
        }
        pos = line.lastIndex;
      }
      const last = /[ \t]*(.*)/sy;
      last.lastIndex = pos;
      match = last.exec(source);
      return res + sep + (match?.[1] ?? "");
    }
    function doubleQuotedValue(source, onError) {
      let res = "";
      for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === "\r" && source[i + 1] === "\n")
          continue;
        if (ch === "\n") {
          const { fold, offset } = foldNewline(source, i);
          res += fold;
          i = offset;
        } else if (ch === "\\") {
          let next = source[++i];
          const cc = escapeCodes[next];
          if (cc)
            res += cc;
          else if (next === "\n") {
            next = source[i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "\r" && source[i + 1] === "\n") {
            next = source[++i + 1];
            while (next === " " || next === "	")
              next = source[++i + 1];
          } else if (next === "x" || next === "u" || next === "U") {
            const length = { x: 2, u: 4, U: 8 }[next];
            res += parseCharCode(source, i + 1, length, onError);
            i += length;
          } else {
            const raw = source.substr(i - 1, 2);
            onError(i - 1, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
            res += raw;
          }
        } else if (ch === " " || ch === "	") {
          const wsStart = i;
          let next = source[i + 1];
          while (next === " " || next === "	")
            next = source[++i + 1];
          if (next !== "\n" && !(next === "\r" && source[i + 2] === "\n"))
            res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        } else {
          res += ch;
        }
      }
      if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, "MISSING_CHAR", 'Missing closing "quote');
      return res;
    }
    function foldNewline(source, offset) {
      let fold = "";
      let ch = source[offset + 1];
      while (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
        if (ch === "\r" && source[offset + 2] !== "\n")
          break;
        if (ch === "\n")
          fold += "\n";
        offset += 1;
        ch = source[offset + 1];
      }
      if (!fold)
        fold = " ";
      return { fold, offset };
    }
    var escapeCodes = {
      "0": "\0",
      // null character
      a: "\x07",
      // bell character
      b: "\b",
      // backspace
      e: "\x1B",
      // escape character
      f: "\f",
      // form feed
      n: "\n",
      // line feed
      r: "\r",
      // carriage return
      t: "	",
      // horizontal tab
      v: "\v",
      // vertical tab
      N: "\x85",
      // Unicode next line
      _: "\xA0",
      // Unicode non-breaking space
      L: "\u2028",
      // Unicode line separator
      P: "\u2029",
      // Unicode paragraph separator
      " ": " ",
      '"': '"',
      "/": "/",
      "\\": "\\",
      "	": "	"
    };
    function parseCharCode(source, offset, length, onError) {
      const cc = source.substr(offset, length);
      const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
      const code = ok ? parseInt(cc, 16) : NaN;
      if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, "BAD_DQ_ESCAPE", `Invalid escape sequence ${raw}`);
        return raw;
      }
      return String.fromCodePoint(code);
    }
    exports2.resolveFlowScalar = resolveFlowScalar;
  }
});

// node_modules/yaml/dist/compose/compose-scalar.js
var require_compose_scalar = __commonJS({
  "node_modules/yaml/dist/compose/compose-scalar.js"(exports2) {
    "use strict";
    var identity = require_identity();
    var Scalar = require_Scalar();
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    function composeScalar(ctx, token, tagToken, onError) {
      const { value, type, comment, range } = token.type === "block-scalar" ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError) : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
      const tagName = tagToken ? ctx.directives.tagName(tagToken.source, (msg) => onError(tagToken, "TAG_RESOLVE_FAILED", msg)) : null;
      let tag;
      if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
      } else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
      else if (token.type === "scalar")
        tag = findScalarTagByTest(ctx, value, token, onError);
      else
        tag = ctx.schema[identity.SCALAR];
      let scalar;
      try {
        const res = tag.resolve(value, (msg) => onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
      } catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, "TAG_RESOLVE_FAILED", msg);
        scalar = new Scalar.Scalar(value);
      }
      scalar.range = range;
      scalar.source = value;
      if (type)
        scalar.type = type;
      if (tagName)
        scalar.tag = tagName;
      if (tag.format)
        scalar.format = tag.format;
      if (comment)
        scalar.comment = comment;
      return scalar;
    }
    function findScalarTagByName(schema, value, tagName, tagToken, onError) {
      if (tagName === "!")
        return schema[identity.SCALAR];
      const matchWithTest = [];
      for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
          if (tag.default && tag.test)
            matchWithTest.push(tag);
          else
            return tag;
        }
      }
      for (const tag of matchWithTest)
        if (tag.test?.test(value))
          return tag;
      const kt = schema.knownTags[tagName];
      if (kt && !kt.collection) {
        schema.tags.push(Object.assign({}, kt, { default: false, test: void 0 }));
        return kt;
      }
      onError(tagToken, "TAG_RESOLVE_FAILED", `Unresolved tag: ${tagName}`, tagName !== "tag:yaml.org,2002:str");
      return schema[identity.SCALAR];
    }
    function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
      const tag = schema.tags.find((tag2) => (tag2.default === true || atKey && tag2.default === "key") && tag2.test?.test(value)) || schema[identity.SCALAR];
      if (schema.compat) {
        const compat = schema.compat.find((tag2) => tag2.default && tag2.test?.test(value)) ?? schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
          const ts = directives.tagString(tag.tag);
          const cs = directives.tagString(compat.tag);
          const msg = `Value may be parsed as either ${ts} or ${cs}`;
          onError(token, "TAG_RESOLVE_FAILED", msg, true);
        }
      }
      return tag;
    }
    exports2.composeScalar = composeScalar;
  }
});

// node_modules/yaml/dist/compose/util-empty-scalar-position.js
var require_util_empty_scalar_position = __commonJS({
  "node_modules/yaml/dist/compose/util-empty-scalar-position.js"(exports2) {
    "use strict";
    function emptyScalarPosition(offset, before, pos) {
      if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
          let st = before[i];
          switch (st.type) {
            case "space":
            case "comment":
            case "newline":
              offset -= st.source.length;
              continue;
          }
          st = before[++i];
          while (st?.type === "space") {
            offset += st.source.length;
            st = before[++i];
          }
          break;
        }
      }
      return offset;
    }
    exports2.emptyScalarPosition = emptyScalarPosition;
  }
});

// node_modules/yaml/dist/compose/compose-node.js
var require_compose_node = __commonJS({
  "node_modules/yaml/dist/compose/compose-node.js"(exports2) {
    "use strict";
    var Alias = require_Alias();
    var identity = require_identity();
    var composeCollection = require_compose_collection();
    var composeScalar = require_compose_scalar();
    var resolveEnd = require_resolve_end();
    var utilEmptyScalarPosition = require_util_empty_scalar_position();
    var CN = { composeNode, composeEmptyNode };
    function composeNode(ctx, token, props, onError) {
      const atKey = ctx.atKey;
      const { spaceBefore, comment, anchor, tag } = props;
      let node;
      let isSrcToken = true;
      switch (token.type) {
        case "alias":
          node = composeAlias(ctx, token, onError);
          if (anchor || tag)
            onError(token, "ALIAS_PROPS", "An alias node must not specify any properties");
          break;
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "block-scalar":
          node = composeScalar.composeScalar(ctx, token, tag, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        case "block-map":
        case "block-seq":
        case "flow-collection":
          node = composeCollection.composeCollection(CN, ctx, token, props, onError);
          if (anchor)
            node.anchor = anchor.source.substring(1);
          break;
        default: {
          const message = token.type === "error" ? token.message : `Unsupported token (type: ${token.type})`;
          onError(token, "UNEXPECTED_TOKEN", message);
          node = composeEmptyNode(ctx, token.offset, void 0, null, props, onError);
          isSrcToken = false;
        }
      }
      if (anchor && node.anchor === "")
        onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      if (atKey && ctx.options.stringKeys && (!identity.isScalar(node) || typeof node.value !== "string" || node.tag && node.tag !== "tag:yaml.org,2002:str")) {
        const msg = "With stringKeys, all keys must be strings";
        onError(tag ?? token, "NON_STRING_KEY", msg);
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        if (token.type === "scalar" && token.source === "")
          node.comment = comment;
        else
          node.commentBefore = comment;
      }
      if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
      return node;
    }
    function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
      const token = {
        type: "scalar",
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ""
      };
      const node = composeScalar.composeScalar(ctx, token, tag, onError);
      if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === "")
          onError(anchor, "BAD_ALIAS", "Anchor cannot be an empty string");
      }
      if (spaceBefore)
        node.spaceBefore = true;
      if (comment) {
        node.comment = comment;
        node.range[2] = end;
      }
      return node;
    }
    function composeAlias({ options }, { offset, source, end }, onError) {
      const alias = new Alias.Alias(source.substring(1));
      if (alias.source === "")
        onError(offset, "BAD_ALIAS", "Alias cannot be an empty string");
      if (alias.source.endsWith(":"))
        onError(offset + source.length - 1, "BAD_ALIAS", "Alias ending in : is ambiguous", true);
      const valueEnd = offset + source.length;
      const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
      alias.range = [offset, valueEnd, re.offset];
      if (re.comment)
        alias.comment = re.comment;
      return alias;
    }
    exports2.composeEmptyNode = composeEmptyNode;
    exports2.composeNode = composeNode;
  }
});

// node_modules/yaml/dist/compose/compose-doc.js
var require_compose_doc = __commonJS({
  "node_modules/yaml/dist/compose/compose-doc.js"(exports2) {
    "use strict";
    var Document = require_Document();
    var composeNode = require_compose_node();
    var resolveEnd = require_resolve_end();
    var resolveProps = require_resolve_props();
    function composeDoc(options, directives, { offset, start, value, end }, onError) {
      const opts = Object.assign({ _directives: directives }, options);
      const doc = new Document.Document(void 0, opts);
      const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
      };
      const props = resolveProps.resolveProps(start, {
        indicator: "doc-start",
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
      });
      if (props.found) {
        doc.directives.docStart = true;
        if (value && (value.type === "block-map" || value.type === "block-seq") && !props.hasNewline)
          onError(props.end, "MISSING_CHAR", "Block collection cannot start on same line with directives-end marker");
      }
      doc.contents = value ? composeNode.composeNode(ctx, value, props, onError) : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
      const contentEnd = doc.contents.range[2];
      const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
      if (re.comment)
        doc.comment = re.comment;
      doc.range = [offset, contentEnd, re.offset];
      return doc;
    }
    exports2.composeDoc = composeDoc;
  }
});

// node_modules/yaml/dist/compose/composer.js
var require_composer = __commonJS({
  "node_modules/yaml/dist/compose/composer.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var directives = require_directives();
    var Document = require_Document();
    var errors = require_errors2();
    var identity = require_identity();
    var composeDoc = require_compose_doc();
    var resolveEnd = require_resolve_end();
    function getErrorPos(src) {
      if (typeof src === "number")
        return [src, src + 1];
      if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
      const { offset, source } = src;
      return [offset, offset + (typeof source === "string" ? source.length : 1)];
    }
    function parsePrelude(prelude) {
      let comment = "";
      let atComment = false;
      let afterEmptyLine = false;
      for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
          case "#":
            comment += (comment === "" ? "" : afterEmptyLine ? "\n\n" : "\n") + (source.substring(1) || " ");
            atComment = true;
            afterEmptyLine = false;
            break;
          case "%":
            if (prelude[i + 1]?.[0] !== "#")
              i += 1;
            atComment = false;
            break;
          default:
            if (!atComment)
              afterEmptyLine = true;
            atComment = false;
        }
      }
      return { comment, afterEmptyLine };
    }
    var Composer = class {
      constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
          const pos = getErrorPos(source);
          if (warning)
            this.warnings.push(new errors.YAMLWarning(pos, code, message));
          else
            this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        this.directives = new directives.Directives({ version: options.version || "1.2" });
        this.options = options;
      }
      decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        if (comment) {
          const dc = doc.contents;
          if (afterDoc) {
            doc.comment = doc.comment ? `${doc.comment}
${comment}` : comment;
          } else if (afterEmptyLine || doc.directives.docStart || !dc) {
            doc.commentBefore = comment;
          } else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
            let it = dc.items[0];
            if (identity.isPair(it))
              it = it.key;
            const cb = it.commentBefore;
            it.commentBefore = cb ? `${comment}
${cb}` : comment;
          } else {
            const cb = dc.commentBefore;
            dc.commentBefore = cb ? `${comment}
${cb}` : comment;
          }
        }
        if (afterDoc) {
          Array.prototype.push.apply(doc.errors, this.errors);
          Array.prototype.push.apply(doc.warnings, this.warnings);
        } else {
          doc.errors = this.errors;
          doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
      }
      /**
       * Current stream status information.
       *
       * Mostly useful at the end of input for an empty stream.
       */
      streamInfo() {
        return {
          comment: parsePrelude(this.prelude).comment,
          directives: this.directives,
          errors: this.errors,
          warnings: this.warnings
        };
      }
      /**
       * Compose tokens into documents.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
          yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
      }
      /** Advance the composer by one CST token. */
      *next(token) {
        if (node_process.env.LOG_STREAM)
          console.dir(token, { depth: null });
        switch (token.type) {
          case "directive":
            this.directives.add(token.source, (offset, message, warning) => {
              const pos = getErrorPos(token);
              pos[0] += offset;
              this.onError(pos, "BAD_DIRECTIVE", message, warning);
            });
            this.prelude.push(token.source);
            this.atDirectives = true;
            break;
          case "document": {
            const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
            if (this.atDirectives && !doc.directives.docStart)
              this.onError(token, "MISSING_CHAR", "Missing directives-end/doc-start indicator line");
            this.decorate(doc, false);
            if (this.doc)
              yield this.doc;
            this.doc = doc;
            this.atDirectives = false;
            break;
          }
          case "byte-order-mark":
          case "space":
            break;
          case "comment":
          case "newline":
            this.prelude.push(token.source);
            break;
          case "error": {
            const msg = token.source ? `${token.message}: ${JSON.stringify(token.source)}` : token.message;
            const error = new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg);
            if (this.atDirectives || !this.doc)
              this.errors.push(error);
            else
              this.doc.errors.push(error);
            break;
          }
          case "doc-end": {
            if (!this.doc) {
              const msg = "Unexpected doc-end without preceding document";
              this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", msg));
              break;
            }
            this.doc.directives.docEnd = true;
            const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
            this.decorate(this.doc, true);
            if (end.comment) {
              const dc = this.doc.comment;
              this.doc.comment = dc ? `${dc}
${end.comment}` : end.comment;
            }
            this.doc.range[2] = end.offset;
            break;
          }
          default:
            this.errors.push(new errors.YAMLParseError(getErrorPos(token), "UNEXPECTED_TOKEN", `Unsupported token ${token.type}`));
        }
      }
      /**
       * Call at end of input to yield any remaining document.
       *
       * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
       * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
       */
      *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
          this.decorate(this.doc, true);
          yield this.doc;
          this.doc = null;
        } else if (forceDoc) {
          const opts = Object.assign({ _directives: this.directives }, this.options);
          const doc = new Document.Document(void 0, opts);
          if (this.atDirectives)
            this.onError(endOffset, "MISSING_CHAR", "Missing directives-end indicator line");
          doc.range = [0, endOffset, endOffset];
          this.decorate(doc, false);
          yield doc;
        }
      }
    };
    exports2.Composer = Composer;
  }
});

// node_modules/yaml/dist/parse/cst-scalar.js
var require_cst_scalar = __commonJS({
  "node_modules/yaml/dist/parse/cst-scalar.js"(exports2) {
    "use strict";
    var resolveBlockScalar = require_resolve_block_scalar();
    var resolveFlowScalar = require_resolve_flow_scalar();
    var errors = require_errors2();
    var stringifyString = require_stringifyString();
    function resolveAsScalar(token, strict = true, onError) {
      if (token) {
        const _onError = (pos, code, message) => {
          const offset = typeof pos === "number" ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
          if (onError)
            onError(offset, code, message);
          else
            throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
          case "block-scalar":
            return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
      }
      return null;
    }
    function createScalarToken(value, context) {
      const { implicitKey = false, indent, inFlow = false, offset = -1, type = "PLAIN" } = context;
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      const end = context.end ?? [
        { type: "newline", offset: -1, indent, source: "\n" }
      ];
      switch (source[0]) {
        case "|":
        case ">": {
          const he = source.indexOf("\n");
          const head = source.substring(0, he);
          const body = source.substring(he + 1) + "\n";
          const props = [
            { type: "block-scalar-header", offset, indent, source: head }
          ];
          if (!addEndtoBlockProps(props, end))
            props.push({ type: "newline", offset: -1, indent, source: "\n" });
          return { type: "block-scalar", offset, indent, props, source: body };
        }
        case '"':
          return { type: "double-quoted-scalar", offset, indent, source, end };
        case "'":
          return { type: "single-quoted-scalar", offset, indent, source, end };
        default:
          return { type: "scalar", offset, indent, source, end };
      }
    }
    function setScalarValue(token, value, context = {}) {
      let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
      let indent = "indent" in token ? token.indent : null;
      if (afterKey && typeof indent === "number")
        indent += 2;
      if (!type)
        switch (token.type) {
          case "single-quoted-scalar":
            type = "QUOTE_SINGLE";
            break;
          case "double-quoted-scalar":
            type = "QUOTE_DOUBLE";
            break;
          case "block-scalar": {
            const header = token.props[0];
            if (header.type !== "block-scalar-header")
              throw new Error("Invalid block scalar header");
            type = header.source[0] === ">" ? "BLOCK_FOLDED" : "BLOCK_LITERAL";
            break;
          }
          default:
            type = "PLAIN";
        }
      const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? " ".repeat(indent) : "",
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
      });
      switch (source[0]) {
        case "|":
        case ">":
          setBlockScalarValue(token, source);
          break;
        case '"':
          setFlowScalarValue(token, source, "double-quoted-scalar");
          break;
        case "'":
          setFlowScalarValue(token, source, "single-quoted-scalar");
          break;
        default:
          setFlowScalarValue(token, source, "scalar");
      }
    }
    function setBlockScalarValue(token, source) {
      const he = source.indexOf("\n");
      const head = source.substring(0, he);
      const body = source.substring(he + 1) + "\n";
      if (token.type === "block-scalar") {
        const header = token.props[0];
        if (header.type !== "block-scalar-header")
          throw new Error("Invalid block scalar header");
        header.source = head;
        token.source = body;
      } else {
        const { offset } = token;
        const indent = "indent" in token ? token.indent : -1;
        const props = [
          { type: "block-scalar-header", offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, "end" in token ? token.end : void 0))
          props.push({ type: "newline", offset: -1, indent, source: "\n" });
        for (const key of Object.keys(token))
          if (key !== "type" && key !== "offset")
            delete token[key];
        Object.assign(token, { type: "block-scalar", indent, props, source: body });
      }
    }
    function addEndtoBlockProps(props, end) {
      if (end)
        for (const st of end)
          switch (st.type) {
            case "space":
            case "comment":
              props.push(st);
              break;
            case "newline":
              props.push(st);
              return true;
          }
      return false;
    }
    function setFlowScalarValue(token, source, type) {
      switch (token.type) {
        case "scalar":
        case "double-quoted-scalar":
        case "single-quoted-scalar":
          token.type = type;
          token.source = source;
          break;
        case "block-scalar": {
          const end = token.props.slice(1);
          let oa = source.length;
          if (token.props[0].type === "block-scalar-header")
            oa -= token.props[0].source.length;
          for (const tok of end)
            tok.offset += oa;
          delete token.props;
          Object.assign(token, { type, source, end });
          break;
        }
        case "block-map":
        case "block-seq": {
          const offset = token.offset + source.length;
          const nl = { type: "newline", offset, indent: token.indent, source: "\n" };
          delete token.items;
          Object.assign(token, { type, source, end: [nl] });
          break;
        }
        default: {
          const indent = "indent" in token ? token.indent : -1;
          const end = "end" in token && Array.isArray(token.end) ? token.end.filter((st) => st.type === "space" || st.type === "comment" || st.type === "newline") : [];
          for (const key of Object.keys(token))
            if (key !== "type" && key !== "offset")
              delete token[key];
          Object.assign(token, { type, indent, source, end });
        }
      }
    }
    exports2.createScalarToken = createScalarToken;
    exports2.resolveAsScalar = resolveAsScalar;
    exports2.setScalarValue = setScalarValue;
  }
});

// node_modules/yaml/dist/parse/cst-stringify.js
var require_cst_stringify = __commonJS({
  "node_modules/yaml/dist/parse/cst-stringify.js"(exports2) {
    "use strict";
    var stringify = (cst) => "type" in cst ? stringifyToken(cst) : stringifyItem(cst);
    function stringifyToken(token) {
      switch (token.type) {
        case "block-scalar": {
          let res = "";
          for (const tok of token.props)
            res += stringifyToken(tok);
          return res + token.source;
        }
        case "block-map":
        case "block-seq": {
          let res = "";
          for (const item of token.items)
            res += stringifyItem(item);
          return res;
        }
        case "flow-collection": {
          let res = token.start.source;
          for (const item of token.items)
            res += stringifyItem(item);
          for (const st of token.end)
            res += st.source;
          return res;
        }
        case "document": {
          let res = stringifyItem(token);
          if (token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
        default: {
          let res = token.source;
          if ("end" in token && token.end)
            for (const st of token.end)
              res += st.source;
          return res;
        }
      }
    }
    function stringifyItem({ start, key, sep, value }) {
      let res = "";
      for (const st of start)
        res += st.source;
      if (key)
        res += stringifyToken(key);
      if (sep)
        for (const st of sep)
          res += st.source;
      if (value)
        res += stringifyToken(value);
      return res;
    }
    exports2.stringify = stringify;
  }
});

// node_modules/yaml/dist/parse/cst-visit.js
var require_cst_visit = __commonJS({
  "node_modules/yaml/dist/parse/cst-visit.js"(exports2) {
    "use strict";
    var BREAK = Symbol("break visit");
    var SKIP = Symbol("skip children");
    var REMOVE = Symbol("remove item");
    function visit(cst, visitor) {
      if ("type" in cst && cst.type === "document")
        cst = { start: cst.start, value: cst.value };
      _visit(Object.freeze([]), cst, visitor);
    }
    visit.BREAK = BREAK;
    visit.SKIP = SKIP;
    visit.REMOVE = REMOVE;
    visit.itemAtPath = (cst, path) => {
      let item = cst;
      for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && "items" in tok) {
          item = tok.items[index];
        } else
          return void 0;
      }
      return item;
    };
    visit.parentCollection = (cst, path) => {
      const parent = visit.itemAtPath(cst, path.slice(0, -1));
      const field = path[path.length - 1][0];
      const coll = parent?.[field];
      if (coll && "items" in coll)
        return coll;
      throw new Error("Parent collection not found");
    };
    function _visit(path, item, visitor) {
      let ctrl = visitor(item, path);
      if (typeof ctrl === "symbol")
        return ctrl;
      for (const field of ["key", "value"]) {
        const token = item[field];
        if (token && "items" in token) {
          for (let i = 0; i < token.items.length; ++i) {
            const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
            if (typeof ci === "number")
              i = ci - 1;
            else if (ci === BREAK)
              return BREAK;
            else if (ci === REMOVE) {
              token.items.splice(i, 1);
              i -= 1;
            }
          }
          if (typeof ctrl === "function" && field === "key")
            ctrl = ctrl(item, path);
        }
      }
      return typeof ctrl === "function" ? ctrl(item, path) : ctrl;
    }
    exports2.visit = visit;
  }
});

// node_modules/yaml/dist/parse/cst.js
var require_cst = __commonJS({
  "node_modules/yaml/dist/parse/cst.js"(exports2) {
    "use strict";
    var cstScalar = require_cst_scalar();
    var cstStringify = require_cst_stringify();
    var cstVisit = require_cst_visit();
    var BOM = "\uFEFF";
    var DOCUMENT = "";
    var FLOW_END = "";
    var SCALAR = "";
    var isCollection = (token) => !!token && "items" in token;
    var isScalar = (token) => !!token && (token.type === "scalar" || token.type === "single-quoted-scalar" || token.type === "double-quoted-scalar" || token.type === "block-scalar");
    function prettyToken(token) {
      switch (token) {
        case BOM:
          return "<BOM>";
        case DOCUMENT:
          return "<DOC>";
        case FLOW_END:
          return "<FLOW_END>";
        case SCALAR:
          return "<SCALAR>";
        default:
          return JSON.stringify(token);
      }
    }
    function tokenType(source) {
      switch (source) {
        case BOM:
          return "byte-order-mark";
        case DOCUMENT:
          return "doc-mode";
        case FLOW_END:
          return "flow-error-end";
        case SCALAR:
          return "scalar";
        case "---":
          return "doc-start";
        case "...":
          return "doc-end";
        case "":
        case "\n":
        case "\r\n":
          return "newline";
        case "-":
          return "seq-item-ind";
        case "?":
          return "explicit-key-ind";
        case ":":
          return "map-value-ind";
        case "{":
          return "flow-map-start";
        case "}":
          return "flow-map-end";
        case "[":
          return "flow-seq-start";
        case "]":
          return "flow-seq-end";
        case ",":
          return "comma";
      }
      switch (source[0]) {
        case " ":
        case "	":
          return "space";
        case "#":
          return "comment";
        case "%":
          return "directive-line";
        case "*":
          return "alias";
        case "&":
          return "anchor";
        case "!":
          return "tag";
        case "'":
          return "single-quoted-scalar";
        case '"':
          return "double-quoted-scalar";
        case "|":
        case ">":
          return "block-scalar-header";
      }
      return null;
    }
    exports2.createScalarToken = cstScalar.createScalarToken;
    exports2.resolveAsScalar = cstScalar.resolveAsScalar;
    exports2.setScalarValue = cstScalar.setScalarValue;
    exports2.stringify = cstStringify.stringify;
    exports2.visit = cstVisit.visit;
    exports2.BOM = BOM;
    exports2.DOCUMENT = DOCUMENT;
    exports2.FLOW_END = FLOW_END;
    exports2.SCALAR = SCALAR;
    exports2.isCollection = isCollection;
    exports2.isScalar = isScalar;
    exports2.prettyToken = prettyToken;
    exports2.tokenType = tokenType;
  }
});

// node_modules/yaml/dist/parse/lexer.js
var require_lexer = __commonJS({
  "node_modules/yaml/dist/parse/lexer.js"(exports2) {
    "use strict";
    var cst = require_cst();
    function isEmpty(ch) {
      switch (ch) {
        case void 0:
        case " ":
        case "\n":
        case "\r":
        case "	":
          return true;
        default:
          return false;
      }
    }
    var hexDigits = new Set("0123456789ABCDEFabcdef");
    var tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
    var flowIndicatorChars = new Set(",[]{}");
    var invalidAnchorChars = new Set(" ,[]{}\n\r	");
    var isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
    var Lexer = class {
      constructor() {
        this.atEnd = false;
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        this.buffer = "";
        this.flowKey = false;
        this.flowLevel = 0;
        this.indentNext = 0;
        this.indentValue = 0;
        this.lineEndPos = null;
        this.next = null;
        this.pos = 0;
      }
      /**
       * Generate YAML tokens from the `source` string. If `incomplete`,
       * a part of the last line may be left as a buffer for the next call.
       *
       * @returns A generator of lexical tokens
       */
      *lex(source, incomplete = false) {
        if (source) {
          if (typeof source !== "string")
            throw TypeError("source is not a string");
          this.buffer = this.buffer ? this.buffer + source : source;
          this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? "stream";
        while (next && (incomplete || this.hasChars(1)))
          next = yield* this.parseNext(next);
      }
      atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === " " || ch === "	")
          ch = this.buffer[++i];
        if (!ch || ch === "#" || ch === "\n")
          return true;
        if (ch === "\r")
          return this.buffer[i + 1] === "\n";
        return false;
      }
      charAt(n2) {
        return this.buffer[this.pos + n2];
      }
      continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
          let indent = 0;
          while (ch === " ")
            ch = this.buffer[++indent + offset];
          if (ch === "\r") {
            const next = this.buffer[indent + offset + 1];
            if (next === "\n" || !next && !this.atEnd)
              return offset + indent + 1;
          }
          return ch === "\n" || indent >= this.indentNext || !ch && !this.atEnd ? offset + indent : -1;
        }
        if (ch === "-" || ch === ".") {
          const dt = this.buffer.substr(offset, 3);
          if ((dt === "---" || dt === "...") && isEmpty(this.buffer[offset + 3]))
            return -1;
        }
        return offset;
      }
      getLine() {
        let end = this.lineEndPos;
        if (typeof end !== "number" || end !== -1 && end < this.pos) {
          end = this.buffer.indexOf("\n", this.pos);
          this.lineEndPos = end;
        }
        if (end === -1)
          return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === "\r")
          end -= 1;
        return this.buffer.substring(this.pos, end);
      }
      hasChars(n2) {
        return this.pos + n2 <= this.buffer.length;
      }
      setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
      }
      peek(n2) {
        return this.buffer.substr(this.pos, n2);
      }
      *parseNext(next) {
        switch (next) {
          case "stream":
            return yield* this.parseStream();
          case "line-start":
            return yield* this.parseLineStart();
          case "block-start":
            return yield* this.parseBlockStart();
          case "doc":
            return yield* this.parseDocument();
          case "flow":
            return yield* this.parseFlowCollection();
          case "quoted-scalar":
            return yield* this.parseQuotedScalar();
          case "block-scalar":
            return yield* this.parseBlockScalar();
          case "plain-scalar":
            return yield* this.parsePlainScalar();
        }
      }
      *parseStream() {
        let line = this.getLine();
        if (line === null)
          return this.setNext("stream");
        if (line[0] === cst.BOM) {
          yield* this.pushCount(1);
          line = line.substring(1);
        }
        if (line[0] === "%") {
          let dirEnd = line.length;
          let cs = line.indexOf("#");
          while (cs !== -1) {
            const ch = line[cs - 1];
            if (ch === " " || ch === "	") {
              dirEnd = cs - 1;
              break;
            } else {
              cs = line.indexOf("#", cs + 1);
            }
          }
          while (true) {
            const ch = line[dirEnd - 1];
            if (ch === " " || ch === "	")
              dirEnd -= 1;
            else
              break;
          }
          const n2 = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
          yield* this.pushCount(line.length - n2);
          this.pushNewline();
          return "stream";
        }
        if (this.atLineEnd()) {
          const sp = yield* this.pushSpaces(true);
          yield* this.pushCount(line.length - sp);
          yield* this.pushNewline();
          return "stream";
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
      }
      *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
          return this.setNext("line-start");
        if (ch === "-" || ch === ".") {
          if (!this.atEnd && !this.hasChars(4))
            return this.setNext("line-start");
          const s = this.peek(3);
          if ((s === "---" || s === "...") && isEmpty(this.charAt(3))) {
            yield* this.pushCount(3);
            this.indentValue = 0;
            this.indentNext = 0;
            return s === "---" ? "doc" : "stream";
          }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
          this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
      }
      *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
          return this.setNext("block-start");
        if ((ch0 === "-" || ch0 === "?" || ch0 === ":") && isEmpty(ch1)) {
          const n2 = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
          this.indentNext = this.indentValue + 1;
          this.indentValue += n2;
          return yield* this.parseBlockStart();
        }
        return "doc";
      }
      *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
          return this.setNext("doc");
        let n2 = yield* this.pushIndicators();
        switch (line[n2]) {
          case "#":
            yield* this.pushCount(line.length - n2);
          // fallthrough
          case void 0:
            yield* this.pushNewline();
            return yield* this.parseLineStart();
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel = 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            return "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "doc";
          case '"':
          case "'":
            return yield* this.parseQuotedScalar();
          case "|":
          case ">":
            n2 += yield* this.parseBlockScalarHeader();
            n2 += yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - n2);
            yield* this.pushNewline();
            return yield* this.parseBlockScalar();
          default:
            return yield* this.parsePlainScalar();
        }
      }
      *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
          nl = yield* this.pushNewline();
          if (nl > 0) {
            sp = yield* this.pushSpaces(false);
            this.indentValue = indent = sp;
          } else {
            sp = 0;
          }
          sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
          return this.setNext("flow");
        if (indent !== -1 && indent < this.indentNext && line[0] !== "#" || indent === 0 && (line.startsWith("---") || line.startsWith("...")) && isEmpty(line[3])) {
          const atFlowEndMarker = indent === this.indentNext - 1 && this.flowLevel === 1 && (line[0] === "]" || line[0] === "}");
          if (!atFlowEndMarker) {
            this.flowLevel = 0;
            yield cst.FLOW_END;
            return yield* this.parseLineStart();
          }
        }
        let n2 = 0;
        while (line[n2] === ",") {
          n2 += yield* this.pushCount(1);
          n2 += yield* this.pushSpaces(true);
          this.flowKey = false;
        }
        n2 += yield* this.pushIndicators();
        switch (line[n2]) {
          case void 0:
            return "flow";
          case "#":
            yield* this.pushCount(line.length - n2);
            return "flow";
          case "{":
          case "[":
            yield* this.pushCount(1);
            this.flowKey = false;
            this.flowLevel += 1;
            return "flow";
          case "}":
          case "]":
            yield* this.pushCount(1);
            this.flowKey = true;
            this.flowLevel -= 1;
            return this.flowLevel ? "flow" : "doc";
          case "*":
            yield* this.pushUntil(isNotAnchorChar);
            return "flow";
          case '"':
          case "'":
            this.flowKey = true;
            return yield* this.parseQuotedScalar();
          case ":": {
            const next = this.charAt(1);
            if (this.flowKey || isEmpty(next) || next === ",") {
              this.flowKey = false;
              yield* this.pushCount(1);
              yield* this.pushSpaces(true);
              return "flow";
            }
          }
          // fallthrough
          default:
            this.flowKey = false;
            return yield* this.parsePlainScalar();
        }
      }
      *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
          while (end !== -1 && this.buffer[end + 1] === "'")
            end = this.buffer.indexOf("'", end + 2);
        } else {
          while (end !== -1) {
            let n2 = 0;
            while (this.buffer[end - 1 - n2] === "\\")
              n2 += 1;
            if (n2 % 2 === 0)
              break;
            end = this.buffer.indexOf('"', end + 1);
          }
        }
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf("\n", this.pos);
        if (nl !== -1) {
          while (nl !== -1) {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = qb.indexOf("\n", cs);
          }
          if (nl !== -1) {
            end = nl - (qb[nl - 1] === "\r" ? 2 : 1);
          }
        }
        if (end === -1) {
          if (!this.atEnd)
            return this.setNext("quoted-scalar");
          end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? "flow" : "doc";
      }
      *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
          const ch = this.buffer[++i];
          if (ch === "+")
            this.blockScalarKeep = true;
          else if (ch > "0" && ch <= "9")
            this.blockScalarIndent = Number(ch) - 1;
          else if (ch !== "-")
            break;
        }
        return yield* this.pushUntil((ch) => isEmpty(ch) || ch === "#");
      }
      *parseBlockScalar() {
        let nl = this.pos - 1;
        let indent = 0;
        let ch;
        loop: for (let i2 = this.pos; ch = this.buffer[i2]; ++i2) {
          switch (ch) {
            case " ":
              indent += 1;
              break;
            case "\n":
              nl = i2;
              indent = 0;
              break;
            case "\r": {
              const next = this.buffer[i2 + 1];
              if (!next && !this.atEnd)
                return this.setNext("block-scalar");
              if (next === "\n")
                break;
            }
            // fallthrough
            default:
              break loop;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("block-scalar");
        if (indent >= this.indentNext) {
          if (this.blockScalarIndent === -1)
            this.indentNext = indent;
          else {
            this.indentNext = this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
          }
          do {
            const cs = this.continueScalar(nl + 1);
            if (cs === -1)
              break;
            nl = this.buffer.indexOf("\n", cs);
          } while (nl !== -1);
          if (nl === -1) {
            if (!this.atEnd)
              return this.setNext("block-scalar");
            nl = this.buffer.length;
          }
        }
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === " ")
          ch = this.buffer[++i];
        if (ch === "	") {
          while (ch === "	" || ch === " " || ch === "\r" || ch === "\n")
            ch = this.buffer[++i];
          nl = i - 1;
        } else if (!this.blockScalarKeep) {
          do {
            let i2 = nl - 1;
            let ch2 = this.buffer[i2];
            if (ch2 === "\r")
              ch2 = this.buffer[--i2];
            const lastChar = i2;
            while (ch2 === " ")
              ch2 = this.buffer[--i2];
            if (ch2 === "\n" && i2 >= this.pos && i2 + 1 + indent > lastChar)
              nl = i2;
            else
              break;
          } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
      }
      *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while (ch = this.buffer[++i]) {
          if (ch === ":") {
            const next = this.buffer[i + 1];
            if (isEmpty(next) || inFlow && flowIndicatorChars.has(next))
              break;
            end = i;
          } else if (isEmpty(ch)) {
            let next = this.buffer[i + 1];
            if (ch === "\r") {
              if (next === "\n") {
                i += 1;
                ch = "\n";
                next = this.buffer[i + 1];
              } else
                end = i;
            }
            if (next === "#" || inFlow && flowIndicatorChars.has(next))
              break;
            if (ch === "\n") {
              const cs = this.continueScalar(i + 1);
              if (cs === -1)
                break;
              i = Math.max(i, cs - 2);
            }
          } else {
            if (inFlow && flowIndicatorChars.has(ch))
              break;
            end = i;
          }
        }
        if (!ch && !this.atEnd)
          return this.setNext("plain-scalar");
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? "flow" : "doc";
      }
      *pushCount(n2) {
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos += n2;
          return n2;
        }
        return 0;
      }
      *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
          yield s;
          this.pos += s.length;
          return s.length;
        } else if (allowEmpty)
          yield "";
        return 0;
      }
      *pushIndicators() {
        switch (this.charAt(0)) {
          case "!":
            return (yield* this.pushTag()) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "&":
            return (yield* this.pushUntil(isNotAnchorChar)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
          case "-":
          // this is an error
          case "?":
          // this is an error outside flow collections
          case ":": {
            const inFlow = this.flowLevel > 0;
            const ch1 = this.charAt(1);
            if (isEmpty(ch1) || inFlow && flowIndicatorChars.has(ch1)) {
              if (!inFlow)
                this.indentNext = this.indentValue + 1;
              else if (this.flowKey)
                this.flowKey = false;
              return (yield* this.pushCount(1)) + (yield* this.pushSpaces(true)) + (yield* this.pushIndicators());
            }
          }
        }
        return 0;
      }
      *pushTag() {
        if (this.charAt(1) === "<") {
          let i = this.pos + 2;
          let ch = this.buffer[i];
          while (!isEmpty(ch) && ch !== ">")
            ch = this.buffer[++i];
          return yield* this.pushToIndex(ch === ">" ? i + 1 : i, false);
        } else {
          let i = this.pos + 1;
          let ch = this.buffer[i];
          while (ch) {
            if (tagChars.has(ch))
              ch = this.buffer[++i];
            else if (ch === "%" && hexDigits.has(this.buffer[i + 1]) && hexDigits.has(this.buffer[i + 2])) {
              ch = this.buffer[i += 3];
            } else
              break;
          }
          return yield* this.pushToIndex(i, false);
        }
      }
      *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === "\n")
          return yield* this.pushCount(1);
        else if (ch === "\r" && this.charAt(1) === "\n")
          return yield* this.pushCount(2);
        else
          return 0;
      }
      *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
          ch = this.buffer[++i];
        } while (ch === " " || allowTabs && ch === "	");
        const n2 = i - this.pos;
        if (n2 > 0) {
          yield this.buffer.substr(this.pos, n2);
          this.pos = i;
        }
        return n2;
      }
      *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
          ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/yaml/dist/parse/line-counter.js
var require_line_counter = __commonJS({
  "node_modules/yaml/dist/parse/line-counter.js"(exports2) {
    "use strict";
    var LineCounter = class {
      constructor() {
        this.lineStarts = [];
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        this.linePos = (offset) => {
          let low = 0;
          let high = this.lineStarts.length;
          while (low < high) {
            const mid = low + high >> 1;
            if (this.lineStarts[mid] < offset)
              low = mid + 1;
            else
              high = mid;
          }
          if (this.lineStarts[low] === offset)
            return { line: low + 1, col: 1 };
          if (low === 0)
            return { line: 0, col: offset };
          const start = this.lineStarts[low - 1];
          return { line: low, col: offset - start + 1 };
        };
      }
    };
    exports2.LineCounter = LineCounter;
  }
});

// node_modules/yaml/dist/parse/parser.js
var require_parser = __commonJS({
  "node_modules/yaml/dist/parse/parser.js"(exports2) {
    "use strict";
    var node_process = require("process");
    var cst = require_cst();
    var lexer = require_lexer();
    function includesToken(list, type) {
      for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
          return true;
      return false;
    }
    function findNonEmptyIndex(list) {
      for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
          case "space":
          case "comment":
          case "newline":
            break;
          default:
            return i;
        }
      }
      return -1;
    }
    function isFlowToken(token) {
      switch (token?.type) {
        case "alias":
        case "scalar":
        case "single-quoted-scalar":
        case "double-quoted-scalar":
        case "flow-collection":
          return true;
        default:
          return false;
      }
    }
    function getPrevProps(parent) {
      switch (parent.type) {
        case "document":
          return parent.start;
        case "block-map": {
          const it = parent.items[parent.items.length - 1];
          return it.sep ?? it.start;
        }
        case "block-seq":
          return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
          return [];
      }
    }
    function getFirstKeyStartProps(prev) {
      if (prev.length === 0)
        return [];
      let i = prev.length;
      loop: while (--i >= 0) {
        switch (prev[i].type) {
          case "doc-start":
          case "explicit-key-ind":
          case "map-value-ind":
          case "seq-item-ind":
          case "newline":
            break loop;
        }
      }
      while (prev[++i]?.type === "space") {
      }
      return prev.splice(i, prev.length);
    }
    function fixFlowSeqItems(fc) {
      if (fc.start.type === "flow-seq-start") {
        for (const it of fc.items) {
          if (it.sep && !it.value && !includesToken(it.start, "explicit-key-ind") && !includesToken(it.sep, "map-value-ind")) {
            if (it.key)
              it.value = it.key;
            delete it.key;
            if (isFlowToken(it.value)) {
              if (it.value.end)
                Array.prototype.push.apply(it.value.end, it.sep);
              else
                it.value.end = it.sep;
            } else
              Array.prototype.push.apply(it.start, it.sep);
            delete it.sep;
          }
        }
      }
    }
    var Parser = class {
      /**
       * @param onNewLine - If defined, called separately with the start position of
       *   each new line (in `parse()`, including the start of input).
       */
      constructor(onNewLine) {
        this.atNewLine = true;
        this.atScalar = false;
        this.indent = 0;
        this.offset = 0;
        this.onKeyLine = false;
        this.stack = [];
        this.source = "";
        this.type = "";
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
      }
      /**
       * Parse `source` as a YAML stream.
       * If `incomplete`, a part of the last line may be left as a buffer for the next call.
       *
       * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
       *
       * @returns A generator of tokens representing each directive, document, and other structure.
       */
      *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
          this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
          yield* this.next(lexeme);
        if (!incomplete)
          yield* this.end();
      }
      /**
       * Advance the parser by the `source` of one lexical token.
       */
      *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
          console.log("|", cst.prettyToken(source));
        if (this.atScalar) {
          this.atScalar = false;
          yield* this.step();
          this.offset += source.length;
          return;
        }
        const type = cst.tokenType(source);
        if (!type) {
          const message = `Not a YAML token: ${source}`;
          yield* this.pop({ type: "error", offset: this.offset, message, source });
          this.offset += source.length;
        } else if (type === "scalar") {
          this.atNewLine = false;
          this.atScalar = true;
          this.type = "scalar";
        } else {
          this.type = type;
          yield* this.step();
          switch (type) {
            case "newline":
              this.atNewLine = true;
              this.indent = 0;
              if (this.onNewLine)
                this.onNewLine(this.offset + source.length);
              break;
            case "space":
              if (this.atNewLine && source[0] === " ")
                this.indent += source.length;
              break;
            case "explicit-key-ind":
            case "map-value-ind":
            case "seq-item-ind":
              if (this.atNewLine)
                this.indent += source.length;
              break;
            case "doc-mode":
            case "flow-error-end":
              return;
            default:
              this.atNewLine = false;
          }
          this.offset += source.length;
        }
      }
      /** Call at end of input to push out any remaining constructions */
      *end() {
        while (this.stack.length > 0)
          yield* this.pop();
      }
      get sourceToken() {
        const st = {
          type: this.type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
        return st;
      }
      *step() {
        const top = this.peek(1);
        if (this.type === "doc-end" && top?.type !== "doc-end") {
          while (this.stack.length > 0)
            yield* this.pop();
          this.stack.push({
            type: "doc-end",
            offset: this.offset,
            source: this.source
          });
          return;
        }
        if (!top)
          return yield* this.stream();
        switch (top.type) {
          case "document":
            return yield* this.document(top);
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return yield* this.scalar(top);
          case "block-scalar":
            return yield* this.blockScalar(top);
          case "block-map":
            return yield* this.blockMap(top);
          case "block-seq":
            return yield* this.blockSequence(top);
          case "flow-collection":
            return yield* this.flowCollection(top);
          case "doc-end":
            return yield* this.documentEnd(top);
        }
        yield* this.pop();
      }
      peek(n2) {
        return this.stack[this.stack.length - n2];
      }
      *pop(error) {
        const token = error ?? this.stack.pop();
        if (!token) {
          const message = "Tried to pop an empty stack";
          yield { type: "error", offset: this.offset, source: "", message };
        } else if (this.stack.length === 0) {
          yield token;
        } else {
          const top = this.peek(1);
          if (token.type === "block-scalar") {
            token.indent = "indent" in top ? top.indent : 0;
          } else if (token.type === "flow-collection" && top.type === "document") {
            token.indent = 0;
          }
          if (token.type === "flow-collection")
            fixFlowSeqItems(token);
          switch (top.type) {
            case "document":
              top.value = token;
              break;
            case "block-scalar":
              top.props.push(token);
              break;
            case "block-map": {
              const it = top.items[top.items.length - 1];
              if (it.value) {
                top.items.push({ start: [], key: token, sep: [] });
                this.onKeyLine = true;
                return;
              } else if (it.sep) {
                it.value = token;
              } else {
                Object.assign(it, { key: token, sep: [] });
                this.onKeyLine = !it.explicitKey;
                return;
              }
              break;
            }
            case "block-seq": {
              const it = top.items[top.items.length - 1];
              if (it.value)
                top.items.push({ start: [], value: token });
              else
                it.value = token;
              break;
            }
            case "flow-collection": {
              const it = top.items[top.items.length - 1];
              if (!it || it.value)
                top.items.push({ start: [], key: token, sep: [] });
              else if (it.sep)
                it.value = token;
              else
                Object.assign(it, { key: token, sep: [] });
              return;
            }
            /* istanbul ignore next should not happen */
            default:
              yield* this.pop();
              yield* this.pop(token);
          }
          if ((top.type === "document" || top.type === "block-map" || top.type === "block-seq") && (token.type === "block-map" || token.type === "block-seq")) {
            const last = token.items[token.items.length - 1];
            if (last && !last.sep && !last.value && last.start.length > 0 && findNonEmptyIndex(last.start) === -1 && (token.indent === 0 || last.start.every((st) => st.type !== "comment" || st.indent < token.indent))) {
              if (top.type === "document")
                top.end = last.start;
              else
                top.items.push({ start: last.start });
              token.items.splice(-1, 1);
            }
          }
        }
      }
      *stream() {
        switch (this.type) {
          case "directive-line":
            yield { type: "directive", offset: this.offset, source: this.source };
            return;
          case "byte-order-mark":
          case "space":
          case "comment":
          case "newline":
            yield this.sourceToken;
            return;
          case "doc-mode":
          case "doc-start": {
            const doc = {
              type: "document",
              offset: this.offset,
              start: []
            };
            if (this.type === "doc-start")
              doc.start.push(this.sourceToken);
            this.stack.push(doc);
            return;
          }
        }
        yield {
          type: "error",
          offset: this.offset,
          message: `Unexpected ${this.type} token in YAML stream`,
          source: this.source
        };
      }
      *document(doc) {
        if (doc.value)
          return yield* this.lineEnd(doc);
        switch (this.type) {
          case "doc-start": {
            if (findNonEmptyIndex(doc.start) !== -1) {
              yield* this.pop();
              yield* this.step();
            } else
              doc.start.push(this.sourceToken);
            return;
          }
          case "anchor":
          case "tag":
          case "space":
          case "comment":
          case "newline":
            doc.start.push(this.sourceToken);
            return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
          this.stack.push(bv);
        else {
          yield {
            type: "error",
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML document`,
            source: this.source
          };
        }
      }
      *scalar(scalar) {
        if (this.type === "map-value-ind") {
          const prev = getPrevProps(this.peek(2));
          const start = getFirstKeyStartProps(prev);
          let sep;
          if (scalar.end) {
            sep = scalar.end;
            sep.push(this.sourceToken);
            delete scalar.end;
          } else
            sep = [this.sourceToken];
          const map = {
            type: "block-map",
            offset: scalar.offset,
            indent: scalar.indent,
            items: [{ start, key: scalar, sep }]
          };
          this.onKeyLine = true;
          this.stack[this.stack.length - 1] = map;
        } else
          yield* this.lineEnd(scalar);
      }
      *blockScalar(scalar) {
        switch (this.type) {
          case "space":
          case "comment":
          case "newline":
            scalar.props.push(this.sourceToken);
            return;
          case "scalar":
            scalar.source = this.source;
            this.atNewLine = true;
            this.indent = 0;
            if (this.onNewLine) {
              let nl = this.source.indexOf("\n") + 1;
              while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf("\n", nl) + 1;
              }
            }
            yield* this.pop();
            break;
          /* istanbul ignore next should not happen */
          default:
            yield* this.pop();
            yield* this.step();
        }
      }
      *blockMap(map) {
        const it = map.items[map.items.length - 1];
        switch (this.type) {
          case "newline":
            this.onKeyLine = false;
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              it.start.push(this.sourceToken);
            }
            return;
          case "space":
          case "comment":
            if (it.value) {
              map.items.push({ start: [this.sourceToken] });
            } else if (it.sep) {
              it.sep.push(this.sourceToken);
            } else {
              if (this.atIndentedComment(it.start, map.indent)) {
                const prev = map.items[map.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  map.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
        }
        if (this.indent >= map.indent) {
          const atMapIndent = !this.onKeyLine && this.indent === map.indent;
          const atNextItem = atMapIndent && (it.sep || it.explicitKey) && this.type !== "seq-item-ind";
          let start = [];
          if (atNextItem && it.sep && !it.value) {
            const nl = [];
            for (let i = 0; i < it.sep.length; ++i) {
              const st = it.sep[i];
              switch (st.type) {
                case "newline":
                  nl.push(i);
                  break;
                case "space":
                  break;
                case "comment":
                  if (st.indent > map.indent)
                    nl.length = 0;
                  break;
                default:
                  nl.length = 0;
              }
            }
            if (nl.length >= 2)
              start = it.sep.splice(nl[1]);
          }
          switch (this.type) {
            case "anchor":
            case "tag":
              if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start });
                this.onKeyLine = true;
              } else if (it.sep) {
                it.sep.push(this.sourceToken);
              } else {
                it.start.push(this.sourceToken);
              }
              return;
            case "explicit-key-ind":
              if (!it.sep && !it.explicitKey) {
                it.start.push(this.sourceToken);
                it.explicitKey = true;
              } else if (atNextItem || it.value) {
                start.push(this.sourceToken);
                map.items.push({ start, explicitKey: true });
              } else {
                this.stack.push({
                  type: "block-map",
                  offset: this.offset,
                  indent: this.indent,
                  items: [{ start: [this.sourceToken], explicitKey: true }]
                });
              }
              this.onKeyLine = true;
              return;
            case "map-value-ind":
              if (it.explicitKey) {
                if (!it.sep) {
                  if (includesToken(it.start, "newline")) {
                    Object.assign(it, { key: null, sep: [this.sourceToken] });
                  } else {
                    const start2 = getFirstKeyStartProps(it.start);
                    this.stack.push({
                      type: "block-map",
                      offset: this.offset,
                      indent: this.indent,
                      items: [{ start: start2, key: null, sep: [this.sourceToken] }]
                    });
                  }
                } else if (it.value) {
                  map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                  });
                } else if (isFlowToken(it.key) && !includesToken(it.sep, "newline")) {
                  const start2 = getFirstKeyStartProps(it.start);
                  const key = it.key;
                  const sep = it.sep;
                  sep.push(this.sourceToken);
                  delete it.key;
                  delete it.sep;
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: start2, key, sep }]
                  });
                } else if (start.length > 0) {
                  it.sep = it.sep.concat(start, this.sourceToken);
                } else {
                  it.sep.push(this.sourceToken);
                }
              } else {
                if (!it.sep) {
                  Object.assign(it, { key: null, sep: [this.sourceToken] });
                } else if (it.value || atNextItem) {
                  map.items.push({ start, key: null, sep: [this.sourceToken] });
                } else if (includesToken(it.sep, "map-value-ind")) {
                  this.stack.push({
                    type: "block-map",
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [], key: null, sep: [this.sourceToken] }]
                  });
                } else {
                  it.sep.push(this.sourceToken);
                }
              }
              this.onKeyLine = true;
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (atNextItem || it.value) {
                map.items.push({ start, key: fs2, sep: [] });
                this.onKeyLine = true;
              } else if (it.sep) {
                this.stack.push(fs2);
              } else {
                Object.assign(it, { key: fs2, sep: [] });
                this.onKeyLine = true;
              }
              return;
            }
            default: {
              const bv = this.startBlockValue(map);
              if (bv) {
                if (bv.type === "block-seq") {
                  if (!it.explicitKey && it.sep && !includesToken(it.sep, "newline")) {
                    yield* this.pop({
                      type: "error",
                      offset: this.offset,
                      message: "Unexpected block-seq-ind on same line with key",
                      source: this.source
                    });
                    return;
                  }
                } else if (atMapIndent) {
                  map.items.push({ start });
                }
                this.stack.push(bv);
                return;
              }
            }
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
          case "newline":
            if (it.value) {
              const end = "end" in it.value ? it.value.end : void 0;
              const last = Array.isArray(end) ? end[end.length - 1] : void 0;
              if (last?.type === "comment")
                end?.push(this.sourceToken);
              else
                seq.items.push({ start: [this.sourceToken] });
            } else
              it.start.push(this.sourceToken);
            return;
          case "space":
          case "comment":
            if (it.value)
              seq.items.push({ start: [this.sourceToken] });
            else {
              if (this.atIndentedComment(it.start, seq.indent)) {
                const prev = seq.items[seq.items.length - 2];
                const end = prev?.value?.end;
                if (Array.isArray(end)) {
                  Array.prototype.push.apply(end, it.start);
                  end.push(this.sourceToken);
                  seq.items.pop();
                  return;
                }
              }
              it.start.push(this.sourceToken);
            }
            return;
          case "anchor":
          case "tag":
            if (it.value || this.indent <= seq.indent)
              break;
            it.start.push(this.sourceToken);
            return;
          case "seq-item-ind":
            if (this.indent !== seq.indent)
              break;
            if (it.value || includesToken(it.start, "seq-item-ind"))
              seq.items.push({ start: [this.sourceToken] });
            else
              it.start.push(this.sourceToken);
            return;
        }
        if (this.indent > seq.indent) {
          const bv = this.startBlockValue(seq);
          if (bv) {
            this.stack.push(bv);
            return;
          }
        }
        yield* this.pop();
        yield* this.step();
      }
      *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === "flow-error-end") {
          let top;
          do {
            yield* this.pop();
            top = this.peek(1);
          } while (top?.type === "flow-collection");
        } else if (fc.end.length === 0) {
          switch (this.type) {
            case "comma":
            case "explicit-key-ind":
              if (!it || it.sep)
                fc.items.push({ start: [this.sourceToken] });
              else
                it.start.push(this.sourceToken);
              return;
            case "map-value-ind":
              if (!it || it.value)
                fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                Object.assign(it, { key: null, sep: [this.sourceToken] });
              return;
            case "space":
            case "comment":
            case "newline":
            case "anchor":
            case "tag":
              if (!it || it.value)
                fc.items.push({ start: [this.sourceToken] });
              else if (it.sep)
                it.sep.push(this.sourceToken);
              else
                it.start.push(this.sourceToken);
              return;
            case "alias":
            case "scalar":
            case "single-quoted-scalar":
            case "double-quoted-scalar": {
              const fs2 = this.flowScalar(this.type);
              if (!it || it.value)
                fc.items.push({ start: [], key: fs2, sep: [] });
              else if (it.sep)
                this.stack.push(fs2);
              else
                Object.assign(it, { key: fs2, sep: [] });
              return;
            }
            case "flow-map-end":
            case "flow-seq-end":
              fc.end.push(this.sourceToken);
              return;
          }
          const bv = this.startBlockValue(fc);
          if (bv)
            this.stack.push(bv);
          else {
            yield* this.pop();
            yield* this.step();
          }
        } else {
          const parent = this.peek(2);
          if (parent.type === "block-map" && (this.type === "map-value-ind" && parent.indent === fc.indent || this.type === "newline" && !parent.items[parent.items.length - 1].sep)) {
            yield* this.pop();
            yield* this.step();
          } else if (this.type === "map-value-ind" && parent.type !== "flow-collection") {
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            fixFlowSeqItems(fc);
            const sep = fc.end.splice(1, fc.end.length);
            sep.push(this.sourceToken);
            const map = {
              type: "block-map",
              offset: fc.offset,
              indent: fc.indent,
              items: [{ start, key: fc, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
          } else {
            yield* this.lineEnd(fc);
          }
        }
      }
      flowScalar(type) {
        if (this.onNewLine) {
          let nl = this.source.indexOf("\n") + 1;
          while (nl !== 0) {
            this.onNewLine(this.offset + nl);
            nl = this.source.indexOf("\n", nl) + 1;
          }
        }
        return {
          type,
          offset: this.offset,
          indent: this.indent,
          source: this.source
        };
      }
      startBlockValue(parent) {
        switch (this.type) {
          case "alias":
          case "scalar":
          case "single-quoted-scalar":
          case "double-quoted-scalar":
            return this.flowScalar(this.type);
          case "block-scalar-header":
            return {
              type: "block-scalar",
              offset: this.offset,
              indent: this.indent,
              props: [this.sourceToken],
              source: ""
            };
          case "flow-map-start":
          case "flow-seq-start":
            return {
              type: "flow-collection",
              offset: this.offset,
              indent: this.indent,
              start: this.sourceToken,
              items: [],
              end: []
            };
          case "seq-item-ind":
            return {
              type: "block-seq",
              offset: this.offset,
              indent: this.indent,
              items: [{ start: [this.sourceToken] }]
            };
          case "explicit-key-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            start.push(this.sourceToken);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, explicitKey: true }]
            };
          }
          case "map-value-ind": {
            this.onKeyLine = true;
            const prev = getPrevProps(parent);
            const start = getFirstKeyStartProps(prev);
            return {
              type: "block-map",
              offset: this.offset,
              indent: this.indent,
              items: [{ start, key: null, sep: [this.sourceToken] }]
            };
          }
        }
        return null;
      }
      atIndentedComment(start, indent) {
        if (this.type !== "comment")
          return false;
        if (this.indent <= indent)
          return false;
        return start.every((st) => st.type === "newline" || st.type === "space");
      }
      *documentEnd(docEnd) {
        if (this.type !== "doc-mode") {
          if (docEnd.end)
            docEnd.end.push(this.sourceToken);
          else
            docEnd.end = [this.sourceToken];
          if (this.type === "newline")
            yield* this.pop();
        }
      }
      *lineEnd(token) {
        switch (this.type) {
          case "comma":
          case "doc-start":
          case "doc-end":
          case "flow-seq-end":
          case "flow-map-end":
          case "map-value-ind":
            yield* this.pop();
            yield* this.step();
            break;
          case "newline":
            this.onKeyLine = false;
          // fallthrough
          case "space":
          case "comment":
          default:
            if (token.end)
              token.end.push(this.sourceToken);
            else
              token.end = [this.sourceToken];
            if (this.type === "newline")
              yield* this.pop();
        }
      }
    };
    exports2.Parser = Parser;
  }
});

// node_modules/yaml/dist/public-api.js
var require_public_api = __commonJS({
  "node_modules/yaml/dist/public-api.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var errors = require_errors2();
    var log = require_log();
    var identity = require_identity();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    function parseOptions(options) {
      const prettyErrors = options.prettyErrors !== false;
      const lineCounter$1 = options.lineCounter || prettyErrors && new lineCounter.LineCounter() || null;
      return { lineCounter: lineCounter$1, prettyErrors };
    }
    function parseAllDocuments(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      const docs = Array.from(composer$1.compose(parser$1.parse(source)));
      if (prettyErrors && lineCounter2)
        for (const doc of docs) {
          doc.errors.forEach(errors.prettifyError(source, lineCounter2));
          doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
        }
      if (docs.length > 0)
        return docs;
      return Object.assign([], { empty: true }, composer$1.streamInfo());
    }
    function parseDocument(source, options = {}) {
      const { lineCounter: lineCounter2, prettyErrors } = parseOptions(options);
      const parser$1 = new parser.Parser(lineCounter2?.addNewLine);
      const composer$1 = new composer.Composer(options);
      let doc = null;
      for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
          doc = _doc;
        else if (doc.options.logLevel !== "silent") {
          doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), "MULTIPLE_DOCS", "Source contains multiple documents; please use YAML.parseAllDocuments()"));
          break;
        }
      }
      if (prettyErrors && lineCounter2) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter2));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter2));
      }
      return doc;
    }
    function parse4(src, reviver, options) {
      let _reviver = void 0;
      if (typeof reviver === "function") {
        _reviver = reviver;
      } else if (options === void 0 && reviver && typeof reviver === "object") {
        options = reviver;
      }
      const doc = parseDocument(src, options);
      if (!doc)
        return null;
      doc.warnings.forEach((warning) => log.warn(doc.options.logLevel, warning));
      if (doc.errors.length > 0) {
        if (doc.options.logLevel !== "silent")
          throw doc.errors[0];
        else
          doc.errors = [];
      }
      return doc.toJS(Object.assign({ reviver: _reviver }, options));
    }
    function stringify(value, replacer, options) {
      let _replacer = null;
      if (typeof replacer === "function" || Array.isArray(replacer)) {
        _replacer = replacer;
      } else if (options === void 0 && replacer) {
        options = replacer;
      }
      if (typeof options === "string")
        options = options.length;
      if (typeof options === "number") {
        const indent = Math.round(options);
        options = indent < 1 ? void 0 : indent > 8 ? { indent: 8 } : { indent };
      }
      if (value === void 0) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
          return void 0;
      }
      if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
      return new Document.Document(value, _replacer, options).toString(options);
    }
    exports2.parse = parse4;
    exports2.parseAllDocuments = parseAllDocuments;
    exports2.parseDocument = parseDocument;
    exports2.stringify = stringify;
  }
});

// node_modules/yaml/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/yaml/dist/index.js"(exports2) {
    "use strict";
    var composer = require_composer();
    var Document = require_Document();
    var Schema = require_Schema();
    var errors = require_errors2();
    var Alias = require_Alias();
    var identity = require_identity();
    var Pair = require_Pair();
    var Scalar = require_Scalar();
    var YAMLMap = require_YAMLMap();
    var YAMLSeq = require_YAMLSeq();
    var cst = require_cst();
    var lexer = require_lexer();
    var lineCounter = require_line_counter();
    var parser = require_parser();
    var publicApi = require_public_api();
    var visit = require_visit();
    exports2.Composer = composer.Composer;
    exports2.Document = Document.Document;
    exports2.Schema = Schema.Schema;
    exports2.YAMLError = errors.YAMLError;
    exports2.YAMLParseError = errors.YAMLParseError;
    exports2.YAMLWarning = errors.YAMLWarning;
    exports2.Alias = Alias.Alias;
    exports2.isAlias = identity.isAlias;
    exports2.isCollection = identity.isCollection;
    exports2.isDocument = identity.isDocument;
    exports2.isMap = identity.isMap;
    exports2.isNode = identity.isNode;
    exports2.isPair = identity.isPair;
    exports2.isScalar = identity.isScalar;
    exports2.isSeq = identity.isSeq;
    exports2.Pair = Pair.Pair;
    exports2.Scalar = Scalar.Scalar;
    exports2.YAMLMap = YAMLMap.YAMLMap;
    exports2.YAMLSeq = YAMLSeq.YAMLSeq;
    exports2.CST = cst;
    exports2.Lexer = lexer.Lexer;
    exports2.LineCounter = lineCounter.LineCounter;
    exports2.Parser = parser.Parser;
    exports2.parse = publicApi.parse;
    exports2.parseAllDocuments = publicApi.parseAllDocuments;
    exports2.parseDocument = publicApi.parseDocument;
    exports2.stringify = publicApi.stringify;
    exports2.visit = visit.visit;
    exports2.visitAsync = visit.visitAsync;
  }
});

// dist/server/transport/tcp.js
var tcp_exports = {};
__export(tcp_exports, {
  TCPServerTransport: () => TCPServerTransport
});
var import_net, TCPServerTransport;
var init_tcp = __esm({
  "dist/server/transport/tcp.js"() {
    "use strict";
    import_net = require("net");
    TCPServerTransport = class {
      port;
      server;
      socket = null;
      _onclose;
      _onerror;
      _onmessage;
      constructor(port = 3e3) {
        this.port = port;
        this.server = new import_net.Server((socket) => {
          console.log("Client connected");
          this.socket = socket;
          let buffer = "";
          socket.on("data", (data) => {
            buffer += data.toString();
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim()) {
                try {
                  const message = JSON.parse(line);
                  this._onmessage?.(message);
                } catch (error) {
                  console.error("Failed to parse message:", error);
                  this._onerror?.(error);
                }
              }
            }
          });
          socket.on("error", (err) => {
            console.error("Socket error:", err);
            this._onerror?.(err);
          });
          socket.on("close", () => {
            console.log("Client disconnected");
            this._onclose?.();
          });
        });
      }
      async start() {
        return new Promise((resolve) => {
          this.server.listen(this.port, () => {
            console.log(`TCP Server listening on port ${this.port}`);
            resolve();
          });
        });
      }
      async close() {
        return new Promise((resolve, reject) => {
          this.server.close((err) => {
            if (err)
              reject(err);
            else
              resolve();
          });
        });
      }
      async send(message) {
        if (!this.socket) {
          throw new Error("No client connected");
        }
        this.socket.write(JSON.stringify(message) + "\n");
      }
      set onclose(handler) {
        this._onclose = handler;
      }
      set onerror(handler) {
        this._onerror = handler;
      }
      set onmessage(handler) {
        this._onmessage = handler;
      }
    };
  }
});

// dist/server/transport/unix.js
var unix_exports = {};
__export(unix_exports, {
  UnixServerTransport: () => UnixServerTransport
});
var import_net2, import_fs4, UnixServerTransport;
var init_unix = __esm({
  "dist/server/transport/unix.js"() {
    "use strict";
    import_net2 = require("net");
    import_fs4 = __toESM(require("fs"), 1);
    UnixServerTransport = class {
      path;
      server;
      socket = null;
      _onclose;
      _onerror;
      _onmessage;
      constructor(path) {
        this.path = path;
        this.server = new import_net2.Server((socket) => {
          console.log("Client connected to socket");
          this.socket = socket;
          let buffer = "";
          socket.on("data", (data) => {
            buffer += data.toString();
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim()) {
                try {
                  const message = JSON.parse(line);
                  this._onmessage?.(message);
                } catch (error) {
                  console.error("Failed to parse message:", error);
                  this._onerror?.(error);
                }
              }
            }
          });
          socket.on("error", (err) => {
            console.error("Socket error:", err);
            this._onerror?.(err);
          });
          socket.on("close", () => {
            console.log("Client disconnected");
            this._onclose?.();
          });
        });
      }
      async start() {
        if (process.platform !== "win32" && import_fs4.default.existsSync(this.path)) {
          import_fs4.default.unlinkSync(this.path);
        }
        return new Promise((resolve) => {
          this.server.listen(this.path, () => {
            console.log(`Unix Server listening on ${this.path}`);
            resolve();
          });
        });
      }
      async close() {
        return new Promise((resolve, reject) => {
          this.server.close((err) => {
            if (err)
              reject(err);
            else
              resolve();
          });
        });
      }
      async send(message) {
        if (!this.socket) {
          throw new Error("No client connected");
        }
        this.socket.write(JSON.stringify(message) + "\n");
      }
      set onclose(handler) {
        this._onclose = handler;
      }
      set onerror(handler) {
        this._onerror = handler;
      }
      set onmessage(handler) {
        this._onmessage = handler;
      }
    };
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    var BINARY_TYPES = ["nodebuffer", "arraybuffer", "fragments"];
    var hasBlob = typeof Blob !== "undefined";
    if (hasBlob) BINARY_TYPES.push("blob");
    module2.exports = {
      BINARY_TYPES,
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      hasBlob,
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: () => {
      }
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    function toBuffer(data) {
      toBuffer.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer.readOnly = false;
      }
      return buf;
    }
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class {
      /**
       * Creates a new `Limiter`.
       *
       * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
       *     to run concurrently
       */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
       * Adds a job to the queue.
       *
       * @param {Function} job The job to run
       * @public
       */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
       * Removes a job from the queue and runs it if possible.
       *
       * @private
       */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib2 = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([0, 0, 255, 255]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class {
      /**
       * Creates a PerMessageDeflate instance.
       *
       * @param {Object} [options] Configuration options
       * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
       *     for, or request, a custom client window size
       * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
       *     acknowledge disabling of client context takeover
       * @param {Number} [options.concurrencyLimit=10] The number of concurrent
       *     calls to zlib
       * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
       *     use of a custom server window size
       * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
       *     disabling of server context takeover
       * @param {Number} [options.threshold=1024] Size (in bytes) below which
       *     messages should not be compressed if context takeover is disabled
       * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
       *     deflate
       * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
       *     inflate
       * @param {Boolean} [isServer=false] Create the instance in either server or
       *     client mode
       * @param {Number} [maxPayload=0] The maximum allowed message length
       */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
       * @type {String}
       */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
       * Create an extension negotiation offer.
       *
       * @return {Object} Extension parameters
       * @public
       */
      offer() {
        const params = {};
        if (this._options.serverNoContextTakeover) {
          params.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params.client_max_window_bits = true;
        }
        return params;
      }
      /**
       * Accept an extension negotiation offer/response.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Object} Accepted configuration
       * @public
       */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
       * Releases all resources used by the extension.
       *
       * @public
       */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(
              new Error(
                "The deflate stream was closed while data was being processed"
              )
            );
          }
        }
      }
      /**
       *  Accept an extension negotiation offer.
       *
       * @param {Array} offers The extension negotiation offers
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params) => {
          if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
       * Accept the extension negotiation response.
       *
       * @param {Array} response The extension negotiation response
       * @return {Object} Accepted configuration
       * @private
       */
      acceptAsClient(response) {
        const params = response[0];
        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error(
            'Unexpected or invalid parameter "client_max_window_bits"'
          );
        }
        return params;
      }
      /**
       * Normalize parameters.
       *
       * @param {Array} configurations The extension negotiation offers/reponse
       * @return {Array} The offers/response with normalized parameters
       * @private
       */
      normalizeParams(configurations) {
        configurations.forEach((params) => {
          Object.keys(params).forEach((key) => {
            let value = params[key];
            if (value.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value = value[0];
            if (key === "client_max_window_bits") {
              if (value !== true) {
                const num = +value;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(
                    `Invalid value for parameter "${key}": ${value}`
                  );
                }
                value = num;
              } else if (!this._isServer) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else if (key === "server_max_window_bits") {
              const num = +value;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
              value = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value !== true) {
                throw new TypeError(
                  `Invalid value for parameter "${key}": ${value}`
                );
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params[key] = value;
          });
        });
        return configurations;
      }
      /**
       * Decompress data. Concurrency limited.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Compress data. Concurrency limited.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @public
       */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result) => {
            done();
            callback(err, result);
          });
        });
      }
      /**
       * Decompress data.
       *
       * @param {Buffer} data Compressed data
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib2.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(
            this._inflate[kBuffers],
            this._inflate[kTotalLength]
          );
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
       * Compress data.
       *
       * @param {(Buffer|String)} data Data to compress
       * @param {Boolean} fin Specifies whether or not this is the last fragment
       * @param {Function} callback Callback
       * @private
       */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib2.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib2.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib2.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(
            this._deflate[kBuffers],
            this._deflate[kTotalLength]
          );
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      if (this[kError]) {
        this[kCallback](this[kError]);
        return;
      }
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
  }
});

// node_modules/ws/lib/validation.js
var require_validation2 = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var { hasBlob } = require_constants();
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 0 - 15
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      // 16 - 31
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      // 32 - 47
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      // 48 - 63
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 64 - 79
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      // 80 - 95
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      // 96 - 111
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    function isBlob(value) {
      return hasBlob && typeof value === "object" && typeof value.arrayBuffer === "function" && typeof value.type === "string" && typeof value.stream === "function" && (value[Symbol.toStringTag] === "Blob" || value[Symbol.toStringTag] === "File");
    }
    module2.exports = {
      isBlob,
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      kStatusCode,
      kWebSocket
    } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation2();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class extends Writable {
      /**
       * Creates a Receiver instance.
       *
       * @param {Object} [options] Options object
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {String} [options.binaryType=nodebuffer] The type for binary data
       * @param {Object} [options.extensions] An object containing the negotiated
       *     extensions
       * @param {Boolean} [options.isServer=false] Specifies whether to operate in
       *     client or server mode
       * @param {Number} [options.maxPayload=0] The maximum allowed message length
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
       * Implements `Writable.prototype._write()`.
       *
       * @param {Buffer} chunk The chunk of data to write
       * @param {String} encoding The character encoding of `chunk`
       * @param {Function} cb Callback
       * @private
       */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
       * Consumes `n` bytes from the buffered data.
       *
       * @param {Number} n The number of bytes to consume
       * @return {Buffer} The consumed bytes
       * @private
       */
      consume(n2) {
        this._bufferedBytes -= n2;
        if (n2 === this._buffers[0].length) return this._buffers.shift();
        if (n2 < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(
            buf.buffer,
            buf.byteOffset + n2,
            buf.length - n2
          );
          return new FastBuffer(buf.buffer, buf.byteOffset, n2);
        }
        const dst = Buffer.allocUnsafe(n2);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n2;
          if (n2 >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n2), offset);
            this._buffers[0] = new FastBuffer(
              buf.buffer,
              buf.byteOffset + n2,
              buf.length - n2
            );
          }
          n2 -= buf.length;
        } while (n2 > 0);
        return dst;
      }
      /**
       * Starts the parsing loop.
       *
       * @param {Function} cb Callback
       * @private
       */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
       * Reads the first two bytes of a frame.
       *
       * @param {Function} cb Callback
       * @private
       */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(
            RangeError,
            "RSV2 and RSV3 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_2_3"
          );
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(
            RangeError,
            "RSV1 must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_RSV_1"
          );
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(
              RangeError,
              "invalid opcode 0",
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(
              RangeError,
              `invalid opcode ${this._opcode}`,
              true,
              1002,
              "WS_ERR_INVALID_OPCODE"
            );
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(
              RangeError,
              "FIN must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_FIN"
            );
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(
              RangeError,
              "RSV1 must be clear",
              true,
              1002,
              "WS_ERR_UNEXPECTED_RSV_1"
            );
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(
              RangeError,
              `invalid payload length ${this._payloadLength}`,
              true,
              1002,
              "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH"
            );
            cb(error);
            return;
          }
        } else {
          const error = this.createError(
            RangeError,
            `invalid opcode ${this._opcode}`,
            true,
            1002,
            "WS_ERR_INVALID_OPCODE"
          );
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(
              RangeError,
              "MASK must be set",
              true,
              1002,
              "WS_ERR_EXPECTED_MASK"
            );
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(
            RangeError,
            "MASK must be clear",
            true,
            1002,
            "WS_ERR_UNEXPECTED_MASK"
          );
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+16).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
       * Gets extended payload length (7+64).
       *
       * @param {Function} cb Callback
       * @private
       */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(
            RangeError,
            "Unsupported WebSocket frame: payload length > 2^53 - 1",
            false,
            1009,
            "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH"
          );
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
       * Payload length has been read.
       *
       * @param {Function} cb Callback
       * @private
       */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(
              RangeError,
              "Max payload size exceeded",
              false,
              1009,
              "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
            );
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
       * Reads mask bytes.
       *
       * @private
       */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
       * Reads data bytes.
       *
       * @param {Function} cb Callback
       * @private
       */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
       * Decompresses data.
       *
       * @param {Buffer} data Compressed data
       * @param {Function} cb Callback
       * @private
       */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(
                RangeError,
                "Max payload size exceeded",
                false,
                1009,
                "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH"
              );
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
       * Handles a data message.
       *
       * @param {Function} cb Callback
       * @private
       */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else if (this._binaryType === "blob") {
            data = new Blob(fragments);
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(
              Error,
              "invalid UTF-8 sequence",
              true,
              1007,
              "WS_ERR_INVALID_UTF8"
            );
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
       * Handles a control message.
       *
       * @param {Buffer} data Data to handle
       * @return {(Error|RangeError|undefined)} A possible error
       * @private
       */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(
                RangeError,
                `invalid status code ${code}`,
                true,
                1002,
                "WS_ERR_INVALID_CLOSE_CODE"
              );
              cb(error);
              return;
            }
            const buf = new FastBuffer(
              data.buffer,
              data.byteOffset + 2,
              data.length - 2
            );
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(
                Error,
                "invalid UTF-8 sequence",
                true,
                1007,
                "WS_ERR_INVALID_UTF8"
              );
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
       * Builds an error object.
       *
       * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
       * @param {String} message The error message
       * @param {Boolean} prefix Specifies whether or not to add a default prefix to
       *     `message`
       * @param {Number} statusCode The status code
       * @param {String} errorCode The exposed error code
       * @return {(Error|RangeError)} The error
       * @private
       */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(
          prefix ? `Invalid WebSocket frame: ${message}` : message
        );
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync: randomFillSync2 } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER, kWebSocket, NOOP } = require_constants();
    var { isBlob, isValidStatusCode } = require_validation2();
    var { mask: applyMask, toBuffer } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var DEFAULT = 0;
    var DEFLATING = 1;
    var GET_BLOB_DATA = 2;
    var Sender2 = class _Sender {
      /**
       * Creates a Sender instance.
       *
       * @param {Duplex} socket The connection socket
       * @param {Object} [extensions] An object containing the negotiated extensions
       * @param {Function} [generateMask] The function used to generate the masking
       *     key
       */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._queue = [];
        this._state = DEFAULT;
        this.onerror = NOOP;
        this[kWebSocket] = void 0;
      }
      /**
       * Frames a piece of data according to the HyBi WebSocket protocol.
       *
       * @param {(Buffer|String)} data The data to frame
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @return {(Buffer|String)[]} The framed data
       * @public
       */
      static frame(data, options) {
        let mask;
        let merge2 = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync2(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge2 = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge2 ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [target, data];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [target, data];
        if (merge2) {
          applyMask(data, mask, target, offset, dataLength);
          return [target];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [target, data];
      }
      /**
       * Sends a close message to the other peer.
       *
       * @param {Number} [code] The status code component of the body
       * @param {(String|Buffer)} [data] The message component of the body
       * @param {Boolean} [mask=false] Specifies whether or not to mask the message
       * @param {Function} [cb] Callback
       * @public
       */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, buf, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(buf, options), cb);
        }
      }
      /**
       * Sends a ping message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      ping(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a pong message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback
       * @public
       */
      pong(data, mask, cb) {
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (byteLength > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, false, options, cb]);
          } else {
            this.getBlobData(data, false, options, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, false, options, cb]);
        } else {
          this.sendFrame(_Sender.frame(data, options), cb);
        }
      }
      /**
       * Sends a data message to the other peer.
       *
       * @param {*} data The message to send
       * @param {Object} options Options object
       * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
       *     or text
       * @param {Boolean} [options.compress=false] Specifies whether or not to
       *     compress `data`
       * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Function} [cb] Callback
       * @public
       */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength;
        let readOnly;
        if (typeof data === "string") {
          byteLength = Buffer.byteLength(data);
          readOnly = false;
        } else if (isBlob(data)) {
          byteLength = data.size;
          readOnly = false;
        } else {
          data = toBuffer(data);
          byteLength = data.length;
          readOnly = toBuffer.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        const opts = {
          [kByteLength]: byteLength,
          fin: options.fin,
          generateMask: this._generateMask,
          mask: options.mask,
          maskBuffer: this._maskBuffer,
          opcode,
          readOnly,
          rsv1
        };
        if (isBlob(data)) {
          if (this._state !== DEFAULT) {
            this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
          } else {
            this.getBlobData(data, this._compress, opts, cb);
          }
        } else if (this._state !== DEFAULT) {
          this.enqueue([this.dispatch, data, this._compress, opts, cb]);
        } else {
          this.dispatch(data, this._compress, opts, cb);
        }
      }
      /**
       * Gets the contents of a blob as binary data.
       *
       * @param {Blob} blob The blob
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     the data
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      getBlobData(blob, compress, options, cb) {
        this._bufferedBytes += options[kByteLength];
        this._state = GET_BLOB_DATA;
        blob.arrayBuffer().then((arrayBuffer) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while the blob was being read"
            );
            process.nextTick(callCallbacks, this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          const data = toBuffer(arrayBuffer);
          if (!compress) {
            this._state = DEFAULT;
            this.sendFrame(_Sender.frame(data, options), cb);
            this.dequeue();
          } else {
            this.dispatch(data, compress, options, cb);
          }
        }).catch((err) => {
          process.nextTick(onError, this, err, cb);
        });
      }
      /**
       * Dispatches a message.
       *
       * @param {(Buffer|String)} data The message to send
       * @param {Boolean} [compress=false] Specifies whether or not to compress
       *     `data`
       * @param {Object} options Options object
       * @param {Boolean} [options.fin=false] Specifies whether or not to set the
       *     FIN bit
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Boolean} [options.mask=false] Specifies whether or not to mask
       *     `data`
       * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
       *     key
       * @param {Number} options.opcode The opcode
       * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
       *     modified
       * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
       *     RSV1 bit
       * @param {Function} [cb] Callback
       * @private
       */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(_Sender.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._state = DEFLATING;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error(
              "The socket was closed while data was being compressed"
            );
            callCallbacks(this, err, cb);
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._state = DEFAULT;
          options.readOnly = false;
          this.sendFrame(_Sender.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
       * Executes queued send operations.
       *
       * @private
       */
      dequeue() {
        while (this._state === DEFAULT && this._queue.length) {
          const params = this._queue.shift();
          this._bufferedBytes -= params[3][kByteLength];
          Reflect.apply(params[0], this, params.slice(1));
        }
      }
      /**
       * Enqueues a send operation.
       *
       * @param {Array} params Send operation parameters.
       * @private
       */
      enqueue(params) {
        this._bufferedBytes += params[3][kByteLength];
        this._queue.push(params);
      }
      /**
       * Sends a frame.
       *
       * @param {(Buffer | String)[]} list The frame to send
       * @param {Function} [cb] Callback
       * @private
       */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
    function callCallbacks(sender, err, cb) {
      if (typeof cb === "function") cb(err);
      for (let i = 0; i < sender._queue.length; i++) {
        const params = sender._queue[i];
        const callback = params[params.length - 1];
        if (typeof callback === "function") callback(err);
      }
    }
    function onError(sender, err, cb) {
      callCallbacks(sender, err, cb);
      sender.onerror(err);
    }
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class {
      /**
       * Create a new `Event`.
       *
       * @param {String} type The name of the event
       * @throws {TypeError} If the `type` argument is not specified
       */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
       * @type {*}
       */
      get target() {
        return this[kTarget];
      }
      /**
       * @type {String}
       */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", { enumerable: true });
    Object.defineProperty(Event.prototype, "type", { enumerable: true });
    var CloseEvent = class extends Event {
      /**
       * Create a new `CloseEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {Number} [options.code=0] The status code explaining why the
       *     connection was closed
       * @param {String} [options.reason=''] A human-readable string explaining why
       *     the connection was closed
       * @param {Boolean} [options.wasClean=false] Indicates whether or not the
       *     connection was cleanly closed
       */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
       * @type {Number}
       */
      get code() {
        return this[kCode];
      }
      /**
       * @type {String}
       */
      get reason() {
        return this[kReason];
      }
      /**
       * @type {Boolean}
       */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "reason", { enumerable: true });
    Object.defineProperty(CloseEvent.prototype, "wasClean", { enumerable: true });
    var ErrorEvent = class extends Event {
      /**
       * Create a new `ErrorEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.error=null] The error that generated this event
       * @param {String} [options.message=''] The error message
       */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
       * @type {*}
       */
      get error() {
        return this[kError];
      }
      /**
       * @type {String}
       */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", { enumerable: true });
    Object.defineProperty(ErrorEvent.prototype, "message", { enumerable: true });
    var MessageEvent = class extends Event {
      /**
       * Create a new `MessageEvent`.
       *
       * @param {String} type The name of the event
       * @param {Object} [options] A dictionary object that allows for setting
       *     attributes via object members of the same name
       * @param {*} [options.data=null] The message content
       */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
       * @type {*}
       */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", { enumerable: true });
    var EventTarget = {
      /**
       * Register an event listener.
       *
       * @param {String} type A string representing the event type to listen for
       * @param {(Function|Object)} handler The listener to add
       * @param {Object} [options] An options object specifies characteristics about
       *     the event listener
       * @param {Boolean} [options.once=false] A `Boolean` indicating that the
       *     listener should be invoked at most once after being added. If `true`,
       *     the listener would be automatically removed when invoked.
       * @public
       */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = function onMessage(data, isBinary) {
            const event = new MessageEvent("message", {
              data: isBinary ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "close") {
          wrapper = function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "error") {
          wrapper = function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else if (type === "open") {
          wrapper = function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          };
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
       * Remove an event listener.
       *
       * @param {String} type A string representing the event type to remove
       * @param {(Function|Object)} handler The listener to remove
       * @public
       */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [elem];
      else dest[name].push(elem);
    }
    function parse4(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params);
              params = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value = header.slice(start, end);
            if (mustUnescape) {
              value = value.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params, paramName, value);
            if (code === 44) {
              push(offers, extensionName, params);
              params = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token, params);
      } else {
        if (paramName === void 0) {
          push(params, token, true);
        } else if (mustUnescape) {
          push(params, paramName, token.replace(/\\/g, ""));
        } else {
          push(params, paramName, token);
        }
        push(offers, extensionName, params);
      }
      return offers;
    }
    function format(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [configurations];
        return configurations.map((params) => {
          return [extension].concat(
            Object.keys(params).map((k) => {
              let values = params[k];
              if (!Array.isArray(values)) values = [values];
              return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
            })
          ).join("; ");
        }).join(", ");
      }).join(", ");
    }
    module2.exports = { format, parse: parse4 };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL2 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { isBlob } = require_validation2();
    var {
      BINARY_TYPES,
      EMPTY_BUFFER,
      GUID,
      kForOnEventAttribute,
      kListener,
      kStatusCode,
      kWebSocket,
      NOOP
    } = require_constants();
    var {
      EventTarget: { addEventListener, removeEventListener }
    } = require_event_target();
    var { format, parse: parse4 } = require_extension();
    var { toBuffer } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [8, 13];
    var readyStates = ["CONNECTING", "OPEN", "CLOSING", "CLOSED"];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class _WebSocket extends EventEmitter {
      /**
       * Create a new `WebSocket`.
       *
       * @param {(String|URL)} address The URL to which to connect
       * @param {(String|String[])} [protocols] The subprotocols
       * @param {Object} [options] Connection options
       */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._errorEmitted = false;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = _WebSocket.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [protocols];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
       * For historical reasons, the custom "nodebuffer" type is used by the default
       * instead of "blob".
       *
       * @type {String}
       */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
       * @type {Number}
       */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
       * @type {String}
       */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
       * @type {Boolean}
       */
      get isPaused() {
        return this._paused;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
       * @type {Function}
       */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
       * @type {String}
       */
      get protocol() {
        return this._protocol;
      }
      /**
       * @type {Number}
       */
      get readyState() {
        return this._readyState;
      }
      /**
       * @type {String}
       */
      get url() {
        return this._url;
      }
      /**
       * Set up the socket and the internal resources.
       *
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Object} options Options object
       * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Function} [options.generateMask] The function used to generate the
       *     masking key
       * @param {Number} [options.maxPayload=0] The maximum allowed message size
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @private
       */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        const sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._sender = sender;
        this._socket = socket;
        receiver[kWebSocket] = this;
        sender[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        sender.onerror = senderOnError;
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = _WebSocket.OPEN;
        this.emit("open");
      }
      /**
       * Emit the `'close'` event.
       *
       * @private
       */
      emitClose() {
        if (!this._socket) {
          this._readyState = _WebSocket.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = _WebSocket.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
       * Start a closing handshake.
       *
       *          +----------+   +-----------+   +----------+
       *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
       *    |     +----------+   +-----------+   +----------+     |
       *          +----------+   +-----------+         |
       * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
       *          +----------+   +-----------+   |
       *    |           |                        |   +---+        |
       *                +------------------------+-->|fin| - - - -
       *    |         +---+                      |   +---+
       *     - - - - -|fin|<---------------------+
       *              +---+
       *
       * @param {Number} [code] Status code explaining why the connection is closing
       * @param {(String|Buffer)} [data] The reason why the connection is
       *     closing
       * @public
       */
      close(code, data) {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === _WebSocket.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = _WebSocket.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        setCloseTimer(this);
      }
      /**
       * Pause the socket.
       *
       * @public
       */
      pause() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
       * Send a ping.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the ping is sent
       * @public
       */
      ping(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Send a pong.
       *
       * @param {*} [data] The data to send
       * @param {Boolean} [mask] Indicates whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when the pong is sent
       * @public
       */
      pong(data, mask, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
       * Resume the socket.
       *
       * @public
       */
      resume() {
        if (this.readyState === _WebSocket.CONNECTING || this.readyState === _WebSocket.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
       * Send a data message.
       *
       * @param {*} data The message to send
       * @param {Object} [options] Options object
       * @param {Boolean} [options.binary] Specifies whether `data` is binary or
       *     text
       * @param {Boolean} [options.compress] Specifies whether or not to compress
       *     `data`
       * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
       *     last one
       * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
       * @param {Function} [cb] Callback which is executed when data is written out
       * @public
       */
      send(data, options, cb) {
        if (this.readyState === _WebSocket.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== _WebSocket.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
       * Forcibly close the connection.
       *
       * @public
       */
      terminate() {
        if (this.readyState === _WebSocket.CLOSED) return;
        if (this.readyState === _WebSocket.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = _WebSocket.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, { enumerable: true });
    });
    ["open", "error", "close", "message"].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener;
    WebSocket2.prototype.removeEventListener = removeEventListener;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(
          `Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`
        );
      }
      let parsedUrl;
      if (address instanceof URL2) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL2(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https:", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(
          opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
          false,
          opts.maxPayload
        );
        opts.headers["Sec-WebSocket-Extensions"] = format({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol of protocols) {
          if (typeof protocol !== "string" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
            throw new SyntaxError(
              "An invalid or duplicated subprotocol was specified"
            );
          }
          protocolSet.add(protocol);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts = opts.path.split(":");
        opts.socketPath = parts[0];
        opts.path = parts[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = { ...options, headers: {} };
          if (headers) {
            for (const [key2, value] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location = res.headers.location;
        const statusCode = res.statusCode;
        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL2(location, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(
            websocket,
            req,
            `Unexpected server response: ${res.statusCode}`
          );
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse4(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket._errorEmitted = true;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = isBlob(data) ? data.size : toBuffer(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(
          `WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`
        );
        process.nextTick(cb, err);
      }
    }
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    function receiverOnMessage(data, isBinary) {
      this[kWebSocket].emit("message", data, isBinary);
    }
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    function resume(stream) {
      stream.resume();
    }
    function senderOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket.readyState === WebSocket2.CLOSED) return;
      if (websocket.readyState === WebSocket2.OPEN) {
        websocket._readyState = WebSocket2.CLOSING;
        setCloseTimer(websocket);
      }
      this._socket.end();
      if (!websocket._errorEmitted) {
        websocket._errorEmitted = true;
        websocket.emit("error", err);
      }
    }
    function setCloseTimer(websocket) {
      websocket._closeTimer = setTimeout(
        websocket._socket.destroy.bind(websocket._socket),
        closeTimeout
      );
    }
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
  }
});

// node_modules/ws/lib/stream.js
var require_stream = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var WebSocket2 = require_websocket();
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", function message(msg, isBinary) {
        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      });
      ws.once("error", function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      });
      ws.once("close", function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      });
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", function error(err2) {
          called = true;
          callback(err2);
        });
        ws.once("close", function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        });
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._final(callback);
          });
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", function finish() {
            callback();
          });
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", function open() {
            duplex._write(chunk, encoding, callback);
          });
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation2();
    function parse4(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol2 = header.slice(start, end);
          if (protocols.has(protocol2)) {
            throw new SyntaxError(`The "${protocol2}" subprotocol is duplicated`);
          }
          protocols.add(protocol2);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol = header.slice(start, i);
      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }
      protocols.add(protocol);
      return protocols;
    }
    module2.exports = { parse: parse4 };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class extends EventEmitter {
      /**
       * Create a `WebSocketServer` instance.
       *
       * @param {Object} options Configuration options
       * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
       *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
       *     multiple times in the same tick
       * @param {Boolean} [options.autoPong=true] Specifies whether or not to
       *     automatically send a pong in response to a ping
       * @param {Number} [options.backlog=511] The maximum length of the queue of
       *     pending connections
       * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
       *     track clients
       * @param {Function} [options.handleProtocols] A hook to handle protocols
       * @param {String} [options.host] The hostname where to bind the server
       * @param {Number} [options.maxPayload=104857600] The maximum allowed message
       *     size
       * @param {Boolean} [options.noServer=false] Enable no server mode
       * @param {String} [options.path] Accept only connections matching this path
       * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
       *     permessage-deflate
       * @param {Number} [options.port] The port where to bind the server
       * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
       *     server to use
       * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
       *     not to skip UTF-8 validation for text and close messages
       * @param {Function} [options.verifyClient] A hook to reject connections
       * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
       *     class to use. It must be the `WebSocket` class or class that extends it
       * @param {Function} [callback] A listener for the `listening` event
       */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          // use default (511 as implemented in net.js)
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError(
            'One and only one of the "port", "server", or "noServer" options must be specified'
          );
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(
            options.port,
            options.host,
            options.backlog,
            callback
          );
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: (req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
       * Returns the bound address, the address family name, and port of the server
       * as reported by the operating system if listening on an IP socket.
       * If the server is listening on a pipe or UNIX domain socket, the name is
       * returned as a string.
       *
       * @return {(Object|String|null)} The address of the server
       * @public
       */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
       * Stop the server from accepting new connections and emit the `'close'` event
       * when all existing connections are closed.
       *
       * @param {Function} [cb] A one-time listener for the `'close'` event
       * @public
       */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
       * See if a given request should be handled by this server instance.
       *
       * @param {http.IncomingMessage} req Request object to inspect
       * @return {Boolean} `true` if the request is valid, else `false`
       * @public
       */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
       * Handle a HTTP Upgrade request.
       *
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @public
       */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version2 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version2 !== 13 && version2 !== 8) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {
            "Sec-WebSocket-Version": "13, 8"
          });
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(
            this.options.perMessageDeflate,
            true,
            this.options.maxPayload
          );
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(
                extensions,
                key,
                protocols,
                req,
                socket,
                head,
                cb
              );
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
       * Upgrade the connection to WebSocket.
       *
       * @param {Object} extensions The accepted extensions
       * @param {String} key The value of the `Sec-WebSocket-Key` header
       * @param {Set} protocols The subprotocols
       * @param {http.IncomingMessage} req The request object
       * @param {Duplex} socket The network socket between the server and client
       * @param {Buffer} head The first packet of the upgraded stream
       * @param {Function} cb Callback
       * @throws {Error} If called more than once with the same socket
       * @private
       */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error(
            "server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration"
          );
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
            ws._protocol = protocol;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params = extensions[PerMessageDeflate.extensionName].params;
          const value = extension.format({
            [PerMessageDeflate.extensionName]: [params]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      };
    }
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    function socketOnError() {
      this.destroy();
    }
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(
        `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message
      );
    }
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message, headers);
      }
    }
  }
});

// node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server;
var init_wrapper = __esm({
  "node_modules/ws/wrapper.mjs"() {
    import_stream = __toESM(require_stream(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
  }
});

// dist/server/transport/websocket.js
var websocket_exports = {};
__export(websocket_exports, {
  WebSocketServerTransport: () => WebSocketServerTransport
});
var WebSocketServerTransport;
var init_websocket = __esm({
  "dist/server/transport/websocket.js"() {
    "use strict";
    init_wrapper();
    WebSocketServerTransport = class {
      wss;
      clients = /* @__PURE__ */ new Set();
      onclose;
      onerror;
      onmessage;
      constructor(port = 3001) {
        this.wss = new import_websocket_server.default({ port });
        this.wss.on("connection", (ws) => {
          console.error(`[WebSocket] Client connected (total: ${this.clients.size + 1})`);
          this.clients.add(ws);
          ws.on("message", (data) => {
            try {
              const message = JSON.parse(data.toString());
              this.onmessage?.(message);
            } catch (e) {
              this.onerror?.(e);
            }
          });
          ws.on("close", () => {
            this.clients.delete(ws);
            console.error(`[WebSocket] Client disconnected (total: ${this.clients.size})`);
          });
          ws.on("error", (error) => {
            this.onerror?.(error);
          });
        });
        this.wss.on("error", (error) => {
          this.onerror?.(error);
        });
        console.error(`[WebSocket] Server listening on port ${port}`);
      }
      async send(message) {
        const data = JSON.stringify(message);
        const promises = [];
        for (const client of this.clients) {
          if (client.readyState === import_websocket.default.OPEN) {
            promises.push(new Promise((resolve, reject) => {
              client.send(data, (error) => {
                if (error)
                  reject(error);
                else
                  resolve();
              });
            }));
          }
        }
        await Promise.all(promises);
      }
      async start() {
        return Promise.resolve();
      }
      async close() {
        for (const client of this.clients) {
          client.close();
        }
        this.clients.clear();
        return new Promise((resolve, reject) => {
          this.wss.close((error) => {
            if (error)
              reject(error);
            else {
              this.onclose?.();
              resolve();
            }
          });
        });
      }
      // Broadcast to all connected clients (useful for notifications)
      broadcast(message) {
        const data = JSON.stringify(message);
        for (const client of this.clients) {
          if (client.readyState === import_websocket.default.OPEN) {
            client.send(data);
          }
        }
      }
    };
  }
});

// node_modules/zod/v4/core/core.js
var NEVER2 = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object3, key, getter) {
  const set = false;
  Object.defineProperty(object3, key, {
    get() {
      if (!set) {
        const value = getter();
        object3[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a;
    (_a = iss).path ?? (_a.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error2) => {
    for (const issue2 of error2.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error);
  return fieldErrors;
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var parse = /* @__PURE__ */ _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a = inst._zod).onattach ?? (_a.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a;
    (_a = inst2._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a;
  $ZodCheck.init(inst, def);
  (_a = inst._zod.def).when ?? (_a.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a = inst._zod).check ?? (_a.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a = inst._zod).deferred ?? (_a.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted2) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted2)
              isAborted2 = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted2)
            isAborted2 = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url = new URL(orig);
      const href = url.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT2(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues2(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta2 = _meta[0];
    this._map.set(schema, meta2);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      if (this._idmap.has(meta2.id)) {
        throw new Error(`ID ${meta2.id} already exists in the registry`);
      }
      this._idmap.set(meta2.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta2 = this._map.get(schema);
    if (meta2 && typeof meta2 === "object" && "id" in meta2) {
      this._idmap.delete(meta2.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}

// node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = params?.metadata ?? globalRegistry;
    this.target = params?.target ?? "draft-2020-12";
    this.unrepresentable = params?.unrepresentable ?? "throw";
    this.override = params?.override ?? (() => {
    });
    this.io = params?.io ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = schema._zod.toJSONSchema?.();
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json = _json;
            json.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minLength = minimum;
            if (typeof maximum === "number")
              json.maxLength = maximum;
            if (format) {
              json.format = formatMap[format] ?? format;
              if (json.format === "")
                delete json.format;
            }
            if (contentEncoding)
              json.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json.type = "integer";
            else
              json.type = "number";
            if (typeof exclusiveMinimum === "number")
              json.exclusiveMinimum = exclusiveMinimum;
            if (typeof minimum === "number") {
              json.minimum = minimum;
              if (typeof exclusiveMinimum === "number") {
                if (exclusiveMinimum >= minimum)
                  delete json.minimum;
                else
                  delete json.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number")
              json.exclusiveMaximum = exclusiveMaximum;
            if (typeof maximum === "number") {
              json.maximum = maximum;
              if (typeof exclusiveMaximum === "number") {
                if (exclusiveMaximum <= maximum)
                  delete json.maximum;
                else
                  delete json.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            json.type = "array";
            json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json = _json;
            json.type = "object";
            json.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json.required = Array.from(requiredKeys);
            }
            if (def.catchall?._zod.def.type === "never") {
              json.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json.additionalProperties = false;
            } else if (def.catchall) {
              json.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json = _json;
            json.anyOf = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, "anyOf", i]
            }));
            break;
          }
          case "intersection": {
            const json = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json.allOf = allOf;
            break;
          }
          case "tuple": {
            const json = _json;
            json.type = "array";
            const prefixItems = def.items.map((x, i) => this.process(x, { ...params, path: [...params.path, "prefixItems", i] }));
            if (this.target === "draft-2020-12") {
              json.prefixItems = prefixItems;
            } else {
              json.items = prefixItems;
            }
            if (def.rest) {
              const rest = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
              if (this.target === "draft-2020-12") {
                json.items = rest;
              } else {
                json.additionalItems = rest;
              }
            }
            if (def.rest) {
              json.items = this.process(def.rest, {
                ...params,
                path: [...params.path, "items"]
              });
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json.minItems = minimum;
            if (typeof maximum === "number")
              json.maxItems = maximum;
            break;
          }
          case "record": {
            const json = _json;
            json.type = "object";
            json.propertyNames = this.process(def.keyType, { ...params, path: [...params.path, "propertyNames"] });
            json.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json.type = "number";
            if (values.every((v) => typeof v === "string"))
              json.type = "string";
            json.enum = values;
            break;
          }
          case "literal": {
            const json = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json.type = val === null ? "null" : typeof val;
              json.const = val;
            } else {
              if (vals.every((v) => typeof v === "number"))
                json.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json.type = "string";
              if (vals.every((v) => v === null))
                json.type = "null";
              json.enum = vals;
            }
            break;
          }
          case "file": {
            const json = _json;
            const file = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file.minLength = minimum;
            if (maximum !== void 0)
              file.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file.contentMediaType = mime[0];
                Object.assign(json, file);
              } else {
                json.anyOf = mime.map((m) => {
                  const mFile = { ...file, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json, file);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            _json.anyOf = [inner, { type: "null" }];
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json = _json;
            json.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json.type = "string";
            json.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta2 = this.metadataRegistry.get(schema);
    if (meta2)
      Object.assign(result.schema, meta2);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a = result.schema).default ?? (_a.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    const params = {
      cycles: _params?.cycles ?? "ref",
      reused: _params?.reused ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: _params?.external ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = params.external.registry.get(entry[0])?.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = params.external.registry.get(entry[0])?.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = this.metadataRegistry.get(entry[0])?.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && params2.target === "draft-7") {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if (params.external?.uri) {
      const id = params.external.registry.get(schema)?.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = params.external?.defs ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params?.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const schema = _schema;
  const def = schema._zod.def;
  switch (def.type) {
    case "string":
    case "number":
    case "bigint":
    case "boolean":
    case "date":
    case "symbol":
    case "undefined":
    case "null":
    case "any":
    case "unknown":
    case "never":
    case "void":
    case "literal":
    case "enum":
    case "nan":
    case "file":
    case "template_literal":
      return false;
    case "array": {
      return isTransforming(def.element, ctx);
    }
    case "object": {
      for (const key in def.shape) {
        if (isTransforming(def.shape[key], ctx))
          return true;
      }
      return false;
    }
    case "union": {
      for (const option of def.options) {
        if (isTransforming(option, ctx))
          return true;
      }
      return false;
    }
    case "intersection": {
      return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
    }
    case "tuple": {
      for (const item of def.items) {
        if (isTransforming(item, ctx))
          return true;
      }
      if (def.rest && isTransforming(def.rest, ctx))
        return true;
      return false;
    }
    case "record": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "map": {
      return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
    }
    case "set": {
      return isTransforming(def.valueType, ctx);
    }
    // inner types
    case "promise":
    case "optional":
    case "nonoptional":
    case "nullable":
    case "readonly":
      return isTransforming(def.innerType, ctx);
    case "lazy":
      return isTransforming(def.getter(), ctx);
    case "default": {
      return isTransforming(def.innerType, ctx);
    }
    case "prefault": {
      return isTransforming(def.innerType, ctx);
    }
    case "custom": {
      return false;
    }
    case "transform": {
      return true;
    }
    case "pipe": {
      return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
    }
    case "success": {
      return false;
    }
    case "catch": {
      return false;
    }
    default:
      def;
  }
  throw new Error(`Unknown schema type: ${def.type}`);
}

// node_modules/zod/v4/mini/schemas.js
var ZodMiniType = /* @__PURE__ */ $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
});
var ZodMiniObject = /* @__PURE__ */ $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodMiniObject(def);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function objectFromShape(shape) {
  const values = Object.values(shape);
  if (values.length === 0)
    return object({});
  const allV4 = values.every(isZ4Schema);
  const allV3 = values.every((s) => !isZ4Schema(s));
  if (allV4)
    return object(shape);
  if (allV3)
    return objectType(shape);
  throw new Error("Mixed Zod versions detected in object shape.");
}
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
async function safeParseAsync2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = await safeParseAsync(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = await v3Schema.safeParseAsync(data);
  return result;
}
function getObjectShape(schema) {
  var _a, _b;
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = (_b = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def) === null || _b === void 0 ? void 0 : _b.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch (_c) {
      return void 0;
    }
  }
  return rawShape;
}
function normalizeObjectSchema(schema) {
  var _a;
  if (!schema)
    return void 0;
  if (typeof schema === "object") {
    const asV3 = schema;
    const asV4 = schema;
    if (!asV3._def && !asV4._zod) {
      const values = Object.values(schema);
      if (values.length > 0 && values.every((v) => typeof v === "object" && v !== null && (v._def !== void 0 || v._zod !== void 0 || typeof v.parse === "function"))) {
        return objectFromShape(schema);
      }
    }
  }
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def;
    if (def && (def.typeName === "object" || def.shape !== void 0)) {
      return schema;
    }
  } else {
    const v3Schema = schema;
    if (v3Schema.shape !== void 0) {
      return schema;
    }
  }
  return void 0;
}
function getParseErrorMessage(error) {
  if (error && typeof error === "object") {
    if ("message" in error && typeof error.message === "string") {
      return error.message;
    }
    if ("issues" in error && Array.isArray(error.issues) && error.issues.length > 0) {
      const firstIssue = error.issues[0];
      if (firstIssue && typeof firstIssue === "object" && "message" in firstIssue) {
        return String(firstIssue.message);
      }
    }
    try {
      return JSON.stringify(error);
    } catch (_a) {
      return String(error);
    }
  }
  return String(error);
}
function getSchemaDescription(schema) {
  var _a, _b, _c, _d;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    return (_b = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def) === null || _b === void 0 ? void 0 : _b.description;
  }
  const v3Schema = schema;
  return (_c = schema.description) !== null && _c !== void 0 ? _c : (_d = v3Schema._def) === null || _d === void 0 ? void 0 : _d.description;
}
function isSchemaOptional(schema) {
  var _a, _b, _c;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    return ((_b = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def) === null || _b === void 0 ? void 0 : _b.typeName) === "ZodOptional";
  }
  const v3Schema = schema;
  if (typeof schema.isOptional === "function") {
    return schema.isOptional();
  }
  return ((_c = v3Schema._def) === null || _c === void 0 ? void 0 : _c.typeName) === "ZodOptional";
}
function getLiteralValue(schema) {
  var _a;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = (_a = v4Schema._zod) === null || _a === void 0 ? void 0 : _a.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}

// node_modules/zod/v4/classic/iso.js
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError2 = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync3 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta2) => {
    reg.add(inst, meta2);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse3(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync3(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType2.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType2.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType2.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType2.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType2.init(inst, def);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType2.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType2.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType2.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType2.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType2.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType2.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType2.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType2.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType2.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType2.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType2.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType2.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom2(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-06-18";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-03-26", "2024-11-05", "2024-10-07"];
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom2((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union([string2(), number2().int()]);
var CursorSchema = string2();
var RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional()
});
var BaseRequestParamsSchema = looseObject({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.optional()
});
var NotificationsParamsSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.optional()
});
var ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var RequestIdSchema = union([string2(), number2().int()]);
var JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
var JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
var JSONRPCResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResponse = (value) => JSONRPCResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: optional(unknown())
  })
}).strict();
var isJSONRPCError = (value) => JSONRPCErrorSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([JSONRPCRequestSchema, JSONRPCNotificationSchema, JSONRPCResponseSchema, JSONRPCErrorSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema,
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional()
});
var IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
});
var BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional()
});
var FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown()));
var ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional()));
var ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: optional(object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: optional(boolean2())
  })),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized")
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping")
});
var ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
});
var ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: optional(CursorSchema)
});
var ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
});
var Base64Schema = string2().refine((val) => {
  try {
    atob(val);
    return true;
  } catch (_a) {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed")
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
});
var PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: object2({}).passthrough(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(object2({}).passthrough())
}).passthrough();
var EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
var ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object2({
  role: _enum(["user", "assistant"]),
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: optional(string2()),
  messages: array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed")
});
var ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
});
var ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: optional(ToolAnnotationsSchema),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: optional(boolean2())
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: optional(record(string2(), unknown()))
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed")
});
var LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
});
var ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: optional(array(ModelHintSchema)),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: optional(number2().min(0).max(1)),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: optional(number2().min(0).max(1)),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: optional(number2().min(0).max(1))
});
var ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: optional(_enum(["auto", "required", "none"]))
});
var ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).passthrough().optional(),
  isError: optional(boolean2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(object2({}).passthrough())
}).passthrough();
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object2({
  role: _enum(["user", "assistant"]),
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(object2({}).passthrough())
}).passthrough();
var CreateMessageRequestParamsSchema = BaseRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: optional(array(ToolSchema)),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: optional(ToolChoiceSchema)
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: _enum(["user", "assistant"]),
  /**
   * Response content. May be ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
});
var StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
});
var NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
});
var TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
});
var LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
});
var SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
});
var MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
});
var ElicitRequestURLParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
});
var ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   */
  content: record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional()
});
var ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
function assertCompleteRequestPrompt(request) {
  if (request.params.ref.type !== "ref/prompt") {
    throw new TypeError(`Expected CompleteRequestPrompt, but got ${request.params.ref.type}`);
  }
  void request;
}
function assertCompleteRequestResourceTemplate(request) {
  if (request.params.ref.type !== "ref/resource") {
    throw new TypeError(`Expected CompleteRequestResourceTemplate, but got ${request.params.ref.type}`);
  }
  void request;
}
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
});
var RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list")
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed")
});
var ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema
]);
var ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema
]);
var ClientResultSchema = union([EmptyResultSchema, CreateMessageResultSchema, ElicitResultSchema, ListRootsResultSchema]);
var ServerRequestSchema = union([PingRequestSchema, CreateMessageRequestSchema, ElicitRequestSchema, ListRootsRequestSchema]);
var ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema
]);
var McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    var _a, _b;
    return (_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.elicitations) !== null && _b !== void 0 ? _b : [];
  }
};

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  target: "jsonSchema7",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  markdownDescription: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref",
  openAiAnyTypeName: "OpenAiAnyType"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// node_modules/zod-to-json-schema/dist/esm/Refs.js
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    flags: { hasReferencedOpenAiAnyType: false },
    currentPath,
    propertyPath: void 0,
    seen: new Map(Object.entries(_options.definitions).map(([name, def]) => [
      def._def,
      {
        def: def._def,
        path: [..._options.basePath, _options.definitionPath, name],
        // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
        jsonSchema: void 0
      }
    ]))
  };
};

// node_modules/zod-to-json-schema/dist/esm/errorMessages.js
function addErrorMessage(res, key, errorMessage, refs) {
  if (!refs?.errorMessages)
    return;
  if (errorMessage) {
    res.errorMessage = {
      ...res.errorMessage,
      [key]: errorMessage
    };
  }
}
function setResponseValueAndErrors(res, key, value, errorMessage, refs) {
  res[key] = value;
  addErrorMessage(res, key, errorMessage, refs);
}

// node_modules/zod-to-json-schema/dist/esm/getRelativePath.js
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i])
      break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// node_modules/zod-to-json-schema/dist/esm/parsers/any.js
function parseAnyDef(refs) {
  if (refs.target !== "openAi") {
    return {};
  }
  const anyDefinitionPath = [
    ...refs.basePath,
    refs.definitionPath,
    refs.openAiAnyTypeName
  ];
  refs.flags.hasReferencedOpenAiAnyType = true;
  return {
    $ref: refs.$refStrategy === "relative" ? getRelativePath(anyDefinitionPath, refs.currentPath) : anyDefinitionPath.join("/")
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/array.js
function parseArrayDef(def, refs) {
  const res = {
    type: "array"
  };
  if (def.type?._def && def.type?._def?.typeName !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    setResponseValueAndErrors(res, "minItems", def.minLength.value, def.minLength.message, refs);
  }
  if (def.maxLength) {
    setResponseValueAndErrors(res, "maxItems", def.maxLength.value, def.maxLength.message, refs);
  }
  if (def.exactLength) {
    setResponseValueAndErrors(res, "minItems", def.exactLength.value, def.exactLength.message, refs);
    setResponseValueAndErrors(res, "maxItems", def.exactLength.value, def.exactLength.message, refs);
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/bigint.js
function parseBigintDef(def, refs) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/boolean.js
function parseBooleanDef() {
  return {
    type: "boolean"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/branded.js
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/catch.js
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/date.js
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy ?? refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def, refs);
  }
}
var integerDateParser = (def, refs) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  if (refs.target === "openApi3") {
    return res;
  }
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "min":
        setResponseValueAndErrors(
          res,
          "minimum",
          check2.value,
          // This is in milliseconds
          check2.message,
          refs
        );
        break;
      case "max":
        setResponseValueAndErrors(
          res,
          "maximum",
          check2.value,
          // This is in milliseconds
          check2.message,
          refs
        );
        break;
    }
  }
  return res;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/default.js
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/effects.js
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/enum.js
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string")
    return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  let unevaluatedProperties = refs.target === "jsonSchema2019-09" ? { unevaluatedProperties: false } : void 0;
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
      if (schema.unevaluatedProperties === void 0) {
        unevaluatedProperties = void 0;
      }
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      } else {
        unevaluatedProperties = void 0;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? {
    allOf: mergedAllOf,
    ...unevaluatedProperties
  } : void 0;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/literal.js
function parseLiteralDef(def, refs) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  if (refs.target === "openApi3") {
    return {
      type: parsedType === "bigint" ? "integer" : parsedType,
      enum: [def.value]
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var emojiRegex2 = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex2 === void 0) {
      emojiRegex2 = RegExp("^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", "u");
    }
    return emojiRegex2;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check2 of def.checks) {
      switch (check2.kind) {
        case "min":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "max":
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check2.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check2.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check2.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check2.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check2.message, refs);
          break;
        case "regex":
          addPattern(res, check2.regex, check2.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check2.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check2.message, refs);
          break;
        case "startsWith":
          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check2.value, refs)}`), check2.message, refs);
          break;
        case "endsWith":
          addPattern(res, RegExp(`${escapeLiteralCheckValue(check2.value, refs)}$`), check2.message, refs);
          break;
        case "datetime":
          addFormat(res, "date-time", check2.message, refs);
          break;
        case "date":
          addFormat(res, "date", check2.message, refs);
          break;
        case "time":
          addFormat(res, "time", check2.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check2.message, refs);
          break;
        case "length":
          setResponseValueAndErrors(res, "minLength", typeof res.minLength === "number" ? Math.max(res.minLength, check2.value) : check2.value, check2.message, refs);
          setResponseValueAndErrors(res, "maxLength", typeof res.maxLength === "number" ? Math.min(res.maxLength, check2.value) : check2.value, check2.message, refs);
          break;
        case "includes": {
          addPattern(res, RegExp(escapeLiteralCheckValue(check2.value, refs)), check2.message, refs);
          break;
        }
        case "ip": {
          if (check2.version !== "v6") {
            addFormat(res, "ipv4", check2.message, refs);
          }
          if (check2.version !== "v4") {
            addFormat(res, "ipv6", check2.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check2.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check2.message, refs);
          break;
        case "cidr": {
          if (check2.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check2.message, refs);
          }
          if (check2.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check2.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check2.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check2.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check2.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              setResponseValueAndErrors(res, "contentEncoding", "base64", check2.message, refs);
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check2.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check2.message, refs);
        }
        case "toLowerCase":
        case "toUpperCase":
        case "trim":
          break;
        default:
          /* @__PURE__ */ ((_) => {
          })(check2);
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal2, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal2) : literal2;
}
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  if (schema.format || schema.anyOf?.some((x) => x.format)) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { format: schema.errorMessage.format }
        }
      });
      delete schema.format;
      if (schema.errorMessage) {
        delete schema.errorMessage.format;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "format", value, message, refs);
  }
}
function addPattern(schema, regex, message, refs) {
  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern,
        ...schema.errorMessage && refs.errorMessages && {
          errorMessage: { pattern: schema.errorMessage.pattern }
        }
      });
      delete schema.pattern;
      if (schema.errorMessage) {
        delete schema.errorMessage.pattern;
        if (Object.keys(schema.errorMessage).length === 0) {
          delete schema.errorMessage;
        }
      }
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    setResponseValueAndErrors(schema, "pattern", stringifyRegExpWithFlags(regex, refs), message, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    m: regex.flags.includes("m"),
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && source[i + 2]?.match(/[a-z]/)) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch {
    console.warn(`Could not convert regex pattern at ${refs.currentPath.join("/")} to a flag-independent form! Falling back to the flag-ignorant source`);
    return regex.source;
  }
  return pattern;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/record.js
function parseRecordDef(def, refs) {
  if (refs.target === "openAi") {
    console.warn("Warning: OpenAI may not support records in schemas! Try an array of key-value pairs instead.");
  }
  if (refs.target === "openApi3" && def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      type: "object",
      required: def.keyType._def.values,
      properties: def.keyType._def.values.reduce((acc, key) => ({
        ...acc,
        [key]: parseDef(def.valueType._def, {
          ...refs,
          currentPath: [...refs.currentPath, "properties", key]
        }) ?? parseAnyDef(refs)
      }), {}),
      additionalProperties: refs.rejectedAdditionalProperties
    };
  }
  const schema = {
    type: "object",
    additionalProperties: parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    }) ?? refs.allowedAdditionalProperties
  };
  if (refs.target === "openApi3") {
    return schema;
  }
  if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.checks?.length) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (def.keyType?._def.typeName === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && def.keyType._def.type._def.checks?.length) {
    const { type, ...keyType } = parseBrandedDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/map.js
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef(refs);
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef(refs);
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/nativeEnum.js
function parseNativeEnumDef(def) {
  const object3 = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object3[object3[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object3[key]);
  const parsedTypes = Array.from(new Set(actualValues.map((values) => typeof values)));
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/never.js
function parseNeverDef(refs) {
  return refs.target === "openAi" ? void 0 : {
    not: parseAnyDef({
      ...refs,
      currentPath: [...refs.currentPath, "not"]
    })
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/null.js
function parseNullDef(refs) {
  return refs.target === "openApi3" ? {
    enum: ["null"],
    nullable: true
  } : {
    type: "null"
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/union.js
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  if (refs.target === "openApi3")
    return asAnyOf(def, refs);
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every((x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce((acc, x) => {
      const type = typeof x._def.value;
      switch (type) {
        case "string":
        case "number":
        case "boolean":
          return [...acc, type];
        case "bigint":
          return [...acc, "integer"];
        case "object":
          if (x._def.value === null)
            return [...acc, "null"];
        case "symbol":
        case "undefined":
        case "function":
        default:
          return acc;
      }
    }, []);
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce((acc, x) => {
          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
        }, [])
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce((acc, x) => [
        ...acc,
        ...x._def.values.filter((x2) => !acc.includes(x2))
      ], [])
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", `${i}`]
  })).filter((x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0));
  return anyOf.length ? { anyOf } : void 0;
};

// node_modules/zod-to-json-schema/dist/esm/parsers/nullable.js
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(def.innerType._def.typeName) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    if (refs.target === "openApi3") {
      return {
        type: primitiveMappings[def.innerType._def.typeName],
        nullable: true
      };
    }
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  if (refs.target === "openApi3") {
    const base2 = parseDef(def.innerType._def, {
      ...refs,
      currentPath: [...refs.currentPath]
    });
    if (base2 && "$ref" in base2)
      return { allOf: [base2], nullable: true };
    return base2 && { ...base2, nullable: true };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/number.js
function parseNumberDef(def, refs) {
  const res = {
    type: "number"
  };
  if (!def.checks)
    return res;
  for (const check2 of def.checks) {
    switch (check2.kind) {
      case "int":
        res.type = "integer";
        addErrorMessage(res, "type", check2.message, refs);
        break;
      case "min":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMinimum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMinimum = true;
          }
          setResponseValueAndErrors(res, "minimum", check2.value, check2.message, refs);
        }
        break;
      case "max":
        if (refs.target === "jsonSchema7") {
          if (check2.inclusive) {
            setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
          } else {
            setResponseValueAndErrors(res, "exclusiveMaximum", check2.value, check2.message, refs);
          }
        } else {
          if (!check2.inclusive) {
            res.exclusiveMaximum = true;
          }
          setResponseValueAndErrors(res, "maximum", check2.value, check2.message, refs);
        }
        break;
      case "multipleOf":
        setResponseValueAndErrors(res, "multipleOf", check2.value, check2.message, refs);
        break;
    }
  }
  return res;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/object.js
function parseObjectDef(def, refs) {
  const forceOptionalIntoNullable = refs.target === "openAi";
  const result = {
    type: "object",
    properties: {}
  };
  const required2 = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    let propOptional = safeIsOptional(propDef);
    if (propOptional && forceOptionalIntoNullable) {
      if (propDef._def.typeName === "ZodOptional") {
        propDef = propDef._def.innerType;
      }
      if (!propDef.isNullable()) {
        propDef = propDef.nullable();
      }
      propOptional = false;
    }
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required2.push(propName);
    }
  }
  if (required2.length) {
    result.required = required2;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch {
    return true;
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/optional.js
var parseOptionalDef = (def, refs) => {
  if (refs.currentPath.toString() === refs.propertyPath?.toString()) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? {
    anyOf: [
      {
        not: parseAnyDef(refs)
      },
      innerSchema
    ]
  } : parseAnyDef(refs);
};

// node_modules/zod-to-json-schema/dist/esm/parsers/pipeline.js
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// node_modules/zod-to-json-schema/dist/esm/parsers/promise.js
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/set.js
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    setResponseValueAndErrors(schema, "minItems", def.minSize.value, def.minSize.message, refs);
  }
  if (def.maxSize) {
    setResponseValueAndErrors(schema, "maxItems", def.maxSize.value, def.maxSize.message, refs);
  }
  return schema;
}

// node_modules/zod-to-json-schema/dist/esm/parsers/tuple.js
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], []),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map((x, i) => parseDef(x._def, {
        ...refs,
        currentPath: [...refs.currentPath, "items", `${i}`]
      })).reduce((acc, x) => x === void 0 ? acc : [...acc, x], [])
    };
  }
}

// node_modules/zod-to-json-schema/dist/esm/parsers/undefined.js
function parseUndefinedDef(refs) {
  return {
    not: parseAnyDef(refs)
  };
}

// node_modules/zod-to-json-schema/dist/esm/parsers/unknown.js
function parseUnknownDef(refs) {
  return parseAnyDef(refs);
}

// node_modules/zod-to-json-schema/dist/esm/parsers/readonly.js
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// node_modules/zod-to-json-schema/dist/esm/selectParser.js
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def, refs);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef(refs);
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef(refs);
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def, refs);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef(refs);
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef(refs);
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef(refs);
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)(typeName);
  }
};

// node_modules/zod-to-json-schema/dist/esm/parseDef.js
function parseDef(def, refs, forceResolution = false) {
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema) {
    addMeta(def, refs, jsonSchema);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema, def, refs);
    newItem.jsonSchema = jsonSchema;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema;
  return jsonSchema;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(`Recursive reference detected at ${refs.currentPath.join("/")}! Defaulting to any`);
        return parseAnyDef(refs);
      }
      return refs.$refStrategy === "seen" ? parseAnyDef(refs) : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema) => {
  if (def.description) {
    jsonSchema.description = def.description;
    if (refs.markdownDescription) {
      jsonSchema.markdownDescription = def.description;
    }
  }
  return jsonSchema;
};

// node_modules/zod-to-json-schema/dist/esm/zodToJsonSchema.js
var zodToJsonSchema = (schema, options) => {
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce((acc, [name2, schema2]) => ({
    ...acc,
    [name2]: parseDef(schema2._def, {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name2]
    }, true) ?? parseAnyDef(refs)
  }), {}) : void 0;
  const name = typeof options === "string" ? options : options?.nameStrategy === "title" ? void 0 : options?.name;
  const main2 = parseDef(schema._def, name === void 0 ? refs : {
    ...refs,
    currentPath: [...refs.basePath, refs.definitionPath, name]
  }, false) ?? parseAnyDef(refs);
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main2.title = title;
  }
  if (refs.flags.hasReferencedOpenAiAnyType) {
    if (!definitions) {
      definitions = {};
    }
    if (!definitions[refs.openAiAnyTypeName]) {
      definitions[refs.openAiAnyTypeName] = {
        // Skipping "object" as no properties can be defined and additionalProperties must be "false"
        type: ["string", "number", "integer", "boolean", "array", "null"],
        items: {
          $ref: refs.$refStrategy === "relative" ? "1" : [
            ...refs.basePath,
            refs.definitionPath,
            refs.openAiAnyTypeName
          ].join("/")
        }
      };
    }
  }
  const combined = name === void 0 ? definitions ? {
    ...main2,
    [refs.definitionPath]: definitions
  } : main2 : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main2
    }
  };
  if (refs.target === "jsonSchema7") {
    combined.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (refs.target === "jsonSchema2019-09" || refs.target === "openAi") {
    combined.$schema = "https://json-schema.org/draft/2019-09/schema#";
  }
  if (refs.target === "openAi" && ("anyOf" in combined || "oneOf" in combined || "allOf" in combined || "type" in combined && Array.isArray(combined.type))) {
    console.warn("Warning: OpenAI may not support schemas with unions as roots! Try wrapping it in an object property.");
  }
  return combined;
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function mapMiniTarget(t) {
  if (!t)
    return "draft-7";
  if (t === "jsonSchema7" || t === "draft-7")
    return "draft-7";
  if (t === "jsonSchema2019-09" || t === "draft-2020-12")
    return "draft-2020-12";
  return "draft-7";
}
function toJsonSchemaCompat(schema, opts) {
  var _a, _b, _c;
  if (isZ4Schema(schema)) {
    return toJSONSchema(schema, {
      target: mapMiniTarget(opts === null || opts === void 0 ? void 0 : opts.target),
      io: (_a = opts === null || opts === void 0 ? void 0 : opts.pipeStrategy) !== null && _a !== void 0 ? _a : "input"
    });
  }
  return zodToJsonSchema(schema, {
    strictUnions: (_b = opts === null || opts === void 0 ? void 0 : opts.strictUnions) !== null && _b !== void 0 ? _b : true,
    pipeStrategy: (_c = opts === null || opts === void 0 ? void 0 : opts.pipeStrategy) !== null && _c !== void 0 ? _c : "input"
  });
}
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape === null || shape === void 0 ? void 0 : shape.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
      controller === null || controller === void 0 ? void 0 : controller.abort(notification.params.reason);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    var _a, _b, _c;
    this._transport = transport;
    const _onclose = (_a = this.transport) === null || _a === void 0 ? void 0 : _a.onclose;
    this._transport.onclose = () => {
      _onclose === null || _onclose === void 0 ? void 0 : _onclose();
      this._onclose();
    };
    const _onerror = (_b = this.transport) === null || _b === void 0 ? void 0 : _b.onerror;
    this._transport.onerror = (error) => {
      _onerror === null || _onerror === void 0 ? void 0 : _onerror(error);
      this._onerror(error);
    };
    const _onmessage = (_c = this._transport) === null || _c === void 0 ? void 0 : _c.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage === null || _onmessage === void 0 ? void 0 : _onmessage(message, extra);
      if (isJSONRPCResponse(message) || isJSONRPCError(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._pendingDebouncedNotifications.clear();
    this._transport = void 0;
    (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
    const error = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    for (const handler of responseHandlers.values()) {
      handler(error);
    }
  }
  _onerror(error) {
    var _a;
    (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
  }
  _onnotification(notification) {
    var _a;
    const handler = (_a = this._notificationHandlers.get(notification.method)) !== null && _a !== void 0 ? _a : this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request, extra) {
    var _a, _b;
    const handler = (_a = this._requestHandlers.get(request.method)) !== null && _a !== void 0 ? _a : this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    if (handler === void 0) {
      capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      }).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.sessionId,
      _meta: (_b = request.params) === null || _b === void 0 ? void 0 : _b._meta,
      sendNotification: (notification) => this.notification(notification, { relatedRequestId: request.id }),
      sendRequest: (r, resultSchema, options) => this.request(r, resultSchema, { ...options, relatedRequestId: request.id }),
      authInfo: extra === null || extra === void 0 ? void 0 : extra.authInfo,
      requestId: request.id,
      requestInfo: extra === null || extra === void 0 ? void 0 : extra.requestInfo
    };
    Promise.resolve().then(() => handler(request, fullExtra)).then((result) => {
      if (abortController.signal.aborted) {
        return;
      }
      return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        result,
        jsonrpc: "2.0",
        id: request.id
      });
    }, (error) => {
      var _a2;
      if (abortController.signal.aborted) {
        return;
      }
      return capturedTransport === null || capturedTransport === void 0 ? void 0 : capturedTransport.send({
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: (_a2 = error.message) !== null && _a2 !== void 0 ? _a2 : "Internal error",
          ...error["data"] !== void 0 && { data: error["data"] }
        }
      });
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        responseHandler(error);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._progressHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    if (isJSONRPCResponse(response)) {
      handler(response);
    } else {
      const error = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    var _a;
    await ((_a = this._transport) === null || _a === void 0 ? void 0 : _a.close());
  }
  /**
   * Sends a request and wait for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken } = options !== null && options !== void 0 ? options : {};
    return new Promise((resolve, reject) => {
      var _a, _b, _c, _d, _e, _f;
      if (!this._transport) {
        reject(new Error("Not connected"));
        return;
      }
      if (((_a = this._options) === null || _a === void 0 ? void 0 : _a.enforceStrictCapabilities) === true) {
        this.assertCapabilityForMethod(request.method);
      }
      (_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options === null || options === void 0 ? void 0 : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...((_c = request.params) === null || _c === void 0 ? void 0 : _c._meta) || {},
            progressToken: messageId
          }
        };
      }
      const cancel = (reason) => {
        var _a2;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => this._onerror(new Error(`Failed to send cancellation: ${error}`)));
        reject(reason);
      };
      this._responseHandlers.set(messageId, (response) => {
        var _a2;
        if ((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error) {
          reject(error);
        }
      });
      (_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.addEventListener("abort", () => {
        var _a2;
        cancel((_a2 = options === null || options === void 0 ? void 0 : options.signal) === null || _a2 === void 0 ? void 0 : _a2.reason);
      });
      const timeout = (_e = options === null || options === void 0 ? void 0 : options.timeout) !== null && _e !== void 0 ? _e : DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options === null || options === void 0 ? void 0 : options.maxTotalTimeout, timeoutHandler, (_f = options === null || options === void 0 ? void 0 : options.resetTimeoutOnProgress) !== null && _f !== void 0 ? _f : false);
      this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
        this._cleanupTimeout(messageId);
        reject(error);
      });
    });
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    var _a, _b;
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const debouncedMethods = (_b = (_a = this._options) === null || _a === void 0 ? void 0 : _a.debouncedNotificationMethods) !== null && _b !== void 0 ? _b : [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options === null || options === void 0 ? void 0 : options.relatedRequestId);
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        var _a2;
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        const jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
      });
      return;
    }
    const jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === void 0)
      continue;
    const baseValue = result[k];
    if (isPlainObject2(baseValue) && isPlainObject2(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  const ajv = new import_ajv.Ajv({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv !== null && ajv !== void 0 ? ajv : createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    var _a;
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? (_a = this._ajv.getSchema(schema.$id)) !== null && _a !== void 0 ? _a : this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    var _a, _b;
    super(options);
    this._serverInfo = _serverInfo;
    this._loggingLevels = /* @__PURE__ */ new Map();
    this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index]));
    this.isMessageIgnored = (level, sessionId) => {
      const currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : false;
    };
    this._capabilities = (_a = options === null || options === void 0 ? void 0 : options.capabilities) !== null && _a !== void 0 ? _a : {};
    this._instructions = options === null || options === void 0 ? void 0 : options.instructions;
    this._jsonSchemaValidator = (_b = options === null || options === void 0 ? void 0 : options.jsonSchemaValidator) !== null && _b !== void 0 ? _b : new AjvJsonSchemaValidator();
    this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request));
    this.setNotificationHandler(InitializedNotificationSchema, () => {
      var _a2;
      return (_a2 = this.oninitialized) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    });
    if (this._capabilities.logging) {
      this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
        var _a2;
        const transportSessionId = extra.sessionId || ((_a2 = extra.requestInfo) === null || _a2 === void 0 ? void 0 : _a2.headers["mcp-session-id"]) || void 0;
        const { level } = request.params;
        const parseResult = LoggingLevelSchema.safeParse(level);
        if (parseResult.success) {
          this._loggingLevels.set(transportSessionId, parseResult.data);
        }
        return {};
      });
    }
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  assertCapabilityForMethod(method) {
    var _a, _b, _c;
    switch (method) {
      case "sampling/createMessage":
        if (!((_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling)) {
          throw new Error(`Client does not support sampling (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!((_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation)) {
          throw new Error(`Client does not support elicitation (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!((_c = this._clientCapabilities) === null || _c === void 0 ? void 0 : _c.roots)) {
          throw new Error(`Client does not support listing roots (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    var _a, _b;
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        }
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        }
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        }
        break;
      case "notifications/elicitation/complete":
        if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.elicitation) === null || _b === void 0 ? void 0 : _b.url)) {
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        }
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    switch (method) {
      case "completion/complete":
        if (!this._capabilities.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "logging/setLevel":
        if (!this._capabilities.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._capabilities.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
        if (!this._capabilities.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._capabilities.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "ping":
      case "initialize":
        break;
    }
  }
  async _oninitialize(request) {
    const requestedVersion = request.params.protocolVersion;
    this._clientCapabilities = request.params.capabilities;
    this._clientVersion = request.params.clientInfo;
    const protocolVersion = SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION;
    return {
      protocolVersion,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  async createMessage(params, options) {
    var _a, _b;
    if (params.tools || params.toolChoice) {
      if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.sampling) === null || _b === void 0 ? void 0 : _b.tools)) {
        throw new Error("Client does not support sampling tools capability.");
      }
    }
    if (params.messages.length > 0) {
      const lastMessage = params.messages[params.messages.length - 1];
      const lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content];
      const hasToolResults = lastContent.some((c) => c.type === "tool_result");
      const previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0;
      const previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [];
      const hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result")) {
          throw new Error("The last message must contain only tool_result content if any is present");
        }
        if (!hasPreviousToolUse) {
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
        }
      }
      if (hasPreviousToolUse) {
        const toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id));
        const toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id))) {
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
        }
      }
    }
    return this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    var _a, _b, _c, _d, _e;
    const mode = (_a = params.mode) !== null && _a !== void 0 ? _a : "form";
    switch (mode) {
      case "url": {
        if (!((_c = (_b = this._clientCapabilities) === null || _b === void 0 ? void 0 : _b.elicitation) === null || _c === void 0 ? void 0 : _c.url)) {
          throw new Error("Client does not support url elicitation.");
        }
        const urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!((_e = (_d = this._clientCapabilities) === null || _d === void 0 ? void 0 : _d.elicitation) === null || _e === void 0 ? void 0 : _e.form)) {
          throw new Error("Client does not support form elicitation.");
        }
        const formParams = params.mode === "form" ? params : { ...params, mode: "form" };
        const result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema) {
          try {
            const validator = this._jsonSchemaValidator.getValidator(formParams.requestedSchema);
            const validationResult = validator(result.content);
            if (!validationResult.valid) {
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
            }
          } catch (error) {
            if (error instanceof McpError) {
              throw error;
            }
            throw new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error instanceof Error ? error.message : String(error)}`);
          }
        }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    var _a, _b;
    if (!((_b = (_a = this._clientCapabilities) === null || _a === void 0 ? void 0 : _a.elicitation) === null || _b === void 0 ? void 0 : _b.url)) {
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    }
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging) {
      if (!this.isMessageIgnored(params.level, sessionId)) {
        return this.notification({ method: "notifications/message", params });
      }
    }
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/completable.js
var COMPLETABLE_SYMBOL = Symbol.for("mcp.completable");
function isCompletable(schema) {
  return !!schema && typeof schema === "object" && COMPLETABLE_SYMBOL in schema;
}
function getCompleter(schema) {
  const meta2 = schema[COMPLETABLE_SYMBOL];
  return meta2 === null || meta2 === void 0 ? void 0 : meta2.complete;
}
var McpZodTypeKind;
(function(McpZodTypeKind2) {
  McpZodTypeKind2["Completable"] = "McpCompletable";
})(McpZodTypeKind || (McpZodTypeKind = {}));

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/toolNameValidation.js
var TOOL_NAME_REGEX = /^[A-Za-z0-9._-]{1,128}$/;
function validateToolName(name) {
  const warnings = [];
  if (name.length === 0) {
    return {
      isValid: false,
      warnings: ["Tool name cannot be empty"]
    };
  }
  if (name.length > 128) {
    return {
      isValid: false,
      warnings: [`Tool name exceeds maximum length of 128 characters (current: ${name.length})`]
    };
  }
  if (name.includes(" ")) {
    warnings.push("Tool name contains spaces, which may cause parsing issues");
  }
  if (name.includes(",")) {
    warnings.push("Tool name contains commas, which may cause parsing issues");
  }
  if (name.startsWith("-") || name.endsWith("-")) {
    warnings.push("Tool name starts or ends with a dash, which may cause parsing issues in some contexts");
  }
  if (name.startsWith(".") || name.endsWith(".")) {
    warnings.push("Tool name starts or ends with a dot, which may cause parsing issues in some contexts");
  }
  if (!TOOL_NAME_REGEX.test(name)) {
    const invalidChars = name.split("").filter((char) => !/[A-Za-z0-9._-]/.test(char)).filter((char, index, arr) => arr.indexOf(char) === index);
    warnings.push(`Tool name contains invalid characters: ${invalidChars.map((c) => `"${c}"`).join(", ")}`, "Allowed characters are: A-Z, a-z, 0-9, underscore (_), dash (-), and dot (.)");
    return {
      isValid: false,
      warnings
    };
  }
  return {
    isValid: true,
    warnings
  };
}
function issueToolNameWarning(name, warnings) {
  if (warnings.length > 0) {
    console.warn(`Tool name validation warning for "${name}":`);
    for (const warning of warnings) {
      console.warn(`  - ${warning}`);
    }
    console.warn("Tool registration will proceed, but this may cause compatibility issues.");
    console.warn("Consider updating the tool name to conform to the MCP tool naming standard.");
    console.warn("See SEP: Specify Format for Tool Names (https://github.com/modelcontextprotocol/modelcontextprotocol/issues/986) for more details.");
  }
}
function validateAndWarnToolName(name) {
  const result = validateToolName(name);
  issueToolNameWarning(name, result.warnings);
  return result.isValid;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/mcp.js
var McpServer = class {
  constructor(serverInfo, options) {
    this._registeredResources = {};
    this._registeredResourceTemplates = {};
    this._registeredTools = {};
    this._registeredPrompts = {};
    this._toolHandlersInitialized = false;
    this._completionHandlerInitialized = false;
    this._resourceHandlersInitialized = false;
    this._promptHandlersInitialized = false;
    this.server = new Server(serverInfo, options);
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The `server` object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    return await this.server.connect(transport);
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this.server.close();
  }
  setToolRequestHandlers() {
    if (this._toolHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListToolsRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(CallToolRequestSchema));
    this.server.registerCapabilities({
      tools: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListToolsRequestSchema, () => ({
      tools: Object.entries(this._registeredTools).filter(([, tool]) => tool.enabled).map(([name, tool]) => {
        const toolDefinition = {
          name,
          title: tool.title,
          description: tool.description,
          inputSchema: (() => {
            const obj = normalizeObjectSchema(tool.inputSchema);
            return obj ? toJsonSchemaCompat(obj, {
              strictUnions: true,
              pipeStrategy: "input"
            }) : EMPTY_OBJECT_JSON_SCHEMA;
          })(),
          annotations: tool.annotations,
          _meta: tool._meta
        };
        if (tool.outputSchema) {
          const obj = normalizeObjectSchema(tool.outputSchema);
          if (obj) {
            toolDefinition.outputSchema = toJsonSchemaCompat(obj, {
              strictUnions: true,
              pipeStrategy: "output"
            });
          }
        }
        return toolDefinition;
      })
    }));
    this.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
      const tool = this._registeredTools[request.params.name];
      let result;
      try {
        if (!tool) {
          throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} not found`);
        }
        if (!tool.enabled) {
          throw new McpError(ErrorCode.InvalidParams, `Tool ${request.params.name} disabled`);
        }
        if (tool.inputSchema) {
          const cb = tool.callback;
          const inputObj = normalizeObjectSchema(tool.inputSchema);
          const schemaToParse = inputObj !== null && inputObj !== void 0 ? inputObj : tool.inputSchema;
          const parseResult = await safeParseAsync2(schemaToParse, request.params.arguments);
          if (!parseResult.success) {
            throw new McpError(ErrorCode.InvalidParams, `Input validation error: Invalid arguments for tool ${request.params.name}: ${getParseErrorMessage(parseResult.error)}`);
          }
          const args = parseResult.data;
          result = await Promise.resolve(cb(args, extra));
        } else {
          const cb = tool.callback;
          result = await Promise.resolve(cb(extra));
        }
        if (tool.outputSchema && !result.isError) {
          if (!result.structuredContent) {
            throw new McpError(ErrorCode.InvalidParams, `Output validation error: Tool ${request.params.name} has an output schema but no structured content was provided`);
          }
          const outputObj = normalizeObjectSchema(tool.outputSchema);
          const parseResult = await safeParseAsync2(outputObj, result.structuredContent);
          if (!parseResult.success) {
            throw new McpError(ErrorCode.InvalidParams, `Output validation error: Invalid structured content for tool ${request.params.name}: ${getParseErrorMessage(parseResult.error)}`);
          }
        }
      } catch (error) {
        if (error instanceof McpError) {
          if (error.code === ErrorCode.UrlElicitationRequired) {
            throw error;
          }
        }
        return this.createToolError(error instanceof Error ? error.message : String(error));
      }
      return result;
    });
    this._toolHandlersInitialized = true;
  }
  /**
   * Creates a tool error result.
   *
   * @param errorMessage - The error message.
   * @returns The tool error result.
   */
  createToolError(errorMessage) {
    return {
      content: [
        {
          type: "text",
          text: errorMessage
        }
      ],
      isError: true
    };
  }
  setCompletionRequestHandler() {
    if (this._completionHandlerInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(CompleteRequestSchema));
    this.server.registerCapabilities({
      completions: {}
    });
    this.server.setRequestHandler(CompleteRequestSchema, async (request) => {
      switch (request.params.ref.type) {
        case "ref/prompt":
          assertCompleteRequestPrompt(request);
          return this.handlePromptCompletion(request, request.params.ref);
        case "ref/resource":
          assertCompleteRequestResourceTemplate(request);
          return this.handleResourceCompletion(request, request.params.ref);
        default:
          throw new McpError(ErrorCode.InvalidParams, `Invalid completion reference: ${request.params.ref}`);
      }
    });
    this._completionHandlerInitialized = true;
  }
  async handlePromptCompletion(request, ref) {
    const prompt = this._registeredPrompts[ref.name];
    if (!prompt) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} not found`);
    }
    if (!prompt.enabled) {
      throw new McpError(ErrorCode.InvalidParams, `Prompt ${ref.name} disabled`);
    }
    if (!prompt.argsSchema) {
      return EMPTY_COMPLETION_RESULT;
    }
    const promptShape = getObjectShape(prompt.argsSchema);
    const field = promptShape === null || promptShape === void 0 ? void 0 : promptShape[request.params.argument.name];
    if (!isCompletable(field)) {
      return EMPTY_COMPLETION_RESULT;
    }
    const completer = getCompleter(field);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request.params.argument.value, request.params.context);
    return createCompletionResult(suggestions);
  }
  async handleResourceCompletion(request, ref) {
    const template = Object.values(this._registeredResourceTemplates).find((t) => t.resourceTemplate.uriTemplate.toString() === ref.uri);
    if (!template) {
      if (this._registeredResources[ref.uri]) {
        return EMPTY_COMPLETION_RESULT;
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource template ${request.params.ref.uri} not found`);
    }
    const completer = template.resourceTemplate.completeCallback(request.params.argument.name);
    if (!completer) {
      return EMPTY_COMPLETION_RESULT;
    }
    const suggestions = await completer(request.params.argument.value, request.params.context);
    return createCompletionResult(suggestions);
  }
  setResourceRequestHandlers() {
    if (this._resourceHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListResourcesRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(ListResourceTemplatesRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(ReadResourceRequestSchema));
    this.server.registerCapabilities({
      resources: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListResourcesRequestSchema, async (request, extra) => {
      const resources = Object.entries(this._registeredResources).filter(([_, resource]) => resource.enabled).map(([uri, resource]) => ({
        uri,
        name: resource.name,
        ...resource.metadata
      }));
      const templateResources = [];
      for (const template of Object.values(this._registeredResourceTemplates)) {
        if (!template.resourceTemplate.listCallback) {
          continue;
        }
        const result = await template.resourceTemplate.listCallback(extra);
        for (const resource of result.resources) {
          templateResources.push({
            ...template.metadata,
            // the defined resource metadata should override the template metadata if present
            ...resource
          });
        }
      }
      return { resources: [...resources, ...templateResources] };
    });
    this.server.setRequestHandler(ListResourceTemplatesRequestSchema, async () => {
      const resourceTemplates = Object.entries(this._registeredResourceTemplates).map(([name, template]) => ({
        name,
        uriTemplate: template.resourceTemplate.uriTemplate.toString(),
        ...template.metadata
      }));
      return { resourceTemplates };
    });
    this.server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
      const uri = new URL(request.params.uri);
      const resource = this._registeredResources[uri.toString()];
      if (resource) {
        if (!resource.enabled) {
          throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} disabled`);
        }
        return resource.readCallback(uri, extra);
      }
      for (const template of Object.values(this._registeredResourceTemplates)) {
        const variables = template.resourceTemplate.uriTemplate.match(uri.toString());
        if (variables) {
          return template.readCallback(uri, variables, extra);
        }
      }
      throw new McpError(ErrorCode.InvalidParams, `Resource ${uri} not found`);
    });
    this.setCompletionRequestHandler();
    this._resourceHandlersInitialized = true;
  }
  setPromptRequestHandlers() {
    if (this._promptHandlersInitialized) {
      return;
    }
    this.server.assertCanSetRequestHandler(getMethodValue(ListPromptsRequestSchema));
    this.server.assertCanSetRequestHandler(getMethodValue(GetPromptRequestSchema));
    this.server.registerCapabilities({
      prompts: {
        listChanged: true
      }
    });
    this.server.setRequestHandler(ListPromptsRequestSchema, () => ({
      prompts: Object.entries(this._registeredPrompts).filter(([, prompt]) => prompt.enabled).map(([name, prompt]) => {
        return {
          name,
          title: prompt.title,
          description: prompt.description,
          arguments: prompt.argsSchema ? promptArgumentsFromSchema(prompt.argsSchema) : void 0
        };
      })
    }));
    this.server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
      const prompt = this._registeredPrompts[request.params.name];
      if (!prompt) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} not found`);
      }
      if (!prompt.enabled) {
        throw new McpError(ErrorCode.InvalidParams, `Prompt ${request.params.name} disabled`);
      }
      if (prompt.argsSchema) {
        const argsObj = normalizeObjectSchema(prompt.argsSchema);
        const parseResult = await safeParseAsync2(argsObj, request.params.arguments);
        if (!parseResult.success) {
          throw new McpError(ErrorCode.InvalidParams, `Invalid arguments for prompt ${request.params.name}: ${getParseErrorMessage(parseResult.error)}`);
        }
        const args = parseResult.data;
        const cb = prompt.callback;
        return await Promise.resolve(cb(args, extra));
      } else {
        const cb = prompt.callback;
        return await Promise.resolve(cb(extra));
      }
    });
    this.setCompletionRequestHandler();
    this._promptHandlersInitialized = true;
  }
  resource(name, uriOrTemplate, ...rest) {
    let metadata;
    if (typeof rest[0] === "object") {
      metadata = rest.shift();
    }
    const readCallback = rest[0];
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, void 0, uriOrTemplate, metadata, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  registerResource(name, uriOrTemplate, config2, readCallback) {
    if (typeof uriOrTemplate === "string") {
      if (this._registeredResources[uriOrTemplate]) {
        throw new Error(`Resource ${uriOrTemplate} is already registered`);
      }
      const registeredResource = this._createRegisteredResource(name, config2.title, uriOrTemplate, config2, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResource;
    } else {
      if (this._registeredResourceTemplates[name]) {
        throw new Error(`Resource template ${name} is already registered`);
      }
      const registeredResourceTemplate = this._createRegisteredResourceTemplate(name, config2.title, uriOrTemplate, config2, readCallback);
      this.setResourceRequestHandlers();
      this.sendResourceListChanged();
      return registeredResourceTemplate;
    }
  }
  _createRegisteredResource(name, title, uri, metadata, readCallback) {
    const registeredResource = {
      name,
      title,
      metadata,
      readCallback,
      enabled: true,
      disable: () => registeredResource.update({ enabled: false }),
      enable: () => registeredResource.update({ enabled: true }),
      remove: () => registeredResource.update({ uri: null }),
      update: (updates) => {
        if (typeof updates.uri !== "undefined" && updates.uri !== uri) {
          delete this._registeredResources[uri];
          if (updates.uri)
            this._registeredResources[updates.uri] = registeredResource;
        }
        if (typeof updates.name !== "undefined")
          registeredResource.name = updates.name;
        if (typeof updates.title !== "undefined")
          registeredResource.title = updates.title;
        if (typeof updates.metadata !== "undefined")
          registeredResource.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResource.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResource.enabled = updates.enabled;
        this.sendResourceListChanged();
      }
    };
    this._registeredResources[uri] = registeredResource;
    return registeredResource;
  }
  _createRegisteredResourceTemplate(name, title, template, metadata, readCallback) {
    const registeredResourceTemplate = {
      resourceTemplate: template,
      title,
      metadata,
      readCallback,
      enabled: true,
      disable: () => registeredResourceTemplate.update({ enabled: false }),
      enable: () => registeredResourceTemplate.update({ enabled: true }),
      remove: () => registeredResourceTemplate.update({ name: null }),
      update: (updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          delete this._registeredResourceTemplates[name];
          if (updates.name)
            this._registeredResourceTemplates[updates.name] = registeredResourceTemplate;
        }
        if (typeof updates.title !== "undefined")
          registeredResourceTemplate.title = updates.title;
        if (typeof updates.template !== "undefined")
          registeredResourceTemplate.resourceTemplate = updates.template;
        if (typeof updates.metadata !== "undefined")
          registeredResourceTemplate.metadata = updates.metadata;
        if (typeof updates.callback !== "undefined")
          registeredResourceTemplate.readCallback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredResourceTemplate.enabled = updates.enabled;
        this.sendResourceListChanged();
      }
    };
    this._registeredResourceTemplates[name] = registeredResourceTemplate;
    return registeredResourceTemplate;
  }
  _createRegisteredPrompt(name, title, description, argsSchema, callback) {
    const registeredPrompt = {
      title,
      description,
      argsSchema: argsSchema === void 0 ? void 0 : objectFromShape(argsSchema),
      callback,
      enabled: true,
      disable: () => registeredPrompt.update({ enabled: false }),
      enable: () => registeredPrompt.update({ enabled: true }),
      remove: () => registeredPrompt.update({ name: null }),
      update: (updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          delete this._registeredPrompts[name];
          if (updates.name)
            this._registeredPrompts[updates.name] = registeredPrompt;
        }
        if (typeof updates.title !== "undefined")
          registeredPrompt.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredPrompt.description = updates.description;
        if (typeof updates.argsSchema !== "undefined")
          registeredPrompt.argsSchema = objectFromShape(updates.argsSchema);
        if (typeof updates.callback !== "undefined")
          registeredPrompt.callback = updates.callback;
        if (typeof updates.enabled !== "undefined")
          registeredPrompt.enabled = updates.enabled;
        this.sendPromptListChanged();
      }
    };
    this._registeredPrompts[name] = registeredPrompt;
    return registeredPrompt;
  }
  _createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, _meta, callback) {
    validateAndWarnToolName(name);
    const registeredTool = {
      title,
      description,
      inputSchema: getZodSchemaObject(inputSchema),
      outputSchema: getZodSchemaObject(outputSchema),
      annotations,
      _meta,
      callback,
      enabled: true,
      disable: () => registeredTool.update({ enabled: false }),
      enable: () => registeredTool.update({ enabled: true }),
      remove: () => registeredTool.update({ name: null }),
      update: (updates) => {
        if (typeof updates.name !== "undefined" && updates.name !== name) {
          if (typeof updates.name === "string") {
            validateAndWarnToolName(updates.name);
          }
          delete this._registeredTools[name];
          if (updates.name)
            this._registeredTools[updates.name] = registeredTool;
        }
        if (typeof updates.title !== "undefined")
          registeredTool.title = updates.title;
        if (typeof updates.description !== "undefined")
          registeredTool.description = updates.description;
        if (typeof updates.paramsSchema !== "undefined")
          registeredTool.inputSchema = objectFromShape(updates.paramsSchema);
        if (typeof updates.callback !== "undefined")
          registeredTool.callback = updates.callback;
        if (typeof updates.annotations !== "undefined")
          registeredTool.annotations = updates.annotations;
        if (typeof updates._meta !== "undefined")
          registeredTool._meta = updates._meta;
        if (typeof updates.enabled !== "undefined")
          registeredTool.enabled = updates.enabled;
        this.sendToolListChanged();
      }
    };
    this._registeredTools[name] = registeredTool;
    this.setToolRequestHandlers();
    this.sendToolListChanged();
    return registeredTool;
  }
  /**
   * tool() implementation. Parses arguments passed to overrides defined above.
   */
  tool(name, ...rest) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    let description;
    let inputSchema;
    let outputSchema;
    let annotations;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    if (rest.length > 1) {
      const firstArg = rest[0];
      if (isZodRawShape(firstArg)) {
        inputSchema = rest.shift();
        if (rest.length > 1 && typeof rest[0] === "object" && rest[0] !== null && !isZodRawShape(rest[0])) {
          annotations = rest.shift();
        }
      } else if (typeof firstArg === "object" && firstArg !== null) {
        annotations = rest.shift();
      }
    }
    const callback = rest[0];
    return this._createRegisteredTool(name, void 0, description, inputSchema, outputSchema, annotations, void 0, callback);
  }
  /**
   * Registers a tool with a config object and callback.
   */
  registerTool(name, config2, cb) {
    if (this._registeredTools[name]) {
      throw new Error(`Tool ${name} is already registered`);
    }
    const { title, description, inputSchema, outputSchema, annotations, _meta } = config2;
    return this._createRegisteredTool(name, title, description, inputSchema, outputSchema, annotations, _meta, cb);
  }
  prompt(name, ...rest) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    let description;
    if (typeof rest[0] === "string") {
      description = rest.shift();
    }
    let argsSchema;
    if (rest.length > 1) {
      argsSchema = rest.shift();
    }
    const cb = rest[0];
    const registeredPrompt = this._createRegisteredPrompt(name, void 0, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Registers a prompt with a config object and callback.
   */
  registerPrompt(name, config2, cb) {
    if (this._registeredPrompts[name]) {
      throw new Error(`Prompt ${name} is already registered`);
    }
    const { title, description, argsSchema } = config2;
    const registeredPrompt = this._createRegisteredPrompt(name, title, description, argsSchema, cb);
    this.setPromptRequestHandlers();
    this.sendPromptListChanged();
    return registeredPrompt;
  }
  /**
   * Checks if the server is connected to a transport.
   * @returns True if the server is connected
   */
  isConnected() {
    return this.server.transport !== void 0;
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    return this.server.sendLoggingMessage(params, sessionId);
  }
  /**
   * Sends a resource list changed event to the client, if connected.
   */
  sendResourceListChanged() {
    if (this.isConnected()) {
      this.server.sendResourceListChanged();
    }
  }
  /**
   * Sends a tool list changed event to the client, if connected.
   */
  sendToolListChanged() {
    if (this.isConnected()) {
      this.server.sendToolListChanged();
    }
  }
  /**
   * Sends a prompt list changed event to the client, if connected.
   */
  sendPromptListChanged() {
    if (this.isConnected()) {
      this.server.sendPromptListChanged();
    }
  }
};
var EMPTY_OBJECT_JSON_SCHEMA = {
  type: "object",
  properties: {}
};
function isZodRawShape(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  const isEmptyObject = Object.keys(obj).length === 0;
  return isEmptyObject || Object.values(obj).some(isZodTypeLike);
}
function isZodTypeLike(value) {
  return value !== null && typeof value === "object" && "parse" in value && typeof value.parse === "function" && "safeParse" in value && typeof value.safeParse === "function";
}
function getZodSchemaObject(schema) {
  if (!schema) {
    return void 0;
  }
  if (isZodRawShape(schema)) {
    return objectFromShape(schema);
  }
  return schema;
}
function promptArgumentsFromSchema(schema) {
  const shape = getObjectShape(schema);
  if (!shape)
    return [];
  return Object.entries(shape).map(([name, field]) => {
    const description = getSchemaDescription(field);
    const isOptional = isSchemaOptional(field);
    return {
      name,
      description,
      required: !isOptional
    };
  });
}
function getMethodValue(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape === null || shape === void 0 ? void 0 : shape.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value === "string") {
    return value;
  }
  throw new Error("Schema method literal must be a string");
}
function createCompletionResult(suggestions) {
  return {
    completion: {
      values: suggestions.slice(0, 100),
      total: suggestions.length,
      hasMore: suggestions.length > 100
    }
  };
}
var EMPTY_COMPLETION_RESULT = {
  completion: {
    values: [],
    hasMore: false
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var import_node_process = __toESM(require("node:process"), 1);

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer) {
      return null;
    }
    const index = this._buffer.indexOf("\n");
    if (index === -1) {
      return null;
    }
    const line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    this._buffer = this._buffer.subarray(index + 1);
    return deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + "\n";
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var StdioServerTransport = class {
  constructor(_stdin = import_node_process.default.stdin, _stdout = import_node_process.default.stdout) {
    this._stdin = _stdin;
    this._stdout = _stdout;
    this._readBuffer = new ReadBuffer();
    this._started = false;
    this._ondata = (chunk) => {
      this._readBuffer.append(chunk);
      this.processReadBuffer();
    };
    this._onerror = (error) => {
      var _a;
      (_a = this.onerror) === null || _a === void 0 ? void 0 : _a.call(this, error);
    };
  }
  /**
   * Starts listening for messages on stdin.
   */
  async start() {
    if (this._started) {
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    }
    this._started = true;
    this._stdin.on("data", this._ondata);
    this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    var _a, _b;
    while (true) {
      try {
        const message = this._readBuffer.readMessage();
        if (message === null) {
          break;
        }
        (_a = this.onmessage) === null || _a === void 0 ? void 0 : _a.call(this, message);
      } catch (error) {
        (_b = this.onerror) === null || _b === void 0 ? void 0 : _b.call(this, error);
      }
    }
  }
  async close() {
    var _a;
    this._stdin.off("data", this._ondata);
    this._stdin.off("error", this._onerror);
    const remainingDataListeners = this._stdin.listenerCount("data");
    if (remainingDataListeners === 0) {
      this._stdin.pause();
    }
    this._readBuffer.clear();
    (_a = this.onclose) === null || _a === void 0 ? void 0 : _a.call(this);
  }
  send(message) {
    return new Promise((resolve) => {
      const json = serializeMessage(message);
      if (this._stdout.write(json)) {
        resolve();
      } else {
        this._stdout.once("drain", resolve);
      }
    });
  }
};

// dist/server/index.js
init_zod();

// dist/server/meta-tools.js
init_zod();

// dist/server/tools.js
init_zod();

// dist/engine/worldgen/heightmap.js
var import_seedrandom = __toESM(require_seedrandom2(), 1);

// node_modules/simplex-noise/dist/esm/simplex-noise.js
var SQRT3 = /* @__PURE__ */ Math.sqrt(3);
var SQRT5 = /* @__PURE__ */ Math.sqrt(5);
var F2 = 0.5 * (SQRT3 - 1);
var G2 = (3 - SQRT3) / 6;
var F3 = 1 / 3;
var G3 = 1 / 6;
var F4 = (SQRT5 - 1) / 4;
var G4 = (5 - SQRT5) / 20;
var fastFloor = (x) => Math.floor(x) | 0;
var grad2 = /* @__PURE__ */ new Float64Array([
  1,
  1,
  -1,
  1,
  1,
  -1,
  -1,
  -1,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1,
  0,
  0,
  1,
  0,
  -1,
  0,
  1,
  0,
  -1
]);
function createNoise2D(random = Math.random) {
  const perm = buildPermutationTable(random);
  const permGrad2x = new Float64Array(perm).map((v) => grad2[v % 12 * 2]);
  const permGrad2y = new Float64Array(perm).map((v) => grad2[v % 12 * 2 + 1]);
  return function noise2D(x, y) {
    let n0 = 0;
    let n1 = 0;
    let n2 = 0;
    const s = (x + y) * F2;
    const i = fastFloor(x + s);
    const j = fastFloor(y + s);
    const t = (i + j) * G2;
    const X0 = i - t;
    const Y0 = j - t;
    const x0 = x - X0;
    const y0 = y - Y0;
    let i1, j1;
    if (x0 > y0) {
      i1 = 1;
      j1 = 0;
    } else {
      i1 = 0;
      j1 = 1;
    }
    const x1 = x0 - i1 + G2;
    const y1 = y0 - j1 + G2;
    const x2 = x0 - 1 + 2 * G2;
    const y2 = y0 - 1 + 2 * G2;
    const ii = i & 255;
    const jj = j & 255;
    let t0 = 0.5 - x0 * x0 - y0 * y0;
    if (t0 >= 0) {
      const gi0 = ii + perm[jj];
      const g0x = permGrad2x[gi0];
      const g0y = permGrad2y[gi0];
      t0 *= t0;
      n0 = t0 * t0 * (g0x * x0 + g0y * y0);
    }
    let t1 = 0.5 - x1 * x1 - y1 * y1;
    if (t1 >= 0) {
      const gi1 = ii + i1 + perm[jj + j1];
      const g1x = permGrad2x[gi1];
      const g1y = permGrad2y[gi1];
      t1 *= t1;
      n1 = t1 * t1 * (g1x * x1 + g1y * y1);
    }
    let t2 = 0.5 - x2 * x2 - y2 * y2;
    if (t2 >= 0) {
      const gi2 = ii + 1 + perm[jj + 1];
      const g2x = permGrad2x[gi2];
      const g2y = permGrad2y[gi2];
      t2 *= t2;
      n2 = t2 * t2 * (g2x * x2 + g2y * y2);
    }
    return 70 * (n0 + n1 + n2);
  };
}
function buildPermutationTable(random) {
  const tableSize = 512;
  const p = new Uint8Array(tableSize);
  for (let i = 0; i < tableSize / 2; i++) {
    p[i] = i;
  }
  for (let i = 0; i < tableSize / 2 - 1; i++) {
    const r = i + ~~(random() * (256 - i));
    const aux = p[i];
    p[i] = p[r];
    p[r] = aux;
  }
  for (let i = 256; i < tableSize; i++) {
    p[i] = p[i - 256];
  }
  return p;
}

// dist/engine/worldgen/heightmap.js
var toIndex = (x, y, width) => y * width + x;
function generateHeightmap(seed, width, height, options) {
  const opts = {
    seed,
    width,
    height,
    octaves: options?.octaves ?? 6,
    persistence: options?.persistence ?? 0.5,
    lacunarity: options?.lacunarity ?? 2,
    landRatio: options?.landRatio ?? 0.3
  };
  const rng2 = (0, import_seedrandom.default)(seed);
  const noise2D = createNoise2D(rng2);
  const rawHeightmap = generateLayeredNoise(noise2D, opts);
  const normalized = normalizeHeightmap(rawHeightmap, opts.width, opts.height, opts.landRatio);
  const smoothed = smoothHeightmap(normalized, opts.width, opts.height, 2);
  return smoothed;
}
function generateLayeredNoise(noise2D, options) {
  const { width, height, octaves, persistence, lacunarity } = options;
  const size = width * height;
  const heightmap = new Float32Array(size);
  let maxAmplitude = 0;
  for (let octave = 0; octave < octaves; octave++) {
    const frequency = Math.pow(lacunarity, octave);
    const amplitude = Math.pow(persistence, octave);
    maxAmplitude += amplitude;
    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const nx = x / width * frequency;
        const ny = y / height * frequency;
        const sample = noise2D(nx, ny);
        heightmap[toIndex(x, y, width)] += sample * amplitude;
      }
    }
  }
  for (let i = 0; i < size; i++) {
    heightmap[i] = (heightmap[i] + maxAmplitude) / (2 * maxAmplitude);
  }
  return heightmap;
}
function normalizeHeightmap(rawHeightmap, width, height, targetLandRatio) {
  const size = width * height;
  const SEA_LEVEL = 20;
  const elevations = new Float32Array(rawHeightmap);
  elevations.sort();
  const seaLevelIndex = Math.floor((1 - targetLandRatio) * (size - 1));
  const seaLevelValue = elevations[seaLevelIndex];
  const normalized = new Uint8Array(size);
  for (let i = 0; i < size; i++) {
    const rawValue = rawHeightmap[i];
    let normalizedValue;
    if (rawValue <= seaLevelValue) {
      normalizedValue = seaLevelValue > 0 ? rawValue / seaLevelValue * SEA_LEVEL : 0;
    } else {
      const landRange = 100 - SEA_LEVEL;
      const rawLandRange = 1 - seaLevelValue;
      normalizedValue = SEA_LEVEL + (rawValue - seaLevelValue) / rawLandRange * landRange;
    }
    normalized[i] = Math.round(Math.max(0, Math.min(100, normalizedValue)));
  }
  return normalized;
}
function smoothHeightmap(heightmap, width, height, iterations = 1) {
  let result = new Uint8Array(heightmap);
  for (let iter = 0; iter < iterations; iter++) {
    const temp = new Uint8Array(result);
    for (let y = 1; y < height - 1; y++) {
      for (let x = 1; x < width - 1; x++) {
        let sum = 0;
        sum += result[toIndex(x - 1, y - 1, width)];
        sum += result[toIndex(x, y - 1, width)];
        sum += result[toIndex(x + 1, y - 1, width)];
        sum += result[toIndex(x - 1, y, width)];
        sum += result[toIndex(x, y, width)];
        sum += result[toIndex(x + 1, y, width)];
        sum += result[toIndex(x - 1, y + 1, width)];
        sum += result[toIndex(x, y + 1, width)];
        sum += result[toIndex(x + 1, y + 1, width)];
        temp[toIndex(x, y, width)] = Math.round(sum / 9);
      }
    }
    result = temp;
  }
  return result;
}

// dist/engine/worldgen/climate.js
var import_seedrandom2 = __toESM(require_seedrandom2(), 1);
var toIndex2 = (x, y, width) => y * width + x;
var fromIndex = (index, width) => ({ x: index % width, y: Math.floor(index / width) });
function generateClimateMap(seed, width, height, heightmap, options) {
  const fullOptions = {
    seed,
    width,
    height,
    heightmap,
    equatorTemp: 30,
    poleTemp: -10,
    elevationLapseRate: 3,
    temperatureOffset: 0,
    moistureOffset: 0,
    ...options
  };
  const temperature = generateTemperatureMap(fullOptions);
  const moisture = generateMoistureMap(fullOptions);
  return {
    width,
    height,
    temperature,
    moisture,
    elevation: heightmap
  };
}
function generateTemperatureMap(options) {
  const { width, height, seed, heightmap, equatorTemp, poleTemp, elevationLapseRate, temperatureOffset = 0 } = options;
  const rng2 = (0, import_seedrandom2.default)(seed + "-temp");
  const noise2D = createNoise2D(rng2);
  const size = width * height;
  const temperature = new Int8Array(size);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const latitudeFactor = 1 - Math.abs(y - height / 2) / (height / 2);
      const baseTemp = poleTemp + latitudeFactor * (equatorTemp - poleTemp);
      const idx = toIndex2(x, y, width);
      const elevation = heightmap[idx];
      const SEA_LEVEL = 20;
      const elevationAboveSeaLevel = Math.max(0, elevation - SEA_LEVEL);
      const elevationAdjustment = -(elevationAboveSeaLevel / 10) * elevationLapseRate;
      const noiseValue = noise2D(x / (width * 0.3), y / (height * 0.3));
      const noiseAdjustment = noiseValue * 5;
      const temp = baseTemp + elevationAdjustment + noiseAdjustment + temperatureOffset;
      temperature[idx] = Math.round(Math.max(-20, Math.min(40, temp)));
    }
  }
  return temperature;
}
function generateMoistureMap(options) {
  const { width, height, seed, heightmap, moistureOffset = 0 } = options;
  const rng2 = (0, import_seedrandom2.default)(seed + "-moisture");
  const noise2D = createNoise2D(rng2);
  const size = width * height;
  const SEA_LEVEL = 20;
  const oceanDistance = calculateOceanDistance(heightmap, SEA_LEVEL, width, height);
  const moisture = new Uint8Array(size);
  const seedOffsetX = rng2() * 500;
  const seedOffsetY = rng2() * 500;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex2(x, y, width);
      const elevation = heightmap[idx];
      if (elevation < SEA_LEVEL) {
        moisture[idx] = 100;
        continue;
      }
      const distance = oceanDistance[idx];
      const maxDistance = Math.max(width, height) / 4;
      const proximityFactor = Math.max(0, 1 - distance / maxDistance);
      const baseMoisture = proximityFactor * 60;
      const latitudeFactor = 1 - Math.abs(y - height / 2) / (height / 2);
      const latitudeMoisture = latitudeFactor * 20;
      const noise1 = noise2D((x + seedOffsetX) / (width * 0.7), (y + seedOffsetY) / (height * 0.7));
      const noise2 = noise2D((x + seedOffsetX) / (width * 0.35), (y + seedOffsetY) / (height * 0.35)) * 0.6;
      const noise3 = noise2D((x + seedOffsetX) / (width * 0.15), (y + seedOffsetY) / (height * 0.15)) * 0.3;
      const noiseAdjustment = (noise1 + noise2 + noise3) * 12;
      const seedBias = Math.round((rng2() - 0.5) * 12);
      const totalMoisture = baseMoisture + latitudeMoisture + noiseAdjustment + seedBias + moistureOffset;
      moisture[idx] = Math.round(Math.max(0, Math.min(100, totalMoisture)));
    }
  }
  const smoothed = applyMoistureSmoothing(moisture, heightmap, SEA_LEVEL, width, height);
  let blended = blendSteepMoistureDeltas(smoothed, heightmap, SEA_LEVEL, width, height);
  blended = blendSteepMoistureDeltas(blended, heightmap, SEA_LEVEL, width, height);
  const capped = enforceMoistureDeltaCap(blended, width, height);
  const recapped = enforceMoistureDeltaCap(capped, width, height);
  return recapped;
}
function applyMoistureSmoothing(moisture, heightmap, seaLevel, width, height) {
  const size = width * height;
  const smoothed = new Uint8Array(size);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex2(x, y, width);
      if (heightmap[idx] < seaLevel) {
        smoothed[idx] = 100;
        continue;
      }
      let sum = moisture[idx] * 2;
      let count = 2;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0)
            continue;
          const nx = x + dx;
          const ny = y + dy;
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            sum += moisture[toIndex2(nx, ny, width)];
            count++;
          }
        }
      }
      smoothed[idx] = Math.round(sum / count);
    }
  }
  return smoothed;
}
function blendSteepMoistureDeltas(moisture, heightmap, seaLevel, width, height) {
  const blended = new Uint8Array(moisture);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex2(x, y, width);
      if (heightmap[idx] < seaLevel)
        continue;
      const neighbors = [];
      if (x + 1 < width)
        neighbors.push({ nx: x + 1, ny: y });
      if (y + 1 < height)
        neighbors.push({ nx: x, ny: y + 1 });
      for (const { nx, ny } of neighbors) {
        const nIdx = toIndex2(nx, ny, width);
        if (heightmap[nIdx] < seaLevel)
          continue;
        const current = moisture[idx];
        const neighbor = moisture[nIdx];
        const delta = Math.abs(current - neighbor);
        if (delta >= 27) {
          const average = Math.round((current + neighbor) / 2);
          blended[idx] = Math.round((current * 2 + average) / 3);
          blended[nIdx] = Math.round((neighbor * 2 + average) / 3);
        }
      }
    }
  }
  return blended;
}
function enforceMoistureDeltaCap(moisture, width, height) {
  const adjusted = new Uint8Array(moisture);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const neighbors = [];
      if (x + 1 < width)
        neighbors.push({ nx: x + 1, ny: y });
      if (y + 1 < height)
        neighbors.push({ nx: x, ny: y + 1 });
      for (const { nx, ny } of neighbors) {
        const idx = toIndex2(x, y, width);
        const nIdx = toIndex2(nx, ny, width);
        const current = adjusted[idx];
        const neighbor = adjusted[nIdx];
        const delta = Math.abs(current - neighbor);
        if (delta > 29) {
          const low = Math.min(current, neighbor);
          const cappedHigh = low + 29;
          if (current > neighbor) {
            adjusted[idx] = cappedHigh;
            adjusted[nIdx] = low;
          } else {
            adjusted[nIdx] = cappedHigh;
            adjusted[idx] = low;
          }
        }
      }
    }
  }
  return adjusted;
}
function calculateOceanDistance(heightmap, seaLevel, width, height) {
  const size = width * height;
  const distance = new Int32Array(size).fill(2147483647);
  const queue = new Int32Array(size);
  let head = 0;
  let tail = 0;
  for (let i = 0; i < size; i++) {
    if (heightmap[i] < seaLevel) {
      distance[i] = 0;
      queue[tail++] = i;
    }
  }
  const directions = [
    { x: -1, y: 0 },
    { x: 1, y: 0 },
    { x: 0, y: -1 },
    { x: 0, y: 1 }
  ];
  while (head < tail) {
    const idx = queue[head++];
    const { x, y } = fromIndex(idx, width);
    const dist = distance[idx];
    for (const { x: dx, y: dy } of directions) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        const nIdx = toIndex2(nx, ny, width);
        const newDist = dist + 1;
        if (newDist < distance[nIdx]) {
          distance[nIdx] = newDist;
          queue[tail++] = nIdx;
        }
      }
    }
  }
  return distance;
}

// dist/schema/biome.js
init_zod();
var BiomeType;
(function(BiomeType2) {
  BiomeType2["OCEAN"] = "ocean";
  BiomeType2["DEEP_OCEAN"] = "deep_ocean";
  BiomeType2["LAKE"] = "lake";
  BiomeType2["DESERT"] = "hot_desert";
  BiomeType2["SAVANNA"] = "savanna";
  BiomeType2["RAINFOREST"] = "tropical_rainforest";
  BiomeType2["GRASSLAND"] = "grassland";
  BiomeType2["FOREST"] = "temperate_deciduous_forest";
  BiomeType2["SWAMP"] = "wetland";
  BiomeType2["TAIGA"] = "taiga";
  BiomeType2["TUNDRA"] = "tundra";
  BiomeType2["GLACIER"] = "glacier";
})(BiomeType || (BiomeType = {}));
var BiomeSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  color: external_exports.string(),
  temperatureMin: external_exports.number(),
  temperatureMax: external_exports.number(),
  moistureMin: external_exports.number().min(0).max(1),
  moistureMax: external_exports.number().min(0).max(1),
  elevationMin: external_exports.number(),
  elevationMax: external_exports.number()
});

// dist/engine/worldgen/biome.js
var TEMP_BANDS = [
  { min: 19, max: Infinity, index: 0 },
  // Hot
  { min: 10, max: 19, index: 1 },
  // Warm
  { min: 0, max: 10, index: 2 },
  // Temperate
  { min: -10, max: 0, index: 3 },
  // Cool
  { min: -Infinity, max: -10, index: 4 }
  // Cold
];
var BIOME_MATRIX = [
  // Band 0: Hot (>19C)
  [
    BiomeType.DESERT,
    // 0-3% moisture
    BiomeType.DESERT,
    BiomeType.DESERT,
    BiomeType.DESERT,
    BiomeType.SAVANNA,
    // 4-10%
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.FOREST,
    // 11-15% (dry forest)
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.RAINFOREST,
    // 16-22% (tropical rainforest)
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.SWAMP,
    // 23-25% (very wet)
    BiomeType.SWAMP,
    BiomeType.SWAMP
  ],
  // Band 1: Warm (10-19C)
  [
    BiomeType.SAVANNA,
    // 0-2%
    BiomeType.SAVANNA,
    BiomeType.SAVANNA,
    BiomeType.GRASSLAND,
    // 3-8%
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.FOREST,
    // 9-17%
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.RAINFOREST,
    // 18-20%
    BiomeType.RAINFOREST,
    BiomeType.RAINFOREST,
    BiomeType.SWAMP,
    // 21-25%
    BiomeType.SWAMP,
    BiomeType.SWAMP,
    BiomeType.SWAMP,
    BiomeType.SWAMP
  ],
  // Band 2: Temperate (0-10C)
  [
    BiomeType.DESERT,
    // 0-2% (cold desert)
    BiomeType.DESERT,
    BiomeType.DESERT,
    BiomeType.GRASSLAND,
    // 3-7%
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.FOREST,
    // 8-15%
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.TAIGA,
    // 16-22%
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.SWAMP,
    // 23-25%
    BiomeType.SWAMP,
    BiomeType.SWAMP
  ],
  // Band 3: Cool (-10 to 0C)
  [
    BiomeType.TUNDRA,
    // 0-3% (cold dry)
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.GRASSLAND,
    // 4-7%
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.GRASSLAND,
    BiomeType.FOREST,
    // 8-11%
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.FOREST,
    BiomeType.TAIGA,
    // 12-22%
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.SWAMP,
    // 23-25%
    BiomeType.SWAMP,
    BiomeType.SWAMP
  ],
  // Band 4: Cold (<-10C)
  [
    BiomeType.DESERT,
    // 0-2% (polar desert)
    BiomeType.DESERT,
    BiomeType.DESERT,
    BiomeType.TUNDRA,
    // 3-14%
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TUNDRA,
    BiomeType.TAIGA,
    // 15-17% (cold taiga)
    BiomeType.TAIGA,
    BiomeType.TAIGA,
    BiomeType.GLACIER,
    // 18-25%
    BiomeType.GLACIER,
    BiomeType.GLACIER,
    BiomeType.GLACIER,
    BiomeType.GLACIER,
    BiomeType.GLACIER,
    BiomeType.GLACIER,
    BiomeType.GLACIER
  ]
];
var toIndex3 = (x, y, width) => y * width + x;
function generateBiomeMap(options) {
  const { width, height, temperature, moisture, elevation } = options;
  const SEA_LEVEL = 20;
  const biomes = Array.from({ length: height }, () => Array.from({ length: width }, () => BiomeType.OCEAN));
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex3(x, y, width);
      if (elevation[idx] < SEA_LEVEL) {
        biomes[y][x] = BiomeType.OCEAN;
        continue;
      }
      const temp = temperature[idx];
      const moist = moisture[idx];
      const tempBand = getTempBand(temp);
      const moistureLevel = getMoistureLevel(moist);
      biomes[y][x] = BIOME_MATRIX[tempBand][moistureLevel];
    }
  }
  return {
    width,
    height,
    biomes,
    temperature,
    moisture
  };
}
function getTempBand(temperature) {
  for (const band of TEMP_BANDS) {
    if (temperature >= band.min && temperature < band.max) {
      return band.index;
    }
  }
  return 2;
}
function getMoistureLevel(moisture) {
  const level = Math.floor(moisture / 100 * 26);
  return Math.min(25, Math.max(0, level));
}

// dist/engine/worldgen/river.js
var import_seedrandom3 = __toESM(require_seedrandom2(), 1);
var toIndex4 = (x, y, width) => y * width + x;
var fromIndex2 = (index, width) => ({ x: index % width, y: Math.floor(index / width) });
function generateRivers(options) {
  const {
    seed,
    width,
    height,
    elevation,
    seaLevel = 20,
    precipitation,
    minFlux = 300
    // Increased threshold - fewer river branches, reduces lake seed points
  } = options;
  const size = width * height;
  const rng2 = (0, import_seedrandom3.default)(seed);
  const workingElevation = new Uint8Array(elevation);
  ensureSeaOutlets(workingElevation, seaLevel, width, height);
  const oceanDistance = calculateOceanDistance2(workingElevation, seaLevel, width, height);
  carveSpillways(workingElevation, oceanDistance, seaLevel, width, height);
  let precipFlat;
  if (precipitation) {
    precipFlat = precipitation;
  } else {
    precipFlat = new Float32Array(size);
    precipFlat.fill(100);
  }
  const flowDirection = calculateFlowDirection(workingElevation, oceanDistance, seaLevel, width, height);
  const flowMapFlat = calculateFlowAccumulation(workingElevation, oceanDistance, precipFlat, seaLevel, flowDirection, width, height);
  const sources = findRiverSources(flowMapFlat, workingElevation, seaLevel, minFlux, rng2, width, height);
  const incomingCounts = calculateIncomingCounts(flowDirection, size);
  const rivers = [];
  const globalVisited = new Uint8Array(size);
  const pathSetBuffer = new Int32Array(size);
  let traceIdCounter = 1;
  for (const source of sources) {
    const sourceIdx = toIndex4(source.x, source.y, width);
    if (globalVisited[sourceIdx] === 1)
      continue;
    const river = traceRiverPath(
      source,
      workingElevation,
      flowMapFlat,
      // Use flat map internally
      flowDirection,
      incomingCounts,
      seaLevel,
      globalVisited,
      pathSetBuffer,
      traceIdCounter++,
      width,
      height
    );
    if (river && river.path.length > 10) {
      river.id = `river_${rivers.length + 1}`;
      rivers.push(river);
    }
  }
  const flowMap2D = Array.from({ length: height }, (_, y) => Array.from({ length: width }, (_2, x) => flowMapFlat[toIndex4(x, y, width)]));
  return {
    rivers,
    flowMap: flowMap2D
  };
}
function calculateFlowDirection(elevation, oceanDistance, seaLevel, width, height) {
  const size = width * height;
  const dir = new Int32Array(size).fill(-1);
  const neighborDeltas = [
    { x: 0, y: -1 },
    // N
    { x: 1, y: -1 },
    // NE
    { x: 1, y: 0 },
    // E
    { x: 1, y: 1 },
    // SE
    { x: 0, y: 1 },
    // S
    { x: -1, y: 1 },
    // SW
    { x: -1, y: 0 },
    // W
    { x: -1, y: -1 }
    // NW
  ];
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex4(x, y, width);
      if (elevation[idx] < seaLevel)
        continue;
      const currentElev = elevation[idx];
      const currentDist = oceanDistance[idx];
      let bestIdx = -1;
      let maxDrop = -Infinity;
      let bestDist = Infinity;
      for (const { x: dx, y: dy } of neighborDeltas) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
          const nIdx = toIndex4(nx, ny, width);
          const nElev = elevation[nIdx];
          const nDist = oceanDistance[nIdx];
          const drop = currentElev - nElev;
          const isValid2 = drop > 0 || drop === 0 && nDist < currentDist;
          if (isValid2) {
            if (drop > maxDrop) {
              maxDrop = drop;
              bestDist = nDist;
              bestIdx = nIdx;
            } else if (drop === maxDrop) {
              if (nDist < bestDist) {
                bestDist = nDist;
                bestIdx = nIdx;
              }
            }
          }
        }
      }
      if (bestIdx !== -1) {
        dir[idx] = bestIdx;
      }
    }
  }
  return dir;
}
function calculateFlowAccumulation(elevation, oceanDistance, precipitation, seaLevel, flowDirection, width, height) {
  const size = width * height;
  const flow = new Float32Array(size);
  for (let i = 0; i < size; i++) {
    if (elevation[i] >= seaLevel) {
      flow[i] = precipitation[i];
    }
  }
  const cells = new Int32Array(size);
  let cellCount = 0;
  for (let i = 0; i < size; i++) {
    if (elevation[i] >= seaLevel) {
      cells[cellCount++] = i;
    }
  }
  const validCells = cells.subarray(0, cellCount);
  validCells.sort((a, b) => {
    const elevDiff = elevation[b] - elevation[a];
    if (elevDiff !== 0)
      return elevDiff;
    return oceanDistance[b] - oceanDistance[a];
  });
  for (let i = 0; i < cellCount; i++) {
    const idx = validCells[i];
    const targetIdx = flowDirection[idx];
    if (targetIdx !== -1) {
      flow[targetIdx] += flow[idx];
    }
  }
  return flow;
}
function findRiverSources(flowMap, elevation, seaLevel, minFlux, _rng, width, height) {
  const sources = [];
  const size = width * height;
  const candidates = [];
  for (let i = 0; i < size; i++) {
    if (elevation[i] >= seaLevel && flowMap[i] >= minFlux) {
      candidates.push(i);
    }
  }
  candidates.sort((a, b) => elevation[b] - elevation[a]);
  for (const idx of candidates) {
    sources.push(fromIndex2(idx, width));
  }
  return sources;
}
function traceRiverPath(start, elevation, flowMap, flowDirection, incomingCounts, seaLevel, globalVisited, pathSetBuffer, traceId, width, height) {
  const path = [start];
  const startIdx = toIndex4(start.x, start.y, width);
  const flux = [clampFlux(flowMap[startIdx])];
  const confluences = [];
  let currentIdx = startIdx;
  pathSetBuffer[currentIdx] = traceId;
  globalVisited[currentIdx] = 1;
  const maxSteps = width * height;
  while (true) {
    const nextIdx = flowDirection[currentIdx];
    if (nextIdx === -1) {
      break;
    }
    const next = fromIndex2(nextIdx, width);
    if (pathSetBuffer[nextIdx] === traceId) {
      console.warn("Cycle detected in river path, terminating");
      break;
    }
    pathSetBuffer[nextIdx] = traceId;
    path.push(next);
    flux.push(clampFlux(flowMap[nextIdx]));
    globalVisited[nextIdx] = 1;
    if (incomingCounts[nextIdx] > 1) {
      confluences.push(next);
    }
    if (elevation[nextIdx] < seaLevel) {
      break;
    }
    if (path.length > maxSteps) {
      console.warn("River path exceeded grid cells, terminating");
      break;
    }
    currentIdx = nextIdx;
  }
  return {
    id: "",
    path,
    flux,
    confluences
  };
}
function clampFlux(val) {
  return Math.max(0, Math.min(1e4, val));
}
function calculateIncomingCounts(flowDirection, size) {
  const counts = new Int32Array(size);
  for (let i = 0; i < size; i++) {
    const target = flowDirection[i];
    if (target !== -1) {
      counts[target]++;
    }
  }
  return counts;
}
function ensureSeaOutlets(elevation, seaLevel, width, height) {
  let hasOcean = false;
  const size = width * height;
  for (let i = 0; i < size; i++) {
    if (elevation[i] < seaLevel) {
      hasOcean = true;
      break;
    }
  }
  if (!hasOcean) {
    let minEdgeElev = 255;
    let minEdgeIdx = -1;
    for (let x = 0; x < width; x++) {
      const topIdx = x;
      const bottomIdx = (height - 1) * width + x;
      if (elevation[topIdx] < minEdgeElev) {
        minEdgeElev = elevation[topIdx];
        minEdgeIdx = topIdx;
      }
      if (elevation[bottomIdx] < minEdgeElev) {
        minEdgeElev = elevation[bottomIdx];
        minEdgeIdx = bottomIdx;
      }
    }
    for (let y = 0; y < height; y++) {
      const leftIdx = y * width;
      const rightIdx = y * width + (width - 1);
      if (elevation[leftIdx] < minEdgeElev) {
        minEdgeElev = elevation[leftIdx];
        minEdgeIdx = leftIdx;
      }
      if (elevation[rightIdx] < minEdgeElev) {
        minEdgeElev = elevation[rightIdx];
        minEdgeIdx = rightIdx;
      }
    }
    if (minEdgeIdx !== -1) {
      elevation[minEdgeIdx] = Math.max(0, seaLevel - 1);
    }
  }
}
function calculateOceanDistance2(elevation, seaLevel, width, height) {
  const size = width * height;
  const distance = new Int32Array(size).fill(2147483647);
  const queue = new Int32Array(size);
  let head = 0;
  let tail = 0;
  let initialQueueSize = 0;
  for (let i = 0; i < size; i++) {
    if (elevation[i] < seaLevel) {
      distance[i] = 0;
      queue[tail++] = i;
      initialQueueSize++;
    }
  }
  console.error(`BFS Initializing Queue Size: ${initialQueueSize} for size ${size} (seaLevel: ${seaLevel})`);
  const neighborDeltas = [
    { x: 0, y: -1 },
    { x: 1, y: 0 },
    { x: 0, y: 1 },
    { x: -1, y: 0 }
  ];
  while (head < tail) {
    const idx = queue[head++];
    const { x, y } = fromIndex2(idx, width);
    const dist = distance[idx];
    for (const { x: dx, y: dy } of neighborDeltas) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
        const nIdx = toIndex4(nx, ny, width);
        if (distance[nIdx] > dist + 1) {
          distance[nIdx] = dist + 1;
          queue[tail++] = nIdx;
        }
      }
    }
  }
  return distance;
}
function carveSpillways(elevation, oceanDistance, seaLevel, width, height) {
  const size = width * height;
  const cells = new Int32Array(size);
  for (let i = 0; i < size; i++)
    cells[i] = i;
  cells.sort((a, b) => oceanDistance[b] - oceanDistance[a]);
  const neighbors = [
    { x: 1, y: 0 },
    { x: -1, y: 0 },
    { x: 0, y: 1 },
    { x: 0, y: -1 }
  ];
  for (let i = 0; i < size; i++) {
    const idx = cells[i];
    const { x, y } = fromIndex2(idx, width);
    if (elevation[idx] < seaLevel)
      continue;
    const currentElev = elevation[idx];
    const currentDist = oceanDistance[idx];
    let bestNIdx = -1;
    let bestNElev = Number.MAX_VALUE;
    for (const { x: dx, y: dy } of neighbors) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || ny < 0 || nx >= width || ny >= height)
        continue;
      const nIdx = toIndex4(nx, ny, width);
      const dist = oceanDistance[nIdx];
      if (dist >= currentDist)
        continue;
      const elev = elevation[nIdx];
      if (elev < bestNElev) {
        bestNElev = elev;
        bestNIdx = nIdx;
      }
    }
    if (bestNIdx !== -1 && bestNElev > currentElev) {
      elevation[bestNIdx] = currentElev;
    } else if (bestNIdx === -1) {
      console.error(`CarveSpillways failed for cell ${x},${y} dist=${currentDist} elev=${currentElev}`);
    }
  }
}

// dist/engine/worldgen/lakes.js
var toIndex5 = (x, y, width) => y * width + x;
var fromIndex3 = (index, width) => ({
  x: index % width,
  y: Math.floor(index / width)
});
var NEIGHBORS_8 = [
  { dx: 0, dy: -1 },
  // N
  { dx: 1, dy: -1 },
  // NE
  { dx: 1, dy: 0 },
  // E
  { dx: 1, dy: 1 },
  // SE
  { dx: 0, dy: 1 },
  // S
  { dx: -1, dy: 1 },
  // SW
  { dx: -1, dy: 0 },
  // W
  { dx: -1, dy: -1 }
  // NW
];
var NEIGHBORS_4 = [
  { dx: 0, dy: -1 },
  { dx: 1, dy: 0 },
  { dx: 0, dy: 1 },
  { dx: -1, dy: 0 }
];
function generateLakes(options) {
  const {
    width,
    height,
    elevation,
    rivers,
    seaLevel = 20,
    minLakeSize = 6,
    // Increased from 4 - require larger depressions
    maxLakeSize = 60,
    // Reduced from 100 - fewer massive lakes
    minDepth = 4,
    // Increased from 2 - require deeper depressions
    maxFillDepth = 12,
    // Reduced from 15 - shallower lake fills
    maxLakeElevation = 55
    // Lakes only form below this elevation (0-100 scale)
  } = options;
  const size = width * height;
  const lakeMap = new Uint8Array(size);
  const spillways = [];
  const processed = new Uint8Array(size);
  const depressionSeeds = findDepressionSeeds(elevation, rivers, seaLevel, maxLakeElevation, width, height);
  console.error(`Found ${depressionSeeds.length} potential depression seeds`);
  let lakeCount = 0;
  depressionSeeds.sort((a, b) => elevation[a] - elevation[b]);
  for (const seedIdx of depressionSeeds) {
    if (processed[seedIdx])
      continue;
    const seedElev = elevation[seedIdx];
    const depression = findDepressionBoundary(
      seedIdx,
      elevation,
      seaLevel,
      processed,
      width,
      height,
      maxLakeSize * 3
      // Search limit (larger than max lake to find rim)
    );
    if (!depression)
      continue;
    const { pourPoint, pourPointElev, basinTiles } = depression;
    const depth = pourPointElev - seedElev;
    if (depth < minDepth) {
      for (const idx of basinTiles) {
        processed[idx] = 1;
      }
      continue;
    }
    const maxLakeLevel = seedElev + maxFillDepth;
    const lakeLevel = Math.min(pourPointElev - 1, maxLakeLevel);
    const lakeTiles = fillToLevel(seedIdx, lakeLevel, elevation, seaLevel, processed, width, height, maxLakeSize);
    if (lakeTiles.length >= minLakeSize && lakeTiles.length <= maxLakeSize) {
      for (const idx of lakeTiles) {
        lakeMap[idx] = 1;
        processed[idx] = 1;
      }
      lakeCount++;
      if (pourPoint !== -1) {
        const spillway = createSpillway(pourPoint, lakeTiles, elevation, seaLevel, width, height);
        if (spillway) {
          spillways.push(spillway);
        }
      }
      console.error(`Created lake #${lakeCount}: ${lakeTiles.length} tiles, depth=${depth}, level=${lakeLevel}`);
    } else {
      for (const idx of basinTiles) {
        processed[idx] = 1;
      }
      if (lakeTiles.length > maxLakeSize) {
        console.error(`Rejected lake: too large (${lakeTiles.length} tiles)`);
      }
    }
  }
  return { lakeMap, lakeCount, spillways };
}
function findDepressionSeeds(elevation, rivers, seaLevel, maxLakeElevation, width, height) {
  const seeds = [];
  for (let y = 1; y < height - 1; y++) {
    for (let x = 1; x < width - 1; x++) {
      const idx = toIndex5(x, y, width);
      if (rivers[idx] === 0)
        continue;
      if (elevation[idx] < seaLevel)
        continue;
      if (elevation[idx] > maxLakeElevation)
        continue;
      const elev = elevation[idx];
      let isLocalMin = true;
      let neighborCount = 0;
      let higherNeighbors = 0;
      let nearOcean = false;
      for (const { dx, dy } of NEIGHBORS_8) {
        const nx = x + dx;
        const ny = y + dy;
        if (nx < 0 || nx >= width || ny < 0 || ny >= height)
          continue;
        const nIdx = toIndex5(nx, ny, width);
        neighborCount++;
        if (elevation[nIdx] < seaLevel) {
          nearOcean = true;
          break;
        }
        if (elevation[nIdx] < elev) {
          isLocalMin = false;
        }
        if (elevation[nIdx] > elev) {
          higherNeighbors++;
        }
      }
      if (nearOcean)
        continue;
      if (isLocalMin && higherNeighbors >= neighborCount * 0.75) {
        seeds.push(idx);
      }
    }
  }
  return seeds;
}
function findDepressionBoundary(seedIdx, elevation, seaLevel, processed, width, height, searchLimit) {
  const seedElev = elevation[seedIdx];
  const basinTiles = [];
  const visited = /* @__PURE__ */ new Set();
  const queue = [seedIdx];
  visited.add(seedIdx);
  let pourPoint = -1;
  let pourPointElev = Infinity;
  while (queue.length > 0 && basinTiles.length < searchLimit) {
    const idx = queue.shift();
    const elev = elevation[idx];
    if (elev < seaLevel)
      continue;
    if (processed[idx])
      continue;
    basinTiles.push(idx);
    const { x, y } = fromIndex3(idx, width);
    for (const { dx, dy } of NEIGHBORS_4) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || nx >= width || ny < 0 || ny >= height)
        continue;
      const nIdx = toIndex5(nx, ny, width);
      if (visited.has(nIdx))
        continue;
      visited.add(nIdx);
      const nElev = elevation[nIdx];
      if (nElev < seaLevel) {
        return null;
      }
      if (nElev > seedElev + 1) {
        if (nElev < pourPointElev) {
          pourPointElev = nElev;
          pourPoint = nIdx;
        }
      } else {
        queue.push(nIdx);
      }
    }
  }
  if (pourPoint === -1 || pourPointElev <= seedElev) {
    return null;
  }
  return { pourPoint, pourPointElev, basinTiles };
}
function fillToLevel(seedIdx, lakeLevel, elevation, seaLevel, processed, width, height, maxSize) {
  const lakeTiles = [];
  const visited = /* @__PURE__ */ new Set();
  const queue = [seedIdx];
  visited.add(seedIdx);
  while (queue.length > 0 && lakeTiles.length < maxSize) {
    const idx = queue.shift();
    const elev = elevation[idx];
    if (elev > lakeLevel || elev < seaLevel)
      continue;
    if (processed[idx])
      continue;
    lakeTiles.push(idx);
    const { x, y } = fromIndex3(idx, width);
    for (const { dx, dy } of NEIGHBORS_4) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || nx >= width || ny < 0 || ny >= height)
        continue;
      const nIdx = toIndex5(nx, ny, width);
      if (visited.has(nIdx))
        continue;
      visited.add(nIdx);
      queue.push(nIdx);
    }
  }
  return lakeTiles;
}
function createSpillway(pourPoint, lakeTiles, elevation, seaLevel, width, height) {
  const lakeSet = new Set(lakeTiles);
  const { x: pourX, y: pourY } = fromIndex3(pourPoint, width);
  let lakeX = -1;
  let lakeY = -1;
  for (const { dx, dy } of NEIGHBORS_4) {
    const nx = pourX + dx;
    const ny = pourY + dy;
    if (nx < 0 || nx >= width || ny < 0 || ny >= height)
      continue;
    const nIdx = toIndex5(nx, ny, width);
    if (lakeSet.has(nIdx)) {
      lakeX = nx;
      lakeY = ny;
      break;
    }
  }
  if (lakeX === -1)
    return null;
  let outflowX = -1;
  let outflowY = -1;
  let lowestElev = elevation[pourPoint];
  for (const { dx, dy } of NEIGHBORS_8) {
    const nx = pourX + dx;
    const ny = pourY + dy;
    if (nx < 0 || nx >= width || ny < 0 || ny >= height)
      continue;
    const nIdx = toIndex5(nx, ny, width);
    if (lakeSet.has(nIdx))
      continue;
    if (elevation[nIdx] < seaLevel)
      continue;
    const nElev = elevation[nIdx];
    if (nElev < lowestElev) {
      lowestElev = nElev;
      outflowX = nx;
      outflowY = ny;
    }
  }
  if (outflowX === -1)
    return null;
  return {
    lakeX,
    lakeY,
    outflowX,
    outflowY,
    elevation: elevation[pourPoint]
  };
}

// dist/engine/worldgen/regions.js
var import_seedrandom4 = __toESM(require_seedrandom2(), 1);
var toIndex6 = (x, y, width) => y * width + x;
var fromIndex4 = (index, width) => ({ x: index % width, y: Math.floor(index / width) });
function generateRegions(options) {
  const { seed, width, height, elevation, biomes, numRegions = 10, seaLevel = 20 } = options;
  const size = width * height;
  const rng2 = (0, import_seedrandom4.default)(seed);
  const regionMap = new Int32Array(size).fill(-1);
  const regions = [];
  const landIndices = [];
  for (let i = 0; i < size; i++) {
    if (elevation[i] >= seaLevel) {
      landIndices.push(i);
    }
  }
  for (let i = landIndices.length - 1; i > 0; i--) {
    const j = Math.floor(rng2() * (i + 1));
    [landIndices[i], landIndices[j]] = [landIndices[j], landIndices[i]];
  }
  const seeds = [];
  const minDistance = Math.sqrt(size) / numRegions;
  for (const idx of landIndices) {
    if (seeds.length >= numRegions)
      break;
    const { x, y } = fromIndex4(idx, width);
    let tooClose = false;
    for (const seedIdx of seeds) {
      const s = fromIndex4(seedIdx, width);
      const dist = Math.sqrt((x - s.x) ** 2 + (y - s.y) ** 2);
      if (dist < minDistance) {
        tooClose = true;
        break;
      }
    }
    if (!tooClose) {
      seeds.push(idx);
    }
  }
  if (seeds.length < numRegions) {
    for (const idx of landIndices) {
      if (seeds.length >= numRegions)
        break;
      if (!seeds.includes(idx)) {
        seeds.push(idx);
      }
    }
  }
  const queues = [];
  seeds.forEach((seedIdx, id) => {
    const { x, y } = fromIndex4(seedIdx, width);
    regions.push({
      id,
      name: `Region ${id + 1}`,
      capital: { x, y },
      area: 0,
      biome: biomes[y][x]
    });
    regionMap[seedIdx] = id;
    queues.push([seedIdx]);
  });
  let active = true;
  while (active) {
    active = false;
    for (let id = 0; id < regions.length; id++) {
      const queue = queues[id];
      if (queue.length === 0)
        continue;
      const nextQueue = [];
      while (queue.length > 0) {
        const currIdx = queue.shift();
        const { x, y } = fromIndex4(currIdx, width);
        const neighbors = [
          { nx: x, ny: y - 1 },
          { nx: x + 1, ny: y },
          { nx: x, ny: y + 1 },
          { nx: x - 1, ny: y }
        ];
        for (const { nx, ny } of neighbors) {
          if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
            const nIdx = toIndex6(nx, ny, width);
            if (regionMap[nIdx] === -1 && elevation[nIdx] >= seaLevel) {
              regionMap[nIdx] = id;
              nextQueue.push(nIdx);
              regions[id].area++;
              active = true;
            }
          }
        }
      }
      queues[id] = nextQueue;
    }
  }
  return { regions, regionMap };
}

// dist/engine/worldgen/structures.js
var import_seedrandom5 = __toESM(require_seedrandom2(), 1);

// dist/schema/structure.js
init_zod();
var StructureType;
(function(StructureType2) {
  StructureType2["CITY"] = "city";
  StructureType2["TOWN"] = "town";
  StructureType2["VILLAGE"] = "village";
  StructureType2["CASTLE"] = "castle";
  StructureType2["RUINS"] = "ruins";
  StructureType2["DUNGEON"] = "dungeon";
  StructureType2["TEMPLE"] = "temple";
})(StructureType || (StructureType = {}));
var StructureSchema = external_exports.object({
  id: external_exports.string(),
  worldId: external_exports.string(),
  regionId: external_exports.string().optional(),
  name: external_exports.string(),
  type: external_exports.nativeEnum(StructureType),
  x: external_exports.number(),
  y: external_exports.number(),
  population: external_exports.number().nonnegative(),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});

// dist/engine/worldgen/structures.js
var toIndex7 = (x, y, width) => y * width + x;
var fromIndex5 = (index, width) => ({ x: index % width, y: Math.floor(index / width) });
function placeStructures(options) {
  const { seed, width, height, elevation, biomes, riverMap, numCities = 5, numTowns = 10, numDungeons = 5 } = options;
  const size = width * height;
  const rng2 = (0, import_seedrandom5.default)(seed);
  const structures = [];
  const occupied = new Uint8Array(size).fill(0);
  const habitability = new Float32Array(size);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = toIndex7(x, y, width);
      if (elevation[idx] < 20) {
        habitability[idx] = -1;
        continue;
      }
      let score = 0;
      if (riverMap[idx] > 0)
        score += 20;
      const biome = biomes[y][x];
      switch (biome) {
        case BiomeType.GRASSLAND:
        case BiomeType.FOREST:
          score += 10;
          break;
        case BiomeType.SAVANNA:
        case BiomeType.TAIGA:
          score += 5;
          break;
        case BiomeType.DESERT:
        case BiomeType.SWAMP:
        case BiomeType.TUNDRA:
        case BiomeType.GLACIER:
          score -= 10;
          break;
      }
      let maxSlope = 0;
      const neighbors = [
        { nx: x, ny: y - 1 },
        { nx: x + 1, ny: y },
        { nx: x, ny: y + 1 },
        { nx: x - 1, ny: y }
      ];
      for (const { nx, ny } of neighbors) {
        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
          const nIdx = toIndex7(nx, ny, width);
          const slope = Math.abs(elevation[idx] - elevation[nIdx]);
          if (slope > maxSlope)
            maxSlope = slope;
        }
      }
      if (maxSlope < 5)
        score += 10;
      else if (maxSlope > 20)
        score -= 20;
      let coastalNeighbors = 0;
      for (const { nx, ny } of neighbors) {
        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
          const nIdx = toIndex7(nx, ny, width);
          if (elevation[nIdx] < 20) {
            coastalNeighbors++;
          }
        }
      }
      if (coastalNeighbors > 0)
        score += 15;
      habitability[idx] = Math.max(0, score);
    }
  }
  const candidates = [];
  for (let i = 0; i < size; i++) {
    if (habitability[i] > 0) {
      candidates.push({ idx: i, score: habitability[i] });
    }
  }
  candidates.sort((a, b) => b.score - a.score);
  let citiesPlaced = 0;
  for (const candidate of candidates) {
    if (citiesPlaced >= numCities)
      break;
    if (isTooClose(candidate.idx, structures, width, 10))
      continue;
    const { x, y } = fromIndex5(candidate.idx, width);
    structures.push({
      type: StructureType.CITY,
      location: { x, y },
      name: `City ${citiesPlaced + 1}`,
      score: candidate.score
    });
    occupied[candidate.idx] = 1;
    citiesPlaced++;
  }
  let townsPlaced = 0;
  let attempts = 0;
  while (townsPlaced < numTowns && attempts < numTowns * 20) {
    attempts++;
    const idx = Math.floor(rng2() * size);
    if (habitability[idx] > 10 && occupied[idx] === 0) {
      if (isTooClose(idx, structures, width, 5))
        continue;
      const { x, y } = fromIndex5(idx, width);
      structures.push({
        type: StructureType.TOWN,
        location: { x, y },
        name: `Town ${townsPlaced + 1}`,
        score: habitability[idx]
      });
      occupied[idx] = 1;
      townsPlaced++;
    }
  }
  let dungeonsPlaced = 0;
  attempts = 0;
  while (dungeonsPlaced < numDungeons && attempts < numDungeons * 20) {
    attempts++;
    const idx = Math.floor(rng2() * size);
    if (elevation[idx] >= 20 && occupied[idx] === 0) {
      if (habitability[idx] < 40) {
        if (isTooClose(idx, structures, width, 5))
          continue;
        const { x, y } = fromIndex5(idx, width);
        structures.push({
          type: StructureType.DUNGEON,
          location: { x, y },
          name: `Dungeon ${dungeonsPlaced + 1}`,
          score: habitability[idx]
        });
        occupied[idx] = 1;
        dungeonsPlaced++;
      }
    }
  }
  return structures;
}
function isTooClose(idx, structures, width, minDistance) {
  const { x, y } = fromIndex5(idx, width);
  for (const structure of structures) {
    const dx = x - structure.location.x;
    const dy = y - structure.location.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < minDistance)
      return true;
  }
  return false;
}

// dist/engine/worldgen/validation.js
var INVALID_BIOME_PLACEMENTS = {
  [StructureType.CITY]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE,
    BiomeType.GLACIER
  ],
  [StructureType.TOWN]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE,
    BiomeType.GLACIER
  ],
  [StructureType.VILLAGE]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE,
    BiomeType.GLACIER
  ],
  [StructureType.CASTLE]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE,
    BiomeType.SWAMP
  ],
  [StructureType.TEMPLE]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE
  ],
  // Ruins and Dungeons can be almost anywhere (even underwater for ancient ruins)
  [StructureType.RUINS]: [
    BiomeType.DEEP_OCEAN
    // Too deep
  ],
  [StructureType.DUNGEON]: [
    BiomeType.OCEAN,
    BiomeType.DEEP_OCEAN,
    BiomeType.LAKE
  ]
};
var WATER_BIOMES = [
  BiomeType.OCEAN,
  BiomeType.DEEP_OCEAN,
  BiomeType.LAKE
];
function canPlaceStructureOnBiome(structureType, biome) {
  const invalidBiomes = INVALID_BIOME_PLACEMENTS[structureType];
  if (!invalidBiomes) {
    return { valid: true };
  }
  if (invalidBiomes.includes(biome)) {
    const isWater = WATER_BIOMES.includes(biome);
    return {
      valid: false,
      reason: isWater ? `Cannot place ${structureType} in water (${biome})` : `Cannot place ${structureType} on ${biome} terrain`
    };
  }
  return { valid: true };
}
function validateStructurePlacement(structureType, x, y, world) {
  if (x < 0 || x >= world.width || y < 0 || y >= world.height) {
    return {
      valid: false,
      reason: `Coordinates (${x}, ${y}) are out of bounds (world is ${world.width}x${world.height})`
    };
  }
  const biome = world.biomes[y][x];
  const idx = y * world.width + x;
  const elevation = world.elevation[idx];
  const biomeCheck = canPlaceStructureOnBiome(structureType, biome);
  if (!biomeCheck.valid) {
    return {
      ...biomeCheck,
      biome,
      elevation
    };
  }
  if (elevation < 20 && structureType !== StructureType.RUINS) {
    return {
      valid: false,
      reason: `Location (${x}, ${y}) is below sea level (elevation: ${elevation})`,
      biome,
      elevation
    };
  }
  return { valid: true, biome, elevation };
}
var BIOME_HABITABILITY = {
  [BiomeType.GRASSLAND]: 15,
  [BiomeType.FOREST]: 12,
  [BiomeType.SAVANNA]: 8,
  [BiomeType.TAIGA]: 5,
  [BiomeType.RAINFOREST]: 6,
  [BiomeType.DESERT]: -5,
  [BiomeType.SWAMP]: -8,
  [BiomeType.TUNDRA]: -10,
  [BiomeType.GLACIER]: -20,
  [BiomeType.OCEAN]: -100,
  [BiomeType.DEEP_OCEAN]: -100,
  [BiomeType.LAKE]: -100
};
function getSuggestedBiomesForStructure(structureType) {
  const goodBiomes = [];
  for (const [biome, score] of Object.entries(BIOME_HABITABILITY)) {
    if (score > 0) {
      const check2 = canPlaceStructureOnBiome(structureType, biome);
      if (check2.valid) {
        goodBiomes.push(biome);
      }
    }
  }
  return goodBiomes;
}

// dist/engine/worldgen/index.js
function generateWorld(options) {
  const { seed, width, height, landRatio, octaves, numRegions, numCities, numTowns, numDungeons, temperatureOffset, moistureOffset } = options;
  const elevation = generateHeightmap(seed, width, height, {
    landRatio,
    octaves
  });
  const climate = generateClimateMap(seed, width, height, elevation, {
    temperatureOffset,
    moistureOffset
  });
  const biomeMap = generateBiomeMap({
    width,
    height,
    temperature: climate.temperature,
    moisture: climate.moisture,
    elevation
  });
  const precipitation = new Float32Array(width * height);
  for (let i = 0; i < width * height; i++)
    precipitation[i] = climate.moisture[i];
  const riverSystem = generateRivers({
    seed,
    width,
    height,
    elevation,
    precipitation
  });
  const riverMap = new Uint8Array(width * height).fill(0);
  for (const river of riverSystem.rivers) {
    for (const p of river.path) {
      riverMap[p.y * width + p.x] = 1;
    }
  }
  const lakeResult = generateLakes({
    width,
    height,
    elevation,
    rivers: riverMap
  });
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      if (lakeResult.lakeMap[idx] === 1) {
        biomeMap.biomes[y][x] = BiomeType.LAKE;
        riverMap[idx] = 0;
      }
    }
  }
  const SEA_LEVEL = 20;
  for (const spillway of lakeResult.spillways) {
    traceSpillwayRiver(spillway, elevation, riverMap, lakeResult.lakeMap, SEA_LEVEL, width, height);
  }
  const regionData = generateRegions({
    seed,
    width,
    height,
    elevation,
    biomes: biomeMap.biomes,
    numRegions
  });
  const structures = placeStructures({
    seed,
    width,
    height,
    elevation,
    biomes: biomeMap.biomes,
    riverMap,
    numCities,
    numTowns,
    numDungeons
  });
  for (let i = 0; i < width * height; i++) {
    if (elevation[i] < SEA_LEVEL) {
      elevation[i] = 0;
    } else {
      const landElev = elevation[i] - SEA_LEVEL;
      elevation[i] = Math.round(1 + landElev / 80 * 99);
    }
  }
  return {
    seed,
    width,
    height,
    elevation,
    temperature: climate.temperature,
    moisture: climate.moisture,
    biomes: biomeMap.biomes,
    rivers: riverMap,
    regions: regionData.regions,
    regionMap: regionData.regionMap,
    structures
  };
}
function traceSpillwayRiver(spillway, elevation, riverMap, lakeMap, seaLevel, width, height) {
  const neighbors = [
    { dx: 0, dy: -1 },
    { dx: 1, dy: -1 },
    { dx: 1, dy: 0 },
    { dx: 1, dy: 1 },
    { dx: 0, dy: 1 },
    { dx: -1, dy: 1 },
    { dx: -1, dy: 0 },
    { dx: -1, dy: -1 }
  ];
  let x = spillway.outflowX;
  let y = spillway.outflowY;
  const maxSteps = width * height;
  const visited = /* @__PURE__ */ new Set();
  for (let step = 0; step < maxSteps; step++) {
    const idx = y * width + x;
    if (elevation[idx] < seaLevel)
      break;
    if (riverMap[idx] === 1)
      break;
    if (lakeMap[idx] === 1)
      break;
    if (visited.has(idx))
      break;
    visited.add(idx);
    riverMap[idx] = 1;
    const currentElev = elevation[idx];
    let bestX = -1;
    let bestY = -1;
    let lowestElev = currentElev;
    for (const { dx, dy } of neighbors) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || nx >= width || ny < 0 || ny >= height)
        continue;
      const nIdx = ny * width + nx;
      const nElev = elevation[nIdx];
      if (lakeMap[nIdx] === 1)
        continue;
      if (nElev < lowestElev || nElev === lowestElev && bestX === -1) {
        lowestElev = nElev;
        bestX = nx;
        bestY = ny;
      }
    }
    if (bestX === -1)
      break;
    x = bestX;
    y = bestY;
  }
}

// dist/server/tools.js
var import_crypto = require("crypto");

// dist/server/state/world-manager.js
var WorldManager = class {
  worlds = /* @__PURE__ */ new Map();
  create(id, world) {
    if (this.worlds.has(id)) {
      throw new Error(`World ${id} already exists`);
    }
    this.worlds.set(id, world);
  }
  get(id) {
    return this.worlds.get(id) || null;
  }
  delete(id) {
    return this.worlds.delete(id);
  }
  list() {
    return Array.from(this.worlds.keys());
  }
};
var instance = null;
function getWorldManager() {
  if (!instance)
    instance = new WorldManager();
  return instance;
}

// dist/schema/world.js
init_zod();
var WorldSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string().min(1),
  seed: external_exports.string().min(1),
  width: external_exports.number().positive(),
  height: external_exports.number().positive(),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime(),
  environment: external_exports.object({
    date: external_exports.string().optional(),
    timeOfDay: external_exports.string().optional(),
    season: external_exports.string().optional(),
    moonPhase: external_exports.string().optional(),
    weatherConditions: external_exports.string().optional(),
    temperature: external_exports.string().optional(),
    lighting: external_exports.string().optional()
  }).passthrough().optional()
});

// dist/storage/repos/world.repo.js
var WorldRepository = class {
  db;
  constructor(db) {
    this.db = db;
    this.ensureEnvironmentColumn();
  }
  ensureEnvironmentColumn() {
    try {
      const columns = this.db.prepare(`PRAGMA table_info(worlds)`).all();
      const hasEnv = columns.some((col) => col.name === "environment");
      if (!hasEnv) {
        this.db.exec(`ALTER TABLE worlds ADD COLUMN environment TEXT`);
      }
    } catch (err) {
    }
  }
  create(world) {
    const validWorld = WorldSchema.parse(world);
    const stmt = this.db.prepare(`
      INSERT INTO worlds (id, name, seed, width, height, created_at, updated_at, environment)
      VALUES (@id, @name, @seed, @width, @height, @createdAt, @updatedAt, @environment)
    `);
    stmt.run({
      id: validWorld.id,
      name: validWorld.name,
      seed: validWorld.seed,
      width: validWorld.width,
      height: validWorld.height,
      createdAt: validWorld.createdAt,
      updatedAt: validWorld.updatedAt,
      environment: JSON.stringify(validWorld.environment || {})
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM worlds WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    let environment = {};
    if (row.environment) {
      try {
        environment = JSON.parse(row.environment);
      } catch {
        environment = {};
      }
    }
    return WorldSchema.parse({
      id: row.id,
      name: row.name,
      seed: row.seed,
      width: row.width,
      height: row.height,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      environment
    });
  }
  findAll() {
    const stmt = this.db.prepare("SELECT * FROM worlds");
    const rows = stmt.all();
    return rows.map((row) => WorldSchema.parse({
      id: row.id,
      name: row.name,
      seed: row.seed,
      width: row.width,
      height: row.height,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      environment: (() => {
        if (!row.environment)
          return {};
        try {
          return JSON.parse(row.environment);
        } catch {
          return {};
        }
      })()
    }));
  }
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM worlds WHERE id = ?");
    stmt.run(id);
  }
  updateEnvironment(id, envPatch) {
    const current = this.findById(id);
    if (!current)
      return null;
    const mergedEnv = { ...current.environment || {}, ...envPatch };
    const updatedAt = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
          UPDATE worlds
          SET environment = @environment,
              updated_at = @updatedAt
          WHERE id = @id
        `);
    stmt.run({
      id,
      environment: JSON.stringify(mergedEnv),
      updatedAt
    });
    return {
      ...current,
      environment: mergedEnv,
      updatedAt
    };
  }
};

// dist/storage/index.js
var import_path = require("path");
var import_fs2 = require("fs");

// dist/storage/db.js
var import_better_sqlite3 = __toESM(require_better_sqlite3(), 1);
var import_fs = require("fs");
function checkDatabaseIntegrity(db) {
  try {
    const result = db.pragma("integrity_check");
    const errors = result.map((row) => row.integrity_check).filter((msg) => msg !== "ok");
    return {
      ok: errors.length === 0,
      errors
    };
  } catch (e) {
    return {
      ok: false,
      errors: [e.message]
    };
  }
}
function handleCorruptedDatabase(path, error) {
  console.error(`[Database] CRITICAL: Database corruption detected at ${path}`);
  console.error(`[Database] Error: ${error.message}`);
  const walPath = `${path}-wal`;
  const shmPath = `${path}-shm`;
  console.error("[Database] Attempting recovery by removing corrupted files...");
  try {
    if ((0, import_fs.existsSync)(path)) {
      (0, import_fs.unlinkSync)(path);
      console.error(`[Database] Removed corrupted database: ${path}`);
    }
    if ((0, import_fs.existsSync)(walPath)) {
      (0, import_fs.unlinkSync)(walPath);
      console.error(`[Database] Removed WAL file: ${walPath}`);
    }
    if ((0, import_fs.existsSync)(shmPath)) {
      (0, import_fs.unlinkSync)(shmPath);
      console.error(`[Database] Removed SHM file: ${shmPath}`);
    }
    console.error("[Database] Recovery complete. A fresh database will be created.");
  } catch (cleanupError) {
    console.error(`[Database] Failed to clean up corrupted files: ${cleanupError.message}`);
    throw new Error(`Database is corrupted and cleanup failed. Please manually delete: ${path}, ${walPath}, ${shmPath}`);
  }
}
function initDB(path) {
  console.error(`[Database] Opening database: ${path}`);
  let db;
  try {
    db = new import_better_sqlite3.default(path);
  } catch (e) {
    const error = e;
    if (error.message.includes("SQLITE_CORRUPT") || error.message.includes("malformed")) {
      handleCorruptedDatabase(path, error);
      db = new import_better_sqlite3.default(path);
    } else {
      throw e;
    }
  }
  db.pragma("journal_mode = WAL");
  db.pragma("foreign_keys = ON");
  const integrity = checkDatabaseIntegrity(db);
  if (!integrity.ok) {
    console.error("[Database] Integrity check failed:");
    integrity.errors.forEach((err) => console.error(`  - ${err}`));
    db.close();
    handleCorruptedDatabase(path, new Error(integrity.errors.join(", ")));
    db = new import_better_sqlite3.default(path);
    db.pragma("journal_mode = WAL");
    db.pragma("foreign_keys = ON");
    console.error("[Database] Fresh database created after corruption recovery");
  } else {
    console.error("[Database] Integrity check passed");
  }
  return db;
}

// dist/storage/migrations.js
function migrate(db) {
  db.exec(`
    CREATE TABLE IF NOT EXISTS worlds(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    seed TEXT NOT NULL,
    width INTEGER NOT NULL,
    height INTEGER NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS regions(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    center_x INTEGER NOT NULL,
    center_y INTEGER NOT NULL,
    color TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS tiles(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    x INTEGER NOT NULL,
    y INTEGER NOT NULL,
    biome TEXT NOT NULL,
    elevation INTEGER NOT NULL,
    moisture INTEGER NOT NULL,
    temperature INTEGER NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE,
    UNIQUE(world_id, x, y)
  );

    CREATE TABLE IF NOT EXISTS structures(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    region_id TEXT,
    name TEXT NOT NULL,
    type TEXT NOT NULL,
    x INTEGER NOT NULL,
    y INTEGER NOT NULL,
    population INTEGER NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    metadata TEXT,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS rivers(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    name TEXT NOT NULL,
    path TEXT NOT NULL, --JSON array of coordinates
      width INTEGER NOT NULL,
    source_elevation INTEGER NOT NULL,
    mouth_elevation INTEGER NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS characters(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    stats TEXT NOT NULL, --JSON
      hp INTEGER NOT NULL,
    max_hp INTEGER NOT NULL,
    ac INTEGER NOT NULL,
    level INTEGER NOT NULL,
    faction_id TEXT,
    behavior TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS encounters(
    id TEXT PRIMARY KEY,
    region_id TEXT,
    tokens TEXT NOT NULL, --JSON
      round INTEGER NOT NULL,
    active_token_id TEXT,
    status TEXT NOT NULL,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(region_id) REFERENCES regions(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS patches(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    op TEXT NOT NULL,
    path TEXT NOT NULL,
    value TEXT, --JSON
      timestamp TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS battlefield(
    id TEXT PRIMARY KEY,
    encounter_id TEXT NOT NULL,
    grid_data TEXT NOT NULL, --JSON
      created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(encounter_id) REFERENCES encounters(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS audit_logs(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    action TEXT NOT NULL,
    actor_id TEXT,
    target_id TEXT,
    details TEXT, --JSON
      timestamp TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS event_logs(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    type TEXT NOT NULL,
    payload TEXT NOT NULL, --JSON
      timestamp TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS items(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    type TEXT NOT NULL,
    weight REAL NOT NULL DEFAULT 0,
    value INTEGER NOT NULL DEFAULT 0,
    properties TEXT, --JSON
      created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

    CREATE TABLE IF NOT EXISTS inventory_items(
    character_id TEXT NOT NULL,
    item_id TEXT NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    equipped INTEGER NOT NULL DEFAULT 0, --boolean 0 / 1
      slot TEXT,
    PRIMARY KEY(character_id, item_id),
    FOREIGN KEY(character_id) REFERENCES characters(id) ON DELETE CASCADE,
    FOREIGN KEY(item_id) REFERENCES items(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS quests(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    name TEXT NOT NULL,
    description TEXT NOT NULL,
    status TEXT NOT NULL,
    objectives TEXT NOT NULL, --JSON
      rewards TEXT NOT NULL, --JSON
      prerequisites TEXT NOT NULL, --JSON
      giver TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS quest_logs(
    character_id TEXT PRIMARY KEY,
    active_quests TEXT NOT NULL, --JSON array of IDs
      completed_quests TEXT NOT NULL, --JSON array of IDs
      failed_quests TEXT NOT NULL, --JSON array of IDs
      FOREIGN KEY(character_id) REFERENCES characters(id) ON DELETE CASCADE
  );

    CREATE TABLE IF NOT EXISTS calculations(
    id TEXT PRIMARY KEY,
    session_id TEXT,
    input TEXT NOT NULL,
    result TEXT NOT NULL, --JSON or string
      steps TEXT, --JSON array
      seed TEXT,
    timestamp TEXT NOT NULL,
    metadata TEXT-- JSON
  );

  CREATE TABLE IF NOT EXISTS turn_state(
    world_id TEXT PRIMARY KEY,
    current_turn INTEGER NOT NULL DEFAULT 1,
    turn_phase TEXT NOT NULL DEFAULT 'planning',
    phase_started_at TEXT NOT NULL,
    nations_ready TEXT NOT NULL DEFAULT '[]',
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

  CREATE TABLE IF NOT EXISTS nations(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    name TEXT NOT NULL,
    leader TEXT NOT NULL,
    ideology TEXT NOT NULL,
    aggression INTEGER NOT NULL DEFAULT 50,
    trust INTEGER NOT NULL DEFAULT 50,
    paranoia INTEGER NOT NULL DEFAULT 50,
    gdp REAL NOT NULL DEFAULT 1000,
    resources TEXT NOT NULL DEFAULT '{"food":0,"metal":0,"oil":0}', --JSON
    relations TEXT NOT NULL DEFAULT '{}', --JSON
    private_memory TEXT, --JSON
    public_intent TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_nations_world ON nations(world_id);

  CREATE TABLE IF NOT EXISTS diplomatic_relations(
    from_nation_id TEXT NOT NULL,
    to_nation_id TEXT NOT NULL,
    opinion INTEGER NOT NULL DEFAULT 0,
    is_allied INTEGER NOT NULL DEFAULT 0,
    truce_until INTEGER,
    updated_at TEXT NOT NULL,
    PRIMARY KEY(from_nation_id, to_nation_id),
    FOREIGN KEY(from_nation_id) REFERENCES nations(id) ON DELETE CASCADE,
    FOREIGN KEY(to_nation_id) REFERENCES nations(id) ON DELETE CASCADE
  );

  CREATE TABLE IF NOT EXISTS territorial_claims(
    id TEXT PRIMARY KEY,
    nation_id TEXT NOT NULL,
    region_id TEXT NOT NULL,
    claim_strength INTEGER NOT NULL DEFAULT 50,
    justification TEXT,
    created_at TEXT NOT NULL,
    FOREIGN KEY(nation_id) REFERENCES nations(id) ON DELETE CASCADE,
    FOREIGN KEY(region_id) REFERENCES regions(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_territorial_claims_nation ON territorial_claims(nation_id);
  CREATE INDEX IF NOT EXISTS idx_territorial_claims_region ON territorial_claims(region_id);

  CREATE TABLE IF NOT EXISTS nation_events(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    world_id TEXT NOT NULL,
    turn_number INTEGER NOT NULL,
    event_type TEXT NOT NULL,
    involved_nations TEXT NOT NULL, --JSON array
    details TEXT NOT NULL, --JSON
    timestamp TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_nation_events_world ON nation_events(world_id);
  CREATE INDEX IF NOT EXISTS idx_nation_events_turn ON nation_events(world_id, turn_number);

  CREATE TABLE IF NOT EXISTS secrets(
    id TEXT PRIMARY KEY,
    world_id TEXT NOT NULL,
    type TEXT NOT NULL,
    category TEXT NOT NULL,
    name TEXT NOT NULL,
    public_description TEXT NOT NULL,
    secret_description TEXT NOT NULL,
    linked_entity_id TEXT,
    linked_entity_type TEXT,
    revealed INTEGER NOT NULL DEFAULT 0,
    revealed_at TEXT,
    revealed_by TEXT,
    reveal_conditions TEXT NOT NULL DEFAULT '[]', --JSON array of conditions
    sensitivity TEXT NOT NULL DEFAULT 'medium',
    leak_patterns TEXT NOT NULL DEFAULT '[]', --JSON array of keywords to avoid
    notes TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_secrets_world ON secrets(world_id);
  CREATE INDEX IF NOT EXISTS idx_secrets_revealed ON secrets(revealed);
  CREATE INDEX IF NOT EXISTS idx_secrets_linked ON secrets(linked_entity_id, linked_entity_type);

  -- Party management tables
  CREATE TABLE IF NOT EXISTS parties(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    world_id TEXT REFERENCES worlds(id) ON DELETE SET NULL,
    status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'dormant', 'archived')),
    current_location TEXT,
    current_quest_id TEXT REFERENCES quests(id) ON DELETE SET NULL,
    formation TEXT NOT NULL DEFAULT 'standard',
    position_x INTEGER,
    position_y INTEGER,
    current_poi TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    last_played_at TEXT
  );

  CREATE TABLE IF NOT EXISTS party_members(
    id TEXT PRIMARY KEY,
    party_id TEXT NOT NULL REFERENCES parties(id) ON DELETE CASCADE,
    character_id TEXT NOT NULL REFERENCES characters(id) ON DELETE CASCADE,
    role TEXT NOT NULL DEFAULT 'member' CHECK (role IN ('leader', 'member', 'companion', 'hireling', 'prisoner', 'mount')),
    is_active INTEGER NOT NULL DEFAULT 0,
    position INTEGER,
    share_percentage INTEGER NOT NULL DEFAULT 100,
    joined_at TEXT NOT NULL,
    notes TEXT,
    UNIQUE(party_id, character_id)
  );

  CREATE INDEX IF NOT EXISTS idx_party_members_party ON party_members(party_id);
  CREATE INDEX IF NOT EXISTS idx_party_members_character ON party_members(character_id);
  CREATE INDEX IF NOT EXISTS idx_parties_status ON parties(status);
  CREATE INDEX IF NOT EXISTS idx_parties_world ON parties(world_id);
  -- idx_parties_position moved to createPostMigrationIndexes (depends on position_x column)

  -- HIGH-004: NPC Memory System
  CREATE TABLE IF NOT EXISTS npc_relationships(
    character_id TEXT NOT NULL,
    npc_id TEXT NOT NULL,
    familiarity TEXT NOT NULL DEFAULT 'stranger' CHECK (familiarity IN ('stranger', 'acquaintance', 'friend', 'close_friend', 'rival', 'enemy')),
    disposition TEXT NOT NULL DEFAULT 'neutral' CHECK (disposition IN ('hostile', 'unfriendly', 'neutral', 'friendly', 'helpful')),
    notes TEXT,
    first_met_at TEXT NOT NULL,
    last_interaction_at TEXT NOT NULL,
    interaction_count INTEGER NOT NULL DEFAULT 1,
    PRIMARY KEY(character_id, npc_id)
  );

  CREATE TABLE IF NOT EXISTS conversation_memories(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    character_id TEXT NOT NULL,
    npc_id TEXT NOT NULL,
    summary TEXT NOT NULL,
    importance TEXT NOT NULL DEFAULT 'medium' CHECK (importance IN ('low', 'medium', 'high', 'critical')),
    topics TEXT NOT NULL DEFAULT '[]', --JSON array of topic keywords
    created_at TEXT NOT NULL
  );

  CREATE INDEX IF NOT EXISTS idx_npc_relationships_char ON npc_relationships(character_id);
  CREATE INDEX IF NOT EXISTS idx_npc_relationships_npc ON npc_relationships(npc_id);
  CREATE INDEX IF NOT EXISTS idx_conversation_memories_char_npc ON conversation_memories(character_id, npc_id);
  CREATE INDEX IF NOT EXISTS idx_conversation_memories_importance ON conversation_memories(importance);

  -- HIGH-008: Stolen Items System
  CREATE TABLE IF NOT EXISTS stolen_items(
    id TEXT PRIMARY KEY,
    item_id TEXT NOT NULL,
    stolen_from TEXT NOT NULL,
    stolen_by TEXT NOT NULL,
    stolen_at TEXT NOT NULL,
    stolen_location TEXT,

    heat_level TEXT NOT NULL DEFAULT 'burning' CHECK (heat_level IN ('burning', 'hot', 'warm', 'cool', 'cold')),
    heat_updated_at TEXT NOT NULL,

    reported_to_guards INTEGER NOT NULL DEFAULT 0,
    bounty INTEGER NOT NULL DEFAULT 0,
    witnesses TEXT NOT NULL DEFAULT '[]',

    recovered INTEGER NOT NULL DEFAULT 0,
    recovered_at TEXT,
    fenced INTEGER NOT NULL DEFAULT 0,
    fenced_at TEXT,
    fenced_to TEXT,

    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,

    FOREIGN KEY(item_id) REFERENCES items(id) ON DELETE CASCADE,
    FOREIGN KEY(stolen_from) REFERENCES characters(id),
    FOREIGN KEY(stolen_by) REFERENCES characters(id)
  );

  CREATE INDEX IF NOT EXISTS idx_stolen_items_item ON stolen_items(item_id);
  CREATE INDEX IF NOT EXISTS idx_stolen_items_thief ON stolen_items(stolen_by);
  CREATE INDEX IF NOT EXISTS idx_stolen_items_victim ON stolen_items(stolen_from);
  CREATE INDEX IF NOT EXISTS idx_stolen_items_heat ON stolen_items(heat_level);

  CREATE TABLE IF NOT EXISTS fence_npcs(
    npc_id TEXT PRIMARY KEY,
    faction_id TEXT,
    buy_rate REAL NOT NULL DEFAULT 0.4,
    max_heat_level TEXT NOT NULL DEFAULT 'hot',
    daily_heat_capacity INTEGER NOT NULL DEFAULT 100,
    current_daily_heat INTEGER NOT NULL DEFAULT 0,
    last_reset_at TEXT NOT NULL,
    specializations TEXT NOT NULL DEFAULT '[]',
    cooldown_days INTEGER NOT NULL DEFAULT 7,
    reputation INTEGER NOT NULL DEFAULT 50,
    FOREIGN KEY(npc_id) REFERENCES characters(id) ON DELETE CASCADE
  );

  -- FAILED-004: Corpse/Loot System
  CREATE TABLE IF NOT EXISTS corpses(
    id TEXT PRIMARY KEY,
    character_id TEXT NOT NULL,
    character_name TEXT NOT NULL,
    character_type TEXT NOT NULL,
    creature_type TEXT,
    cr REAL,

    world_id TEXT,
    region_id TEXT,
    position_x INTEGER,
    position_y INTEGER,
    encounter_id TEXT,

    state TEXT NOT NULL DEFAULT 'fresh' CHECK (state IN ('fresh', 'decaying', 'skeletal', 'gone')),
    state_updated_at TEXT NOT NULL,

    loot_generated INTEGER NOT NULL DEFAULT 0,
    looted INTEGER NOT NULL DEFAULT 0,
    looted_by TEXT,
    looted_at TEXT,

    harvestable INTEGER NOT NULL DEFAULT 0,
    harvestable_resources TEXT NOT NULL DEFAULT '[]',

    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

  CREATE INDEX IF NOT EXISTS idx_corpses_encounter ON corpses(encounter_id);
  CREATE INDEX IF NOT EXISTS idx_corpses_world_position ON corpses(world_id, position_x, position_y);
  CREATE INDEX IF NOT EXISTS idx_corpses_state ON corpses(state);
  CREATE INDEX IF NOT EXISTS idx_corpses_character ON corpses(character_id);

  CREATE TABLE IF NOT EXISTS corpse_inventory(
    corpse_id TEXT NOT NULL,
    item_id TEXT NOT NULL,
    quantity INTEGER NOT NULL DEFAULT 1,
    looted INTEGER NOT NULL DEFAULT 0,
    PRIMARY KEY(corpse_id, item_id),
    FOREIGN KEY(corpse_id) REFERENCES corpses(id) ON DELETE CASCADE,
    FOREIGN KEY(item_id) REFERENCES items(id) ON DELETE CASCADE
  );

  CREATE TABLE IF NOT EXISTS loot_tables(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL,
    creature_types TEXT NOT NULL DEFAULT '[]',
    cr_min REAL,
    cr_max REAL,
    guaranteed_drops TEXT NOT NULL DEFAULT '[]',
    random_drops TEXT NOT NULL DEFAULT '[]',
    currency_range TEXT,
    harvestable_resources TEXT,
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL
  );

  CREATE INDEX IF NOT EXISTS idx_loot_tables_name ON loot_tables(name);

  -- IMPROVISATION SYSTEMS: Custom Effects Table
  -- Tracks divine boons, curses, transformations, and player-invented conditions
  CREATE TABLE IF NOT EXISTS custom_effects(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    target_id TEXT NOT NULL,
    target_type TEXT NOT NULL CHECK (target_type IN ('character', 'npc')),
    name TEXT NOT NULL,
    description TEXT,
    source_type TEXT NOT NULL CHECK (source_type IN ('divine', 'arcane', 'natural', 'cursed', 'psionic', 'unknown')),
    source_entity_id TEXT,
    source_entity_name TEXT,
    category TEXT NOT NULL CHECK (category IN ('boon', 'curse', 'neutral', 'transformative')),
    power_level INTEGER NOT NULL CHECK (power_level BETWEEN 1 AND 5),
    mechanics TEXT NOT NULL DEFAULT '[]', -- JSON array of mechanic objects
    duration_type TEXT NOT NULL CHECK (duration_type IN ('rounds', 'minutes', 'hours', 'days', 'permanent', 'until_removed')),
    duration_value INTEGER,
    rounds_remaining INTEGER,
    triggers TEXT NOT NULL DEFAULT '[]', -- JSON array of trigger objects
    removal_conditions TEXT NOT NULL DEFAULT '[]', -- JSON array of removal condition objects
    stackable INTEGER NOT NULL DEFAULT 0, -- boolean
    max_stacks INTEGER NOT NULL DEFAULT 1,
    current_stacks INTEGER NOT NULL DEFAULT 1,
    is_active INTEGER NOT NULL DEFAULT 1, -- boolean
    created_at TEXT NOT NULL,
    expires_at TEXT
  );

  CREATE INDEX IF NOT EXISTS idx_custom_effects_target ON custom_effects(target_id, target_type);
  CREATE INDEX IF NOT EXISTS idx_custom_effects_active ON custom_effects(is_active);
  CREATE INDEX IF NOT EXISTS idx_custom_effects_name ON custom_effects(name);

  -- IMPROVISATION SYSTEMS: Synthesized Spells Table
  -- Tracks spells permanently learned through Arcane Synthesis mastery
  CREATE TABLE IF NOT EXISTS synthesized_spells(
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    character_id TEXT NOT NULL,
    name TEXT NOT NULL,
    level INTEGER NOT NULL CHECK (level BETWEEN 1 AND 9),
    school TEXT NOT NULL,
    effect_type TEXT NOT NULL,
    effect_dice TEXT,
    damage_type TEXT,
    targeting_type TEXT NOT NULL,
    targeting_range INTEGER NOT NULL,
    targeting_area_size INTEGER,
    targeting_max_targets INTEGER,
    saving_throw_ability TEXT,
    saving_throw_effect TEXT,
    components_verbal INTEGER NOT NULL DEFAULT 1,
    components_somatic INTEGER NOT NULL DEFAULT 1,
    components_material TEXT, -- JSON object or null
    concentration INTEGER NOT NULL DEFAULT 0,
    duration TEXT NOT NULL,
    synthesis_dc INTEGER NOT NULL,
    created_at TEXT NOT NULL,
    mastered_at TEXT NOT NULL,
    times_cast INTEGER NOT NULL DEFAULT 0,
    UNIQUE(character_id, name)
  );

  CREATE INDEX IF NOT EXISTS idx_synthesized_spells_character ON synthesized_spells(character_id);
  CREATE INDEX IF NOT EXISTS idx_synthesized_spells_school ON synthesized_spells(school);

  -- PHASE-1: Spatial Graph System - Room Nodes
  CREATE TABLE IF NOT EXISTS room_nodes(
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL CHECK(length(trim(name)) > 0 AND length(name) <= 100),
    base_description TEXT NOT NULL CHECK(length(trim(base_description)) >= 10 AND length(base_description) <= 2000),
    biome_context TEXT NOT NULL CHECK(biome_context IN (
      'forest', 'mountain', 'urban', 'dungeon', 'coastal', 'cavern', 'divine', 'arcane'
    )),
    atmospherics TEXT NOT NULL DEFAULT '[]', -- JSON array of atmospheric effects
    exits TEXT NOT NULL DEFAULT '[]', -- JSON array of exit objects {direction, targetNodeId, type, dc?, description?}
    entity_ids TEXT NOT NULL DEFAULT '[]', -- JSON array of UUID strings
    created_at TEXT NOT NULL,
    updated_at TEXT NOT NULL,
    visited_count INTEGER NOT NULL DEFAULT 0,
    last_visited_at TEXT
  );

  CREATE INDEX IF NOT EXISTS idx_room_nodes_biome ON room_nodes(biome_context);
  CREATE INDEX IF NOT EXISTS idx_room_nodes_visited ON room_nodes(last_visited_at DESC);

  -- Concentration System - tracks active concentration spells
  CREATE TABLE IF NOT EXISTS concentration(
    character_id TEXT PRIMARY KEY,
    active_spell TEXT NOT NULL,
    spell_level INTEGER NOT NULL CHECK (spell_level BETWEEN 0 AND 9),
    target_ids TEXT, -- JSON array of target IDs
    started_at INTEGER NOT NULL, -- Round number
    max_duration INTEGER, -- Maximum rounds (null = indefinite)
    save_dc_base INTEGER NOT NULL DEFAULT 10, -- Base DC for concentration saves
    FOREIGN KEY(character_id) REFERENCES characters(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_concentration_character ON concentration(character_id);

  -- Aura System - tracks active area-effect auras centered on characters
  CREATE TABLE IF NOT EXISTS auras(
    id TEXT PRIMARY KEY,
    owner_id TEXT NOT NULL,
    spell_name TEXT NOT NULL,
    spell_level INTEGER NOT NULL CHECK (spell_level BETWEEN 0 AND 9),
    radius INTEGER NOT NULL CHECK (radius > 0), -- Radius in feet
    affects_allies INTEGER NOT NULL DEFAULT 0, -- boolean
    affects_enemies INTEGER NOT NULL DEFAULT 0, -- boolean
    affects_self INTEGER NOT NULL DEFAULT 0, -- boolean
    effects TEXT NOT NULL, -- JSON array of AuraEffect objects
    started_at INTEGER NOT NULL, -- Round number
    max_duration INTEGER, -- Maximum rounds (null = indefinite)
    requires_concentration INTEGER NOT NULL DEFAULT 0, -- boolean
    FOREIGN KEY(owner_id) REFERENCES characters(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_auras_owner ON auras(owner_id);

  -- EVENT INBOX: Polling-based event queue for "autonomous" NPC actions
  -- Events are pushed by internal systems, polled by frontend
  CREATE TABLE IF NOT EXISTS event_inbox (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    event_type TEXT NOT NULL CHECK (event_type IN (
      'npc_action', 'combat_update', 'world_change', 'quest_update',
      'time_passage', 'environmental', 'system'
    )),
    payload TEXT NOT NULL,              -- JSON event data
    source_type TEXT CHECK (source_type IN ('npc', 'combat', 'world', 'system', 'scheduler')),
    source_id TEXT,                     -- ID of source entity
    priority INTEGER NOT NULL DEFAULT 0, -- Higher = more urgent
    created_at TEXT NOT NULL DEFAULT (DATETIME('now')),
    consumed_at TEXT,                   -- NULL means unread
    expires_at TEXT                     -- Optional TTL
  );

  CREATE INDEX IF NOT EXISTS idx_event_inbox_unconsumed ON event_inbox(consumed_at) WHERE consumed_at IS NULL;
  CREATE INDEX IF NOT EXISTS idx_event_inbox_created ON event_inbox(created_at DESC);
  CREATE INDEX IF NOT EXISTS idx_event_inbox_priority ON event_inbox(priority DESC);
  `);
  runMigrations(db);
  createPostMigrationIndexes(db);
}
function runMigrations(db) {
  const charColumns = db.prepare("PRAGMA table_info(characters)").all();
  const hasCharacterType = charColumns.some((col) => col.name === "character_type");
  if (!hasCharacterType) {
    console.error("[Migration] Adding character_type column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN character_type TEXT DEFAULT 'pc';`);
  }
  const regionColumns = db.prepare("PRAGMA table_info(regions)").all();
  const hasOwnerNationId = regionColumns.some((col) => col.name === "owner_nation_id");
  const hasControlLevel = regionColumns.some((col) => col.name === "control_level");
  if (!hasOwnerNationId) {
    console.error("[Migration] Adding owner_nation_id column to regions table");
    db.exec(`ALTER TABLE regions ADD COLUMN owner_nation_id TEXT REFERENCES nations(id) ON DELETE SET NULL;`);
  }
  if (!hasControlLevel) {
    console.error("[Migration] Adding control_level column to regions table");
    db.exec(`ALTER TABLE regions ADD COLUMN control_level INTEGER NOT NULL DEFAULT 0;`);
  }
  const partyColumns = db.prepare("PRAGMA table_info(parties)").all();
  const hasPositionX = partyColumns.some((col) => col.name === "position_x");
  const hasPositionY = partyColumns.some((col) => col.name === "position_y");
  const hasCurrentPOI = partyColumns.some((col) => col.name === "current_poi");
  if (!hasPositionX) {
    console.error("[Migration] Adding position_x column to parties table");
    db.exec(`ALTER TABLE parties ADD COLUMN position_x INTEGER;`);
  }
  if (!hasPositionY) {
    console.error("[Migration] Adding position_y column to parties table");
    db.exec(`ALTER TABLE parties ADD COLUMN position_y INTEGER;`);
  }
  if (!hasCurrentPOI) {
    console.error("[Migration] Adding current_poi column to parties table");
    db.exec(`ALTER TABLE parties ADD COLUMN current_poi TEXT;`);
  }
  db.exec(`
    UPDATE parties
    SET position_x = 50, position_y = 50
    WHERE position_x IS NULL;
  `);
  const hasCharacterClass = charColumns.some((col) => col.name === "character_class");
  const hasSpellSlots = charColumns.some((col) => col.name === "spell_slots");
  const hasPactMagicSlots = charColumns.some((col) => col.name === "pact_magic_slots");
  const hasKnownSpells = charColumns.some((col) => col.name === "known_spells");
  const hasPreparedSpells = charColumns.some((col) => col.name === "prepared_spells");
  const hasCantripsKnown = charColumns.some((col) => col.name === "cantrips_known");
  const hasMaxSpellLevel = charColumns.some((col) => col.name === "max_spell_level");
  const hasConcentratingOn = charColumns.some((col) => col.name === "concentrating_on");
  const hasConditions = charColumns.some((col) => col.name === "conditions");
  if (!hasCharacterClass) {
    console.error("[Migration] Adding character_class column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN character_class TEXT DEFAULT 'fighter';`);
  }
  if (!hasSpellSlots) {
    console.error("[Migration] Adding spell_slots column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN spell_slots TEXT;`);
  }
  if (!hasPactMagicSlots) {
    console.error("[Migration] Adding pact_magic_slots column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN pact_magic_slots TEXT;`);
  }
  if (!hasKnownSpells) {
    console.error("[Migration] Adding known_spells column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN known_spells TEXT DEFAULT '[]';`);
  }
  if (!hasPreparedSpells) {
    console.error("[Migration] Adding prepared_spells column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN prepared_spells TEXT DEFAULT '[]';`);
  }
  if (!hasCantripsKnown) {
    console.error("[Migration] Adding cantrips_known column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN cantrips_known TEXT DEFAULT '[]';`);
  }
  if (!hasMaxSpellLevel) {
    console.error("[Migration] Adding max_spell_level column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN max_spell_level INTEGER DEFAULT 0;`);
  }
  if (!hasConcentratingOn) {
    console.error("[Migration] Adding concentrating_on column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN concentrating_on TEXT;`);
  }
  if (!hasConditions) {
    console.error("[Migration] Adding conditions column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN conditions TEXT DEFAULT '[]';`);
  }
  const hasRace = charColumns.some((col) => col.name === "race");
  if (!hasRace) {
    console.error("[Migration] Adding race column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN race TEXT DEFAULT 'Human';`);
  }
  const hasLegendaryActions = charColumns.some((col) => col.name === "legendary_actions");
  const hasLegendaryActionsRemaining = charColumns.some((col) => col.name === "legendary_actions_remaining");
  const hasLegendaryResistances = charColumns.some((col) => col.name === "legendary_resistances");
  const hasLegendaryResistancesRemaining = charColumns.some((col) => col.name === "legendary_resistances_remaining");
  const hasLairActions = charColumns.some((col) => col.name === "has_lair_actions");
  const hasResistances = charColumns.some((col) => col.name === "resistances");
  const hasVulnerabilities = charColumns.some((col) => col.name === "vulnerabilities");
  const hasImmunities = charColumns.some((col) => col.name === "immunities");
  if (!hasLegendaryActions) {
    console.error("[Migration] Adding legendary_actions column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN legendary_actions INTEGER;`);
  }
  if (!hasLegendaryActionsRemaining) {
    console.error("[Migration] Adding legendary_actions_remaining column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN legendary_actions_remaining INTEGER;`);
  }
  if (!hasLegendaryResistances) {
    console.error("[Migration] Adding legendary_resistances column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN legendary_resistances INTEGER;`);
  }
  if (!hasLegendaryResistancesRemaining) {
    console.error("[Migration] Adding legendary_resistances_remaining column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN legendary_resistances_remaining INTEGER;`);
  }
  if (!hasLairActions) {
    console.error("[Migration] Adding has_lair_actions column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN has_lair_actions INTEGER DEFAULT 0;`);
  }
  if (!hasResistances) {
    console.error("[Migration] Adding resistances column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN resistances TEXT DEFAULT '[]';`);
  }
  if (!hasVulnerabilities) {
    console.error("[Migration] Adding vulnerabilities column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN vulnerabilities TEXT DEFAULT '[]';`);
  }
  if (!hasImmunities) {
    console.error("[Migration] Adding immunities column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN immunities TEXT DEFAULT '[]';`);
  }
  const hasCurrency = charColumns.some((col) => col.name === "currency");
  if (!hasCurrency) {
    console.error("[Migration] Adding currency column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN currency TEXT DEFAULT '{"gold":0,"silver":0,"copper":0}';`);
  }
  const corpseColumns = db.prepare("PRAGMA table_info(corpses)").all();
  const hasCorpseCurrency = corpseColumns.some((col) => col.name === "currency");
  if (!hasCorpseCurrency) {
    console.error("[Migration] Adding currency column to corpses table");
    db.exec(`ALTER TABLE corpses ADD COLUMN currency TEXT DEFAULT '{"gold":0,"silver":0,"copper":0}';`);
  }
  const hasCorpseCurrencyLooted = corpseColumns.some((col) => col.name === "currency_looted");
  if (!hasCorpseCurrencyLooted) {
    console.error("[Migration] Adding currency_looted column to corpses table");
    db.exec(`ALTER TABLE corpses ADD COLUMN currency_looted INTEGER NOT NULL DEFAULT 0;`);
  }
  const hasCurrentRoomId = charColumns.some((col) => col.name === "current_room_id");
  if (!hasCurrentRoomId) {
    console.error("[Migration] Adding current_room_id column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN current_room_id TEXT REFERENCES room_nodes(id) ON DELETE SET NULL;`);
  }
  const hasPerceptionBonus = charColumns.some((col) => col.name === "perception_bonus");
  const hasStealthBonus = charColumns.some((col) => col.name === "stealth_bonus");
  if (!hasPerceptionBonus) {
    console.error("[Migration] Adding perception_bonus column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN perception_bonus INTEGER DEFAULT 0;`);
  }
  if (!hasStealthBonus) {
    console.error("[Migration] Adding stealth_bonus column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN stealth_bonus INTEGER DEFAULT 0;`);
  }
  const roomColumns = db.prepare("PRAGMA table_info(room_nodes)").all();
  const hasNetworkId = roomColumns.some((col) => col.name === "network_id");
  const hasLocalX = roomColumns.some((col) => col.name === "local_x");
  const hasLocalY = roomColumns.some((col) => col.name === "local_y");
  const hasXp = charColumns.some((col) => col.name === "xp");
  if (!hasXp) {
    console.error("[Migration] Adding xp column to characters table");
    db.exec(`ALTER TABLE characters ADD COLUMN xp INTEGER NOT NULL DEFAULT 0;`);
  }
  const hasWorldX = roomColumns.some((col) => col.name === "world_x");
  const hasWorldY = roomColumns.some((col) => col.name === "world_y");
  if (hasWorldX && !hasLocalX) {
    console.error("[Migration] Renaming world_x to local_x in room_nodes table");
    db.exec(`ALTER TABLE room_nodes RENAME COLUMN world_x TO local_x;`);
  } else if (!hasLocalX && !hasWorldX) {
    console.error("[Migration] Adding local_x column to room_nodes table");
    db.exec(`ALTER TABLE room_nodes ADD COLUMN local_x INTEGER DEFAULT 0;`);
  }
  if (hasWorldY && !hasLocalY) {
    console.error("[Migration] Renaming world_y to local_y in room_nodes table");
    db.exec(`ALTER TABLE room_nodes RENAME COLUMN world_y TO local_y;`);
  } else if (!hasLocalY && !hasWorldY) {
    console.error("[Migration] Adding local_y column to room_nodes table");
    db.exec(`ALTER TABLE room_nodes ADD COLUMN local_y INTEGER DEFAULT 0;`);
  }
  if (!hasNetworkId) {
    console.error("[Migration] Adding network_id column to room_nodes table");
    db.exec(`ALTER TABLE room_nodes ADD COLUMN network_id TEXT REFERENCES node_networks(id) ON DELETE SET NULL;`);
  }
  db.exec(`
    CREATE TABLE IF NOT EXISTS node_networks(
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL CHECK(length(trim(name)) > 0 AND length(name) <= 100),
      type TEXT NOT NULL CHECK(type IN ('cluster', 'linear')),
      world_id TEXT NOT NULL,
      center_x INTEGER NOT NULL,
      center_y INTEGER NOT NULL,
      bounding_box TEXT, -- JSON: {minX, maxX, minY, maxY}
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL
    );

    CREATE INDEX IF NOT EXISTS idx_node_networks_coords ON node_networks(center_x, center_y);
    CREATE INDEX IF NOT EXISTS idx_node_networks_world ON node_networks(world_id);
    CREATE INDEX IF NOT EXISTS idx_room_nodes_local_coords ON room_nodes(local_x, local_y);
    CREATE INDEX IF NOT EXISTS idx_room_nodes_network ON room_nodes(network_id);

    -- NARRATIVE MEMORY LAYER: Typed notes for plot threads, canonical moments, NPC voices
    CREATE TABLE IF NOT EXISTS narrative_notes(
      id TEXT PRIMARY KEY,
      world_id TEXT NOT NULL,
      type TEXT NOT NULL CHECK(type IN ('plot_thread', 'canonical_moment', 'npc_voice', 'foreshadowing', 'session_log')),
      content TEXT NOT NULL,
      metadata TEXT NOT NULL DEFAULT '{}', -- JSON: type-specific structured data
      visibility TEXT NOT NULL DEFAULT 'dm_only' CHECK(visibility IN ('dm_only', 'player_visible')),
      tags TEXT NOT NULL DEFAULT '[]', -- JSON array of tag strings
      entity_id TEXT, -- Optional: Link to character/NPC/location
      entity_type TEXT, -- Optional: 'character', 'npc', 'location', 'item'
      status TEXT DEFAULT 'active' CHECK(status IN ('active', 'resolved', 'dormant', 'archived')),
      created_at TEXT NOT NULL,
      updated_at TEXT NOT NULL,
      FOREIGN KEY(world_id) REFERENCES worlds(id) ON DELETE CASCADE
    );

    CREATE INDEX IF NOT EXISTS idx_narrative_notes_world ON narrative_notes(world_id);
    CREATE INDEX IF NOT EXISTS idx_narrative_notes_type ON narrative_notes(type);
    CREATE INDEX IF NOT EXISTS idx_narrative_notes_status ON narrative_notes(status);
    CREATE INDEX IF NOT EXISTS idx_narrative_notes_created ON narrative_notes(created_at DESC);
    CREATE INDEX IF NOT EXISTS idx_narrative_notes_entity ON narrative_notes(entity_id, entity_type);
  `);
}
function createPostMigrationIndexes(db) {
  try {
    db.exec(`CREATE INDEX IF NOT EXISTS idx_characters_type ON characters(character_type);`);
  } catch (e) {
    console.error("[Migration] Note: Could not create idx_characters_type:", e.message);
  }
  try {
    db.exec(`CREATE INDEX IF NOT EXISTS idx_parties_position ON parties(position_x, position_y);`);
  } catch (e) {
    console.error("[Migration] Note: Could not create idx_parties_position:", e.message);
  }
  try {
    db.exec(`CREATE INDEX IF NOT EXISTS idx_regions_owner_nation ON regions(owner_nation_id);`);
  } catch (e) {
    console.error("[Migration] Note: Could not create idx_regions_owner_nation:", e.message);
  }
}

// dist/schema/audit.js
init_zod();
var AuditLogSchema = external_exports.object({
  id: external_exports.number().int().optional(),
  // Auto-increment
  action: external_exports.string(),
  actorId: external_exports.string().optional().nullable(),
  targetId: external_exports.string().optional().nullable(),
  details: external_exports.record(external_exports.unknown()).optional(),
  // JSON
  timestamp: external_exports.string().datetime()
});

// dist/storage/audit.repo.js
var AuditRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(log) {
    const validated = AuditLogSchema.omit({ id: true }).parse(log);
    const stmt = this.db.prepare(`
            INSERT INTO audit_logs (action, actor_id, target_id, details, timestamp)
            VALUES (@action, @actorId, @targetId, @details, @timestamp)
        `);
    const info = stmt.run({
      action: validated.action,
      actorId: validated.actorId || null,
      targetId: validated.targetId || null,
      details: validated.details ? JSON.stringify(validated.details) : null,
      timestamp: validated.timestamp
    });
    return {
      ...validated,
      actorId: validated.actorId ?? null,
      targetId: validated.targetId ?? null,
      id: Number(info.lastInsertRowid)
    };
  }
  list(limit = 50) {
    const stmt = this.db.prepare(`
            SELECT id, action, actor_id as actorId, target_id as targetId, details, timestamp
            FROM audit_logs
            ORDER BY timestamp DESC
            LIMIT ?
        `);
    const rows = stmt.all(limit);
    console.error(`AuditRepository.list found ${rows.length} rows`);
    return rows.map((row) => ({
      id: row.id,
      action: row.action,
      actorId: row.actorId,
      targetId: row.targetId,
      details: row.details ? JSON.parse(row.details) : void 0,
      timestamp: row.timestamp
    }));
  }
};

// dist/storage/index.js
var dbInstance = null;
var configuredDbPath = null;
function getDefaultDbPath() {
  if (process.env.RPG_MCP_DB_PATH) {
    return process.env.RPG_MCP_DB_PATH;
  }
  const args = process.argv;
  const dbPathIndex = args.indexOf("--db-path");
  if (dbPathIndex !== -1 && args[dbPathIndex + 1]) {
    return args[dbPathIndex + 1];
  }
  const exePath = process.execPath;
  const exeDir = (0, import_path.dirname)(exePath);
  if (process.pkg || exePath.includes("rpg-mcp-server")) {
    const prodPath = (0, import_path.join)(exeDir, "rpg.db");
    if ((0, import_fs2.existsSync)(prodPath)) {
      return prodPath;
    }
    let searchDir = exeDir;
    for (let i = 0; i < 5; i++) {
      const tauriDevPath = (0, import_path.join)(searchDir, "binaries", "rpg.db");
      if ((0, import_fs2.existsSync)(tauriDevPath)) {
        console.error(`[Database] Found database at Tauri dev path: ${tauriDevPath}`);
        return tauriDevPath;
      }
      const srcTauriPath = (0, import_path.join)(searchDir, "src-tauri", "binaries", "rpg.db");
      if ((0, import_fs2.existsSync)(srcTauriPath)) {
        console.error(`[Database] Found database at src-tauri path: ${srcTauriPath}`);
        return srcTauriPath;
      }
      searchDir = (0, import_path.dirname)(searchDir);
    }
    console.error(`[Database] No existing database found, will create at: ${prodPath}`);
    return prodPath;
  }
  return (0, import_path.join)(process.cwd(), "rpg.db");
}
function resolveDbPath(path) {
  const dbPath = path || configuredDbPath || getDefaultDbPath();
  if (dbPath === ":memory:") {
    return dbPath;
  }
  if ((0, import_path.isAbsolute)(dbPath)) {
    return dbPath;
  }
  return (0, import_path.join)(process.cwd(), dbPath);
}
function getDbPath() {
  return resolveDbPath();
}
function getDb(path) {
  if (!dbInstance) {
    const resolvedPath = resolveDbPath(path);
    console.error(`[Database] Initializing database at: ${resolvedPath}`);
    dbInstance = initDB(resolvedPath);
    migrate(dbInstance);
  }
  return dbInstance;
}
function closeDb() {
  if (dbInstance) {
    try {
      dbInstance.pragma("wal_checkpoint(TRUNCATE)");
      console.error("[Database] WAL checkpoint completed");
    } catch (e) {
      console.error("[Database] WAL checkpoint failed:", e.message);
    }
    dbInstance.close();
    dbInstance = null;
    console.error("[Database] Database closed");
  }
}

// dist/server/tools.js
var zlib = __toESM(require("zlib"), 1);

// dist/engine/dsl/schema.js
init_zod();
var CommandType;
(function(CommandType2) {
  CommandType2["ADD_STRUCTURE"] = "ADD_STRUCTURE";
  CommandType2["SET_BIOME"] = "SET_BIOME";
  CommandType2["EDIT_TILE"] = "EDIT_TILE";
  CommandType2["ADD_ROAD"] = "ADD_ROAD";
  CommandType2["MOVE_STRUCTURE"] = "MOVE_STRUCTURE";
  CommandType2["ADD_ANNOTATION"] = "ADD_ANNOTATION";
})(CommandType || (CommandType = {}));
var CoordinateSchema = external_exports.coerce.number().int().min(0, "Coordinates must be non-negative");
var AddStructureSchema = external_exports.object({
  command: external_exports.literal(CommandType.ADD_STRUCTURE),
  args: external_exports.object({
    type: external_exports.nativeEnum(StructureType),
    x: CoordinateSchema,
    y: CoordinateSchema,
    name: external_exports.string().min(1, "Name cannot be empty")
  })
});
var SetBiomeSchema = external_exports.object({
  command: external_exports.literal(CommandType.SET_BIOME),
  args: external_exports.object({
    x: CoordinateSchema,
    y: CoordinateSchema,
    type: external_exports.nativeEnum(BiomeType)
  })
});
var EditTileSchema = external_exports.object({
  command: external_exports.literal(CommandType.EDIT_TILE),
  args: external_exports.object({
    x: CoordinateSchema,
    y: CoordinateSchema,
    elevation: external_exports.coerce.number().int().min(0).max(255).optional(),
    moisture: external_exports.coerce.number().int().min(0).max(255).optional(),
    temperature: external_exports.coerce.number().int().min(-128).max(127).optional()
  })
});
var AddRoadSchema = external_exports.object({
  command: external_exports.literal(CommandType.ADD_ROAD),
  args: external_exports.object({
    from_x: CoordinateSchema,
    from_y: CoordinateSchema,
    to_x: CoordinateSchema,
    to_y: CoordinateSchema
  })
});
var MoveStructureSchema = external_exports.object({
  command: external_exports.literal(CommandType.MOVE_STRUCTURE),
  args: external_exports.object({
    id: external_exports.string().min(1, "Structure ID cannot be empty"),
    x: CoordinateSchema,
    y: CoordinateSchema
  })
});
var AddAnnotationSchema = external_exports.object({
  command: external_exports.literal(CommandType.ADD_ANNOTATION),
  args: external_exports.object({
    x: CoordinateSchema,
    y: CoordinateSchema,
    text: external_exports.string().min(1, "Annotation text cannot be empty")
  })
});
var PatchCommandSchema = external_exports.discriminatedUnion("command", [
  AddStructureSchema,
  SetBiomeSchema,
  EditTileSchema,
  AddRoadSchema,
  MoveStructureSchema,
  AddAnnotationSchema
]);

// dist/engine/dsl/parser.js
function parseDSL(script) {
  const lines = script.split("\n");
  const commands = [];
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();
    if (!line || line.startsWith("#")) {
      continue;
    }
    try {
      const command = parseLine(line);
      commands.push(command);
    } catch (error) {
      throw new Error(`Error on line ${i + 1}: ${error.message}`);
    }
  }
  return commands;
}
function parseLine(line) {
  const tokens = line.match(/[a-zA-Z0-9_]+=(?:"[^"]*"|\S+)|"[^"]*"|\S+/g) || [];
  if (tokens.length === 0) {
    throw new Error("Empty command");
  }
  const commandName = tokens[0];
  const args = {};
  if (tokens.length > 1 && !tokens[1].includes("=")) {
    if (commandName === "ADD_STRUCTURE" && tokens.length >= 4) {
      args["type"] = tokens[1];
      args["x"] = tokens[2];
      args["y"] = tokens[3];
      if (tokens.length > 4) {
        let name = tokens[4];
        if (name.startsWith('"') && name.endsWith('"')) {
          name = name.slice(1, -1);
        }
        args["name"] = name;
      } else {
        args["name"] = tokens[1];
      }
    } else if (commandName === "SET_BIOME" && tokens.length >= 4) {
      args["type"] = tokens[1];
      args["x"] = tokens[2];
      args["y"] = tokens[3];
    } else if (commandName === "EDIT_TILE" && tokens.length >= 4) {
      args["x"] = tokens[1];
      args["y"] = tokens[2];
      args["elevation"] = tokens[3];
    } else {
    }
  }
  const hasPositionalArgs = Object.keys(args).length > 0;
  if (!hasPositionalArgs) {
    for (let i = 1; i < tokens.length; i++) {
      const token = tokens[i];
      const eqIndex = token.indexOf("=");
      if (eqIndex === -1) {
        throw new Error(`Invalid argument format: ${token}. Expected key=value`);
      }
      const key = token.substring(0, eqIndex);
      let value = token.substring(eqIndex + 1);
      if (value.startsWith('"') && value.endsWith('"')) {
        value = value.slice(1, -1);
      }
      args[key] = value;
    }
  }
  const rawCommand = {
    command: commandName,
    args
  };
  const result = PatchCommandSchema.safeParse(rawCommand);
  if (!result.success) {
    const errorMessages = result.error.errors.map((e) => `${e.path.join(".")}: ${e.message}`).join(", ");
    throw new Error(`Invalid command arguments: ${errorMessages}`);
  }
  return result.data;
}

// dist/engine/dsl/engine.js
function applyPatch(world, commands, options = {}) {
  const { skipInvalid = false, dryRun = false } = options;
  const result = {
    success: true,
    commandsExecuted: 0,
    errors: [],
    warnings: []
  };
  for (const command of commands) {
    const cmdResult = validateAndApplyCommand(world, command, dryRun);
    if (cmdResult.error) {
      result.errors.push(cmdResult.error);
      if (!skipInvalid) {
        result.success = false;
        break;
      }
    } else {
      result.commandsExecuted++;
    }
    if (cmdResult.warning) {
      result.warnings.push(cmdResult.warning);
    }
  }
  return result;
}
function validateAndApplyCommand(world, command, dryRun) {
  switch (command.command) {
    case CommandType.ADD_STRUCTURE: {
      const { type, x, y, name } = command.args;
      const validation = validateStructurePlacement(type, x, y, world);
      if (!validation.valid) {
        const suggestedBiomes = getSuggestedBiomesForStructure(type);
        return {
          error: {
            command: `ADD_STRUCTURE ${type} ${x} ${y}`,
            message: `${validation.reason}. Suggested biomes for ${type}: ${suggestedBiomes.join(", ")}`,
            location: { x, y }
          }
        };
      }
      if (!dryRun) {
        world.structures.push({
          type,
          location: { x, y },
          name,
          score: 100
          // Manual placement gets max score
        });
      }
      return {};
    }
    case CommandType.SET_BIOME: {
      const { x, y, type } = command.args;
      if (!isValidCoordinate(world, x, y)) {
        return {
          error: {
            command: `SET_BIOME ${type} ${x} ${y}`,
            message: `Coordinates (${x}, ${y}) are out of bounds`,
            location: { x, y }
          }
        };
      }
      if (!dryRun) {
        world.biomes[y][x] = type;
      }
      return {};
    }
    case CommandType.EDIT_TILE: {
      const { x, y, elevation, moisture, temperature } = command.args;
      if (!isValidCoordinate(world, x, y)) {
        return {
          error: {
            command: `EDIT_TILE ${x} ${y}`,
            message: `Coordinates (${x}, ${y}) are out of bounds`,
            location: { x, y }
          }
        };
      }
      if (!dryRun) {
        const idx = y * world.width + x;
        if (elevation !== void 0)
          world.elevation[idx] = elevation;
        if (moisture !== void 0)
          world.moisture[idx] = moisture;
        if (temperature !== void 0)
          world.temperature[idx] = temperature;
      }
      return {};
    }
    case CommandType.MOVE_STRUCTURE: {
      const { id, x, y } = command.args;
      const structure = world.structures.find((s) => s.name === id);
      if (!structure) {
        return {
          error: {
            command: `MOVE_STRUCTURE ${id} ${x} ${y}`,
            message: `Structure not found: ${id}`,
            location: { x, y }
          }
        };
      }
      const validation = validateStructurePlacement(structure.type, x, y, world);
      if (!validation.valid) {
        return {
          error: {
            command: `MOVE_STRUCTURE ${id} ${x} ${y}`,
            message: validation.reason,
            location: { x, y }
          }
        };
      }
      if (!dryRun) {
        structure.location = { x, y };
      }
      return {};
    }
    case CommandType.ADD_ROAD:
    case CommandType.ADD_ANNOTATION:
      return {
        warning: {
          command: command.command,
          message: `Command ${command.command} is not yet implemented`
        }
      };
  }
  return {};
}
function isValidCoordinate(world, x, y) {
  return x >= 0 && x < world.width && y >= 0 && y < world.height;
}

// dist/server/tools.js
var pubsub = null;
function setWorldPubSub(instance3) {
  pubsub = instance3;
}
var Tools = {
  GENERATE_WORLD: {
    name: "generate_world",
    description: "Generate a new procedural RPG world with seed, width, and height parameters.",
    inputSchema: external_exports.object({
      seed: external_exports.string().describe("Seed for random number generation"),
      width: external_exports.number().int().min(10).max(1e3).describe("Width of the world grid"),
      height: external_exports.number().int().min(10).max(1e3).describe("Height of the world grid"),
      landRatio: external_exports.number().min(0.1).max(0.9).optional().describe("Land to water ratio (0.1 = mostly ocean, 0.9 = mostly land, default 0.3)"),
      temperatureOffset: external_exports.number().min(-30).max(30).optional().describe("Global temperature offset (-30 to +30) to shift biome distribution"),
      moistureOffset: external_exports.number().min(-30).max(30).optional().describe("Global moisture offset (-30 to +30) to shift biome distribution")
    })
  },
  GET_WORLD_STATE: {
    name: "get_world_state",
    description: "Retrieves the current state of the generated world.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world to retrieve")
    })
  },
  APPLY_MAP_PATCH: {
    name: "apply_map_patch",
    description: "Apply DSL commands to modify the world map. Use find_valid_poi_location first for structure placement.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world to patch"),
      script: external_exports.string().describe("The DSL script containing patch commands.")
    })
  },
  GET_WORLD_MAP_OVERVIEW: {
    name: "get_world_map_overview",
    description: "Returns a high-level overview of the world including biome distribution and statistics.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world to overview")
    })
  },
  GET_REGION_MAP: {
    name: "get_region_map",
    description: "Returns detailed information about a specific region including its tiles and structures.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world"),
      regionId: external_exports.number().int().min(0).describe("The ID of the region to retrieve")
    })
  },
  GET_WORLD_TILES: {
    name: "get_world_tiles",
    description: "Returns the full tile grid for rendering the world map. Includes biome, elevation, region, and river data for visualization.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world")
    })
  },
  PREVIEW_MAP_PATCH: {
    name: "preview_map_patch",
    description: "Previews what a DSL patch script would do without applying it to the world.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world to preview patch on"),
      script: external_exports.string().describe("The DSL script to preview")
    })
  },
  FIND_VALID_POI_LOCATION: {
    name: "find_valid_poi_location",
    description: "Find terrain-valid locations for placing a POI/structure. Returns ranked candidates by suitability.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world"),
      poiType: external_exports.enum(["city", "town", "village", "castle", "ruins", "dungeon", "temple"]).describe("Type of POI to place"),
      nearWater: external_exports.boolean().optional().describe("If true, prefer locations within 5 tiles of river/coast"),
      preferredBiomes: external_exports.array(external_exports.string()).optional().describe("List of preferred biome types"),
      avoidExistingPOIs: external_exports.boolean().optional().default(true).describe("If true, avoid placing near existing structures"),
      minDistanceFromPOI: external_exports.number().optional().default(5).describe("Minimum distance from existing POIs"),
      regionId: external_exports.number().optional().describe("Limit search to specific region"),
      count: external_exports.number().int().min(1).max(10).optional().default(3).describe("Number of candidate locations to return")
    })
  },
  SUGGEST_POI_LOCATIONS: {
    name: "suggest_poi_locations",
    description: "Batch suggest locations for multiple POI types at once. Returns DSL script for easy application.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The ID of the world"),
      requests: external_exports.array(external_exports.object({
        poiType: external_exports.enum(["city", "town", "village", "castle", "ruins", "dungeon", "temple"]),
        count: external_exports.number().int().min(1).max(10).default(1),
        nearWater: external_exports.boolean().optional(),
        preferredBiomes: external_exports.array(external_exports.string()).optional()
      })).describe("List of POI placement requests")
    })
  }
};
function ensureTileCacheColumn(db) {
  try {
    const columns = db.prepare(`PRAGMA table_info(worlds)`).all();
    const hasCache = columns.some((col) => col.name === "tile_cache");
    if (!hasCache) {
      console.error("[WorldGen] Adding tile_cache column to worlds table");
      db.exec(`ALTER TABLE worlds ADD COLUMN tile_cache BLOB`);
    }
  } catch (err) {
  }
}
function getCachedTiles(db, worldId) {
  try {
    ensureTileCacheColumn(db);
    const row = db.prepare("SELECT tile_cache FROM worlds WHERE id = ?").get(worldId);
    if (row?.tile_cache) {
      const decompressed = zlib.gunzipSync(row.tile_cache);
      return JSON.parse(decompressed.toString("utf-8"));
    }
  } catch (err) {
    console.error("[WorldGen] Failed to read tile cache:", err);
  }
  return null;
}
function saveTilesToCache(db, worldId, tileData) {
  try {
    ensureTileCacheColumn(db);
    const json = JSON.stringify(tileData);
    const compressed = zlib.gzipSync(json);
    db.prepare("UPDATE worlds SET tile_cache = ? WHERE id = ?").run(compressed, worldId);
    console.error(`[WorldGen] Cached ${compressed.length} bytes of tile data for world ${worldId}`);
  } catch (err) {
    console.error("[WorldGen] Failed to save tile cache:", err);
  }
}
function invalidateTileCache(db, worldId) {
  try {
    ensureTileCacheColumn(db);
    db.prepare("UPDATE worlds SET tile_cache = NULL WHERE id = ?").run(worldId);
    console.error(`[WorldGen] Invalidated tile cache for world ${worldId}`);
  } catch (err) {
    console.error("[WorldGen] Failed to invalidate tile cache:", err);
  }
}
async function handleGenerateWorld(args, ctx) {
  const parsed = Tools.GENERATE_WORLD.inputSchema.parse(args);
  console.error(`[WorldGen] Generating world with seed "${parsed.seed}" (${parsed.width}x${parsed.height})`);
  const startTime = Date.now();
  const world = generateWorld({
    seed: parsed.seed,
    width: parsed.width,
    height: parsed.height,
    landRatio: parsed.landRatio,
    temperatureOffset: parsed.temperatureOffset,
    moistureOffset: parsed.moistureOffset
  });
  const genTime = Date.now() - startTime;
  console.error(`[WorldGen] World generated in ${genTime}ms`);
  const worldId = (0, import_crypto.randomUUID)();
  getWorldManager().create(`${ctx.sessionId}:${worldId}`, world);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const worldRepo = new WorldRepository(db);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  worldRepo.create({
    id: worldId,
    name: `World-${parsed.seed}`,
    seed: parsed.seed,
    width: parsed.width,
    height: parsed.height,
    createdAt: now,
    updatedAt: now
  });
  const tileData = buildTileData(world);
  saveTilesToCache(db, worldId, tileData);
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          worldId,
          message: "World generated successfully",
          generationTimeMs: genTime,
          stats: {
            width: world.width,
            height: world.height,
            regions: world.regions.length,
            structures: world.structures.length,
            rivers: world.rivers.filter((r) => r > 0).length
          }
        }, null, 2)
      }
    ]
  };
}
async function getOrRestoreWorld(worldId, sessionId) {
  const manager = getWorldManager();
  const sessionKey = `${sessionId}:${worldId}`;
  let world = manager.get(sessionKey);
  if (world)
    return world;
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const worldRepo = new WorldRepository(db);
  const storedWorld = worldRepo.findById(worldId);
  if (!storedWorld) {
    return null;
  }
  console.error(`[WorldGen] Restoring world ${worldId} from seed ${storedWorld.seed}`);
  const startTime = Date.now();
  world = generateWorld({
    seed: storedWorld.seed,
    width: storedWorld.width,
    height: storedWorld.height
  });
  const genTime = Date.now() - startTime;
  console.error(`[WorldGen] World restored in ${genTime}ms`);
  manager.create(sessionKey, world);
  return world;
}
async function handleGetWorldState(args, ctx) {
  const parsed = Tools.GET_WORLD_STATE.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          seed: currentWorld.seed,
          width: currentWorld.width,
          height: currentWorld.height,
          stats: {
            regions: currentWorld.regions.length,
            structures: currentWorld.structures.length
          }
        }, null, 2)
      }
    ]
  };
}
async function handleApplyMapPatch(args, ctx) {
  const parsed = Tools.APPLY_MAP_PATCH.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  try {
    const commands = parseDSL(parsed.script);
    const result = applyPatch(currentWorld, commands);
    if (result.commandsExecuted > 0) {
      const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
      invalidateTileCache(db, parsed.worldId);
      pubsub?.publish("world", {
        type: "patch_applied",
        commandsExecuted: result.commandsExecuted,
        timestamp: Date.now()
      });
    }
    if (!result.success) {
      return {
        isError: true,
        content: [
          {
            type: "text",
            text: JSON.stringify({
              success: false,
              message: "Patch failed - some commands could not be applied",
              commandsExecuted: result.commandsExecuted,
              errors: result.errors,
              warnings: result.warnings,
              hint: "Use find_valid_poi_location to get valid coordinates for structure placement"
            }, null, 2)
          }
        ]
      };
    }
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: true,
            message: "Patch applied successfully",
            commandsExecuted: result.commandsExecuted,
            warnings: result.warnings.length > 0 ? result.warnings : void 0
          }, null, 2)
        }
      ]
    };
  } catch (error) {
    return {
      isError: true,
      content: [
        {
          type: "text",
          text: `Failed to parse patch script: ${error.message}`
        }
      ]
    };
  }
}
async function handleGetWorldMapOverview(args, ctx) {
  const parsed = Tools.GET_WORLD_MAP_OVERVIEW.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  const biomeDistribution = {};
  for (let y = 0; y < currentWorld.height; y++) {
    for (let x = 0; x < currentWorld.width; x++) {
      const biome = currentWorld.biomes[y][x];
      biomeDistribution[biome] = (biomeDistribution[biome] || 0) + 1;
    }
  }
  const totalTiles = currentWorld.width * currentWorld.height;
  const biomePercentages = {};
  for (const [biome, count] of Object.entries(biomeDistribution)) {
    biomePercentages[biome] = Math.round(count / totalTiles * 100 * 10) / 10;
  }
  const landmasses = detectLandmasses(currentWorld);
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          seed: currentWorld.seed,
          dimensions: {
            width: currentWorld.width,
            height: currentWorld.height
          },
          biomeDistribution: biomePercentages,
          regionCount: currentWorld.regions.length,
          structureCount: currentWorld.structures.length,
          riverTileCount: currentWorld.rivers.filter((r) => r > 0).length,
          landmasses: landmasses.slice(0, 5)
          // Top 5 landmasses
        }, null, 2)
      }
    ]
  };
}
function detectLandmasses(world) {
  const { width, height, biomes } = world;
  const visited = new Uint8Array(width * height);
  const landmasses = [];
  let landmassId = 0;
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      if (visited[idx])
        continue;
      const biome = biomes[y][x];
      if (WATER_BIOMES.includes(biome)) {
        visited[idx] = 1;
        continue;
      }
      const tiles = [];
      const stack = [{ x, y }];
      let minX = x, maxX = x, minY = y, maxY = y;
      while (stack.length > 0) {
        const { x: cx, y: cy } = stack.pop();
        const cIdx = cy * width + cx;
        if (visited[cIdx])
          continue;
        if (cx < 0 || cx >= width || cy < 0 || cy >= height)
          continue;
        const cBiome = biomes[cy][cx];
        if (WATER_BIOMES.includes(cBiome))
          continue;
        visited[cIdx] = 1;
        tiles.push({ x: cx, y: cy, biome: cBiome });
        minX = Math.min(minX, cx);
        maxX = Math.max(maxX, cx);
        minY = Math.min(minY, cy);
        maxY = Math.max(maxY, cy);
        stack.push({ x: cx + 1, y: cy });
        stack.push({ x: cx - 1, y: cy });
        stack.push({ x: cx, y: cy + 1 });
        stack.push({ x: cx, y: cy - 1 });
      }
      if (tiles.length > 10) {
        landmasses.push({
          id: landmassId++,
          size: tiles.length,
          boundingBox: { x1: minX, y1: minY, x2: maxX, y2: maxY },
          tiles
        });
      }
    }
  }
  landmasses.sort((a, b) => b.size - a.size);
  return landmasses.map((lm) => {
    const biomeCounts = {};
    for (const tile of lm.tiles) {
      biomeCounts[tile.biome] = (biomeCounts[tile.biome] || 0) + 1;
    }
    const dominantBiomes = Object.entries(biomeCounts).sort((a, b) => b[1] - a[1]).slice(0, 3).map(([biome]) => biome);
    return {
      id: lm.id,
      size: lm.size,
      boundingBox: lm.boundingBox,
      dominantBiomes
    };
  });
}
async function handleGetRegionMap(args, ctx) {
  const parsed = Tools.GET_REGION_MAP.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  const regionId = parsed.regionId;
  const region = currentWorld.regions.find((r) => r.id === regionId);
  if (!region) {
    throw new Error(`Region not found: ${regionId}`);
  }
  const tiles = [];
  for (let y = 0; y < currentWorld.height; y++) {
    for (let x = 0; x < currentWorld.width; x++) {
      const idx = y * currentWorld.width + x;
      if (currentWorld.regionMap[idx] === regionId) {
        tiles.push({
          x,
          y,
          biome: currentWorld.biomes[y][x],
          elevation: currentWorld.elevation[idx]
        });
      }
    }
  }
  const world = currentWorld;
  const structures = world.structures.filter((s) => {
    const idx = s.location.y * world.width + s.location.x;
    return world.regionMap[idx] === regionId;
  });
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          region: {
            id: region.id,
            name: region.name,
            capitalX: region.capital.x,
            capitalY: region.capital.y,
            dominantBiome: region.biome
          },
          tiles,
          structures,
          tileCount: tiles.length
        }, null, 2)
      }
    ]
  };
}
function buildTileData(world) {
  const biomeIndex = {};
  const biomes = [];
  for (let y = 0; y < world.height; y++) {
    for (let x = 0; x < world.width; x++) {
      const biome = world.biomes[y][x];
      if (!(biome in biomeIndex)) {
        biomeIndex[biome] = biomes.length;
        biomes.push(biome);
      }
    }
  }
  const structureSet = /* @__PURE__ */ new Set();
  world.structures.forEach((s) => {
    structureSet.add(`${s.location.x},${s.location.y}`);
  });
  const tiles = [];
  for (let y = 0; y < world.height; y++) {
    const row = [];
    for (let x = 0; x < world.width; x++) {
      const idx = y * world.width + x;
      const biome = world.biomes[y][x];
      const elevation = world.elevation[idx];
      const regionId = world.regionMap[idx];
      const hasRiver = world.rivers[idx] > 0 ? 1 : 0;
      const hasStructure = structureSet.has(`${x},${y}`) ? 1 : 0;
      row.push(biomeIndex[biome], elevation, regionId, hasRiver, hasStructure);
    }
    tiles.push(row);
  }
  const regions = world.regions.map((r) => ({
    id: r.id,
    name: r.name,
    biome: r.biome,
    capitalX: r.capital.x,
    capitalY: r.capital.y
  }));
  const structures = world.structures.map((s) => ({
    type: s.type,
    name: s.name,
    x: s.location.x,
    y: s.location.y
  }));
  return {
    width: world.width,
    height: world.height,
    biomes,
    tiles,
    regions,
    structures
  };
}
async function handleGetWorldTiles(args, ctx) {
  const parsed = Tools.GET_WORLD_TILES.inputSchema.parse(args);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const cachedTiles = getCachedTiles(db, parsed.worldId);
  if (cachedTiles) {
    console.error(`[WorldGen] Returning cached tiles for world ${parsed.worldId}`);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(cachedTiles)
          // Compact JSON - pretty-print causes stdio buffer issues
        }
      ]
    };
  }
  console.error(`[WorldGen] No tile cache found, regenerating world ${parsed.worldId}`);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  const tileData = buildTileData(currentWorld);
  saveTilesToCache(db, parsed.worldId, tileData);
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify(tileData)
        // Compact JSON - pretty-print causes stdio buffer issues
      }
    ]
  };
}
async function handlePreviewMapPatch(args, ctx) {
  const parsed = Tools.PREVIEW_MAP_PATCH.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  try {
    const commands = parseDSL(parsed.script);
    const result = applyPatch(currentWorld, commands, { dryRun: true });
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            valid: result.success,
            commands: commands.map((cmd) => {
              const preview = {
                type: cmd.command
              };
              if ("x" in cmd.args && "y" in cmd.args) {
                preview.x = cmd.args.x;
                preview.y = cmd.args.y;
              }
              if ("type" in cmd.args) {
                preview.structureType = cmd.args.type;
              }
              if ("name" in cmd.args) {
                preview.name = cmd.args.name;
              }
              return preview;
            }),
            commandCount: commands.length,
            errors: result.errors,
            warnings: result.warnings
          }, null, 2)
        }
      ]
    };
  } catch (error) {
    throw new Error(`Invalid patch script: ${error.message}`);
  }
}
async function handleFindValidPoiLocation(args, ctx) {
  const parsed = Tools.FIND_VALID_POI_LOCATION.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  const { width, height, biomes, elevation, rivers, structures, regionMap } = currentWorld;
  const poiType = parsed.poiType;
  const candidates = [];
  const existingLocations = structures.map((s) => s.location);
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      const biome = biomes[y][x];
      const elev = elevation[idx];
      const regionId = regionMap[idx];
      if (parsed.regionId !== void 0 && regionId !== parsed.regionId)
        continue;
      const validation = validateStructurePlacement(poiType, x, y, currentWorld);
      if (!validation.valid)
        continue;
      let score = 50;
      score += BIOME_HABITABILITY[biome] || 0;
      if (parsed.preferredBiomes?.includes(biome)) {
        score += 20;
      }
      const nearWater = isNearWater(x, y, width, height, rivers, biomes);
      if (parsed.nearWater && nearWater) {
        score += 15;
      } else if (parsed.nearWater && !nearWater) {
        score -= 10;
      }
      if (parsed.avoidExistingPOIs) {
        let tooClose = false;
        for (const loc of existingLocations) {
          const dist = Math.sqrt((x - loc.x) ** 2 + (y - loc.y) ** 2);
          if (dist < (parsed.minDistanceFromPOI || 5)) {
            tooClose = true;
            break;
          }
        }
        if (tooClose)
          continue;
      }
      if (poiType === StructureType.CITY || poiType === StructureType.TOWN || poiType === StructureType.VILLAGE) {
        if (elev >= 20 && elev <= 60)
          score += 5;
      }
      if (poiType === StructureType.DUNGEON) {
        if (score < 50)
          score += 10;
      }
      candidates.push({
        x,
        y,
        score,
        biome,
        elevation: elev,
        nearWater,
        regionId
      });
    }
  }
  candidates.sort((a, b) => b.score - a.score);
  const count = parsed.count || 3;
  const topCandidates = candidates.slice(0, count);
  if (topCandidates.length === 0) {
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: false,
            message: `No valid locations found for ${poiType}`,
            suggestedBiomes: getSuggestedBiomesForStructure(poiType)
          }, null, 2)
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          success: true,
          poiType,
          candidates: topCandidates,
          totalValidLocations: candidates.length,
          hint: `Use these coordinates with apply_map_patch: ADD_STRUCTURE ${poiType} ${topCandidates[0].x} ${topCandidates[0].y}`
        }, null, 2)
      }
    ]
  };
}
function isNearWater(x, y, width, height, rivers, biomes) {
  const searchRadius = 5;
  for (let dy = -searchRadius; dy <= searchRadius; dy++) {
    for (let dx = -searchRadius; dx <= searchRadius; dx++) {
      const nx = x + dx;
      const ny = y + dy;
      if (nx < 0 || nx >= width || ny < 0 || ny >= height)
        continue;
      const nIdx = ny * width + nx;
      if (rivers[nIdx] > 0)
        return true;
      if (WATER_BIOMES.includes(biomes[ny][nx]))
        return true;
    }
  }
  return false;
}
async function handleSuggestPoiLocations(args, ctx) {
  const parsed = Tools.SUGGEST_POI_LOCATIONS.inputSchema.parse(args);
  const currentWorld = await getOrRestoreWorld(parsed.worldId, ctx.sessionId);
  if (!currentWorld) {
    throw new Error(`World ${parsed.worldId} not found.`);
  }
  const results = [];
  const usedLocations = /* @__PURE__ */ new Set();
  for (const structure of currentWorld.structures) {
    usedLocations.add(`${structure.location.x},${structure.location.y}`);
  }
  for (const request of parsed.requests) {
    const locationResult = await handleFindValidPoiLocation({
      worldId: parsed.worldId,
      poiType: request.poiType,
      nearWater: request.nearWater,
      preferredBiomes: request.preferredBiomes,
      avoidExistingPOIs: true,
      count: request.count * 2
      // Get extra candidates to filter
    }, ctx);
    const locationData = JSON.parse(locationResult.content[0].text);
    if (locationData.success && locationData.candidates) {
      const availableLocations = locationData.candidates.filter((loc) => {
        const key = `${loc.x},${loc.y}`;
        if (usedLocations.has(key))
          return false;
        usedLocations.add(key);
        return true;
      }).slice(0, request.count);
      results.push({
        poiType: request.poiType,
        locations: availableLocations.map((loc) => ({
          x: loc.x,
          y: loc.y,
          score: loc.score,
          biome: loc.biome
        }))
      });
    } else {
      results.push({
        poiType: request.poiType,
        locations: []
      });
    }
  }
  const dslLines = [];
  let poiIndex = 1;
  for (const result of results) {
    for (const loc of result.locations) {
      dslLines.push(`ADD_STRUCTURE ${result.poiType} ${loc.x} ${loc.y} "${result.poiType.charAt(0).toUpperCase() + result.poiType.slice(1)} ${poiIndex++}"`);
    }
  }
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          success: true,
          results,
          suggestedDSL: dslLines.join("\n"),
          hint: "Copy the suggestedDSL to apply_map_patch to create all POIs at once"
        }, null, 2)
      }
    ]
  };
}

// dist/server/combat-tools.js
init_zod();

// dist/engine/combat/rng.js
var import_seedrandom6 = __toESM(require_seedrandom2(), 1);
var CombatRNG = class {
  rng;
  constructor(seed) {
    this.rng = (0, import_seedrandom6.default)(seed);
  }
  /**
   * Roll a single die with N sides
   */
  rollDie(sides) {
    return Math.floor(this.rng() * sides) + 1;
  }
  /**
   * Parse and execute standard dice notation (NdS+M or NdS-M)
   * Examples: "1d20", "2d6+3", "1d8-1"
   */
  roll(notation) {
    const match = notation.match(/^(\d+)d(\d+)(([+\-])(\d+))?$/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = parseInt(match[1], 10);
    const sides = parseInt(match[2], 10);
    const modifier = match[3] ? parseInt(match[4] + match[5], 10) : 0;
    let total = 0;
    for (let i = 0; i < count; i++) {
      total += this.rollDie(sides);
    }
    return total + modifier;
  }
  /**
   * D&D 5e: Roll with Advantage (2d20, keep highest)
   */
  rollWithAdvantage(modifier = 0) {
    const roll1 = this.rollDie(20);
    const roll2 = this.rollDie(20);
    return Math.max(roll1, roll2) + modifier;
  }
  /**
   * D&D 5e: Roll with Disadvantage (2d20, keep lowest)
   */
  rollWithDisadvantage(modifier = 0) {
    const roll1 = this.rollDie(20);
    const roll2 = this.rollDie(20);
    return Math.min(roll1, roll2) + modifier;
  }
  /**
   * General Keep/Drop mechanic
   * Roll N dice of S sides, keep the highest/lowest K dice
   */
  rollKeepDrop(count, sides, keep, type) {
    if (keep > count) {
      throw new Error(`Cannot keep ${keep} dice when only rolling ${count}`);
    }
    const rolls = [];
    for (let i = 0; i < count; i++) {
      rolls.push(this.rollDie(sides));
    }
    rolls.sort((a, b) => type === "highest" ? b - a : a - b);
    let total = 0;
    for (let i = 0; i < keep; i++) {
      total += rolls[i];
    }
    return total;
  }
  /**
   * D&D 5e: Reroll specific values once (e.g., Great Weapon Fighting)
   * rerollOn: array of values to reroll (e.g., [1, 2])
   */
  rollWithReroll(count, sides, rerollOn) {
    let total = 0;
    for (let i = 0; i < count; i++) {
      let roll = this.rollDie(sides);
      if (rerollOn.includes(roll)) {
        roll = this.rollDie(sides);
      }
      total += roll;
    }
    return total;
  }
  /**
   * D&D 5e: Roll with minimum value (e.g., Reliable Talent)
   * Any roll below min is treated as min
   */
  rollWithMin(count, sides, min) {
    let total = 0;
    for (let i = 0; i < count; i++) {
      const roll = this.rollDie(sides);
      total += Math.max(roll, min);
    }
    return total;
  }
  /**
   * Savage Worlds/L5R: Exploding dice
   * When max value is rolled, roll again and add (can chain indefinitely)
   */
  rollExploding(count, sides) {
    let total = 0;
    for (let i = 0; i < count; i++) {
      let roll = this.rollDie(sides);
      total += roll;
      while (roll === sides) {
        roll = this.rollDie(sides);
        total += roll;
      }
    }
    return total;
  }
  /**
   * Hackmaster: Penetrating dice
   * Like exploding, but subtract 1 from each reroll after the first
   */
  rollPenetrating(count, sides) {
    let total = 0;
    for (let i = 0; i < count; i++) {
      let roll = this.rollDie(sides);
      total += roll;
      while (roll === sides) {
        roll = this.rollDie(sides) - 1;
        total += roll;
      }
    }
    return total;
  }
  /**
   * Shadowrun/World of Darkness: Dice pool success counting
   * Roll poolSize dice of diceSize, count how many meet/exceed threshold
   *
   * @param poolSize Number of dice to roll
   * @param diceSize Size of each die (typically d6 or d10)
   * @param threshold Minimum value to count as success
   * @returns Number of successes
   */
  rollPool(poolSize, diceSize, threshold) {
    let successes = 0;
    for (let i = 0; i < poolSize; i++) {
      const roll = this.rollDie(diceSize);
      if (roll >= threshold) {
        successes++;
      }
    }
    return successes;
  }
  /**
   * Convenience method for d20 checks
   */
  d20(modifier = 0) {
    return this.rollDie(20) + modifier;
  }
  /**
   * Make a check against a Difficulty Class
   * Returns true if roll + modifier meets or exceeds DC
   */
  check(modifier, dc) {
    return this.d20(modifier) >= dc;
  }
  /**
   * Pathfinder 2e: Determine degree of success
   * Returns: 'critical-failure' | 'failure' | 'success' | 'critical-success'
   */
  checkDegree(modifier, dc) {
    const result = this.checkDegreeDetailed(modifier, dc);
    return result.degree;
  }
  /**
   * Detailed check result with full dice mechanics exposed
   * This is the TRANSPARENT version - shows exactly what was rolled
   */
  checkDegreeDetailed(modifier, dc) {
    const roll = this.rollDie(20);
    const total = roll + modifier;
    const margin = total - dc;
    let degree;
    if (margin >= 10) {
      degree = "critical-success";
    } else if (margin >= 0) {
      degree = "success";
    } else if (margin >= -10) {
      degree = "failure";
    } else {
      degree = "critical-failure";
    }
    const isNat20 = roll === 20;
    const isNat1 = roll === 1;
    if (isNat20) {
      if (degree === "failure")
        degree = "success";
      else if (degree === "success")
        degree = "critical-success";
    }
    if (isNat1) {
      if (degree === "success")
        degree = "failure";
      else if (degree === "critical-success")
        degree = "success";
    }
    return {
      roll,
      modifier,
      total,
      dc,
      margin,
      degree,
      isNat20,
      isNat1,
      isHit: degree === "success" || degree === "critical-success",
      isCrit: degree === "critical-success"
    };
  }
  /**
   * Roll damage dice with detailed breakdown
   */
  rollDamageDetailed(notation) {
    const match = notation.match(/^(\d+)d(\d+)(([+\-])(\d+))?$/i);
    if (!match) {
      throw new Error(`Invalid dice notation: ${notation}`);
    }
    const count = parseInt(match[1], 10);
    const sides = parseInt(match[2], 10);
    const modifierSign = match[4] || "+";
    const modifierValue = match[5] ? parseInt(match[5], 10) : 0;
    const modifier = modifierSign === "-" ? -modifierValue : modifierValue;
    const rolls = [];
    for (let i = 0; i < count; i++) {
      rolls.push(this.rollDie(sides));
    }
    const diceTotal = rolls.reduce((sum, r) => sum + r, 0);
    const total = diceTotal + modifier;
    return {
      notation,
      rolls,
      diceTotal,
      modifier,
      total
    };
  }
};

// dist/engine/combat/conditions.js
var ConditionType;
(function(ConditionType2) {
  ConditionType2["BLINDED"] = "blinded";
  ConditionType2["CHARMED"] = "charmed";
  ConditionType2["DEAFENED"] = "deafened";
  ConditionType2["FRIGHTENED"] = "frightened";
  ConditionType2["GRAPPLED"] = "grappled";
  ConditionType2["INCAPACITATED"] = "incapacitated";
  ConditionType2["INVISIBLE"] = "invisible";
  ConditionType2["PARALYZED"] = "paralyzed";
  ConditionType2["PETRIFIED"] = "petrified";
  ConditionType2["POISONED"] = "poisoned";
  ConditionType2["PRONE"] = "prone";
  ConditionType2["RESTRAINED"] = "restrained";
  ConditionType2["STUNNED"] = "stunned";
  ConditionType2["UNCONSCIOUS"] = "unconscious";
  ConditionType2["BLEEDING"] = "bleeding";
  ConditionType2["BURNING"] = "burning";
  ConditionType2["CONCENTRATING"] = "concentrating";
  ConditionType2["EXHAUSTED"] = "exhausted";
  ConditionType2["HASTED"] = "hasted";
  ConditionType2["SLOWED"] = "slowed";
  ConditionType2["BLESSED"] = "blessed";
  ConditionType2["CURSED"] = "cursed";
  ConditionType2["MARKED"] = "marked";
  ConditionType2["HIDDEN"] = "hidden";
})(ConditionType || (ConditionType = {}));
var DurationType;
(function(DurationType2) {
  DurationType2["END_OF_TURN"] = "end_of_turn";
  DurationType2["START_OF_TURN"] = "start_of_turn";
  DurationType2["ROUNDS"] = "rounds";
  DurationType2["SAVE_ENDS"] = "save_ends";
  DurationType2["PERMANENT"] = "permanent";
  DurationType2["CONCENTRATION"] = "concentration";
})(DurationType || (DurationType = {}));
var Ability;
(function(Ability2) {
  Ability2["STRENGTH"] = "strength";
  Ability2["DEXTERITY"] = "dexterity";
  Ability2["CONSTITUTION"] = "constitution";
  Ability2["INTELLIGENCE"] = "intelligence";
  Ability2["WISDOM"] = "wisdom";
  Ability2["CHARISMA"] = "charisma";
})(Ability || (Ability = {}));
var CONDITION_EFFECTS = {
  [ConditionType.BLINDED]: {
    description: "Cannot see, fails checks requiring sight",
    attackDisadvantage: true,
    attacksAgainstAdvantage: true,
    autoFail: [Ability.STRENGTH, Ability.DEXTERITY]
    // Auto-fail checks requiring sight
  },
  [ConditionType.CHARMED]: {
    description: "Cannot attack charmer, charmer has advantage on social checks",
    attackDisadvantage: false
  },
  [ConditionType.DEAFENED]: {
    description: "Cannot hear, fails checks requiring hearing",
    autoFail: []
    // Auto-fail hearing checks
  },
  [ConditionType.FRIGHTENED]: {
    description: "Disadvantage on checks while source is in sight, cannot move closer",
    attackDisadvantage: true,
    abilityCheckDisadvantage: true
  },
  [ConditionType.GRAPPLED]: {
    description: "Speed becomes 0",
    speed: 0
  },
  [ConditionType.INCAPACITATED]: {
    description: "Cannot take actions or reactions",
    canTakeActions: false,
    canTakeReactions: false
  },
  [ConditionType.INVISIBLE]: {
    description: "Attacks have advantage, attacks against have disadvantage",
    attacksAgainstAdvantage: false
    // Actually disadvantage for attackers
  },
  [ConditionType.PARALYZED]: {
    description: "Incapacitated, auto-fail STR/DEX saves, attacks against have advantage, crits within 5ft",
    canTakeActions: false,
    canTakeReactions: false,
    speed: 0,
    autoFail: [Ability.STRENGTH, Ability.DEXTERITY],
    attacksAgainstAdvantage: true
  },
  [ConditionType.PETRIFIED]: {
    description: "Transformed to stone, incapacitated, resistance to all damage",
    canTakeActions: false,
    canTakeReactions: false,
    speed: 0,
    autoFail: [Ability.STRENGTH, Ability.DEXTERITY]
  },
  [ConditionType.POISONED]: {
    description: "Disadvantage on attack rolls and ability checks",
    attackDisadvantage: true,
    abilityCheckDisadvantage: true
  },
  [ConditionType.PRONE]: {
    description: "Disadvantage on attacks, attacks against have advantage (if within 5ft)",
    attackDisadvantage: true,
    speed: 0
    // Half speed to stand up
  },
  [ConditionType.RESTRAINED]: {
    description: "Speed 0, disadvantage on attacks and DEX saves, attacks against have advantage",
    speed: 0,
    attackDisadvantage: true,
    savingThrowDisadvantage: true,
    attacksAgainstAdvantage: true
  },
  [ConditionType.STUNNED]: {
    description: "Incapacitated, auto-fail STR/DEX saves, attacks against have advantage",
    canTakeActions: false,
    canTakeReactions: false,
    autoFail: [Ability.STRENGTH, Ability.DEXTERITY],
    attacksAgainstAdvantage: true
  },
  [ConditionType.UNCONSCIOUS]: {
    description: "Incapacitated, prone, auto-fail STR/DEX saves, attacks against have advantage, crits within 5ft",
    canTakeActions: false,
    canTakeReactions: false,
    speed: 0,
    autoFail: [Ability.STRENGTH, Ability.DEXTERITY],
    attacksAgainstAdvantage: true
  },
  [ConditionType.BLEEDING]: {
    description: "Takes ongoing damage at start of turn",
    attackDisadvantage: false
  },
  [ConditionType.BURNING]: {
    description: "Takes ongoing fire damage at start of turn",
    attackDisadvantage: false
  },
  [ConditionType.CONCENTRATING]: {
    description: "Maintaining concentration on a spell or effect",
    attackDisadvantage: false
  },
  [ConditionType.EXHAUSTED]: {
    description: "Disadvantage on checks, reduced speed",
    abilityCheckDisadvantage: true,
    attackDisadvantage: true
  },
  [ConditionType.HASTED]: {
    description: "Increased speed and extra actions",
    attackDisadvantage: false
  },
  [ConditionType.SLOWED]: {
    description: "Reduced speed and disadvantage on DEX saves",
    savingThrowDisadvantage: true
  },
  [ConditionType.BLESSED]: {
    description: "Bonus to attack rolls and saving throws",
    attackDisadvantage: false
  },
  [ConditionType.CURSED]: {
    description: "Penalty to attack rolls and saving throws",
    attackDisadvantage: true
  },
  [ConditionType.MARKED]: {
    description: "Attacks against this target have advantage",
    attacksAgainstAdvantage: true
  },
  [ConditionType.HIDDEN]: {
    description: "Cannot be seen by enemies",
    attacksAgainstAdvantage: false
  }
};

// dist/engine/combat/engine.js
var CombatEngine = class {
  rng;
  state = null;
  emitter;
  constructor(seed, emitter) {
    this.rng = new CombatRNG(seed);
    this.emitter = emitter;
  }
  /**
   * Start a new combat encounter
   * Rolls initiative for all participants and establishes turn order
   *
   * If any participant has hasLairActions=true, adds 'LAIR' to turn order at initiative 20
   */
  startEncounter(participants) {
    const participantsWithInitiative = participants.map((p) => {
      const rolledInitiative = this.rng.d20(p.initiativeBonus);
      return {
        ...p,
        initiative: rolledInitiative,
        // Auto-detect isEnemy if not explicitly set
        isEnemy: p.isEnemy ?? this.detectIsEnemy(p.id, p.name),
        // Initialize legendary actions remaining to max if applicable
        legendaryActionsRemaining: p.legendaryActions ?? p.legendaryActionsRemaining,
        legendaryResistancesRemaining: p.legendaryResistances ?? p.legendaryResistancesRemaining
      };
    });
    const lairOwner = participantsWithInitiative.find((p) => p.hasLairActions);
    const hasLairActions = !!lairOwner;
    participantsWithInitiative.sort((a, b) => {
      if (b.initiative !== a.initiative) {
        return b.initiative - a.initiative;
      }
      return a.id.localeCompare(b.id);
    });
    let turnOrder = participantsWithInitiative.map((r) => r.id);
    if (hasLairActions) {
      const lairIndex = participantsWithInitiative.findIndex((p) => (p.initiative ?? 0) <= 20);
      if (lairIndex === -1) {
        turnOrder.push("LAIR");
      } else {
        turnOrder.splice(lairIndex, 0, "LAIR");
      }
    }
    this.state = {
      participants: participantsWithInitiative,
      turnOrder,
      currentTurnIndex: 0,
      round: 1,
      hasLairActions,
      lairOwnerId: lairOwner?.id
    };
    this.emitter?.publish("combat", {
      type: "encounter_started",
      state: this.state
    });
    return this.state;
  }
  /**
   * Auto-detect if a participant is an enemy based on ID/name patterns
   */
  detectIsEnemy(id, name) {
    const idLower = id.toLowerCase();
    const nameLower = name.toLowerCase();
    const enemyPatterns = [
      "goblin",
      "orc",
      "wolf",
      "bandit",
      "skeleton",
      "zombie",
      "dragon",
      "troll",
      "ogre",
      "kobold",
      "gnoll",
      "demon",
      "devil",
      "undead",
      "enemy",
      "monster",
      "creature",
      "beast",
      "spider",
      "rat",
      "bat",
      "slime",
      "ghost",
      "wraith",
      "dracolich",
      "lich",
      "vampire",
      "golem",
      "elemental"
    ];
    for (const pattern of enemyPatterns) {
      if (idLower.includes(pattern) || nameLower.includes(pattern)) {
        return true;
      }
    }
    const allyPatterns = [
      "hero",
      "player",
      "pc",
      "ally",
      "companion",
      "npc-friendly"
    ];
    for (const pattern of allyPatterns) {
      if (idLower.includes(pattern) || nameLower.includes(pattern)) {
        return false;
      }
    }
    return !idLower.startsWith("player") && !idLower.startsWith("hero");
  }
  /**
   * Get the current state
   */
  getState() {
    return this.state;
  }
  /**
   * Load an existing combat state
   */
  loadState(state) {
    this.state = state;
  }
  /**
   * Get the participant whose turn it currently is
   * Returns null if it's LAIR's turn
   */
  getCurrentParticipant() {
    if (!this.state)
      return null;
    const currentId = this.state.turnOrder[this.state.currentTurnIndex];
    if (currentId === "LAIR")
      return null;
    return this.state.participants.find((p) => p.id === currentId) || null;
  }
  /**
   * Check if it's currently the LAIR's turn (initiative 20)
   */
  isLairActionPending() {
    if (!this.state)
      return false;
    return this.state.turnOrder[this.state.currentTurnIndex] === "LAIR";
  }
  /**
   * Check if a legendary creature can use a legendary action
   * Rules: Can only use at the end of another creature's turn, not their own
   */
  canUseLegendaryAction(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return false;
    if (!participant.legendaryActions || participant.legendaryActions <= 0)
      return false;
    if (!participant.legendaryActionsRemaining || participant.legendaryActionsRemaining <= 0)
      return false;
    const currentId = this.state.turnOrder[this.state.currentTurnIndex];
    if (currentId === participantId)
      return false;
    if (currentId === "LAIR")
      return false;
    return true;
  }
  /**
   * Use a legendary action
   * @param participantId - ID of the legendary creature
   * @param cost - How many legendary actions this use costs (default 1)
   * @returns Result with success status and remaining actions
   */
  useLegendaryAction(participantId, cost = 1) {
    if (!this.state) {
      return { success: false, remaining: 0, error: "No active combat" };
    }
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant) {
      return { success: false, remaining: 0, error: "Participant not found" };
    }
    if (!this.canUseLegendaryAction(participantId)) {
      return {
        success: false,
        remaining: participant.legendaryActionsRemaining ?? 0,
        error: "Cannot use legendary action (own turn, no actions, or none remaining)"
      };
    }
    const remaining = participant.legendaryActionsRemaining ?? 0;
    if (remaining < cost) {
      return {
        success: false,
        remaining,
        error: `Not enough legendary actions (need ${cost}, have ${remaining})`
      };
    }
    participant.legendaryActionsRemaining = remaining - cost;
    this.emitter?.publish("combat", {
      type: "legendary_action_used",
      participantId,
      cost,
      remaining: participant.legendaryActionsRemaining
    });
    return {
      success: true,
      remaining: participant.legendaryActionsRemaining
    };
  }
  /**
   * Use a legendary resistance to automatically succeed on a failed save
   * Unlike legendary actions, these do NOT reset each round
   */
  useLegendaryResistance(participantId) {
    if (!this.state) {
      return { success: false, remaining: 0, error: "No active combat" };
    }
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant) {
      return { success: false, remaining: 0, error: "Participant not found" };
    }
    if (!participant.legendaryResistances || participant.legendaryResistances <= 0) {
      return { success: false, remaining: 0, error: "No legendary resistances" };
    }
    const remaining = participant.legendaryResistancesRemaining ?? 0;
    if (remaining <= 0) {
      return { success: false, remaining: 0, error: "No legendary resistances remaining" };
    }
    participant.legendaryResistancesRemaining = remaining - 1;
    this.emitter?.publish("combat", {
      type: "legendary_resistance_used",
      participantId,
      remaining: participant.legendaryResistancesRemaining
    });
    return {
      success: true,
      remaining: participant.legendaryResistancesRemaining
    };
  }
  /**
   * Reset legendary actions for a participant (called at start of their turn)
   */
  resetLegendaryActions(participant) {
    if (participant.legendaryActions && participant.legendaryActions > 0) {
      participant.legendaryActionsRemaining = participant.legendaryActions;
    }
  }
  /**
   * Advance to the next turn
   * Returns the participant whose turn it now is
   */
  nextTurn() {
    if (!this.state)
      return null;
    this.state.currentTurnIndex++;
    if (this.state.currentTurnIndex >= this.state.turnOrder.length) {
      this.state.currentTurnIndex = 0;
      this.state.round++;
    }
    return this.getCurrentParticipant();
  }
  /**
   * HIGH-002: Calculate damage after applying resistance/vulnerability/immunity
   */
  calculateDamageWithModifiers(baseDamage, damageType, target) {
    if (!damageType) {
      return { finalDamage: baseDamage, modifier: "normal" };
    }
    const typeLC = damageType.toLowerCase();
    if (target.immunities?.some((i) => i.toLowerCase() === typeLC)) {
      return { finalDamage: 0, modifier: "immune" };
    }
    if (target.resistances?.some((r) => r.toLowerCase() === typeLC)) {
      return { finalDamage: Math.floor(baseDamage / 2), modifier: "resistant" };
    }
    if (target.vulnerabilities?.some((v) => v.toLowerCase() === typeLC)) {
      return { finalDamage: baseDamage * 2, modifier: "vulnerable" };
    }
    return { finalDamage: baseDamage, modifier: "normal" };
  }
  /**
   * Execute an attack with full transparency
   * Returns detailed breakdown of what happened
   */
  executeAttack(actorId, targetId, attackBonus, dc, damage, damageType) {
    if (!this.state)
      throw new Error("No active combat");
    const actor = this.state.participants.find((p) => p.id === actorId);
    const target = this.state.participants.find((p) => p.id === targetId);
    if (!actor)
      throw new Error(`Actor ${actorId} not found`);
    if (!target)
      throw new Error(`Target ${targetId} not found`);
    const hpBefore = target.hp;
    const attackRoll = this.rng.checkDegreeDetailed(attackBonus, dc);
    let damageDealt = 0;
    let damageModifier = "normal";
    if (attackRoll.isHit) {
      const baseDamage = attackRoll.isCrit ? damage * 2 : damage;
      const modResult = this.calculateDamageWithModifiers(baseDamage, damageType, target);
      damageDealt = modResult.finalDamage;
      damageModifier = modResult.modifier;
      target.hp = Math.max(0, target.hp - damageDealt);
    }
    const defeated = target.hp <= 0;
    let breakdown = `\u{1F3B2} Attack Roll: d20(${attackRoll.roll}) + ${attackBonus} = ${attackRoll.total} vs AC ${dc}
`;
    if (attackRoll.isNat20) {
      breakdown += `   \u2B50 NATURAL 20!
`;
    } else if (attackRoll.isNat1) {
      breakdown += `   \u{1F480} NATURAL 1!
`;
    }
    breakdown += `   ${attackRoll.isHit ? "\u2705 HIT" : "\u274C MISS"}`;
    if (attackRoll.isHit) {
      breakdown += attackRoll.isCrit ? " (CRITICAL!)" : "";
      const typeStr = damageType ? ` ${damageType}` : "";
      let modStr = "";
      if (damageModifier === "immune") {
        modStr = " [IMMUNE - No damage!]";
      } else if (damageModifier === "resistant") {
        modStr = " [Resistant - Halved!]";
      } else if (damageModifier === "vulnerable") {
        modStr = " [Vulnerable - Doubled!]";
      }
      breakdown += `

\u{1F4A5} Damage: ${damageDealt}${typeStr}${attackRoll.isCrit ? " (crit)" : ""}${modStr}
`;
      breakdown += `   ${target.name}: ${hpBefore} \u2192 ${target.hp}/${target.maxHp} HP`;
      if (defeated) {
        breakdown += ` [DEFEATED]`;
      }
    }
    let message = "";
    if (attackRoll.isHit) {
      message = `${attackRoll.isCrit ? "CRITICAL " : ""}HIT! ${actor.name} deals ${damageDealt} damage to ${target.name}`;
      if (defeated)
        message += " [DEFEATED]";
    } else {
      message = `MISS! ${actor.name}'s attack misses ${target.name}`;
    }
    this.emitter?.publish("combat", {
      type: "attack_executed",
      result: {
        actor: actor.name,
        target: target.name,
        roll: attackRoll.roll,
        total: attackRoll.total,
        dc,
        hit: attackRoll.isHit,
        crit: attackRoll.isCrit,
        damage: damageDealt,
        targetHp: target.hp
      }
    });
    return {
      type: "attack",
      actor: { id: actor.id, name: actor.name },
      target: { id: target.id, name: target.name, hpBefore, hpAfter: target.hp, maxHp: target.maxHp },
      attackRoll,
      damage: damageDealt,
      success: attackRoll.isHit,
      defeated,
      message,
      detailedBreakdown: breakdown
    };
  }
  /**
   * Execute a heal action
   */
  executeHeal(actorId, targetId, amount) {
    if (!this.state)
      throw new Error("No active combat");
    const actor = this.state.participants.find((p) => p.id === actorId);
    const target = this.state.participants.find((p) => p.id === targetId);
    if (!actor)
      throw new Error(`Actor ${actorId} not found`);
    if (!target)
      throw new Error(`Target ${targetId} not found`);
    const hpBefore = target.hp;
    const actualHeal = Math.min(amount, target.maxHp - target.hp);
    target.hp = Math.min(target.maxHp, target.hp + amount);
    const breakdown = `\u{1F49A} Heal: ${amount} HP
   ${target.name}: ${hpBefore} \u2192 ${target.hp}/${target.maxHp} HP
` + (actualHeal < amount ? `   (${amount - actualHeal} HP wasted - at max)` : "");
    const message = `${actor.name} heals ${target.name} for ${actualHeal} HP`;
    this.emitter?.publish("combat", {
      type: "heal_executed",
      result: {
        actor: actor.name,
        target: target.name,
        amount: actualHeal,
        targetHp: target.hp
      }
    });
    return {
      type: "heal",
      actor: { id: actor.id, name: actor.name },
      target: { id: target.id, name: target.name, hpBefore, hpAfter: target.hp, maxHp: target.maxHp },
      healAmount: actualHeal,
      success: true,
      defeated: false,
      message,
      detailedBreakdown: breakdown
    };
  }
  /**
   * Pathfinder 2e: Make a check and return degree of success
   */
  makeCheck(modifier, dc) {
    return this.rng.checkDegree(modifier, dc);
  }
  /**
   * Make a detailed check exposing all dice mechanics
   */
  makeCheckDetailed(modifier, dc) {
    return this.rng.checkDegreeDetailed(modifier, dc);
  }
  /**
   * Apply damage to a participant
   */
  applyDamage(participantId, damage) {
    if (!this.state)
      return;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (participant) {
      participant.hp = Math.max(0, participant.hp - damage);
      this.emitter?.publish("combat", {
        type: "damage_applied",
        participantId,
        amount: damage,
        newHp: participant.hp
      });
    }
  }
  /**
   * Heal a participant
   * MED-003: Also resets death saves if healing from 0 HP
   */
  heal(participantId, amount) {
    if (!this.state)
      return;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (participant) {
      const wasAtZero = participant.hp === 0;
      participant.hp = Math.min(participant.maxHp, participant.hp + amount);
      if (wasAtZero && participant.hp > 0) {
        participant.deathSaveSuccesses = 0;
        participant.deathSaveFailures = 0;
        participant.isStabilized = false;
      }
      this.emitter?.publish("combat", {
        type: "healed",
        participantId,
        amount,
        newHp: participant.hp
      });
    }
  }
  /**
   * MED-003: Roll a death saving throw for a participant at 0 HP
   * D&D 5e Rules:
   * - Roll d20
   * - 10+ = success
   * - 9 or less = failure
   * - Natural 20 = regain 1 HP (conscious again)
   * - Natural 1 = counts as 2 failures
   * - 3 successes = stabilized (unconscious but won't die)
   * - 3 failures = dead
   */
  rollDeathSave(participantId) {
    if (!this.state)
      return null;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return null;
    if (participant.hp > 0) {
      return null;
    }
    if (participant.isDead) {
      return null;
    }
    if (participant.isStabilized) {
      return null;
    }
    if (participant.deathSaveSuccesses === void 0) {
      participant.deathSaveSuccesses = 0;
    }
    if (participant.deathSaveFailures === void 0) {
      participant.deathSaveFailures = 0;
    }
    const roll = Math.floor(Math.random() * 20) + 1;
    const isNat20 = roll === 20;
    const isNat1 = roll === 1;
    const success = roll >= 10;
    if (isNat20) {
      participant.hp = 1;
      participant.deathSaveSuccesses = 0;
      participant.deathSaveFailures = 0;
      participant.isStabilized = false;
    } else if (isNat1) {
      participant.deathSaveFailures = Math.min(3, participant.deathSaveFailures + 2);
    } else if (success) {
      participant.deathSaveSuccesses = Math.min(3, participant.deathSaveSuccesses + 1);
    } else {
      participant.deathSaveFailures = Math.min(3, participant.deathSaveFailures + 1);
    }
    if (participant.deathSaveSuccesses >= 3) {
      participant.isStabilized = true;
    }
    if (participant.deathSaveFailures >= 3) {
      participant.isDead = true;
    }
    const result = {
      roll,
      isNat20,
      isNat1,
      success,
      successes: participant.deathSaveSuccesses,
      failures: participant.deathSaveFailures,
      isStabilized: participant.isStabilized ?? false,
      isDead: participant.isDead ?? false,
      regainedHp: isNat20
    };
    this.emitter?.publish("combat", {
      type: "death_save",
      participantId,
      result
    });
    return result;
  }
  /**
   * MED-003: Apply damage at 0 HP (causes automatic death save failures)
   * D&D 5e Rules: Taking damage at 0 HP = 1 failure (crit = 2 failures)
   */
  applyDamageAtZeroHp(participantId, isCritical = false) {
    if (!this.state)
      return;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant || participant.hp > 0 || participant.isDead)
      return;
    if (participant.deathSaveFailures === void 0) {
      participant.deathSaveFailures = 0;
    }
    const failures = isCritical ? 2 : 1;
    participant.deathSaveFailures = Math.min(3, participant.deathSaveFailures + failures);
    if (participant.deathSaveFailures >= 3) {
      participant.isDead = true;
    }
    participant.isStabilized = false;
    this.emitter?.publish("combat", {
      type: "death_save_failure",
      participantId,
      failures,
      total: participant.deathSaveFailures,
      isDead: participant.isDead
    });
  }
  /**
   * Check if a participant is still conscious (hp > 0)
   */
  isConscious(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    return participant ? participant.hp > 0 : false;
  }
  /**
   * Get count of conscious participants
   */
  getConsciousCount() {
    if (!this.state)
      return 0;
    return this.state.participants.filter((p) => p.hp > 0).length;
  }
  /**
   * Apply a condition to a participant
   */
  applyCondition(participantId, condition) {
    if (!this.state)
      throw new Error("No active combat");
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      throw new Error(`Participant ${participantId} not found`);
    const fullCondition = {
      ...condition,
      id: `${participantId}-${condition.type}-${Date.now()}-${Math.random()}`
    };
    participant.conditions.push(fullCondition);
    return fullCondition;
  }
  /**
   * Remove a specific condition instance by ID
   */
  removeCondition(participantId, conditionId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return false;
    const initialLength = participant.conditions.length;
    participant.conditions = participant.conditions.filter((c) => c.id !== conditionId);
    return participant.conditions.length < initialLength;
  }
  /**
   * Remove all conditions of a specific type from a participant
   */
  removeConditionsByType(participantId, type) {
    if (!this.state)
      return 0;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return 0;
    const initialLength = participant.conditions.length;
    participant.conditions = participant.conditions.filter((c) => c.type !== type);
    return initialLength - participant.conditions.length;
  }
  /**
   * Check if a participant has a specific condition type
   */
  hasCondition(participantId, type) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    return participant ? participant.conditions.some((c) => c.type === type) : false;
  }
  /**
   * Get all conditions on a participant
   */
  getConditions(participantId) {
    if (!this.state)
      return [];
    const participant = this.state.participants.find((p) => p.id === participantId);
    return participant ? [...participant.conditions] : [];
  }
  /**
   * HIGH-003: Reset reaction and disengage status at start of turn
   */
  resetTurnResources(participant) {
    participant.reactionUsed = false;
    participant.hasDisengaged = false;
  }
  /**
   * Process start-of-turn condition effects
   */
  processStartOfTurnConditions(participant) {
    this.resetTurnResources(participant);
    this.resetLegendaryActions(participant);
    for (const condition of [...participant.conditions]) {
      if (condition.ongoingEffects) {
        for (const effect of condition.ongoingEffects) {
          if (effect.trigger === "start_of_turn") {
            if (effect.type === "damage" && effect.amount) {
              this.applyDamage(participant.id, effect.amount);
            } else if (effect.type === "healing" && effect.amount) {
              this.heal(participant.id, effect.amount);
            } else if (effect.type === "damage" && effect.dice) {
              const damage = this.rng.roll(effect.dice);
              this.applyDamage(participant.id, damage);
            }
          }
        }
      }
      if (condition.durationType === DurationType.START_OF_TURN) {
        this.removeCondition(participant.id, condition.id);
      } else if (condition.durationType === DurationType.ROUNDS && condition.duration !== void 0) {
        condition.duration--;
        if (condition.duration <= 0) {
          this.removeCondition(participant.id, condition.id);
        }
      }
    }
  }
  /**
   * Process end-of-turn condition effects
   */
  processEndOfTurnConditions(participant) {
    for (const condition of [...participant.conditions]) {
      if (condition.ongoingEffects) {
        for (const effect of condition.ongoingEffects) {
          if (effect.trigger === "end_of_turn") {
            if (effect.type === "damage" && effect.amount) {
              this.applyDamage(participant.id, effect.amount);
            } else if (effect.type === "healing" && effect.amount) {
              this.heal(participant.id, effect.amount);
            } else if (effect.type === "damage" && effect.dice) {
              const damage = this.rng.roll(effect.dice);
              this.applyDamage(participant.id, damage);
            }
          }
        }
      }
      if (condition.durationType === DurationType.END_OF_TURN) {
        this.removeCondition(participant.id, condition.id);
      }
      if (condition.durationType === DurationType.SAVE_ENDS && condition.saveDC && condition.saveAbility) {
        const saveBonus = this.getSaveBonus(participant, condition.saveAbility);
        const degree = this.rng.checkDegree(saveBonus, condition.saveDC);
        if (degree === "success" || degree === "critical-success") {
          this.removeCondition(participant.id, condition.id);
        }
      }
    }
  }
  /**
   * Get saving throw bonus for a participant
   */
  getSaveBonus(participant, ability) {
    if (!participant.abilityScores)
      return 0;
    const score = participant.abilityScores[ability];
    return Math.floor((score - 10) / 2);
  }
  /**
   * Enhanced nextTurn with condition processing and legendary action reset
   */
  nextTurnWithConditions() {
    if (!this.state)
      return null;
    const currentParticipant = this.getCurrentParticipant();
    if (currentParticipant) {
      this.processEndOfTurnConditions(currentParticipant);
    }
    this.state.currentTurnIndex++;
    if (this.state.currentTurnIndex >= this.state.turnOrder.length) {
      this.state.currentTurnIndex = 0;
      this.state.round++;
    }
    const newParticipant = this.getCurrentParticipant();
    if (newParticipant) {
      this.processStartOfTurnConditions(newParticipant);
    }
    this.emitter?.publish("combat", {
      type: "turn_changed",
      round: this.state.round,
      activeParticipantId: newParticipant?.id,
      isLairAction: this.isLairActionPending()
    });
    return newParticipant;
  }
  /**
   * Check if a participant can take actions (not incapacitated)
   */
  canTakeActions(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant || participant.hp <= 0)
      return false;
    return !participant.conditions.some((c) => {
      const effects = CONDITION_EFFECTS[c.type];
      return effects.canTakeActions === false;
    });
  }
  /**
   * Check if a participant can take reactions
   */
  canTakeReactions(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant || participant.hp <= 0)
      return false;
    return !participant.conditions.some((c) => {
      const effects = CONDITION_EFFECTS[c.type];
      return effects.canTakeReactions === false;
    });
  }
  /**
   * HIGH-003: Check if two positions are adjacent (within 1 tile - 8-directional)
   */
  isAdjacent(pos1, pos2) {
    const dx = Math.abs(pos1.x - pos2.x);
    const dy = Math.abs(pos1.y - pos2.y);
    return dx <= 1 && dy <= 1 && !(dx === 0 && dy === 0);
  }
  /**
   * HIGH-003: Get adjacent enemies that could make opportunity attacks
   * @param moverId - The creature that is moving
   * @param fromPos - Starting position
   * @param toPos - Target position
   * @returns Array of participants who can make opportunity attacks
   */
  getOpportunityAttackers(moverId, fromPos, toPos) {
    if (!this.state)
      return [];
    const mover = this.state.participants.find((p) => p.id === moverId);
    if (!mover)
      return [];
    if (mover.hasDisengaged)
      return [];
    const attackers = [];
    for (const p of this.state.participants) {
      if (p.id === moverId)
        continue;
      if (p.hp <= 0)
        continue;
      if (p.isEnemy === mover.isEnemy)
        continue;
      if (p.reactionUsed)
        continue;
      if (!p.position)
        continue;
      const wasAdjacent = this.isAdjacent(fromPos, p.position);
      const stillAdjacent = this.isAdjacent(toPos, p.position);
      if (wasAdjacent && !stillAdjacent) {
        attackers.push(p);
      }
    }
    return attackers;
  }
  /**
   * HIGH-003: Execute an opportunity attack
   * Uses simplified attack: d20 + attacker's initiative bonus vs target's initiative + 10
   * Damage is fixed at 1d6 + 2 for simplicity
   */
  executeOpportunityAttack(attackerId, targetId) {
    if (!this.state)
      throw new Error("No active combat");
    const attacker = this.state.participants.find((p) => p.id === attackerId);
    const target = this.state.participants.find((p) => p.id === targetId);
    if (!attacker)
      throw new Error(`Attacker ${attackerId} not found`);
    if (!target)
      throw new Error(`Target ${targetId} not found`);
    attacker.reactionUsed = true;
    const attackBonus = attacker.initiativeBonus + 2;
    const targetAC = 10 + (target.initiativeBonus > 0 ? Math.floor(target.initiativeBonus / 2) : 0);
    const baseDamage = this.rng.roll("1d6") + 2;
    const hpBefore = target.hp;
    const attackRoll = this.rng.checkDegreeDetailed(attackBonus, targetAC);
    let damageDealt = 0;
    if (attackRoll.isHit) {
      damageDealt = attackRoll.isCrit ? baseDamage * 2 : baseDamage;
      target.hp = Math.max(0, target.hp - damageDealt);
    }
    const defeated = target.hp <= 0;
    let breakdown = `\u26A1 OPPORTUNITY ATTACK by ${attacker.name}!
`;
    breakdown += `\u{1F3B2} Attack Roll: d20(${attackRoll.roll}) + ${attackBonus} = ${attackRoll.total} vs AC ${targetAC}
`;
    if (attackRoll.isNat20) {
      breakdown += `   \u2B50 NATURAL 20!
`;
    } else if (attackRoll.isNat1) {
      breakdown += `   \u{1F480} NATURAL 1!
`;
    }
    breakdown += `   ${attackRoll.isHit ? "\u2705 HIT" : "\u274C MISS"}`;
    if (attackRoll.isHit) {
      breakdown += attackRoll.isCrit ? " (CRITICAL!)" : "";
      breakdown += `

\u{1F4A5} Damage: ${damageDealt}${attackRoll.isCrit ? " (crit)" : ""}
`;
      breakdown += `   ${target.name}: ${hpBefore} \u2192 ${target.hp}/${target.maxHp} HP`;
      if (defeated) {
        breakdown += ` [DEFEATED]`;
      }
    }
    const message = attackRoll.isHit ? `OPPORTUNITY ATTACK HIT! ${attacker.name} strikes ${target.name} for ${damageDealt} damage` : `OPPORTUNITY ATTACK MISS! ${attacker.name}'s attack misses ${target.name}`;
    this.emitter?.publish("combat", {
      type: "opportunity_attack",
      result: {
        attacker: attacker.name,
        target: target.name,
        roll: attackRoll.roll,
        total: attackRoll.total,
        ac: targetAC,
        hit: attackRoll.isHit,
        crit: attackRoll.isCrit,
        damage: damageDealt,
        targetHp: target.hp
      }
    });
    return {
      type: "attack",
      actor: { id: attacker.id, name: attacker.name },
      target: { id: target.id, name: target.name, hpBefore, hpAfter: target.hp, maxHp: target.maxHp },
      attackRoll,
      damage: damageDealt,
      success: attackRoll.isHit,
      defeated,
      message,
      detailedBreakdown: breakdown
    };
  }
  /**
   * HIGH-003: Mark a participant as having taken the disengage action
   */
  disengage(participantId) {
    if (!this.state)
      return;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (participant) {
      participant.hasDisengaged = true;
    }
  }
  /**
   * Check if attacks against a participant have advantage
   */
  attacksAgainstHaveAdvantage(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return false;
    return participant.conditions.some((c) => {
      const effects = CONDITION_EFFECTS[c.type];
      return effects.attacksAgainstAdvantage === true;
    });
  }
  /**
   * Check if a participant's attacks have disadvantage
   */
  attacksHaveDisadvantage(participantId) {
    if (!this.state)
      return false;
    const participant = this.state.participants.find((p) => p.id === participantId);
    if (!participant)
      return false;
    return participant.conditions.some((c) => {
      const effects = CONDITION_EFFECTS[c.type];
      return effects.attackDisadvantage === true;
    });
  }
};

// dist/engine/spatial/heap.js
var MinHeap = class {
  keyFn;
  heap = [];
  itemMap = /* @__PURE__ */ new Map();
  // Maps stringified item to index
  constructor(keyFn) {
    this.keyFn = keyFn;
  }
  /**
   * Insert an item with a given priority.
   * Time complexity: O(log n)
   */
  insert(item, priority) {
    const key = this.keyFn(item);
    if (this.itemMap.has(key)) {
      this.decreaseKey(item, priority);
      return;
    }
    this.heap.push({ item, priority });
    const index = this.heap.length - 1;
    this.itemMap.set(key, index);
    this.bubbleUp(index);
  }
  /**
   * Extract and return the item with minimum priority.
   * Time complexity: O(log n)
   */
  extractMin() {
    if (this.heap.length === 0)
      return null;
    if (this.heap.length === 1) {
      const { item } = this.heap.pop();
      this.itemMap.clear();
      return item;
    }
    const min = this.heap[0];
    const last = this.heap.pop();
    this.heap[0] = last;
    this.itemMap.delete(this.keyFn(min.item));
    this.itemMap.set(this.keyFn(last.item), 0);
    this.bubbleDown(0);
    return min.item;
  }
  /**
   * Decrease the priority of an existing item.
   * Time complexity: O(log n)
   */
  decreaseKey(item, newPriority) {
    const key = this.keyFn(item);
    const index = this.itemMap.get(key);
    if (index === void 0)
      return;
    const oldPriority = this.heap[index].priority;
    if (newPriority >= oldPriority)
      return;
    this.heap[index].priority = newPriority;
    this.bubbleUp(index);
  }
  /**
   * Check if the heap is empty.
   */
  isEmpty() {
    return this.heap.length === 0;
  }
  /**
   * Get the current size of the heap.
   */
  size() {
    return this.heap.length;
  }
  /**
   * Bubble up an item to maintain heap property.
   */
  bubbleUp(index) {
    while (index > 0) {
      const parentIndex = Math.floor((index - 1) / 2);
      if (this.heap[index].priority >= this.heap[parentIndex].priority) {
        break;
      }
      this.swap(index, parentIndex);
      index = parentIndex;
    }
  }
  /**
   * Bubble down an item to maintain heap property.
   */
  bubbleDown(index) {
    while (true) {
      const leftChild = 2 * index + 1;
      const rightChild = 2 * index + 2;
      let smallest = index;
      if (leftChild < this.heap.length && this.heap[leftChild].priority < this.heap[smallest].priority) {
        smallest = leftChild;
      }
      if (rightChild < this.heap.length && this.heap[rightChild].priority < this.heap[smallest].priority) {
        smallest = rightChild;
      }
      if (smallest === index)
        break;
      this.swap(index, smallest);
      index = smallest;
    }
  }
  /**
   * Swap two elements in the heap and update the item map.
   */
  swap(i, j) {
    const temp = this.heap[i];
    this.heap[i] = this.heap[j];
    this.heap[j] = temp;
    this.itemMap.set(this.keyFn(this.heap[i].item), i);
    this.itemMap.set(this.keyFn(this.heap[j].item), j);
  }
};

// dist/engine/spatial/engine.js
var SpatialEngine = class {
  // AoE shape cache for common radii
  circleCache = /* @__PURE__ */ new Map();
  MAX_CACHED_RADIUS = 10;
  /**
   * Validates that a point has finite numeric coordinates and is within optional bounds.
   * @throws Error if coordinates are not finite numbers or out of bounds
   */
  validatePoint(p, paramName, bounds) {
    if (!Number.isFinite(p.x) || !Number.isFinite(p.y)) {
      throw new Error(`Invalid ${paramName}: coordinates must be finite numbers (got x=${p.x}, y=${p.y})`);
    }
    if (p.z !== void 0 && !Number.isFinite(p.z)) {
      throw new Error(`Invalid ${paramName}: z-coordinate must be a finite number (got z=${p.z})`);
    }
    if (bounds) {
      if (p.x < bounds.min.x || p.x > bounds.max.x || p.y < bounds.min.y || p.y > bounds.max.y) {
        throw new Error(`Invalid ${paramName}: out of bounds (got ${p.x},${p.y}; bounds: ${bounds.min.x},${bounds.min.y} to ${bounds.max.x},${bounds.max.y})`);
      }
      if (p.z !== void 0 && (bounds.min.z !== void 0 && bounds.max.z !== void 0)) {
        if (p.z < bounds.min.z || p.z > bounds.max.z) {
          throw new Error(`Invalid ${paramName}: z-coordinate out of bounds`);
        }
      }
    }
  }
  /**
   * Calculates distance between two points using the specified metric.
   * Automatically handles 2D and 3D points.
   *
   * @param p1 First point
   * @param p2 Second point
   * @param metric Distance metric to use (default: 'euclidean')
   * @returns Distance between points
   *
   * @example
   * ```typescript
   * const engine = new SpatialEngine();
   * // 2D
   * engine.getDistance({x: 0, y: 0}, {x: 3, y: 4}); // 5
   * // 3D
   * engine.getDistance({x: 0, y: 0, z: 0}, {x: 3, y: 4, z: 12}); // 13
   * ```
   */
  getDistance(p1, p2, metric = "euclidean") {
    this.validatePoint(p1, "p1");
    this.validatePoint(p2, "p2");
    const dx = Math.abs(p1.x - p2.x);
    const dy = Math.abs(p1.y - p2.y);
    const dz = Math.abs((p1.z ?? 0) - (p2.z ?? 0));
    switch (metric) {
      case "manhattan":
        return dx + dy + dz;
      case "chebyshev":
        return Math.max(dx, dy, dz);
      case "euclidean":
        return Math.sqrt(dx * dx + dy * dy + dz * dz);
    }
  }
  /**
   * Returns all tiles within a given radius of a center point.
   * Uses Euclidean distance for circular shape.
   * Automatically caches results for radii <= 10 for performance.
   *
   * @param center Center point of the circle
   * @param radius Radius in grid units (must be non-negative)
   * @param useCache Whether to use caching (default: true)
   * @returns Array of points within the radius
   *
   * @example
   * ```typescript
   * const engine = new SpatialEngine();
   * // Get tiles in a 5-unit radius (cached)
   * const tiles = engine.getCircleTiles({x: 10, y: 10}, 5);
   * // Large radius without caching
   * const largeTiles = engine.getCircleTiles({x: 0, y: 0}, 50, false);
   * ```
   */
  getCircleTiles(center, radius, useCache = true) {
    this.validatePoint(center, "center");
    if (!Number.isFinite(radius) || radius < 0) {
      throw new Error(`Invalid radius: must be a non-negative finite number (got ${radius})`);
    }
    if (useCache && radius <= this.MAX_CACHED_RADIUS && !center.z) {
      const cacheKey = radius.toString();
      if (!this.circleCache.has(cacheKey)) {
        const origin = { x: 0, y: 0 };
        const offsets2 = this.computeCircleTiles(origin, radius);
        this.circleCache.set(cacheKey, offsets2);
      }
      const offsets = this.circleCache.get(cacheKey);
      return offsets.map((offset) => ({
        x: center.x + offset.x,
        y: center.y + offset.y
      }));
    }
    return this.computeCircleTiles(center, radius);
  }
  /**
   * Internal method to compute circle tiles without caching.
   * @private
   */
  computeCircleTiles(center, radius) {
    const tiles = [];
    const rCeil = Math.ceil(radius);
    if (center.z !== void 0) {
      for (let x = center.x - rCeil; x <= center.x + rCeil; x++) {
        for (let y = center.y - rCeil; y <= center.y + rCeil; y++) {
          for (let z = center.z - rCeil; z <= center.z + rCeil; z++) {
            const p = { x, y, z };
            if (this.getDistance(center, p) <= radius) {
              tiles.push(p);
            }
          }
        }
      }
    } else {
      for (let x = center.x - rCeil; x <= center.x + rCeil; x++) {
        for (let y = center.y - rCeil; y <= center.y + rCeil; y++) {
          const p = { x, y };
          if (this.getDistance(center, p) <= radius) {
            tiles.push(p);
          }
        }
      }
    }
    return tiles;
  }
  /**
   * Returns tiles within a cone defined by origin, direction, length, and angle.
   *
   * @param origin Origin point of the cone (typically the caster's position)
   * @param direction Direction vector (NOT a target point). For example, {x: 1, y: 0} points East.
   * @param length Maximum distance from origin in grid units
   * @param angleDegrees Total angle of the cone in degrees (e.g., 90 for a quarter-circle)
   * @returns Array of points within the cone
   *
   * @example
   * ```typescript
   * const engine = new SpatialEngine();
   * // 90-degree cone facing East, 10 units long
   * const tiles = engine.getConeTiles(
   *     {x: 0, y: 0},           // origin
   *     {x: 1, y: 0},           // direction vector (East)
   *     10,                     // length
   *     90                      // angle in degrees
   * );
   * ```
   */
  getConeTiles(origin, direction, length, angleDegrees) {
    this.validatePoint(origin, "origin");
    this.validatePoint(direction, "direction");
    if (!Number.isFinite(length) || length < 0) {
      throw new Error(`Invalid length: must be non-negative (got ${length})`);
    }
    if (!Number.isFinite(angleDegrees) || angleDegrees <= 0 || angleDegrees > 360) {
      throw new Error(`Invalid angle: must be between 0 and 360 degrees (got ${angleDegrees})`);
    }
    const tiles = [];
    const halfAngleRad = angleDegrees / 2 * (Math.PI / 180);
    const dirLen = Math.sqrt(direction.x * direction.x + direction.y * direction.y + (direction.z ?? 0) * (direction.z ?? 0));
    if (dirLen === 0) {
      throw new Error("Invalid direction vector: length cannot be zero");
    }
    const dirNorm = {
      x: direction.x / dirLen,
      y: direction.y / dirLen,
      z: (direction.z ?? 0) / dirLen
    };
    const lCeil = Math.ceil(length);
    if (origin.z !== void 0) {
      for (let x = origin.x - lCeil; x <= origin.x + lCeil; x++) {
        for (let y = origin.y - lCeil; y <= origin.y + lCeil; y++) {
          for (let z = origin.z - lCeil; z <= origin.z + lCeil; z++) {
            const p = { x, y, z };
            if (this.isInCone(origin, p, dirNorm, length, halfAngleRad)) {
              tiles.push(p);
            }
          }
        }
      }
    } else {
      for (let x = origin.x - lCeil; x <= origin.x + lCeil; x++) {
        for (let y = origin.y - lCeil; y <= origin.y + lCeil; y++) {
          const p = { x, y };
          if (this.isInCone(origin, p, dirNorm, length, halfAngleRad)) {
            tiles.push(p);
          }
        }
      }
    }
    return tiles;
  }
  /**
   * Helper to check if a point is within a cone.
   * @private
   */
  isInCone(origin, p, dirNorm, length, halfAngleRad) {
    const dist = this.getDistance(origin, p);
    if (dist > length)
      return false;
    if (dist === 0)
      return true;
    const px = p.x - origin.x;
    const py = p.y - origin.y;
    const pz = (p.z ?? 0) - (origin.z ?? 0);
    const dot = px * dirNorm.x + py * dirNorm.y + pz * (dirNorm.z ?? 0);
    const cosTheta = dot / dist;
    return cosTheta >= Math.cos(halfAngleRad) - 1e-4;
  }
  /**
   * Returns tiles along a line from start to end using Bresenham's algorithm.
   *
   * @param start Start point of the line
   * @param end End point of the line
   * @returns Array of points along the line (including endpoints)
   */
  getLineTiles(start, end) {
    this.validatePoint(start, "start");
    this.validatePoint(end, "end");
    return this.bresenhamLine(start, end);
  }
  /**
   * Finds the shortest path between start and end using A* algorithm with binary heap optimization.
   * Supports custom movement costs including diagonal costs and terrain modifiers.
   *
   * @param start Starting point
   * @param end Target point
   * @param obstacles Set of blocked tiles in "x,y" or "x,y,z" format
   * @param options Optional configuration
   * @returns Array of points representing the path, or null if no path exists
   *
   * @example
   * ```typescript
   * const engine = new SpatialEngine();
   * const obstacles = new Set(['5,5', '5,6', '5,7']); // Wall
   *
   * // Basic pathfinding
   * const path1 = engine.findPath({x: 0, y: 0}, {x: 10, y: 0}, obstacles);
   *
   * // With D&D 5e diagonal costs
   * const path2 = engine.findPath({x: 0, y: 0}, {x: 10, y: 10}, obstacles, {
   *     diagonalCost: 'alternating' // 5-10-5 rule
   * });
   *
   * // With terrain costs
   * const terrainMap = { getTileCost: (p) => p.y > 5 ? 2 : 1 }; // Difficult terrain above y=5
   * const path3 = engine.findPath({x: 0, y: 0}, {x: 10, y: 10}, obstacles, {
   *     terrainCosts: terrainMap
   * });
   * ```
   */
  findPath(start, end, obstacles, options = {}) {
    this.validatePoint(start, "start", options.bounds);
    this.validatePoint(end, "end", options.bounds);
    const maxIterations = options.maxIterations ?? 1e4;
    const startKey = this.pointToKey(start);
    const endKey = this.pointToKey(end);
    const is3D = start.z !== void 0 || end.z !== void 0;
    if (startKey === endKey) {
      return [start];
    }
    if (obstacles.has(endKey)) {
      return null;
    }
    const getCost = this.createCostFunction(options);
    const openHeap = new MinHeap(this.pointToKey);
    const closedSet = /* @__PURE__ */ new Set();
    const cameFrom = /* @__PURE__ */ new Map();
    const gScore = /* @__PURE__ */ new Map();
    gScore.set(startKey, 0);
    const fScore = this.getDistance(start, end, "chebyshev");
    openHeap.insert(start, fScore);
    let iterations = 0;
    while (!openHeap.isEmpty()) {
      iterations++;
      if (iterations > maxIterations) {
        return null;
      }
      const current = openHeap.extractMin();
      const currentKey = this.pointToKey(current);
      if (this.pointsEqual(current, end)) {
        return this.reconstructPath(cameFrom, current);
      }
      closedSet.add(currentKey);
      const neighbors = this.getNeighbors(current, is3D);
      for (const neighbor of neighbors) {
        const neighborKey = this.pointToKey(neighbor);
        if (obstacles.has(neighborKey) || closedSet.has(neighborKey)) {
          continue;
        }
        const baseCost = getCost(current, neighbor);
        const terrainMultiplier = options.terrainCosts?.getTileCost(neighbor) ?? 1;
        if (terrainMultiplier === Infinity) {
          continue;
        }
        const moveCost = baseCost * terrainMultiplier;
        const tentativeG = gScore.get(currentKey) + moveCost;
        if (tentativeG < (gScore.get(neighborKey) ?? Infinity)) {
          cameFrom.set(neighborKey, current);
          gScore.set(neighborKey, tentativeG);
          const f = tentativeG + this.getDistance(neighbor, end, "chebyshev");
          openHeap.insert(neighbor, f);
        }
      }
    }
    return null;
  }
  /**
   * Creates a cost function based on pathfinding options.
   * @private
   */
  createCostFunction(options) {
    if (options.movementCostFn) {
      return options.movementCostFn;
    }
    const diagCost = options.diagonalCost ?? "uniform";
    return (from, to) => {
      const dx = Math.abs(to.x - from.x);
      const dy = Math.abs(to.y - from.y);
      const dz = Math.abs((to.z ?? 0) - (from.z ?? 0));
      const isDiagonal = dx + dy + dz > 1;
      if (diagCost === "uniform") {
        return 1;
      } else if (diagCost === "alternating") {
        return isDiagonal ? 1.5 : 1;
      } else {
        return isDiagonal ? diagCost : 1;
      }
    };
  }
  /**
   * Gets neighboring tiles (8 for 2D, 26 for 3D).
   * @private
   */
  getNeighbors(point, is3D) {
    const neighbors = [];
    const deltas = is3D ? [-1, 0, 1] : [-1, 0, 1];
    for (const dx of deltas) {
      for (const dy of deltas) {
        if (is3D && point.z !== void 0) {
          for (const dz of [-1, 0, 1]) {
            if (dx === 0 && dy === 0 && dz === 0)
              continue;
            neighbors.push({
              x: point.x + dx,
              y: point.y + dy,
              z: point.z + dz
            });
          }
        } else {
          if (dx === 0 && dy === 0)
            continue;
          neighbors.push({
            x: point.x + dx,
            y: point.y + dy
          });
        }
      }
    }
    return neighbors;
  }
  /**
   * Smooths a path by removing unnecessary waypoints using line-of-sight checks.
   * Uses the "string pulling" algorithm.
   *
   * @param path Original path from pathfinding
   * @param obstacles Obstacle set used for LOS checks
   * @returns Smoothed path with fewer waypoints
   *
   * @example
   * ```typescript
   * const obstacles = new Set(['5,5']);
   * const path = engine.findPath({x: 0, y: 0}, {x: 10, y: 10}, obstacles);
   * const smoothed = engine.smoothPath(path!, obstacles);
   * // smoothed.length <= path.length
   * ```
   */
  smoothPath(path, obstacles) {
    if (path.length <= 2)
      return path;
    const smoothed = [path[0]];
    let current = 0;
    while (current < path.length - 1) {
      let farthest = current + 1;
      for (let i = path.length - 1; i > current + 1; i--) {
        if (this.hasLineOfSight(path[current], path[i], obstacles)) {
          farthest = i;
          break;
        }
      }
      smoothed.push(path[farthest]);
      current = farthest;
    }
    return smoothed;
  }
  /**
   * Computes field of view (all visible tiles) from an origin using shadowcasting.
   * This is much more efficient than calling hasLineOfSight multiple times.
   *
   * @param origin Viewer position
   * @param range Maximum vision range
   * @param obstacles Set of opaque tiles
   * @returns Set of visible tile keys in "x,y" format
   *
   * @example
   * ```typescript
   * const obstacles = new Set(['5,5', '6,5']);
   * const fov = engine.getFieldOfView({x: 0, y: 0}, 10, obstacles);
   * console.log(fov.has('3,3')); // true - visible
   * console.log(fov.has('7,5')); // false - blocked by wall
   * ```
   */
  getFieldOfView(origin, range, obstacles) {
    const visible = /* @__PURE__ */ new Set();
    visible.add(this.pointToKey(origin));
    for (let octant = 0; octant < 8; octant++) {
      this.castLight(origin, range, 1, 1, 0, octant, obstacles, visible);
    }
    return visible;
  }
  /**
   * Recursive shadowcasting for one octant.
   * Based on the algorithm by Bjrn Bergstrm.
   * @private
   */
  castLight(origin, range, row, startSlope, endSlope, octant, obstacles, visible) {
    if (startSlope < endSlope)
      return;
    let nextStartSlope = startSlope;
    for (let i = row; i <= range; i++) {
      let blocked = false;
      for (let dy = -i; dy <= 0; dy++) {
        const dx = -i - dy;
        const tile = this.transformOctant(origin, dx, dy, octant);
        const dist = this.getDistance(origin, tile);
        if (dist > range)
          continue;
        const lSlope = (dy - 0.5) / (dx + 0.5);
        const rSlope = (dy + 0.5) / (dx - 0.5);
        if (startSlope < rSlope) {
          continue;
        } else if (endSlope > lSlope) {
          break;
        }
        const tileKey = this.pointToKey(tile);
        visible.add(tileKey);
        if (blocked) {
          if (obstacles.has(tileKey)) {
            nextStartSlope = rSlope;
            continue;
          } else {
            blocked = false;
            startSlope = nextStartSlope;
          }
        } else if (obstacles.has(tileKey) && i < range) {
          blocked = true;
          this.castLight(origin, range, i + 1, startSlope, lSlope, octant, obstacles, visible);
          nextStartSlope = rSlope;
        }
      }
      if (blocked)
        break;
    }
  }
  /**
   * Transforms coordinates based on octant for shadowcasting.
   * @private
   */
  transformOctant(origin, dx, dy, octant) {
    switch (octant) {
      case 0:
        return { x: origin.x + dx, y: origin.y + dy };
      case 1:
        return { x: origin.x + dy, y: origin.y + dx };
      case 2:
        return { x: origin.x - dy, y: origin.y + dx };
      case 3:
        return { x: origin.x - dx, y: origin.y + dy };
      case 4:
        return { x: origin.x - dx, y: origin.y - dy };
      case 5:
        return { x: origin.x - dy, y: origin.y - dx };
      case 6:
        return { x: origin.x + dy, y: origin.y - dx };
      case 7:
        return { x: origin.x + dx, y: origin.y - dy };
      default:
        return origin;
    }
  }
  /**
   * Checks if there is a clear line of sight between start and end points.
   * Uses Bresenham's line algorithm to check for obstacles on the path.
   * The start and end points themselves are not checked (you can see *to* an obstacle).
   *
   * @param start The starting point (viewer position)
   * @param end The ending point (target position)
   * @param obstacles Set of blocked tiles in "x,y" format
   * @returns true if the path is clear, false if blocked
   */
  hasLineOfSight(start, end, obstacles) {
    this.validatePoint(start, "start");
    this.validatePoint(end, "end");
    const line = this.bresenhamLine(start, end);
    for (let i = 1; i < line.length - 1; i++) {
      const p = line[i];
      if (obstacles.has(this.pointToKey(p))) {
        return false;
      }
    }
    return true;
  }
  /**
   * Bresenham's line algorithm implementation.
   * Returns all points on the line from start to end (inclusive).
   *
   * @private
   * @param start Start point
   * @param end End point
   * @returns Array of points on the line
   */
  bresenhamLine(start, end) {
    const points = [];
    let x0 = start.x;
    let y0 = start.y;
    const x1 = end.x;
    const y1 = end.y;
    const dx = Math.abs(x1 - x0);
    const dy = Math.abs(y1 - y0);
    const sx = x0 < x1 ? 1 : -1;
    const sy = y0 < y1 ? 1 : -1;
    let err = dx - dy;
    while (true) {
      points.push({ x: x0, y: y0 });
      if (x0 === x1 && y0 === y1)
        break;
      const e2 = 2 * err;
      if (e2 > -dy) {
        err -= dy;
        x0 += sx;
      }
      if (e2 < dx) {
        err += dx;
        y0 += sy;
      }
    }
    return points;
  }
  /**
   * Reconstructs the path from A* cameFrom map.
   *
   * @private
   * @param cameFrom Map of point keys to their predecessors
   * @param current The goal point
   * @returns Array of points from start to goal
   */
  reconstructPath(cameFrom, current) {
    const totalPath = [current];
    let curr = current;
    while (true) {
      const currKey = this.pointToKey(curr);
      if (!cameFrom.has(currKey))
        break;
      curr = cameFrom.get(currKey);
      totalPath.unshift(curr);
    }
    return totalPath;
  }
  /**
   * Converts a point to a string key.
   * @private
   */
  pointToKey(p) {
    return p.z !== void 0 ? `${p.x},${p.y},${p.z}` : `${p.x},${p.y}`;
  }
  /**
   * Checks if two points are equal.
   * @private
   */
  pointsEqual(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y && (p1.z ?? 0) === (p2.z ?? 0);
  }
};

// dist/server/state/combat-manager.js
var CombatManager = class {
  encounters = /* @__PURE__ */ new Map();
  create(id, engine) {
    if (this.encounters.has(id)) {
      throw new Error(`Encounter ${id} already exists`);
    }
    this.encounters.set(id, engine);
  }
  get(id) {
    return this.encounters.get(id) || null;
  }
  delete(id) {
    return this.encounters.delete(id);
  }
  list() {
    return Array.from(this.encounters.keys());
  }
  /**
   * Check if a character is participating in any active encounter
   * Used to prevent resting during combat
   */
  isCharacterInCombat(characterId) {
    for (const engine of this.encounters.values()) {
      const state = engine.getState();
      if (state?.participants.some((p) => p.id === characterId)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get list of encounter IDs that a character is participating in
   * Useful for error messages
   */
  getEncountersForCharacter(characterId) {
    const encounterIds = [];
    for (const [id, engine] of this.encounters.entries()) {
      const state = engine.getState();
      if (state?.participants.some((p) => p.id === characterId)) {
        encounterIds.push(id);
      }
    }
    return encounterIds;
  }
};
var instance2 = null;
function getCombatManager() {
  if (!instance2)
    instance2 = new CombatManager();
  return instance2;
}

// dist/schema/encounter.js
init_zod();
var ConditionSchema = external_exports.object({
  id: external_exports.string(),
  type: external_exports.string(),
  durationType: external_exports.string(),
  duration: external_exports.number().optional(),
  sourceId: external_exports.string().optional(),
  saveDC: external_exports.number().optional(),
  saveAbility: external_exports.string().optional(),
  ongoingEffects: external_exports.array(external_exports.any()).optional(),
  metadata: external_exports.record(external_exports.any()).optional()
});
var PositionSchema = external_exports.object({
  x: external_exports.number(),
  y: external_exports.number(),
  z: external_exports.number().optional()
});
var GridBoundsSchema = external_exports.object({
  minX: external_exports.number().default(0),
  maxX: external_exports.number().default(100),
  minY: external_exports.number().default(0),
  maxY: external_exports.number().default(100),
  minZ: external_exports.number().optional(),
  maxZ: external_exports.number().optional()
});
var DEFAULT_GRID_BOUNDS = {
  minX: 0,
  maxX: 100,
  minY: 0,
  maxY: 100
};
var SizeCategorySchema = external_exports.enum([
  "tiny",
  // 2.5ft, shares space
  "small",
  // 5ft, 1 square
  "medium",
  // 5ft, 1 square
  "large",
  // 10ft, 2x2 squares
  "huge",
  // 15ft, 3x3 squares
  "gargantuan"
  // 20ft+, 4x4+ squares
]);
var TokenSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  initiativeBonus: external_exports.number(),
  initiative: external_exports.number().optional(),
  // Rolled initiative value
  isEnemy: external_exports.boolean().optional(),
  // Whether this is an enemy
  hp: external_exports.number(),
  maxHp: external_exports.number(),
  conditions: external_exports.array(ConditionSchema),
  position: PositionSchema.optional(),
  // CRIT-003: Spatial position for movement
  // Phase 4: Movement economy
  movementSpeed: external_exports.number().default(30),
  // Base speed in feet (6 squares at 5ft/square)
  movementRemaining: external_exports.number().optional(),
  // Remaining movement this turn
  size: SizeCategorySchema.default("medium"),
  // Creature size for footprint
  abilityScores: external_exports.object({
    strength: external_exports.number(),
    dexterity: external_exports.number(),
    constitution: external_exports.number(),
    intelligence: external_exports.number(),
    wisdom: external_exports.number(),
    charisma: external_exports.number()
  }).optional()
});
var TerrainSchema = external_exports.object({
  obstacles: external_exports.array(external_exports.string()).default([]),
  // "x,y" format for blocking tiles
  difficultTerrain: external_exports.array(external_exports.string()).optional()
  // Future: 2x movement cost
});
var PropSchema = external_exports.object({
  id: external_exports.string(),
  position: external_exports.string(),
  // "x,y" format
  label: external_exports.string(),
  propType: external_exports.enum(["structure", "cover", "climbable", "hazard", "interactive", "decoration"]),
  heightFeet: external_exports.number().optional(),
  cover: external_exports.enum(["none", "half", "three_quarter", "full"]).optional(),
  climbable: external_exports.boolean().optional(),
  climbDC: external_exports.number().optional(),
  breakable: external_exports.boolean().optional(),
  hp: external_exports.number().optional(),
  currentHp: external_exports.number().optional(),
  description: external_exports.string().optional()
});
var EncounterSchema = external_exports.object({
  id: external_exports.string(),
  regionId: external_exports.string().optional(),
  // Made optional as it might not always be linked to a region
  tokens: external_exports.array(TokenSchema),
  round: external_exports.number().int().min(0),
  activeTokenId: external_exports.string().optional(),
  status: external_exports.enum(["active", "completed", "paused"]),
  terrain: TerrainSchema.optional(),
  // CRIT-003: Terrain obstacles
  props: external_exports.array(PropSchema).optional(),
  // PHASE 1: Improvised props
  gridBounds: GridBoundsSchema.optional(),
  // BUG-001: Spatial boundary validation
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});

// dist/storage/repos/encounter.repo.js
var EncounterRepository = class {
  db;
  constructor(db) {
    this.db = db;
    this.ensureSchema();
  }
  /**
   * Ensure the encounters table has all required columns
   * This handles migration for existing databases
   */
  ensureSchema() {
    const tableInfo = this.db.prepare("PRAGMA table_info(encounters)").all();
    const columnNames = tableInfo.map((c) => c.name);
    if (!columnNames.includes("terrain")) {
      this.db.prepare("ALTER TABLE encounters ADD COLUMN terrain TEXT").run();
    }
    if (!columnNames.includes("grid_bounds")) {
      this.db.prepare("ALTER TABLE encounters ADD COLUMN grid_bounds TEXT").run();
    }
    if (!columnNames.includes("props")) {
      this.db.prepare("ALTER TABLE encounters ADD COLUMN props TEXT").run();
    }
  }
  create(encounter) {
    const validEncounter = EncounterSchema.parse(encounter);
    const stmt = this.db.prepare(`
      INSERT INTO encounters (id, region_id, tokens, round, active_token_id, status, terrain, props, grid_bounds, created_at, updated_at)
      VALUES (@id, @regionId, @tokens, @round, @activeTokenId, @status, @terrain, @props, @gridBounds, @createdAt, @updatedAt)
    `);
    stmt.run({
      id: validEncounter.id,
      regionId: validEncounter.regionId || null,
      // PHASE 1: Tokens JSON now includes position data
      tokens: JSON.stringify(validEncounter.tokens),
      round: validEncounter.round,
      activeTokenId: validEncounter.activeTokenId || null,
      status: validEncounter.status,
      // PHASE 1: Persist terrain separately
      terrain: validEncounter.terrain ? JSON.stringify(validEncounter.terrain) : null,
      // PHASE 1: Persist props
      props: validEncounter.props ? JSON.stringify(validEncounter.props) : null,
      // PHASE 2: Persist grid bounds
      gridBounds: validEncounter.gridBounds ? JSON.stringify(validEncounter.gridBounds) : null,
      createdAt: validEncounter.createdAt,
      updatedAt: validEncounter.updatedAt
    });
  }
  findByRegionId(regionId) {
    const stmt = this.db.prepare("SELECT * FROM encounters WHERE region_id = ?");
    const rows = stmt.all(regionId);
    return rows.map((row) => EncounterSchema.parse({
      id: row.id,
      regionId: row.region_id,
      tokens: JSON.parse(row.tokens),
      round: row.round,
      activeTokenId: row.active_token_id || void 0,
      status: row.status,
      // Restoring props
      props: row.props ? JSON.parse(row.props) : void 0,
      // Restoring terrain
      terrain: row.terrain ? JSON.parse(row.terrain) : void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    }));
  }
  /**
   * Save combat state to database
   * PHASE 1: Now persists positions, terrain, and grid bounds
   *
   * @param encounterId The encounter ID
   * @param state The CombatState object (includes participants with positions)
   */
  saveState(encounterId, state) {
    const stmt = this.db.prepare(`
            UPDATE encounters
            SET tokens = ?, round = ?, active_token_id = ?, status = ?, terrain = ?, props = ?, grid_bounds = ?, updated_at = ?
            WHERE id = ?
        `);
    const currentTurnId = state.turnOrder[state.currentTurnIndex];
    stmt.run(
      JSON.stringify(state.participants),
      state.round,
      currentTurnId,
      "active",
      // PHASE 1: Persist terrain
      state.terrain ? JSON.stringify(state.terrain) : null,
      // PHASE 1: Persist props
      state.props ? JSON.stringify(state.props) : null,
      // PHASE 2: Persist grid bounds
      state.gridBounds ? JSON.stringify(state.gridBounds) : null,
      (/* @__PURE__ */ new Date()).toISOString(),
      encounterId
    );
  }
  /**
   * Load combat state from database
   * PHASE 1: Now restores positions, terrain, and grid bounds
   *
   * @param encounterId The encounter ID
   * @returns CombatState object with all spatial data, or null if not found
   */
  loadState(encounterId) {
    const row = this.findById(encounterId);
    if (!row)
      return null;
    const participants = JSON.parse(row.tokens);
    const terrain = row.terrain ? JSON.parse(row.terrain) : void 0;
    const props = row.props ? JSON.parse(row.props) : void 0;
    const gridBounds = row.grid_bounds ? JSON.parse(row.grid_bounds) : DEFAULT_GRID_BOUNDS;
    const sortedParticipants = [...participants].sort((a, b) => {
      const initA = a.initiative ?? 0;
      const initB = b.initiative ?? 0;
      if (initB !== initA)
        return initB - initA;
      return a.id.localeCompare(b.id);
    });
    const turnOrder = sortedParticipants.map((p) => p.id);
    const lairOwner = participants.find((p) => p.hasLairActions);
    if (lairOwner) {
      const lairIndex = sortedParticipants.findIndex((p) => (p.initiative ?? 0) <= 20);
      if (lairIndex === -1) {
        turnOrder.push("LAIR");
      } else {
        turnOrder.splice(lairIndex, 0, "LAIR");
      }
    }
    return {
      participants,
      turnOrder,
      currentTurnIndex: turnOrder.indexOf(row.active_token_id ?? turnOrder[0]),
      round: row.round,
      // PHASE 1: Restore terrain
      terrain,
      props,
      // PHASE 2: Restore grid bounds
      gridBounds,
      // LAIR action support
      hasLairActions: !!lairOwner,
      lairOwnerId: lairOwner?.id
    };
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM encounters WHERE id = ?");
    return stmt.get(id);
  }
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM encounters WHERE id = ?");
    const result = stmt.run(id);
    return result.changes > 0;
  }
};

// dist/engine/magic/spell-database.js
var SPELL_DATABASE = /* @__PURE__ */ new Map();
function registerSpell(input) {
  const spell = {
    ...input,
    ritual: input.ritual ?? false
  };
  SPELL_DATABASE.set(spell.name.toLowerCase(), spell);
}
registerSpell({
  id: "fire-bolt",
  name: "Fire Bolt",
  level: 0,
  school: "evocation",
  castingTime: "action",
  range: 120,
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "You hurl a mote of fire at a creature or object within range.",
  classes: ["sorcerer", "wizard", "artificer"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "1d10",
    // Scales: 2d10 at 5th, 3d10 at 11th, 4d10 at 17th
    damageType: "fire",
    saveType: "none"
  }],
  autoHit: false
});
registerSpell({
  id: "sacred-flame",
  name: "Sacred Flame",
  level: 0,
  school: "evocation",
  castingTime: "action",
  range: 60,
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "Flame-like radiance descends on a creature that you can see within range.",
  classes: ["cleric"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "1d8",
    // Scales like Fire Bolt
    damageType: "radiant",
    saveType: "dexterity",
    saveEffect: "none"
  }],
  autoHit: false
});
registerSpell({
  id: "eldritch-blast",
  name: "Eldritch Blast",
  level: 0,
  school: "evocation",
  castingTime: "action",
  range: 120,
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "A beam of crackling energy streaks toward a creature within range.",
  classes: ["warlock"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "1d10",
    // Multiple beams at higher levels
    damageType: "force",
    saveType: "none"
  }],
  autoHit: false
});
registerSpell({
  id: "magic-missile",
  name: "Magic Missile",
  level: 1,
  school: "evocation",
  castingTime: "action",
  range: 120,
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "You create three glowing darts of magical force. Each dart hits and deals 1d4+1 force damage.",
  higherLevels: "One additional dart for each slot level above 1st.",
  classes: ["sorcerer", "wizard"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "3d4+3",
    // 3 darts at 1d4+1 each
    damageType: "force",
    saveType: "none",
    upcastBonus: { dice: "1d4+1", perLevel: 1 }
    // +1 dart per level
  }],
  autoHit: true
  // Magic Missile never misses
});
registerSpell({
  id: "shield",
  name: "Shield",
  level: 1,
  school: "abjuration",
  castingTime: "reaction",
  range: "self",
  components: { verbal: true, somatic: true, material: false },
  duration: "1 round",
  concentration: false,
  description: "An invisible barrier of magical force appears and protects you. +5 AC until the start of your next turn.",
  classes: ["sorcerer", "wizard"],
  targetType: "self",
  effects: [{
    type: "buff",
    conditions: ["AC_BONUS_5"]
  }],
  autoHit: false
});
registerSpell({
  id: "cure-wounds",
  name: "Cure Wounds",
  level: 1,
  school: "evocation",
  castingTime: "action",
  range: "touch",
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "A creature you touch regains a number of hit points equal to 1d8 + your spellcasting ability modifier.",
  higherLevels: "Healing increases by 1d8 for each slot level above 1st.",
  classes: ["bard", "cleric", "druid", "paladin", "ranger", "artificer"],
  targetType: "creature",
  effects: [{
    type: "healing",
    dice: "1d8",
    upcastBonus: { dice: "1d8", perLevel: 1 }
  }],
  autoHit: false
});
registerSpell({
  id: "hex",
  name: "Hex",
  level: 1,
  school: "enchantment",
  castingTime: "bonus_action",
  range: 90,
  components: { verbal: true, somatic: true, material: true, materialDescription: "the petrified eye of a newt" },
  duration: "Concentration, up to 1 hour",
  concentration: true,
  description: "You place a curse on a creature that you can see within range. Deal extra 1d6 necrotic damage on hits.",
  higherLevels: "Duration increases with higher slots.",
  classes: ["warlock"],
  targetType: "creature",
  effects: [{
    type: "debuff",
    dice: "1d6",
    damageType: "necrotic",
    conditions: ["HEXED"]
  }],
  autoHit: false
});
registerSpell({
  id: "burning-hands",
  name: "Burning Hands",
  level: 1,
  school: "evocation",
  castingTime: "action",
  range: "self",
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "A thin sheet of flames shoots forth from your outstretched fingertips.",
  higherLevels: "Damage increases by 1d6 for each slot level above 1st.",
  classes: ["sorcerer", "wizard"],
  targetType: "area",
  areaOfEffect: { shape: "cone", size: 15 },
  effects: [{
    type: "damage",
    dice: "3d6",
    damageType: "fire",
    saveType: "dexterity",
    saveEffect: "half",
    upcastBonus: { dice: "1d6", perLevel: 1 }
  }],
  autoHit: false
});
registerSpell({
  id: "misty-step",
  name: "Misty Step",
  level: 2,
  school: "conjuration",
  castingTime: "bonus_action",
  range: "self",
  components: { verbal: true, somatic: false, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "Briefly surrounded by silvery mist, you teleport up to 30 feet to an unoccupied space.",
  classes: ["sorcerer", "warlock", "wizard"],
  targetType: "self",
  effects: [{
    type: "utility"
  }],
  autoHit: false
});
registerSpell({
  id: "hold-person",
  name: "Hold Person",
  level: 2,
  school: "enchantment",
  castingTime: "action",
  range: 60,
  components: { verbal: true, somatic: true, material: true, materialDescription: "a small, straight piece of iron" },
  duration: "Concentration, up to 1 minute",
  concentration: true,
  description: "Choose a humanoid that you can see within range. The target must succeed on a Wisdom saving throw or be paralyzed.",
  higherLevels: "Target one additional humanoid for each slot level above 2nd.",
  classes: ["bard", "cleric", "druid", "sorcerer", "warlock", "wizard"],
  targetType: "creature",
  effects: [{
    type: "debuff",
    saveType: "wisdom",
    saveEffect: "none",
    conditions: ["PARALYZED"]
  }],
  autoHit: false
});
registerSpell({
  id: "spiritual-weapon",
  name: "Spiritual Weapon",
  level: 2,
  school: "evocation",
  castingTime: "bonus_action",
  range: 60,
  components: { verbal: true, somatic: true, material: false },
  duration: "1 minute",
  concentration: false,
  description: "You create a floating, spectral weapon within range that lasts for the duration.",
  higherLevels: "Damage increases by 1d8 for every two slot levels above 2nd.",
  classes: ["cleric"],
  targetType: "point",
  effects: [{
    type: "damage",
    dice: "1d8",
    damageType: "force",
    upcastBonus: { dice: "1d8", perLevel: 2 }
  }],
  autoHit: false
});
registerSpell({
  id: "fireball",
  name: "Fireball",
  level: 3,
  school: "evocation",
  castingTime: "action",
  range: 150,
  components: { verbal: true, somatic: true, material: true, materialDescription: "a tiny ball of bat guano and sulfur" },
  duration: "Instantaneous",
  concentration: false,
  description: "A bright streak flashes from your pointing finger to a point you choose within range and then blossoms with a low roar into an explosion of flame.",
  higherLevels: "Damage increases by 1d6 for each slot level above 3rd.",
  classes: ["sorcerer", "wizard"],
  targetType: "point",
  areaOfEffect: { shape: "sphere", size: 20 },
  effects: [{
    type: "damage",
    dice: "8d6",
    damageType: "fire",
    saveType: "dexterity",
    saveEffect: "half",
    upcastBonus: { dice: "1d6", perLevel: 1 }
  }],
  autoHit: false
});
registerSpell({
  id: "lightning-bolt",
  name: "Lightning Bolt",
  level: 3,
  school: "evocation",
  castingTime: "action",
  range: "self",
  components: { verbal: true, somatic: true, material: true, materialDescription: "a bit of fur and a rod of amber, crystal, or glass" },
  duration: "Instantaneous",
  concentration: false,
  description: "A stroke of lightning forming a line 100 feet long and 5 feet wide blasts out from you.",
  higherLevels: "Damage increases by 1d6 for each slot level above 3rd.",
  classes: ["sorcerer", "wizard"],
  targetType: "area",
  areaOfEffect: { shape: "line", size: 100 },
  effects: [{
    type: "damage",
    dice: "8d6",
    damageType: "lightning",
    saveType: "dexterity",
    saveEffect: "half",
    upcastBonus: { dice: "1d6", perLevel: 1 }
  }],
  autoHit: false
});
registerSpell({
  id: "counterspell",
  name: "Counterspell",
  level: 3,
  school: "abjuration",
  castingTime: "reaction",
  range: 60,
  components: { verbal: false, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "You attempt to interrupt a creature in the process of casting a spell.",
  higherLevels: "Automatically counter spells of 3rd level or lower. Higher levels require ability check.",
  classes: ["sorcerer", "warlock", "wizard"],
  targetType: "creature",
  effects: [{
    type: "utility"
  }],
  autoHit: false
});
registerSpell({
  id: "dimension-door",
  name: "Dimension Door",
  level: 4,
  school: "conjuration",
  castingTime: "action",
  range: 500,
  components: { verbal: true, somatic: false, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "You teleport yourself to any spot within range.",
  classes: ["bard", "sorcerer", "warlock", "wizard"],
  targetType: "self",
  effects: [{
    type: "utility"
  }],
  autoHit: false
});
registerSpell({
  id: "haste",
  name: "Haste",
  level: 3,
  school: "transmutation",
  castingTime: "action",
  range: 30,
  components: { verbal: true, somatic: true, material: true, materialDescription: "a shaving of licorice root" },
  duration: "Concentration, up to 1 minute",
  concentration: true,
  description: "Choose a willing creature. Until the spell ends, the target's speed is doubled, it gains +2 AC, has advantage on Dexterity saving throws, and gains an additional action.",
  classes: ["sorcerer", "wizard", "artificer"],
  targetType: "creature",
  effects: [{
    type: "buff",
    conditions: ["HASTED"]
  }],
  autoHit: false
});
registerSpell({
  id: "fly",
  name: "Fly",
  level: 3,
  school: "transmutation",
  castingTime: "action",
  range: "touch",
  components: { verbal: true, somatic: true, material: true, materialDescription: "a wing feather from any bird" },
  duration: "Concentration, up to 10 minutes",
  concentration: true,
  description: "You touch a willing creature. The target gains a flying speed of 60 feet for the duration.",
  higherLevels: "Target one additional creature for each slot level above 3rd.",
  classes: ["sorcerer", "warlock", "wizard", "artificer"],
  targetType: "creature",
  effects: [{
    type: "buff",
    conditions: ["FLYING"]
  }],
  autoHit: false
});
registerSpell({
  id: "disintegrate",
  name: "Disintegrate",
  level: 6,
  school: "transmutation",
  castingTime: "action",
  range: 60,
  components: { verbal: true, somatic: true, material: true, materialDescription: "a lodestone and a pinch of dust" },
  duration: "Instantaneous",
  concentration: false,
  description: "A thin green ray springs from your pointing finger. The target takes 10d6+40 force damage.",
  higherLevels: "Damage increases by 3d6 for each slot level above 6th.",
  classes: ["sorcerer", "wizard"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "10d6+40",
    damageType: "force",
    saveType: "dexterity",
    saveEffect: "none",
    // All or nothing
    upcastBonus: { dice: "3d6", perLevel: 1 }
  }],
  autoHit: false
});
registerSpell({
  id: "meteor-swarm",
  name: "Meteor Swarm",
  level: 9,
  school: "evocation",
  castingTime: "action",
  range: "self",
  // 1 mile actually but self for targeting
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "Blazing orbs of fire plummet to the ground at four different points you can see within range.",
  classes: ["sorcerer", "wizard"],
  targetType: "point",
  areaOfEffect: { shape: "sphere", size: 40 },
  effects: [{
    type: "damage",
    dice: "40d6",
    // 20d6 fire + 20d6 bludgeoning
    damageType: "fire",
    saveType: "dexterity",
    saveEffect: "half"
  }],
  autoHit: false
});
registerSpell({
  id: "power-word-kill",
  name: "Power Word Kill",
  level: 9,
  school: "enchantment",
  castingTime: "action",
  range: 60,
  components: { verbal: true, somatic: false, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "You utter a word of power that can compel one creature you can see within range to die instantly if it has 100 HP or less.",
  classes: ["bard", "sorcerer", "warlock", "wizard"],
  targetType: "creature",
  effects: [{
    type: "damage",
    conditions: ["INSTANT_DEATH"]
  }],
  autoHit: true
});
registerSpell({
  id: "wish",
  name: "Wish",
  level: 9,
  school: "conjuration",
  castingTime: "action",
  range: "self",
  components: { verbal: true, somatic: false, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "Wish is the mightiest spell a mortal creature can cast. By simply speaking aloud, you can alter the very foundations of reality in accord with your desires.",
  classes: ["sorcerer", "wizard"],
  targetType: "self",
  effects: [{
    type: "utility"
  }],
  autoHit: false
});
registerSpell({
  id: "bless",
  name: "Bless",
  level: 1,
  school: "enchantment",
  castingTime: "action",
  range: 30,
  components: { verbal: true, somatic: true, material: true, materialDescription: "a sprinkling of holy water" },
  duration: "Concentration, up to 1 minute",
  concentration: true,
  description: "You bless up to three creatures of your choice within range. Whenever a target makes an attack roll or saving throw, they can roll a d4 and add to the roll.",
  higherLevels: "One additional creature for each slot level above 1st.",
  classes: ["cleric", "paladin"],
  targetType: "creatures",
  effects: [{
    type: "buff",
    dice: "1d4",
    conditions: ["BLESSED"]
  }],
  autoHit: false
});
registerSpell({
  id: "guiding-bolt",
  name: "Guiding Bolt",
  level: 1,
  school: "evocation",
  castingTime: "action",
  range: 120,
  components: { verbal: true, somatic: true, material: false },
  duration: "Instantaneous",
  concentration: false,
  description: "A flash of light streaks toward a creature of your choice within range. On hit, the target takes 4d6 radiant damage and the next attack against it has advantage.",
  higherLevels: "Damage increases by 1d6 for each slot level above 1st.",
  classes: ["cleric"],
  targetType: "creature",
  effects: [{
    type: "damage",
    dice: "4d6",
    damageType: "radiant",
    saveType: "none",
    upcastBonus: { dice: "1d6", perLevel: 1 },
    conditions: ["GLOWING"]
  }],
  autoHit: false
});
function getSpell(name) {
  return SPELL_DATABASE.get(name.toLowerCase());
}
function isSpellAvailableToClass(spellName, characterClass) {
  const spell = getSpell(spellName);
  if (!spell)
    return false;
  return spell.classes.includes(characterClass);
}
function calculateUpcastDice(spell, slotLevel) {
  const effect = spell.effects.find((e) => e.dice);
  if (!effect?.dice)
    return "";
  const baseDice = effect.dice;
  const upcastBonus = effect.upcastBonus;
  if (!upcastBonus || slotLevel <= spell.level) {
    return baseDice;
  }
  const levelsAbove = slotLevel - spell.level;
  const bonusLevels = Math.floor(levelsAbove / upcastBonus.perLevel);
  const baseDiceMatch = baseDice.match(/(\d+)d(\d+)/);
  const bonusDiceMatch = upcastBonus.dice.match(/(\d+)d(\d+)/);
  if (!baseDiceMatch)
    return baseDice;
  let totalCount = parseInt(baseDiceMatch[1]);
  const diceSize = baseDiceMatch[2];
  if (bonusDiceMatch) {
    totalCount += parseInt(bonusDiceMatch[1]) * bonusLevels;
  }
  const modMatch = baseDice.match(/([+-]\d+)$/);
  const modifier = modMatch ? modMatch[1] : "";
  return `${totalCount}d${diceSize}${modifier}`;
}
var SPELL_COUNT = SPELL_DATABASE.size;

// dist/engine/magic/spell-validator.js
var SPELLCASTING_CONFIG = {
  barbarian: { canCast: false, startLevel: 999, ability: "charisma", fullCaster: false, preparationRequired: false, pactMagic: false },
  bard: { canCast: true, startLevel: 1, ability: "charisma", fullCaster: true, preparationRequired: false, pactMagic: false },
  cleric: { canCast: true, startLevel: 1, ability: "wisdom", fullCaster: true, preparationRequired: true, pactMagic: false },
  druid: { canCast: true, startLevel: 1, ability: "wisdom", fullCaster: true, preparationRequired: true, pactMagic: false },
  fighter: { canCast: false, startLevel: 3, ability: "intelligence", fullCaster: false, preparationRequired: false, pactMagic: false },
  // Eldritch Knight
  monk: { canCast: false, startLevel: 999, ability: "wisdom", fullCaster: false, preparationRequired: false, pactMagic: false },
  paladin: { canCast: true, startLevel: 2, ability: "charisma", fullCaster: false, preparationRequired: true, pactMagic: false },
  ranger: { canCast: true, startLevel: 2, ability: "wisdom", fullCaster: false, preparationRequired: false, pactMagic: false },
  rogue: { canCast: false, startLevel: 3, ability: "intelligence", fullCaster: false, preparationRequired: false, pactMagic: false },
  // Arcane Trickster
  sorcerer: { canCast: true, startLevel: 1, ability: "charisma", fullCaster: true, preparationRequired: false, pactMagic: false },
  warlock: { canCast: true, startLevel: 1, ability: "charisma", fullCaster: false, preparationRequired: false, pactMagic: true },
  wizard: { canCast: true, startLevel: 1, ability: "intelligence", fullCaster: true, preparationRequired: true, pactMagic: false },
  artificer: { canCast: true, startLevel: 1, ability: "intelligence", fullCaster: false, preparationRequired: true, pactMagic: false }
};
var FULL_CASTER_SLOTS = {
  1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
  2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  5: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  6: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  7: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  8: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  9: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  10: [4, 3, 3, 3, 2, 0, 0, 0, 0],
  11: [4, 3, 3, 3, 2, 1, 0, 0, 0],
  12: [4, 3, 3, 3, 2, 1, 0, 0, 0],
  13: [4, 3, 3, 3, 2, 1, 1, 0, 0],
  14: [4, 3, 3, 3, 2, 1, 1, 0, 0],
  15: [4, 3, 3, 3, 2, 1, 1, 1, 0],
  16: [4, 3, 3, 3, 2, 1, 1, 1, 0],
  17: [4, 3, 3, 3, 2, 1, 1, 1, 1],
  18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
  19: [4, 3, 3, 3, 3, 2, 1, 1, 1],
  20: [4, 3, 3, 3, 3, 2, 2, 1, 1]
};
var HALF_CASTER_SLOTS = {
  2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
  3: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  4: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  5: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  6: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  7: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  8: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  9: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  10: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  11: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  12: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  13: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  14: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  15: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  16: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  17: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  18: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  19: [4, 3, 3, 3, 2, 0, 0, 0, 0],
  20: [4, 3, 3, 3, 2, 0, 0, 0, 0]
};
var WARLOCK_SLOTS = {
  1: { count: 1, level: 1 },
  2: { count: 2, level: 1 },
  3: { count: 2, level: 2 },
  4: { count: 2, level: 2 },
  5: { count: 2, level: 3 },
  6: { count: 2, level: 3 },
  7: { count: 2, level: 4 },
  8: { count: 2, level: 4 },
  9: { count: 2, level: 5 },
  10: { count: 2, level: 5 },
  11: { count: 3, level: 5 },
  12: { count: 3, level: 5 },
  13: { count: 3, level: 5 },
  14: { count: 3, level: 5 },
  15: { count: 3, level: 5 },
  16: { count: 3, level: 5 },
  17: { count: 4, level: 5 },
  18: { count: 4, level: 5 },
  19: { count: 4, level: 5 },
  20: { count: 4, level: 5 }
};
function getMaxSpellLevel(characterClass, level) {
  const config2 = SPELLCASTING_CONFIG[characterClass];
  if (!config2.canCast)
    return 0;
  if (level < config2.startLevel)
    return 0;
  if (config2.pactMagic) {
    const warlockSlots = WARLOCK_SLOTS[level];
    return warlockSlots?.level || 0;
  }
  if (config2.fullCaster) {
    const slots = FULL_CASTER_SLOTS[level];
    if (!slots)
      return 0;
    for (let i = 8; i >= 0; i--) {
      if (slots[i] > 0)
        return i + 1;
    }
    return 0;
  } else {
    const effectiveLevel = level >= config2.startLevel ? level : 0;
    const slots = HALF_CASTER_SLOTS[effectiveLevel];
    if (!slots)
      return 0;
    for (let i = 8; i >= 0; i--) {
      if (slots[i] > 0)
        return i + 1;
    }
    return 0;
  }
}
function getInitialSpellSlots(characterClass, level) {
  const config2 = SPELLCASTING_CONFIG[characterClass];
  const empty = {
    level1: { current: 0, max: 0 },
    level2: { current: 0, max: 0 },
    level3: { current: 0, max: 0 },
    level4: { current: 0, max: 0 },
    level5: { current: 0, max: 0 },
    level6: { current: 0, max: 0 },
    level7: { current: 0, max: 0 },
    level8: { current: 0, max: 0 },
    level9: { current: 0, max: 0 }
  };
  if (!config2.canCast || level < config2.startLevel) {
    return empty;
  }
  let slots;
  if (config2.fullCaster) {
    slots = FULL_CASTER_SLOTS[level] || [0, 0, 0, 0, 0, 0, 0, 0, 0];
  } else if (config2.pactMagic) {
    return empty;
  } else {
    slots = HALF_CASTER_SLOTS[level] || [0, 0, 0, 0, 0, 0, 0, 0, 0];
  }
  return {
    level1: { current: slots[0], max: slots[0] },
    level2: { current: slots[1], max: slots[1] },
    level3: { current: slots[2], max: slots[2] },
    level4: { current: slots[3], max: slots[3] },
    level5: { current: slots[4], max: slots[4] },
    level6: { current: slots[5], max: slots[5] },
    level7: { current: slots[6], max: slots[6] },
    level8: { current: slots[7], max: slots[7] },
    level9: { current: slots[8], max: slots[8] }
  };
}
function calculateSpellSaveDC(character) {
  const config2 = SPELLCASTING_CONFIG[character.characterClass || "fighter"];
  if (!config2.canCast)
    return 0;
  const profBonus = Math.floor((character.level - 1) / 4) + 2;
  const abilityMod = getAbilityModifier(character, config2.ability);
  return 8 + profBonus + abilityMod;
}
function calculateSpellAttackBonus(character) {
  const config2 = SPELLCASTING_CONFIG[character.characterClass || "fighter"];
  if (!config2.canCast)
    return 0;
  const profBonus = Math.floor((character.level - 1) / 4) + 2;
  const abilityMod = getAbilityModifier(character, config2.ability);
  return profBonus + abilityMod;
}
function getAbilityModifier(character, ability) {
  const statMap = {
    intelligence: "int",
    wisdom: "wis",
    charisma: "cha"
  };
  const stat = character.stats[statMap[ability]];
  return Math.floor((stat - 10) / 2);
}
function canCastSpells(character) {
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (!config2.canCast) {
    return {
      canCast: false,
      reason: `${charClass} is not a spellcasting class`
    };
  }
  if (character.level < config2.startLevel) {
    return {
      canCast: false,
      reason: `${charClass} gains spellcasting at level ${config2.startLevel}`
    };
  }
  const conditions = character.conditions || [];
  if (conditions.some((c) => c.name === "INCAPACITATED") || conditions.some((c) => c.name === "STUNNED") || conditions.some((c) => c.name === "PARALYZED") || conditions.some((c) => c.name === "UNCONSCIOUS")) {
    return {
      canCast: false,
      reason: "Cannot take actions while incapacitated"
    };
  }
  return { canCast: true };
}
function characterKnowsSpell(character, spellName) {
  const spell = getSpell(spellName);
  if (!spell) {
    return { knows: false, reason: `Unknown spell: ${spellName}` };
  }
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (!isSpellAvailableToClass(spellName, charClass)) {
    return {
      knows: false,
      reason: `${spell.name} is not available to ${charClass} class`
    };
  }
  if (spell.level === 0) {
    const cantrips = character.cantripsKnown || [];
    if (!cantrips.some((c) => c.toLowerCase() === spellName.toLowerCase())) {
      return {
        knows: false,
        reason: `${spell.name} is not in your known cantrips`
      };
    }
    return { knows: true };
  }
  const knownSpells = character.knownSpells || [];
  const preparedSpells = character.preparedSpells || [];
  if (config2.preparationRequired) {
    if (!preparedSpells.some((s) => s.toLowerCase() === spellName.toLowerCase())) {
      if (knownSpells.some((s) => s.toLowerCase() === spellName.toLowerCase())) {
        return {
          knows: false,
          reason: `${spell.name} is not prepared`
        };
      }
      return {
        knows: false,
        reason: `${spell.name} is not in your spellbook`
      };
    }
  } else {
    if (!knownSpells.some((s) => s.toLowerCase() === spellName.toLowerCase())) {
      return {
        knows: false,
        reason: `${spell.name} is not in your known spells`
      };
    }
  }
  return { knows: true };
}
function hasSpellSlotAvailable(character, minLevel) {
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (config2.pactMagic) {
    const pactSlots = character.pactMagicSlots;
    if (!pactSlots || pactSlots.current <= 0) {
      return { available: false, reason: "No pact magic slots remaining" };
    }
    if (pactSlots.slotLevel < minLevel) {
      return { available: false, reason: `Pact magic slot level (${pactSlots.slotLevel}) is lower than spell minimum (${minLevel})` };
    }
    return { available: true, availableLevel: pactSlots.slotLevel };
  }
  const slots = character.spellSlots;
  if (!slots) {
    return { available: false, reason: "No spell slots available" };
  }
  const slotKeys = ["level1", "level2", "level3", "level4", "level5", "level6", "level7", "level8", "level9"];
  for (let i = minLevel - 1; i < 9; i++) {
    const key = slotKeys[i];
    if (slots[key] && slots[key].current > 0) {
      return { available: true, availableLevel: i + 1 };
    }
  }
  return { available: false, reason: `No level ${minLevel}+ spell slots available` };
}
function validateSpellCast(character, spellName, requestedSlotLevel) {
  if (!spellName || spellName.trim() === "") {
    return {
      valid: false,
      error: { code: "EMPTY_SPELL_NAME", message: "Spell name is required" }
    };
  }
  const spell = getSpell(spellName);
  if (!spell) {
    return {
      valid: false,
      error: { code: "UNKNOWN_SPELL", message: `Unknown spell: ${spellName}` }
    };
  }
  const castCheck = canCastSpells(character);
  if (!castCheck.canCast) {
    return {
      valid: false,
      error: { code: "CANNOT_CAST", message: castCheck.reason }
    };
  }
  const knowsCheck = characterKnowsSpell(character, spellName);
  if (!knowsCheck.knows) {
    return {
      valid: false,
      error: { code: "SPELL_NOT_KNOWN", message: knowsCheck.reason }
    };
  }
  const conditions = character.conditions || [];
  if (conditions.some((c) => c.name === "SILENCED") && spell.components.verbal) {
    return {
      valid: false,
      error: { code: "SILENCED", message: "Cannot cast spells with verbal components while silenced" }
    };
  }
  if (spell.level === 0) {
    return {
      valid: true,
      spell,
      effectiveSlotLevel: 0
    };
  }
  const maxLevel = getMaxSpellLevel(character.characterClass || "fighter", character.level);
  const spellLevel = spell.level;
  if (spellLevel > maxLevel) {
    return {
      valid: false,
      error: {
        code: "SPELL_LEVEL_TOO_HIGH",
        message: `Cannot cast level ${spellLevel} spells (max spell level: ${maxLevel})`
      }
    };
  }
  let targetSlotLevel = requestedSlotLevel || spellLevel;
  if (targetSlotLevel < spellLevel) {
    return {
      valid: false,
      error: {
        code: "CANNOT_DOWNCAST",
        message: `${spell.name} requires minimum slot level ${spellLevel}`
      }
    };
  }
  if (targetSlotLevel > maxLevel) {
    return {
      valid: false,
      error: {
        code: "SLOT_LEVEL_TOO_HIGH",
        message: `Cannot cast at level ${targetSlotLevel} (max available: ${maxLevel})`
      }
    };
  }
  const slotCheck = hasSpellSlotAvailable(character, targetSlotLevel);
  if (!slotCheck.available) {
    return {
      valid: false,
      error: { code: "NO_SLOTS", message: slotCheck.reason }
    };
  }
  const config2 = SPELLCASTING_CONFIG[character.characterClass || "fighter"];
  if (config2.pactMagic) {
    targetSlotLevel = slotCheck.availableLevel;
  }
  return {
    valid: true,
    spell,
    effectiveSlotLevel: targetSlotLevel
  };
}
function consumeSpellSlot(character, slotLevel) {
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (config2.pactMagic) {
    if (character.pactMagicSlots && character.pactMagicSlots.current > 0) {
      return {
        ...character,
        pactMagicSlots: {
          ...character.pactMagicSlots,
          current: character.pactMagicSlots.current - 1
        }
      };
    }
    return character;
  }
  if (!character.spellSlots)
    return character;
  const slotKey = `level${slotLevel}`;
  const currentSlot = character.spellSlots[slotKey];
  if (currentSlot && currentSlot.current > 0) {
    return {
      ...character,
      spellSlots: {
        ...character.spellSlots,
        [slotKey]: {
          ...currentSlot,
          current: currentSlot.current - 1
        }
      }
    };
  }
  return character;
}
function restoreAllSpellSlots(character) {
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (!config2.canCast || character.level < config2.startLevel) {
    return character;
  }
  if (config2.pactMagic) {
    const warlockSlots = WARLOCK_SLOTS[character.level];
    return {
      ...character,
      pactMagicSlots: {
        current: warlockSlots.count,
        max: warlockSlots.count,
        slotLevel: warlockSlots.level
      }
    };
  }
  const slots = getInitialSpellSlots(charClass, character.level);
  return {
    ...character,
    spellSlots: slots
  };
}
function restorePactSlots(character) {
  const charClass = character.characterClass || "fighter";
  const config2 = SPELLCASTING_CONFIG[charClass];
  if (!config2.pactMagic) {
    return character;
  }
  const warlockSlots = WARLOCK_SLOTS[character.level];
  return {
    ...character,
    pactMagicSlots: {
      current: warlockSlots.count,
      max: warlockSlots.count,
      slotLevel: warlockSlots.level
    }
  };
}
function getSpellcastingConfig(characterClass) {
  const normalizedClass = characterClass.toLowerCase();
  const config2 = SPELLCASTING_CONFIG[normalizedClass];
  if (config2) {
    return config2;
  }
  return {
    canCast: false,
    startLevel: 999,
    ability: "intelligence",
    fullCaster: false,
    preparationRequired: false,
    pactMagic: false
  };
}

// dist/engine/magic/spell-resolver.js
function rollDice(diceNotation) {
  const notation = diceNotation.trim();
  const rolls = [];
  let total = 0;
  const match = notation.match(/^(\d+)d(\d+)([+-]\d+)?$/);
  if (!match) {
    const num = parseInt(notation);
    if (!isNaN(num)) {
      return { total: num, rolls: [num], notation };
    }
    return { total: 0, rolls: [], notation };
  }
  const count = parseInt(match[1]);
  const size = parseInt(match[2]);
  const modifier = match[3] ? parseInt(match[3]) : 0;
  for (let i = 0; i < count; i++) {
    const roll = Math.floor(Math.random() * size) + 1;
    rolls.push(roll);
    total += roll;
  }
  total += modifier;
  return { total: Math.max(0, total), rolls, notation };
}
function getCantripDamage(baseDice, characterLevel) {
  const match = baseDice.match(/^(\d+)d(\d+)/);
  if (!match)
    return baseDice;
  const baseCount = parseInt(match[1]);
  const diceSize = match[2];
  let diceCount = baseCount;
  if (characterLevel >= 5)
    diceCount = baseCount * 2;
  if (characterLevel >= 11)
    diceCount = baseCount * 3;
  if (characterLevel >= 17)
    diceCount = baseCount * 4;
  return `${diceCount}d${diceSize}`;
}
function getMagicMissileDarts(slotLevel) {
  return 3 + (slotLevel - 1);
}
function resolveSpell(spell, caster, slotLevel, options = {}) {
  const result = {
    success: true,
    spellName: spell.name,
    slotUsed: spell.level === 0 ? void 0 : slotLevel,
    diceRolled: "",
    concentration: spell.concentration
  };
  const spellSaveDC = caster.spellSaveDC || calculateSpellSaveDC(caster);
  const spellAttackBonus = caster.spellAttackBonus || calculateSpellAttackBonus(caster);
  for (const effect of spell.effects) {
    switch (effect.type) {
      case "damage": {
        let diceNotation;
        if (spell.level === 0) {
          diceNotation = getCantripDamage(effect.dice || "1d10", caster.level);
        } else {
          diceNotation = calculateUpcastDice(spell, slotLevel);
        }
        result.diceRolled = diceNotation;
        result.damageType = effect.damageType;
        if (spell.name.toLowerCase() === "magic missile") {
          const darts = getMagicMissileDarts(slotLevel);
          result.dartCount = darts;
          let totalDamage = 0;
          for (let i = 0; i < darts; i++) {
            totalDamage += Math.floor(Math.random() * 4) + 1 + 1;
          }
          result.damage = totalDamage;
          result.damageRolled = totalDamage;
          result.damageApplied = totalDamage;
          result.autoHit = true;
          result.diceRolled = `${darts}d4+${darts}`;
          break;
        }
        const damageRoll = rollDice(diceNotation);
        result.damageRolled = damageRoll.total;
        if (spell.autoHit) {
          result.autoHit = true;
          result.damageApplied = damageRoll.total;
          result.damage = damageRoll.total;
        } else if (effect.saveType && effect.saveType !== "none") {
          result.saveDC = spellSaveDC;
          const saveRoll = options.targetSaveRoll ?? Math.floor(Math.random() * 20) + 1;
          const saveTotal = saveRoll;
          if (saveTotal >= spellSaveDC) {
            result.saveResult = "passed";
            if (effect.saveEffect === "half") {
              result.damageApplied = Math.floor(damageRoll.total / 2);
            } else {
              result.damageApplied = 0;
            }
          } else {
            result.saveResult = "failed";
            result.damageApplied = damageRoll.total;
          }
          result.damage = result.damageApplied;
        } else {
          const attackRoll = Math.floor(Math.random() * 20) + 1;
          result.attackRoll = attackRoll;
          result.attackTotal = attackRoll + spellAttackBonus;
          const targetAC = options.targetAC ?? 10;
          result.hit = result.attackTotal >= targetAC;
          if (result.hit) {
            result.damageApplied = damageRoll.total;
            result.damage = damageRoll.total;
          } else {
            result.damageApplied = 0;
            result.damage = 0;
          }
        }
        if (effect.conditions && effect.conditions.length > 0) {
          result.conditionsApplied = effect.conditions;
        }
        break;
      }
      case "healing": {
        let healingDice = effect.dice || "1d8";
        if (effect.upcastBonus && slotLevel > spell.level) {
          const bonusLevels = Math.floor((slotLevel - spell.level) / effect.upcastBonus.perLevel);
          const bonusMatch = effect.upcastBonus.dice.match(/^(\d+)d(\d+)/);
          const baseMatch = healingDice.match(/^(\d+)d(\d+)/);
          if (bonusMatch && baseMatch) {
            const newCount = parseInt(baseMatch[1]) + parseInt(bonusMatch[1]) * bonusLevels;
            healingDice = `${newCount}d${baseMatch[2]}`;
          }
        }
        result.diceRolled = healingDice;
        const healingRoll = rollDice(healingDice);
        const abilityMod = options.casterAbilityMod ?? Math.floor((caster.stats.wis - 10) / 2);
        result.healing = healingRoll.total + abilityMod;
        break;
      }
      case "buff": {
        if (effect.conditions && effect.conditions.length > 0) {
          result.conditionsApplied = effect.conditions;
          if (effect.conditions.includes("AC_BONUS_5")) {
            result.acBonus = 5;
          }
        }
        if (effect.dice) {
          result.diceRolled = effect.dice;
        }
        break;
      }
      case "debuff": {
        if (effect.saveType && effect.saveType !== "none") {
          result.saveDC = spellSaveDC;
          const saveRoll = options.targetSaveRoll ?? Math.floor(Math.random() * 20) + 1;
          if (saveRoll >= spellSaveDC) {
            result.saveResult = "passed";
          } else {
            result.saveResult = "failed";
            if (effect.conditions && effect.conditions.length > 0) {
              result.conditionsApplied = effect.conditions;
            }
          }
        } else {
          if (effect.conditions && effect.conditions.length > 0) {
            result.conditionsApplied = effect.conditions;
          }
        }
        break;
      }
      case "utility": {
        result.success = true;
        break;
      }
      case "summon": {
        result.success = true;
        break;
      }
    }
  }
  return result;
}

// dist/server/combat-tools.js
init_character_repo();

// dist/schema/concentration.js
init_zod();
var ConcentrationStateSchema = external_exports.object({
  characterId: external_exports.string(),
  activeSpell: external_exports.string(),
  // Spell name
  spellLevel: external_exports.number().int().min(0).max(9),
  targetIds: external_exports.array(external_exports.string()).optional(),
  // Targets affected by the spell
  startedAt: external_exports.number().int().min(1),
  // Round number when concentration started
  maxDuration: external_exports.number().int().optional(),
  // Maximum rounds (null = indefinite)
  saveDCBase: external_exports.number().int().default(10)
  // Base DC for concentration saves (min 10 or half damage)
});
var ConcentrationCheckResultSchema = external_exports.object({
  characterId: external_exports.string(),
  spell: external_exports.string(),
  broken: external_exports.boolean(),
  reason: external_exports.enum(["damage", "incapacitated", "death", "new_spell", "voluntary", "duration", "failed_save"]),
  saveRoll: external_exports.number().int().optional(),
  // d20 roll result
  saveDC: external_exports.number().int().optional(),
  // DC of the save
  saveTotal: external_exports.number().int().optional(),
  // Roll + modifier
  damageAmount: external_exports.number().int().optional(),
  // Damage that triggered the check
  constitutionModifier: external_exports.number().int().optional()
});
var BreakConcentrationRequestSchema = external_exports.object({
  characterId: external_exports.string(),
  reason: external_exports.enum(["damage", "incapacitated", "death", "new_spell", "voluntary", "duration"]),
  damageAmount: external_exports.number().int().optional()
  // Required if reason is 'damage'
});

// dist/storage/repos/concentration.repo.js
var ConcentrationRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Start concentration on a spell
   */
  create(concentration) {
    const valid = ConcentrationStateSchema.parse(concentration);
    const stmt = this.db.prepare(`
            INSERT INTO concentration (
                character_id, active_spell, spell_level, target_ids,
                started_at, max_duration, save_dc_base
            )
            VALUES (@characterId, @activeSpell, @spellLevel, @targetIds,
                    @startedAt, @maxDuration, @saveDCBase)
        `);
    stmt.run({
      characterId: valid.characterId,
      activeSpell: valid.activeSpell,
      spellLevel: valid.spellLevel,
      targetIds: valid.targetIds ? JSON.stringify(valid.targetIds) : null,
      startedAt: valid.startedAt,
      maxDuration: valid.maxDuration ?? null,
      saveDCBase: valid.saveDCBase
    });
  }
  /**
   * Get active concentration for a character
   */
  findByCharacterId(characterId) {
    const stmt = this.db.prepare(`
            SELECT * FROM concentration WHERE character_id = ?
        `);
    const row = stmt.get(characterId);
    if (!row)
      return null;
    return ConcentrationStateSchema.parse({
      characterId: row.character_id,
      activeSpell: row.active_spell,
      spellLevel: row.spell_level,
      targetIds: row.target_ids ? JSON.parse(row.target_ids) : void 0,
      startedAt: row.started_at,
      maxDuration: row.max_duration ?? void 0,
      saveDCBase: row.save_dc_base
    });
  }
  /**
   * Break concentration (delete the record)
   */
  delete(characterId) {
    const stmt = this.db.prepare(`
            DELETE FROM concentration WHERE character_id = ?
        `);
    const result = stmt.run(characterId);
    return result.changes > 0;
  }
  /**
   * Check if a character is concentrating
   */
  isConcentrating(characterId) {
    const stmt = this.db.prepare(`
            SELECT COUNT(*) as count FROM concentration WHERE character_id = ?
        `);
    const row = stmt.get(characterId);
    return row.count > 0;
  }
  /**
   * Get all active concentrations (for debugging/admin)
   */
  findAll() {
    const stmt = this.db.prepare(`SELECT * FROM concentration`);
    const rows = stmt.all();
    return rows.map((row) => ConcentrationStateSchema.parse({
      characterId: row.character_id,
      activeSpell: row.active_spell,
      spellLevel: row.spell_level,
      targetIds: row.target_ids ? JSON.parse(row.target_ids) : void 0,
      startedAt: row.started_at,
      maxDuration: row.max_duration ?? void 0,
      saveDCBase: row.save_dc_base
    }));
  }
};

// dist/engine/magic/concentration.js
function calculateConcentrationDC(damageAmount) {
  const halfDamage = Math.floor(damageAmount / 2);
  return Math.max(10, halfDamage);
}
function rollConcentrationSave(constitutionModifier) {
  const roll = Math.floor(Math.random() * 20) + 1;
  const total = roll + constitutionModifier;
  return { roll, total };
}
function checkConcentration(character, damageAmount, concentrationRepo) {
  const concentration = concentrationRepo.findByCharacterId(character.id);
  if (!concentration) {
    return {
      characterId: character.id,
      spell: "none",
      broken: false,
      reason: "damage"
    };
  }
  const dc = calculateConcentrationDC(damageAmount);
  const constitutionModifier = Math.floor((character.stats.con - 10) / 2);
  const { roll, total } = rollConcentrationSave(constitutionModifier);
  const success = total >= dc;
  return {
    characterId: character.id,
    spell: concentration.activeSpell,
    broken: !success,
    reason: success ? "damage" : "failed_save",
    saveRoll: roll,
    saveDC: dc,
    saveTotal: total,
    damageAmount,
    constitutionModifier
  };
}
function breakConcentration(request, concentrationRepo, characterRepo) {
  const concentration = concentrationRepo.findByCharacterId(request.characterId);
  if (!concentration) {
    return {
      characterId: request.characterId,
      spell: "none",
      broken: false,
      reason: request.reason
    };
  }
  const spell = concentration.activeSpell;
  concentrationRepo.delete(request.characterId);
  const character = characterRepo.findById(request.characterId);
  if (character) {
    characterRepo.update(request.characterId, {
      concentratingOn: null
    });
  }
  return {
    characterId: request.characterId,
    spell,
    broken: true,
    reason: request.reason,
    damageAmount: request.damageAmount
  };
}
function startConcentration(characterId, spellName, spellLevel, currentRound, maxDuration, targetIds, concentrationRepo, characterRepo) {
  if (concentrationRepo.isConcentrating(characterId)) {
    breakConcentration({ characterId, reason: "new_spell" }, concentrationRepo, characterRepo);
  }
  const concentration = {
    characterId,
    activeSpell: spellName,
    spellLevel,
    startedAt: currentRound,
    maxDuration,
    targetIds,
    saveDCBase: 10
  };
  concentrationRepo.create(concentration);
  characterRepo.update(characterId, {
    concentratingOn: spellName
  });
}
function checkConcentrationDuration(characterId, currentRound, concentrationRepo, characterRepo) {
  const concentration = concentrationRepo.findByCharacterId(characterId);
  if (!concentration) {
    return null;
  }
  if (!concentration.maxDuration) {
    return null;
  }
  const roundsElapsed = currentRound - concentration.startedAt;
  if (roundsElapsed >= concentration.maxDuration) {
    return breakConcentration({ characterId, reason: "duration" }, concentrationRepo, characterRepo);
  }
  return null;
}
function getConcentration(characterId, concentrationRepo) {
  return concentrationRepo.findByCharacterId(characterId);
}
function checkAutomaticConcentrationBreak(character, concentrationRepo, characterRepo) {
  if (!concentrationRepo.isConcentrating(character.id)) {
    return null;
  }
  if (character.hp <= 0) {
    return breakConcentration({ characterId: character.id, reason: "death" }, concentrationRepo, characterRepo);
  }
  const incapacitatingConditions = [
    "unconscious",
    "stunned",
    "paralyzed",
    "petrified"
  ];
  const hasIncapacitatingCondition = character.conditions?.some((condition) => {
    if (typeof condition === "string") {
      return incapacitatingConditions.includes(condition.toLowerCase());
    }
    return incapacitatingConditions.includes(condition.type.toLowerCase());
  });
  if (hasIncapacitatingCondition) {
    return breakConcentration({ characterId: character.id, reason: "incapacitated" }, concentrationRepo, characterRepo);
  }
  return null;
}

// dist/server/terrain-patterns.js
function generateRiverValley(originX, originY, width, height) {
  const obstacles = [];
  const water = [];
  const westWallX = originX + 2;
  const eastWallX = originX + width - 3;
  const riverStartX = originX + Math.floor(width / 2) - 1;
  const riverWidth = 3;
  for (let y = originY; y < originY + height; y++) {
    obstacles.push(`${westWallX},${y}`);
    obstacles.push(`${westWallX + 1},${y}`);
  }
  for (let y = originY; y < originY + height; y++) {
    obstacles.push(`${eastWallX},${y}`);
    obstacles.push(`${eastWallX - 1},${y}`);
  }
  for (let y = originY; y < originY + height; y++) {
    for (let dx = 0; dx < riverWidth; dx++) {
      water.push(`${riverStartX + dx},${y}`);
    }
  }
  const props = [
    { position: `${westWallX},${originY + 2}`, label: "West Cliff", heightFeet: 30, propType: "structure", cover: "full" },
    { position: `${eastWallX},${originY + 2}`, label: "East Cliff", heightFeet: 30, propType: "structure", cover: "full" }
  ];
  return { obstacles, water, difficultTerrain: [], props };
}
function generateCanyon(originX, originY, width, height) {
  const obstacles = [];
  const northWallY = originY + 3;
  const southWallY = originY + height - 4;
  for (let x = originX; x < originX + width; x++) {
    obstacles.push(`${x},${northWallY}`);
    obstacles.push(`${x},${northWallY - 1}`);
  }
  for (let x = originX; x < originX + width; x++) {
    obstacles.push(`${x},${southWallY}`);
    obstacles.push(`${x},${southWallY + 1}`);
  }
  const props = [
    { position: `${originX + Math.floor(width / 2)},${northWallY}`, label: "North Canyon Wall", heightFeet: 25, propType: "structure", cover: "full" },
    { position: `${originX + Math.floor(width / 2)},${southWallY}`, label: "South Canyon Wall", heightFeet: 25, propType: "structure", cover: "full" }
  ];
  return { obstacles, water: [], difficultTerrain: [], props };
}
function generateArena(originX, originY, width, height) {
  const obstacles = [];
  const centerX = originX + Math.floor(width / 2);
  const centerY = originY + Math.floor(height / 2);
  const radius = Math.min(width, height) / 2 - 2;
  for (let angle = 0; angle < 360; angle += 5) {
    const rad = angle * Math.PI / 180;
    const x = Math.round(centerX + radius * Math.cos(rad));
    const y = Math.round(centerY + radius * Math.sin(rad));
    const key = `${x},${y}`;
    if (!obstacles.includes(key)) {
      obstacles.push(key);
    }
  }
  const props = [
    { position: `${centerX},${originY + 1}`, label: "Arena North Gate", heightFeet: 15, propType: "structure", cover: "three-quarter" },
    { position: `${centerX},${originY + height - 2}`, label: "Arena South Gate", heightFeet: 15, propType: "structure", cover: "three-quarter" }
  ];
  return { obstacles, water: [], difficultTerrain: [], props };
}
function generateMountainPass(originX, originY, width, height) {
  const obstacles = [];
  const difficultTerrain = [];
  const centerY = originY + Math.floor(height / 2);
  for (let y = originY; y < originY + height; y++) {
    const distFromCenter = Math.abs(y - centerY);
    const wallOffset = Math.floor(distFromCenter / 3) + 3;
    obstacles.push(`${originX + wallOffset},${y}`);
    obstacles.push(`${originX + width - wallOffset - 1},${y}`);
    if (distFromCenter > 2) {
      difficultTerrain.push(`${originX + wallOffset + 1},${y}`);
      difficultTerrain.push(`${originX + width - wallOffset - 2},${y}`);
    }
  }
  const props = [
    { position: `${originX + Math.floor(width / 2)},${centerY}`, label: "Pass Chokepoint", heightFeet: 5, propType: "cover", cover: "half" }
  ];
  return { obstacles, water: [], difficultTerrain, props };
}
function getPatternGenerator(pattern) {
  switch (pattern) {
    case "river_valley":
      return generateRiverValley;
    case "canyon":
      return generateCanyon;
    case "arena":
      return generateArena;
    case "mountain_pass":
      return generateMountainPass;
    default:
      return generateCanyon;
  }
}
var PATTERN_DESCRIPTIONS = {
  river_valley: "Parallel cliff walls on east/west edges with 3-wide river in center",
  canyon: "Two parallel walls running east-west with open pass between",
  arena: "Circular wall perimeter enclosing an open fighting area",
  mountain_pass: "Narrowing corridor toward center, wider at edges"
};

// dist/server/combat-tools.js
var pubsub2 = null;
function setCombatPubSub(instance3) {
  pubsub2 = instance3;
}
function buildStateJson(state, encounterId) {
  const currentParticipant = state.participants.find((p) => p.id === state.turnOrder[state.currentTurnIndex]);
  return {
    encounterId,
    round: state.round,
    currentTurnIndex: state.currentTurnIndex,
    currentTurn: currentParticipant ? {
      id: currentParticipant.id,
      name: currentParticipant.name,
      isEnemy: currentParticipant.isEnemy
    } : null,
    turnOrder: state.turnOrder.map((id) => {
      const p = state.participants.find((part) => part.id === id);
      return p?.name || id;
    }),
    participants: state.participants.map((p) => ({
      id: p.id,
      name: p.name,
      hp: p.hp,
      maxHp: p.maxHp,
      initiative: p.initiative,
      isEnemy: p.isEnemy,
      conditions: p.conditions.map((c) => c.type),
      isDefeated: p.hp <= 0,
      isCurrentTurn: p.id === currentParticipant?.id,
      // Spatial visualization data
      position: p.position ?? null,
      size: p.size ?? "medium",
      movementSpeed: p.movementSpeed ?? 30,
      movementRemaining: p.movementRemaining ?? (p.movementSpeed ?? 30)
    })),
    // HIGH-006: Lair action status
    isLairActionPending: state.turnOrder[state.currentTurnIndex] === "LAIR",
    hasLairActions: state.hasLairActions ?? false,
    lairOwnerId: state.lairOwnerId,
    // Spatial visualization data
    terrain: state.terrain ?? { obstacles: [], difficultTerrain: [], water: [] },
    props: state.props ?? [],
    gridBounds: state.gridBounds ?? null
  };
}
function formatCombatStateText(state) {
  const currentParticipant = state.participants.find((p) => p.id === state.turnOrder[state.currentTurnIndex]);
  const isEnemy = currentParticipant?.isEnemy ?? false;
  const turnIcon = isEnemy ? "\u{1F479}" : "\u2694\uFE0F";
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 ${turnIcon} ROUND ${state.round} \u2014 ${currentParticipant?.name}'s Turn
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `\u{1F4CB} INITIATIVE ORDER
`;
  output += `\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500
`;
  state.turnOrder.forEach((id, index) => {
    const p = state.participants.find((part) => part.id === id);
    if (!p)
      return;
    const isCurrent = index === state.currentTurnIndex;
    const icon = p.isEnemy ? "\u{1F479}" : "\u{1F9D9}";
    const hpPct = p.maxHp > 0 ? p.hp / p.maxHp * 100 : 0;
    const hpBar = createHpBar(hpPct);
    const marker = isCurrent ? "\u25B6" : " ";
    const status = p.hp <= 0 ? "\u{1F480} DEFEATED" : "";
    output += `${marker} ${icon} ${p.name.padEnd(18)} ${hpBar} ${p.hp}/${p.maxHp} HP  [Init: ${p.initiative}] ${status}
`;
  });
  output += `
`;
  const validPlayerTargets = state.participants.filter((p) => !p.isEnemy && p.hp > 0).map((p) => `${p.name} (${p.id})`);
  const validEnemyTargets = state.participants.filter((p) => p.isEnemy && p.hp > 0).map((p) => `${p.name} (${p.id})`);
  if (isEnemy && currentParticipant && currentParticipant.hp > 0) {
    output += `\u26A1 ENEMY TURN
`;
    output += `   Available targets: ${validPlayerTargets.join(", ") || "None"}
`;
    output += `   \u2192 Execute attack, then call advance_turn
`;
  } else if (currentParticipant && currentParticipant.hp > 0) {
    output += `\u{1F3AE} PLAYER TURN
`;
    output += `   Available targets: ${validEnemyTargets.join(", ") || "None"}
`;
    output += `   \u2192 Awaiting player action
`;
  } else {
    output += `\u23ED\uFE0F Current combatant is defeated \u2014 call advance_turn
`;
  }
  return output;
}
function createHpBar(percentage) {
  const filled = Math.round(percentage / 10);
  const empty = 10 - filled;
  const bar = "\u2588".repeat(filled) + "\u2591".repeat(empty);
  return `[${bar}]`;
}
function formatAttackResult(result) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u2694\uFE0F  ATTACK ACTION
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${result.actor.name} attacks ${result.target.name}!

`;
  output += result.detailedBreakdown;
  if (result.defeated) {
    output += `

\u{1F480} ${result.target.name} has been defeated!`;
  }
  output += `

\u2192 Call advance_turn to proceed`;
  return output;
}
function formatHealResult(result) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F49A} HEAL ACTION
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${result.actor.name} heals ${result.target.name}!

`;
  output += result.detailedBreakdown;
  output += `

\u2192 Call advance_turn to proceed`;
  return output;
}
function formatSpellCastResult(casterName, resolution, target, targetHpBefore) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u2728 SPELL CAST
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${casterName} casts ${resolution.spellName}!

`;
  if (resolution.diceRolled) {
    output += `\u{1F3B2} Rolled: ${resolution.diceRolled}
`;
  }
  if (resolution.dartCount) {
    output += `\u2728 Darts: ${resolution.dartCount}
`;
  }
  if (resolution.saveResult && resolution.saveDC) {
    const saveIcon = resolution.saveResult === "passed" ? "\u2713" : "\u2717";
    output += `\u{1F6E1}\uFE0F Save DC ${resolution.saveDC}: ${saveIcon} ${resolution.saveResult}
`;
  }
  if (resolution.autoHit) {
    output += `\u{1F3AF} Auto-hit!
`;
  }
  if (resolution.damage && resolution.damage > 0) {
    const damageType = resolution.damageType || "magical";
    output += `\u{1F4A5} Damage: ${resolution.damage} ${damageType}
`;
    if (target) {
      output += `
${target.name}: ${targetHpBefore} \u2192 ${target.hp} HP`;
      if (target.hp <= 0) {
        output += ` \u{1F480} DEFEATED!`;
      }
    }
  }
  if (resolution.healing && resolution.healing > 0) {
    output += `\u{1F49A} Healing: ${resolution.healing}
`;
    if (target) {
      output += `
${target.name}: ${targetHpBefore} \u2192 ${target.hp} HP`;
    }
  }
  if (resolution.concentration) {
    output += `
\u26A1 Concentration required`;
  }
  output += `

\u2192 Call advance_turn to proceed`;
  return output;
}
function formatDisengageResult(actorName) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F3C3} DISENGAGE ACTION
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${actorName} takes the Disengage action.
`;
  output += `Movement this turn will not provoke opportunity attacks.
`;
  output += `
\u2192 Call advance_turn to proceed (or move first)`;
  return output;
}
function formatOpportunityAttackResult(result) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u26A1 OPPORTUNITY ATTACK
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += result.detailedBreakdown;
  return output;
}
function formatMoveResult(actorName, fromPos, toPos, success, failReason, distance) {
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F6B6} MOVE ACTION
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  if (success) {
    if (fromPos) {
      output += `${actorName} moved from (${fromPos.x}, ${fromPos.y}) to (${toPos.x}, ${toPos.y})`;
      if (distance !== void 0) {
        output += ` [${distance} tiles]`;
      }
      output += `
`;
    } else {
      output += `${actorName} placed at (${toPos.x}, ${toPos.y})
`;
    }
  } else {
    output += `${actorName} cannot move to (${toPos.x}, ${toPos.y})
`;
    output += `Reason: ${failReason}
`;
  }
  output += `
\u2192 Call advance_turn to proceed`;
  return output;
}
function renderGrid(state, options) {
  const width = options?.width ?? 20;
  const height = options?.height ?? 20;
  const showLegend = options?.showLegend ?? true;
  const grid = [];
  for (let y = 0; y < height; y++) {
    grid[y] = [];
    for (let x = 0; x < width; x++) {
      grid[y][x] = "\xB7";
    }
  }
  const terrain = state.terrain ?? { obstacles: [] };
  for (const obs of terrain.obstacles) {
    const [x, y] = obs.split(",").map(Number);
    if (x >= 0 && x < width && y >= 0 && y < height) {
      grid[y][x] = "\u2588";
    }
  }
  if (terrain.difficultTerrain) {
    for (const dt of terrain.difficultTerrain) {
      const [x, y] = dt.split(",").map(Number);
      if (x >= 0 && x < width && y >= 0 && y < height && grid[y][x] === "\xB7") {
        grid[y][x] = "\u2591";
      }
    }
  }
  const legend = [];
  let friendlyIndex = 1;
  let enemyIndex = 1;
  for (const p of state.participants) {
    if (!p.position)
      continue;
    const { x, y } = p.position;
    if (x >= 0 && x < width && y >= 0 && y < height) {
      let symbol;
      if (p.hp <= 0) {
        symbol = "\u2620";
      } else if (p.isEnemy) {
        symbol = String(enemyIndex);
        legend.push(`  ${symbol} = ${p.name} (Enemy, HP: ${p.hp}/${p.maxHp})`);
        enemyIndex = enemyIndex % 9 + 1;
      } else {
        symbol = String.fromCharCode(64 + friendlyIndex);
        legend.push(`  ${symbol} = ${p.name} (HP: ${p.hp}/${p.maxHp})`);
        friendlyIndex++;
      }
      grid[y][x] = symbol;
    }
  }
  let output = "\n\u250C\u2500 COMBAT MAP \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n";
  output += "    ";
  for (let x = 0; x < width; x++) {
    output += x % 5 === 0 ? String(x).padStart(2, " ").slice(-1) : " ";
  }
  output += "\n";
  for (let y = 0; y < height; y++) {
    const yLabel = y % 5 === 0 ? String(y).padStart(2, " ") : "  ";
    output += `${yLabel} \u2502`;
    for (let x = 0; x < width; x++) {
      output += grid[y][x];
    }
    output += "\u2502\n";
  }
  output += "\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n";
  if (showLegend && legend.length > 0) {
    output += "\n\u{1F4CD} LEGEND:\n";
    output += legend.join("\n") + "\n";
    output += "\n  \xB7 = Empty   \u2588 = Obstacle   \u2591 = Difficult Terrain   \u2620 = Defeated\n";
  }
  return output;
}
function calculateAoE(state, shape, origin, params) {
  const spatial = new SpatialEngine();
  let tiles = [];
  if (shape === "circle" && params.radius !== void 0) {
    tiles = spatial.getCircleTiles(origin, params.radius);
  } else if (shape === "cone" && params.direction && params.length !== void 0 && params.angle !== void 0) {
    tiles = spatial.getConeTiles(origin, params.direction, params.length, params.angle);
  } else if (shape === "line" && params.direction && params.length !== void 0) {
    const endX = origin.x + params.direction.x * params.length;
    const endY = origin.y + params.direction.y * params.length;
    tiles = spatial.getLineTiles(origin, { x: endX, y: endY });
  }
  const tileSet = new Set(tiles.map((t) => `${t.x},${t.y}`));
  const affectedParticipants = state.participants.filter((p) => p.position && tileSet.has(`${p.position.x},${p.position.y}`) && p.hp > 0).map((p) => ({ id: p.id, name: p.name, position: p.position }));
  return { tiles, affectedParticipants };
}
var CombatTools = {
  CREATE_ENCOUNTER: {
    name: "create_encounter",
    description: `Create a combat encounter with positioned combatants and terrain.

\u{1F4CB} WORKFLOW:
1. Generate terrain (obstacles, water, difficult)
2. Add props (buildings, trees, cover)
3. Place party (safe starting positions)
4. Place enemies (tactical positions)

\u26A0\uFE0F CRITICAL VERTICALITY RULES:
- z=0 means "standing on surface at (x,y)" - EVEN ON TOP OF OBSTACLES
- If obstacles exist at (15,3), placing a unit at {x:15,y:3,z:0} = STANDING ON the obstacle
- z>0 = FLYING/LEVITATING only. Creatures without flight condition WILL FALL!
- Do NOT use z values to represent "standing on high ground"

\u2705 CORRECT: Goblin on rock at (15,3) \u2192 position: {x:15, y:3, z:0}
\u274C WRONG: Goblin on rock \u2192 position: {x:15, y:3, z:25} (will fall!)

\u{1F3D4}\uFE0F TERRAIN GENERATION RULES:
- Obstacles should CLUSTER to form hills/mountains/caverns
- Include SLOPES: Adjacent tiles stepping down to ground level
- Isolated cliffs only if intentionally inaccessible
- Water must CONNECT (rivers/streams/pools), never isolated tiles

\u{1F4D0} PATTERN TEMPLATES (USE THESE!):

RIVER VALLEY (cliffs on sides, river in middle):
obstacles: ["5,0","5,1","5,2",...,"5,19"] (west cliff),
           ["13,0","13,1","13,2",...,"13,19"] (east cliff)
water: ["8,0","9,0","10,0","8,1","9,1","10,1",...] (3-wide river at x=8,9,10)

CANYON (two parallel walls):
obstacles: ["0,5","1,5","2,5",...,"9,5"] (north wall),
           ["0,15","1,15","2,15",...,"9,15"] (south wall)

Example:
{
  "seed": "battle-1",
  "terrain": {
    "obstacles": ["10,5", "11,5", "10,6"],
    "water": ["5,10", "5,11", "6,11"]
  },
  "participants": [
    {"id": "hero-1", "name": "Valeros", "hp": 20, "maxHp": 20, "initiativeBonus": 2, 
     "position": {"x": 15, "y": 15, "z": 0}},
    {"id": "goblin-1", "name": "Goblin Archer", "hp": 7, "maxHp": 7, "initiativeBonus": 1,
     "position": {"x": 10, "y": 5, "z": 0}, "isEnemy": true}
  ]
}`,
    inputSchema: external_exports.object({
      seed: external_exports.string().describe("Seed for deterministic combat resolution"),
      participants: external_exports.array(external_exports.object({
        id: external_exports.string(),
        name: external_exports.string(),
        initiativeBonus: external_exports.number().int(),
        hp: external_exports.number().int().positive(),
        maxHp: external_exports.number().int().positive(),
        isEnemy: external_exports.boolean().optional().describe("Whether this is an enemy (auto-detected if not set)"),
        conditions: external_exports.array(external_exports.string()).default([]),
        position: external_exports.object({ x: external_exports.number(), y: external_exports.number(), z: external_exports.number().optional() }).optional().describe("CRIT-003: Spatial position for movement (x, y coordinates)"),
        // HIGH-002: Damage modifiers
        resistances: external_exports.array(external_exports.string()).optional().describe('Damage types that deal half damage (e.g., ["fire", "cold"])'),
        vulnerabilities: external_exports.array(external_exports.string()).optional().describe("Damage types that deal double damage"),
        immunities: external_exports.array(external_exports.string()).optional().describe("Damage types that deal no damage")
      })).min(1),
      terrain: external_exports.object({
        obstacles: external_exports.array(external_exports.string()).default([]).describe('Array of "x,y" strings for blocking tiles'),
        difficultTerrain: external_exports.array(external_exports.string()).optional().describe('Array of "x,y" strings for difficult terrain'),
        water: external_exports.array(external_exports.string()).optional().describe('Array of "x,y" strings for water terrain (streams, rivers)')
      }).optional().describe("CRIT-003: Terrain configuration for collision")
    })
  },
  GET_ENCOUNTER_STATE: {
    name: "get_encounter_state",
    description: "Get the current state of the active combat encounter.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter")
    })
  },
  EXECUTE_COMBAT_ACTION: {
    name: "execute_combat_action",
    description: `Execute a combat action (attack, heal, move, cast_spell, etc.).

Examples:
{
  "action": "attack",
  "actorId": "hero-1",
  "targetId": "goblin-1",
  "attackBonus": 5,
  "dc": 12,
  "damage": 6
}

{
  "action": "heal",
  "actorId": "cleric-1",
  "targetId": "hero-1",
  "amount": 8
}

{
  "action": "move",
  "actorId": "hero-1",
  "targetPosition": { "x": 5, "y": 3 }
}

{
  "action": "disengage",
  "actorId": "hero-1"
}

{
  "action": "cast_spell",
  "actorId": "wizard-1",
  "spellName": "Fireball",
  "targetId": "goblin-1",
  "slotLevel": 3
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      action: external_exports.enum(["attack", "heal", "move", "disengage", "cast_spell"]),
      actorId: external_exports.string(),
      targetId: external_exports.string().optional().describe("Target ID for attack/heal/cast_spell actions"),
      attackBonus: external_exports.number().int().optional(),
      dc: external_exports.number().int().optional(),
      damage: external_exports.number().int().optional(),
      damageType: external_exports.string().optional().describe('HIGH-002: Damage type (e.g., "fire", "cold", "slashing") for resistance calculation'),
      amount: external_exports.number().int().optional(),
      targetPosition: external_exports.object({ x: external_exports.number(), y: external_exports.number() }).optional().describe("CRIT-003: Target position for move action"),
      // CRIT-006: Spell casting fields
      spellName: external_exports.string().optional().describe("CRIT-006: Name of the spell to cast (must exist in spell database)"),
      slotLevel: external_exports.number().int().min(1).max(9).optional().describe("CRIT-006: Spell slot level to use (for upcasting)")
    })
  },
  ADVANCE_TURN: {
    name: "advance_turn",
    description: "Advance to the next combatant's turn.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter")
    })
  },
  END_ENCOUNTER: {
    name: "end_encounter",
    description: "End the current combat encounter.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter")
    })
  },
  LOAD_ENCOUNTER: {
    name: "load_encounter",
    description: "Load a combat encounter from the database.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter to load")
    })
  },
  ROLL_DEATH_SAVE: {
    name: "roll_death_save",
    description: "Roll a d20 death saving throw for a character at 0 HP. 10+ success, nat 20 regains 1 HP, nat 1 counts as 2 failures.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      characterId: external_exports.string().describe("The ID of the character at 0 HP")
    })
  },
  EXECUTE_LAIR_ACTION: {
    name: "execute_lair_action",
    description: "Execute a lair action at initiative 20 when isLairActionPending is true. Apply environmental effects to targets.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      actionDescription: external_exports.string().describe("Description of the lair action"),
      targetIds: external_exports.array(external_exports.string()).optional().describe("IDs of affected participants (optional)"),
      damage: external_exports.number().int().min(0).optional().describe("Damage dealt by the lair action"),
      damageType: external_exports.string().optional().describe("Type of damage (fire, cold, etc.)"),
      savingThrow: external_exports.object({
        ability: external_exports.enum(["strength", "dexterity", "constitution", "intelligence", "wisdom", "charisma"]),
        dc: external_exports.number().int().min(1).max(30)
      }).optional().describe("Saving throw required to avoid/reduce effect"),
      halfDamageOnSave: external_exports.boolean().default(true).describe("Whether successful save halves damage")
    })
  },
  // ============================================================
  // VISUALIZATION TOOLS
  // ============================================================
  RENDER_MAP: {
    name: "render_map",
    description: `Render an ASCII map of the current combat state showing participant positions, obstacles, and terrain.
Returns a text-based grid visualization with:
- A-Z for friendly participants
- 1-9 for enemies
- \u2588 for obstacles
- \u2591 for difficult terrain
- \u2620 for defeated combatants

Example:
{
  "encounterId": "encounter-battle-1-123456",
  "width": 15,
  "height": 15
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      width: external_exports.number().int().min(5).max(50).default(20).describe("Grid width (default: 20)"),
      height: external_exports.number().int().min(5).max(50).default(20).describe("Grid height (default: 20)"),
      showLegend: external_exports.boolean().default(true).describe("Include legend explaining symbols")
    })
  },
  CALCULATE_AOE: {
    name: "calculate_aoe",
    description: `Calculate which tiles and participants are affected by an Area of Effect spell or ability.
Supports circle (Fireball), cone (Burning Hands), and line (Lightning Bolt) shapes.

Example - Fireball (20ft radius circle):
{
  "encounterId": "encounter-1",
  "shape": "circle",
  "origin": { "x": 10, "y": 10 },
  "radius": 4
}

Example - Burning Hands (15ft cone):
{
  "encounterId": "encounter-1",
  "shape": "cone",
  "origin": { "x": 5, "y": 5 },
  "direction": { "x": 1, "y": 0 },
  "length": 3,
  "angle": 90
}

Example - Lightning Bolt (100ft line):
{
  "encounterId": "encounter-1",
  "shape": "line",
  "origin": { "x": 0, "y": 5 },
  "direction": { "x": 1, "y": 0 },
  "length": 20
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      shape: external_exports.enum(["circle", "cone", "line"]).describe("Shape of the AoE"),
      origin: external_exports.object({
        x: external_exports.number(),
        y: external_exports.number()
      }).describe("Origin point of the AoE"),
      radius: external_exports.number().optional().describe("Radius for circle shape (in tiles)"),
      direction: external_exports.object({
        x: external_exports.number(),
        y: external_exports.number()
      }).optional().describe("Direction vector for cone/line (e.g., {x:1,y:0} = East)"),
      length: external_exports.number().optional().describe("Length for cone/line shapes (in tiles)"),
      angle: external_exports.number().optional().describe("Angle for cone shape (in degrees, e.g., 90 for quarter circle)")
    })
  },
  UPDATE_TERRAIN: {
    name: "update_terrain",
    description: `Add, remove, or modify terrain in an active encounter. Use this to dynamically change the battlefield.

Supports:
- obstacles: Blocking terrain (walls, rocks, fallen trees)
- difficultTerrain: Half-speed terrain (mud, rubble, underbrush)
- water: Watery terrain (streams, rivers, pools)

Example - Add a river:
{
  "encounterId": "encounter-1",
  "operation": "add",
  "terrainType": "water",
  "tiles": ["40,0", "40,1", "40,2", "40,3", "40,4"]
}

Example - Remove obstacles:
{
  "encounterId": "encounter-1",
  "operation": "remove",
  "terrainType": "obstacles",
  "tiles": ["5,5", "5,6"]
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      operation: external_exports.enum(["add", "remove"]).describe("Add or remove terrain"),
      terrainType: external_exports.enum(["obstacles", "difficultTerrain", "water"]).describe("Type of terrain to modify"),
      tiles: external_exports.array(external_exports.string()).min(1).describe('Array of "x,y" coordinate strings')
    })
  },
  PLACE_PROP: {
    name: "place_prop",
    description: `Place an improvised prop/object on the battlefield during combat.

Props are free-form terrain features with rich description that can be interacted with.
Think: ladders, wagons, trees, buildings, towers, cliffs, chandeliers, etc.

\u26A0\uFE0F HEIGHT SEMANTICS (CRITICAL):
- heightFeet describes the PROP'S visual/physical height, NOT entity position
- A 30ft cliff at (5,5) is visually tall 
- Entities standing ON such a prop use position (5,5, z=0), NOT z=30!
- The terrain height is implicit in the visualization

\u{1F3D7}\uFE0F PROP TYPES:
- cliff: Stacked rocky terrain with slopes
- wall: Stone/brick barriers  
- bridge: Spanning structures over gaps
- tree: Vegetation cover
- stairs: Stepped access to elevation
- pit: Below-ground areas (negative Y)

Cover Types (D&D 5e):
- half: +2 AC (waist-high wall, thick furniture)
- three_quarter: +5 AC (arrow slit, portcullis)
- full: Total cover (complete obstruction)

Example - Climbable cliff with slopes adjacent:
{
  "encounterId": "encounter-1",
  "position": "15,20",
  "label": "Rocky Cliff",
  "propType": "structure",
  "heightFeet": 25,
  "cover": "half",
  "climbable": true,
  "climbDC": 12,
  "description": "A 25ft rocky outcrop. Adjacent tiles (14,20), (16,20) slope down."
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      position: external_exports.string().describe('Position as "x,y" coordinate string'),
      label: external_exports.string().describe('Free-text label (e.g., "Burning Cart", "Watch Tower", "Rope Bridge")'),
      propType: external_exports.enum(["structure", "cover", "climbable", "hazard", "interactive", "decoration"]).describe("General category of prop"),
      heightFeet: external_exports.number().int().min(0).optional().describe("Height in feet for elevated props"),
      cover: external_exports.enum(["none", "half", "three_quarter", "full"]).optional().default("none").describe("Cover provided by this prop"),
      climbable: external_exports.boolean().optional().default(false).describe("Can this be climbed?"),
      climbDC: external_exports.number().int().min(0).max(30).optional().describe("Athletics DC to climb (if climbable)"),
      breakable: external_exports.boolean().optional().default(false).describe("Can this be destroyed?"),
      hp: external_exports.number().int().min(1).optional().describe("Hit points (if breakable)"),
      description: external_exports.string().optional().describe("Rich narrative description of the prop")
    })
  },
  MEASURE_DISTANCE: {
    name: "measure_distance",
    description: `Calculate the distance between two points or entities on the battlefield.
Returns distance in feet (5ft per square, diagonal = 5ft using D&D simplified rules).

Example - Between two coordinates:
{
  "encounterId": "encounter-1",
  "from": { "type": "position", "value": "10,10" },
  "to": { "type": "position", "value": "15,18" }
}

Example - Between two entities:
{
  "encounterId": "encounter-1",
  "from": { "type": "entity", "value": "hero-1" },
  "to": { "type": "entity", "value": "goblin-3" }
}

Example - From entity to position:
{
  "encounterId": "encounter-1",
  "from": { "type": "entity", "value": "wizard-1" },
  "to": { "type": "position", "value": "25,30" }
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      from: external_exports.object({
        type: external_exports.enum(["position", "entity"]),
        value: external_exports.string().describe('Either "x,y" coordinate or entity ID')
      }),
      to: external_exports.object({
        type: external_exports.enum(["position", "entity"]),
        value: external_exports.string().describe('Either "x,y" coordinate or entity ID')
      })
    })
  },
  GENERATE_TERRAIN_PATCH: {
    name: "generate_terrain_patch",
    description: `Generate a terrain patch using procedural noise or preset patterns.
Much easier than placing individual tiles - LLM describes the area and this tool generates it.

Biome Presets:
- forest: Trees (climbable props), undergrowth (difficult terrain), paths
- cave: Rocky walls (obstacles), stalactites (props), pools (water)  
- village: Buildings (obstacle clusters), roads (clear), market stalls (props)
- dungeon: Walls (obstacles), rubble (difficult), traps (hazards)
- swamp: Water, lily pads (props), dead trees, difficult terrain
- battlefield: Barricades, craters (difficult), debris (props)

Density: 0.1 (sparse) to 1.0 (dense)

Example - Generate a forest clearing:
{
  "encounterId": "encounter-1",
  "biome": "forest",
  "origin": { "x": 10, "y": 10 },
  "width": 20,
  "height": 20,
  "density": 0.4,
  "seed": "goblin-ambush",
  "clearCenter": true
}

Example - Dungeon room:
{
  "encounterId": "encounter-1",
  "biome": "dungeon",
  "origin": { "x": 0, "y": 0 },
  "width": 15,
  "height": 12,
  "density": 0.6,
  "seed": "throne-room"
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      biome: external_exports.enum(["forest", "cave", "village", "dungeon", "swamp", "battlefield"]).describe("Biome preset to use"),
      origin: external_exports.object({
        x: external_exports.number().int(),
        y: external_exports.number().int()
      }).describe("Top-left corner of the patch"),
      width: external_exports.number().int().min(5).max(100).describe("Width of the patch in tiles"),
      height: external_exports.number().int().min(5).max(100).describe("Height of the patch in tiles"),
      density: external_exports.number().min(0.1).max(1).default(0.5).describe("How densely packed (0.1=sparse, 1.0=very dense)"),
      seed: external_exports.string().optional().describe("Seed for reproducible generation"),
      clearCenter: external_exports.boolean().optional().default(false).describe("Keep the center area clear (for player spawn)"),
      pattern: external_exports.enum(["river_valley", "canyon", "arena", "mountain_pass"]).optional().describe("Use a terrain pattern template instead of biome generation")
    })
  },
  /**
   * Generate terrain with a specific geometric pattern
   */
  GENERATE_TERRAIN_PATTERN: {
    name: "generate_terrain_pattern",
    description: `Generate terrain using a geometric pattern template for consistent layouts.

PATTERNS:
- river_valley: Parallel cliff walls on east/west edges, 3-wide river in center
- canyon: Two parallel walls running east-west with open pass between
- arena: Circular wall perimeter enclosing fighting area
- mountain_pass: Narrowing corridor toward center, wider at edges

This tool generates consistent terrain layouts every time, unlike biome-based generation.

Example:
{
  "encounterId": "enc-1",
  "pattern": "river_valley",
  "origin": { "x": 0, "y": 0 },
  "width": 25,
  "height": 40
}`,
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The ID of the encounter"),
      pattern: external_exports.enum(["river_valley", "canyon", "arena", "mountain_pass"]).describe("Terrain pattern to generate"),
      origin: external_exports.object({
        x: external_exports.number().int(),
        y: external_exports.number().int()
      }).describe("Top-left corner of the pattern"),
      width: external_exports.number().int().min(10).max(100).describe("Width of the pattern area"),
      height: external_exports.number().int().min(10).max(100).describe("Height of the pattern area")
    })
  }
};
async function handleCreateEncounter(args, ctx) {
  const parsed = CombatTools.CREATE_ENCOUNTER.inputSchema.parse(args);
  const engine = new CombatEngine(parsed.seed, pubsub2 || void 0);
  const participants = parsed.participants.map((p) => ({
    id: p.id,
    name: p.name,
    initiativeBonus: p.initiativeBonus,
    hp: p.hp,
    maxHp: p.maxHp,
    isEnemy: p.isEnemy,
    // Will be auto-detected in startEncounter if undefined
    conditions: [],
    position: p.position,
    // CRIT-003: Preserve spatial position
    // HIGH-002: Preserve damage modifiers
    resistances: p.resistances,
    vulnerabilities: p.vulnerabilities,
    immunities: p.immunities
  }));
  const state = engine.startEncounter(participants);
  if (parsed.terrain && state) {
    state.terrain = parsed.terrain;
  }
  const encounterId = `encounter-${parsed.seed}-${Date.now()}`;
  getCombatManager().create(`${ctx.sessionId}:${encounterId}`, engine);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.create({
    id: encounterId,
    tokens: state.participants.map((p) => ({
      id: p.id,
      name: p.name,
      initiativeBonus: p.initiativeBonus,
      initiative: p.initiative,
      // Store rolled initiative
      isEnemy: p.isEnemy,
      // Store enemy flag
      hp: p.hp,
      maxHp: p.maxHp,
      conditions: p.conditions,
      abilityScores: p.abilityScores,
      // Spatial visualization data
      position: p.position,
      movementSpeed: p.movementSpeed ?? 30,
      size: p.size ?? "medium"
    })),
    round: state.round,
    activeTokenId: state.turnOrder[state.currentTurnIndex],
    status: "active",
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString()
  });
  const stateJson = buildStateJson(state, encounterId);
  const formattedText = formatCombatStateText(state);
  let output = `\u2694\uFE0F COMBAT STARTED
`;
  output += `Encounter ID: ${encounterId}
`;
  output += formattedText;
  output += `

<!-- STATE_JSON
${JSON.stringify(stateJson)}
STATE_JSON -->`;
  return {
    content: [
      {
        type: "text",
        text: output
      }
    ]
  };
}
async function handleGetEncounterState(args, ctx) {
  const parsed = CombatTools.GET_ENCOUNTER_STATE.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  const stateJson = buildStateJson(state, parsed.encounterId);
  return stateJson;
}
async function handleExecuteCombatAction(args, ctx) {
  const parsed = CombatTools.EXECUTE_COMBAT_ACTION.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  let result;
  let output = "";
  if (parsed.action === "attack") {
    if (parsed.attackBonus === void 0 || parsed.dc === void 0 || parsed.damage === void 0) {
      throw new Error("Attack action requires attackBonus, dc, and damage");
    }
    if (!parsed.targetId) {
      throw new Error("Attack action requires targetId");
    }
    result = engine.executeAttack(
      parsed.actorId,
      parsed.targetId,
      parsed.attackBonus,
      parsed.dc,
      parsed.damage,
      parsed.damageType
      // HIGH-002: Pass damage type for resistance calculation
    );
    if (result.success && result.damage && result.damage > 0) {
      const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
      const concentrationRepo = new ConcentrationRepository(db);
      const charRepo = new CharacterRepository(db);
      const targetChar = charRepo.findById(parsed.targetId);
      if (targetChar && concentrationRepo.isConcentrating(parsed.targetId)) {
        const concentrationCheck = checkConcentration(targetChar, result.damage, concentrationRepo);
        if (concentrationCheck.broken) {
          breakConcentration({ characterId: parsed.targetId, reason: "damage", damageAmount: result.damage }, concentrationRepo, charRepo);
        }
      }
    }
    output = formatAttackResult(result);
  } else if (parsed.action === "heal") {
    if (parsed.amount === void 0) {
      throw new Error("Heal action requires amount");
    }
    if (!parsed.targetId) {
      throw new Error("Heal action requires targetId");
    }
    result = engine.executeHeal(parsed.actorId, parsed.targetId, parsed.amount);
    output = formatHealResult(result);
  } else if (parsed.action === "disengage") {
    const currentState = engine.getState();
    if (!currentState) {
      throw new Error("No combat state");
    }
    const actor = currentState.participants.find((p) => p.id === parsed.actorId);
    if (!actor) {
      throw new Error(`Actor ${parsed.actorId} not found`);
    }
    engine.disengage(parsed.actorId);
    output = formatDisengageResult(actor.name);
    result = {
      type: "attack",
      // Placeholder type
      success: true,
      actor: { id: actor.id, name: actor.name },
      target: { id: actor.id, name: actor.name, hpBefore: actor.hp, hpAfter: actor.hp, maxHp: actor.maxHp },
      defeated: false,
      message: `${actor.name} disengages`,
      detailedBreakdown: output
    };
  } else if (parsed.action === "move") {
    if (!parsed.targetPosition) {
      throw new Error("Move action requires targetPosition");
    }
    const currentState = engine.getState();
    if (!currentState) {
      throw new Error("No combat state");
    }
    const actor = currentState.participants.find((p) => p.id === parsed.actorId);
    if (!actor) {
      throw new Error(`Actor ${parsed.actorId} not found`);
    }
    const actorPos = actor.position;
    if (!actorPos) {
      actor.position = parsed.targetPosition;
      output = formatMoveResult(actor.name, void 0, parsed.targetPosition, true, null);
    } else {
      const opportunityAttackers = engine.getOpportunityAttackers(parsed.actorId, actorPos, parsed.targetPosition);
      let opportunityAttackOutput = "";
      for (const attacker of opportunityAttackers) {
        const oaResult = engine.executeOpportunityAttack(attacker.id, parsed.actorId);
        opportunityAttackOutput += formatOpportunityAttackResult(oaResult) + "\n";
        if (oaResult.defeated) {
          output = opportunityAttackOutput;
          output += `
${actor.name} was defeated while attempting to move and cannot complete the movement!`;
          result = {
            type: "attack",
            success: false,
            actor: { id: actor.id, name: actor.name },
            target: { id: actor.id, name: actor.name, hpBefore: oaResult.target.hpBefore, hpAfter: oaResult.target.hpAfter, maxHp: actor.maxHp },
            defeated: true,
            message: `${actor.name} defeated by opportunity attack`,
            detailedBreakdown: output
          };
          break;
        }
      }
      const updatedActor = currentState.participants.find((p) => p.id === parsed.actorId);
      if (updatedActor && updatedActor.hp > 0) {
        const obstacles = /* @__PURE__ */ new Set();
        for (const p of currentState.participants) {
          if (p.id !== parsed.actorId && p.position) {
            const pos = p.position;
            obstacles.add(`${pos.x},${pos.y}`);
          }
        }
        const terrain = currentState.terrain;
        if (terrain?.obstacles) {
          for (const obs of terrain.obstacles) {
            obstacles.add(obs);
          }
        }
        const destKey = `${parsed.targetPosition.x},${parsed.targetPosition.y}`;
        if (obstacles.has(destKey)) {
          output = opportunityAttackOutput + formatMoveResult(actor.name, actorPos, parsed.targetPosition, false, "Destination is blocked");
        } else {
          const spatial = new SpatialEngine();
          const path = spatial.findPath({ x: actorPos.x, y: actorPos.y }, { x: parsed.targetPosition.x, y: parsed.targetPosition.y }, obstacles);
          if (path === null) {
            output = opportunityAttackOutput + formatMoveResult(actor.name, actorPos, parsed.targetPosition, false, "No valid path - blocked by obstacles");
          } else {
            updatedActor.position = parsed.targetPosition;
            output = opportunityAttackOutput + formatMoveResult(actor.name, actorPos, parsed.targetPosition, true, null, path.length - 1);
          }
        }
        result = {
          type: "attack",
          success: output.includes("moved"),
          actor: { id: actor.id, name: actor.name },
          target: { id: actor.id, name: actor.name, hpBefore: actor.hp, hpAfter: updatedActor.hp, maxHp: actor.maxHp },
          defeated: updatedActor.hp <= 0,
          message: output.includes("moved") ? `${actor.name} moved` : `${actor.name} could not move`,
          detailedBreakdown: output
        };
      }
    }
    if (!result) {
      result = {
        type: "attack",
        success: output.includes("moved") || output.includes("placed"),
        actor: { id: actor.id, name: actor.name },
        target: { id: actor.id, name: actor.name, hpBefore: actor.hp, hpAfter: actor.hp, maxHp: actor.maxHp },
        defeated: false,
        message: `${actor.name} moved`,
        detailedBreakdown: output
      };
    }
  } else if (parsed.action === "cast_spell") {
    if (!parsed.spellName) {
      throw new Error("cast_spell action requires spellName");
    }
    if (parsed.damage !== void 0) {
      throw new Error("damage parameter not allowed for cast_spell - damage is calculated from spell");
    }
    const currentState = engine.getState();
    if (!currentState) {
      throw new Error("No combat state");
    }
    const actor = currentState.participants.find((p) => p.id === parsed.actorId);
    if (!actor) {
      throw new Error(`Actor ${parsed.actorId} not found`);
    }
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const charRepo = new CharacterRepository(db);
    let casterChar = null;
    try {
      casterChar = charRepo.findById(parsed.actorId);
    } catch {
    }
    if (!casterChar) {
      throw new Error(`Character ${parsed.actorId} not found in database. Spellcasting requires a character record with class and spell slots.`);
    }
    const validation = validateSpellCast(casterChar, parsed.spellName, parsed.slotLevel);
    if (!validation.valid) {
      throw new Error(validation.error?.message || "Invalid spell cast");
    }
    const spell = validation.spell;
    const effectiveSlotLevel = validation.effectiveSlotLevel || spell.level;
    let target = currentState.participants.find((p) => p.id === parsed.targetId);
    const targetHpBefore = target?.hp || 0;
    const resolution = resolveSpell(spell, casterChar, effectiveSlotLevel, {
      targetAC: target ? target.ac || 10 : 10
    });
    if (resolution.damage && resolution.damage > 0 && target) {
      const damageType = resolution.damageType || "force";
      engine.executeAttack(
        parsed.actorId,
        parsed.targetId,
        100,
        // Auto-hit for spell damage
        0,
        // DC doesn't matter
        resolution.damage,
        damageType
      );
      target = currentState.participants.find((p) => p.id === parsed.targetId);
      if (target) {
        const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
        const concentrationRepo = new ConcentrationRepository(db2);
        const targetChar = charRepo.findById(parsed.targetId);
        if (targetChar && concentrationRepo.isConcentrating(parsed.targetId)) {
          const concentrationCheck = checkConcentration(targetChar, resolution.damage, concentrationRepo);
          if (concentrationCheck.broken) {
            breakConcentration({ characterId: parsed.targetId, reason: "damage", damageAmount: resolution.damage }, concentrationRepo, charRepo);
          }
        }
      }
    }
    if (resolution.healing && resolution.healing > 0 && target) {
      engine.executeHeal(parsed.actorId, parsed.targetId, resolution.healing);
      target = currentState.participants.find((p) => p.id === parsed.targetId);
    }
    if (effectiveSlotLevel > 0) {
      const updatedChar = consumeSpellSlot(casterChar, effectiveSlotLevel);
      charRepo.update(casterChar.id, updatedChar);
    }
    if (spell.concentration) {
      const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
      const concentrationRepo = new ConcentrationRepository(db2);
      const currentState2 = engine.getState();
      let maxDuration;
      const durationMatch = spell.duration.match(/(\d+)\s+(minute|hour)/i);
      if (durationMatch) {
        const value = parseInt(durationMatch[1]);
        const unit = durationMatch[2].toLowerCase();
        if (unit === "minute") {
          maxDuration = value * 10;
        } else if (unit === "hour") {
          maxDuration = value * 600;
        }
      }
      startConcentration(casterChar.id, spell.name, effectiveSlotLevel, currentState2?.round || 1, maxDuration, parsed.targetId ? [parsed.targetId] : void 0, concentrationRepo, charRepo);
    }
    output = formatSpellCastResult(actor.name, resolution, target, targetHpBefore);
    output += `
[SPELL: ${spell.name}, SLOT: ${effectiveSlotLevel > 0 ? effectiveSlotLevel : "cantrip"}, DMG: ${resolution.damage || 0}, HEAL: ${resolution.healing || 0}]`;
    result = {
      type: "attack",
      success: resolution.success,
      actor: { id: actor.id, name: actor.name },
      target: target ? {
        id: target.id,
        name: target.name,
        hpBefore: targetHpBefore,
        hpAfter: target.hp,
        maxHp: target.maxHp
      } : { id: "none", name: "none", hpBefore: 0, hpAfter: 0, maxHp: 0 },
      defeated: target ? target.hp <= 0 : false,
      message: `${actor.name} cast ${spell.name}`,
      // CRIT-006: Include spell damage/healing in result for testing and frontend
      damage: resolution.damage,
      healAmount: resolution.healing,
      detailedBreakdown: output
    };
  } else {
    throw new Error(`Unknown action: ${parsed.action}`);
  }
  const state = engine.getState();
  if (state) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    repo.saveState(parsed.encounterId, state);
    const stateJson = buildStateJson(state, parsed.encounterId);
    output += `

<!-- STATE_JSON
${JSON.stringify(stateJson)}
STATE_JSON -->`;
  }
  return {
    content: [
      {
        type: "text",
        text: output
      }
    ]
  };
}
async function handleAdvanceTurn(args, ctx) {
  const parsed = CombatTools.ADVANCE_TURN.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const previousParticipant = engine.getCurrentParticipant();
  engine.nextTurnWithConditions();
  const state = engine.getState();
  if (state) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    repo.saveState(parsed.encounterId, state);
  }
  let output = `
\u23ED\uFE0F TURN ENDED: ${previousParticipant?.name}
`;
  output += state ? formatCombatStateText(state) : "No combat state";
  if (state) {
    const stateJson = buildStateJson(state, parsed.encounterId);
    output += `

<!-- STATE_JSON
${JSON.stringify(stateJson)}
STATE_JSON -->`;
  }
  return {
    content: [
      {
        type: "text",
        text: output
      }
    ]
  };
}
async function handleEndEncounter(args, ctx) {
  const parsed = CombatTools.END_ENCOUNTER.inputSchema.parse(args);
  const namespacedId = `${ctx.sessionId}:${parsed.encounterId}`;
  const engine = getCombatManager().get(namespacedId);
  if (!engine) {
    throw new Error(`Encounter ${parsed.encounterId} not found.`);
  }
  const finalState = engine.getState();
  const syncResults = [];
  if (finalState) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const { CharacterRepository: CharacterRepository2 } = await Promise.resolve().then(() => (init_character_repo(), character_repo_exports));
    const charRepo = new CharacterRepository2(db);
    for (const participant of finalState.participants) {
      const character = charRepo.findById(participant.id);
      if (character) {
        charRepo.update(participant.id, { hp: participant.hp });
        syncResults.push({
          id: participant.id,
          name: participant.name,
          hp: participant.hp,
          synced: true
        });
      } else {
        syncResults.push({
          id: participant.id,
          name: participant.name,
          hp: participant.hp,
          synced: false
        });
      }
    }
  }
  getCombatManager().delete(namespacedId);
  let output = `
\u{1F3C1} COMBAT ENDED
Encounter ID: ${parsed.encounterId}

`;
  const syncedChars = syncResults.filter((r) => r.synced);
  if (syncedChars.length > 0) {
    output += `\u{1F4CA} Character HP Synced:
`;
    for (const char of syncedChars) {
      output += `   \u2022 ${char.name}: ${char.hp} HP
`;
    }
  }
  output += `
All combatants have been removed from the battlefield.`;
  return {
    content: [
      {
        type: "text",
        text: output
      }
    ]
  };
}
async function handleLoadEncounter(args, ctx) {
  const parsed = CombatTools.LOAD_ENCOUNTER.inputSchema.parse(args);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  const state = repo.loadState(parsed.encounterId);
  if (!state) {
    throw new Error(`Encounter ${parsed.encounterId} not found in database.`);
  }
  const engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
  engine.loadState(state);
  getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  const stateJson = buildStateJson(state, parsed.encounterId);
  let output = `\u{1F4E5} ENCOUNTER LOADED
Encounter ID: ${parsed.encounterId}
`;
  output += formatCombatStateText(state);
  output += `

<!-- STATE_JSON
${JSON.stringify(stateJson)}
STATE_JSON -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleRollDeathSave(args, ctx) {
  const parsed = CombatTools.ROLL_DEATH_SAVE.inputSchema.parse(args);
  const engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    throw new Error(`No active encounter with ID ${parsed.encounterId}`);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("Encounter has no active state");
  }
  const participant = state.participants.find((p) => p.id === parsed.characterId);
  if (!participant) {
    throw new Error(`Participant ${parsed.characterId} not found in encounter`);
  }
  if (participant.hp > 0) {
    throw new Error(`${participant.name} is not at 0 HP and cannot make death saving throws`);
  }
  if (participant.isDead) {
    throw new Error(`${participant.name} is already dead`);
  }
  if (participant.isStabilized) {
    return {
      content: [{
        type: "text",
        text: `${participant.name} is already stabilized and does not need to make death saving throws.`
      }]
    };
  }
  const result = engine.rollDeathSave(parsed.characterId);
  if (!result) {
    throw new Error("Failed to roll death save");
  }
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F480} DEATH SAVING THROW
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${participant.name} makes a death saving throw...

`;
  output += `\u{1F3B2} Roll: d20 = ${result.roll}`;
  if (result.isNat20) {
    output += ` \u2B50 NATURAL 20!

`;
    output += `\u2728 ${participant.name} regains 1 HP and is conscious again!
`;
  } else if (result.isNat1) {
    output += ` \u{1F4A5} NATURAL 1! (Counts as 2 failures)

`;
  } else if (result.success) {
    output += ` \u2713 SUCCESS (10+)

`;
  } else {
    output += ` \u2717 FAILURE (9 or less)

`;
  }
  const successMarkers = "\u25CF".repeat(result.successes) + "\u25CB".repeat(3 - result.successes);
  const failureMarkers = "\u25CF".repeat(result.failures) + "\u25CB".repeat(3 - result.failures);
  output += `Successes: [${successMarkers}] ${result.successes}/3
`;
  output += `Failures:  [${failureMarkers}] ${result.failures}/3

`;
  if (result.isStabilized) {
    output += `\u{1F6E1}\uFE0F ${participant.name} is STABILIZED! (Unconscious but no longer dying)
`;
  } else if (result.isDead) {
    output += `\u2620\uFE0F ${participant.name} has DIED!
`;
  }
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, engine.getState());
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleExecuteLairAction(args, ctx) {
  const parsed = CombatTools.EXECUTE_LAIR_ACTION.inputSchema.parse(args);
  const engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    throw new Error(`No active encounter with ID ${parsed.encounterId}`);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("Encounter has no active state");
  }
  if (!engine.isLairActionPending()) {
    throw new Error("Cannot execute lair action: it is not the lair's turn (initiative 20)");
  }
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F3F0} LAIR ACTION (Initiative 20)
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `${parsed.actionDescription}

`;
  const results = [];
  if (parsed.targetIds && parsed.targetIds.length > 0 && parsed.damage) {
    for (const targetId of parsed.targetIds) {
      const target = state.participants.find((p) => p.id === targetId);
      if (!target) {
        output += `\u26A0\uFE0F Target ${targetId} not found in encounter
`;
        continue;
      }
      let damageTaken = parsed.damage;
      let saved = false;
      let saveRoll;
      let saveTotal;
      if (parsed.savingThrow) {
        saveRoll = Math.floor(Math.random() * 20) + 1;
        const abilityScore = target.abilityScores?.[parsed.savingThrow.ability] ?? 10;
        const modifier = Math.floor((abilityScore - 10) / 2);
        saveTotal = saveRoll + modifier;
        saved = saveTotal >= parsed.savingThrow.dc;
        if (saved && parsed.halfDamageOnSave) {
          damageTaken = Math.floor(parsed.damage / 2);
        } else if (saved) {
          damageTaken = 0;
        }
      }
      const damageType = parsed.damageType?.toLowerCase() || "untyped";
      if (target.immunities?.includes(damageType)) {
        damageTaken = 0;
      } else if (target.resistances?.includes(damageType)) {
        damageTaken = Math.floor(damageTaken / 2);
      } else if (target.vulnerabilities?.includes(damageType)) {
        damageTaken = damageTaken * 2;
      }
      if (damageTaken > 0) {
        engine.applyDamage(targetId, damageTaken);
      }
      results.push({
        targetId,
        targetName: target.name,
        saveRoll,
        saveTotal,
        saved,
        damageTaken
      });
      output += `\u{1F3AF} ${target.name}`;
      if (parsed.savingThrow) {
        const saveAbility = parsed.savingThrow.ability.charAt(0).toUpperCase() + parsed.savingThrow.ability.slice(1);
        output += ` - ${saveAbility} Save: ${saveRoll} + ${Math.floor(((target.abilityScores?.[parsed.savingThrow.ability] ?? 10) - 10) / 2)} = ${saveTotal} vs DC ${parsed.savingThrow.dc}`;
        output += saved ? " \u2713 SAVED" : " \u2717 FAILED";
      }
      output += `
`;
      output += `   Damage: ${damageTaken}${parsed.damageType ? ` ${parsed.damageType}` : ""}
`;
      const updatedTarget = engine.getState().participants.find((p) => p.id === targetId);
      if (updatedTarget) {
        output += `   HP: ${updatedTarget.hp}/${updatedTarget.maxHp}`;
        if (updatedTarget.hp <= 0) {
          output += " \u{1F480} DEFEATED";
        }
        output += "\n";
      }
    }
  } else {
    output += `(No mechanical effect - narrative only)
`;
  }
  output += `
\u2192 Call advance_turn to proceed to the next combatant`;
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, engine.getState());
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleRenderMap(args, ctx) {
  const parsed = CombatTools.RENDER_MAP.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  const map = renderGrid(state, {
    width: parsed.width,
    height: parsed.height,
    showLegend: parsed.showLegend
  });
  return {
    content: [{
      type: "text",
      text: map
    }]
  };
}
async function handleCalculateAoe(args, ctx) {
  const parsed = CombatTools.CALCULATE_AOE.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  const result = calculateAoE(state, parsed.shape, parsed.origin, {
    radius: parsed.radius,
    direction: parsed.direction,
    length: parsed.length,
    angle: parsed.angle
  });
  let output = `
\u250C\u2500 AREA OF EFFECT \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 Shape: ${parsed.shape.toUpperCase()}
`;
  output += `\u2502 Origin: (${parsed.origin.x}, ${parsed.origin.y})
`;
  if (parsed.radius)
    output += `\u2502 Radius: ${parsed.radius} tiles
`;
  if (parsed.length)
    output += `\u2502 Length: ${parsed.length} tiles
`;
  if (parsed.angle)
    output += `\u2502 Angle: ${parsed.angle}\xB0
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `\u{1F4CD} Affected Tiles: ${result.tiles.length}
`;
  if (result.affectedParticipants.length > 0) {
    output += `
\u26A0\uFE0F AFFECTED CREATURES:
`;
    for (const p of result.affectedParticipants) {
      output += `  \u2022 ${p.name} at (${p.position.x}, ${p.position.y})
`;
    }
  } else {
    output += `
\u2713 No creatures in area of effect
`;
  }
  output += `
<!-- AOE_JSON
${JSON.stringify(result)}
AOE_JSON -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleUpdateTerrain(args, ctx) {
  const parsed = CombatTools.UPDATE_TERRAIN.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo2 = new EncounterRepository(db2);
    const state2 = repo2.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  if (!state.terrain) {
    state.terrain = { obstacles: [], difficultTerrain: [], water: [] };
  }
  const terrainKey = parsed.terrainType;
  if (!state.terrain[terrainKey]) {
    state.terrain[terrainKey] = [];
  }
  const terrainArray = state.terrain[terrainKey];
  let modified = 0;
  if (parsed.operation === "add") {
    for (const tile of parsed.tiles) {
      if (!terrainArray.includes(tile)) {
        terrainArray.push(tile);
        modified++;
      }
    }
  } else {
    const tileSet = new Set(parsed.tiles);
    const originalLength = terrainArray.length;
    state.terrain[terrainKey] = terrainArray.filter((t) => !tileSet.has(t));
    modified = originalLength - state.terrain[terrainKey].length;
  }
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, state);
  const stateJson = buildStateJson(state, parsed.encounterId);
  let output = `\\n\u26CF\uFE0F TERRAIN UPDATED\\n`;
  output += `\u251C\u2500 Operation: ${parsed.operation.toUpperCase()}\\n`;
  output += `\u251C\u2500 Type: ${parsed.terrainType}\\n`;
  output += `\u251C\u2500 Tiles modified: ${modified}\\n`;
  output += `\u2514\u2500 Total ${parsed.terrainType}: ${state.terrain[terrainKey].length}\\n`;
  output += `\\n\\n<!-- STATE_JSON\\n${JSON.stringify(stateJson)}\\nSTATE_JSON -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handlePlaceProp(args, ctx) {
  const parsed = CombatTools.PLACE_PROP.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo2 = new EncounterRepository(db2);
    const state2 = repo2.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  if (!state.props) {
    state.props = [];
  }
  const propId = `prop-${parsed.label.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`;
  const prop = {
    id: propId,
    position: parsed.position,
    label: parsed.label,
    propType: parsed.propType,
    heightFeet: parsed.heightFeet,
    cover: parsed.cover || "none",
    climbable: parsed.climbable || false,
    climbDC: parsed.climbDC,
    breakable: parsed.breakable || false,
    hp: parsed.hp,
    currentHp: parsed.hp,
    description: parsed.description
  };
  state.props.push(prop);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, state);
  const stateJson = buildStateJson(state, parsed.encounterId);
  const coverIcon = {
    "none": "\u25CB",
    "half": "\u25D0",
    "three_quarter": "\u25D5",
    "full": "\u25CF"
  }[prop.cover || "none"];
  let output = `\\n\u{1F3D7}\uFE0F PROP PLACED\\n`;
  output += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n`;
  output += `\u2502 ${parsed.label}\\n`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n`;
  output += `\u{1F4CD} Position: (${parsed.position})\\n`;
  output += `\u{1F4E6} Type: ${parsed.propType}\\n`;
  if (parsed.heightFeet)
    output += `\u{1F4CF} Height: ${parsed.heightFeet} ft\\n`;
  output += `\u{1F6E1}\uFE0F Cover: ${coverIcon} ${parsed.cover || "none"}\\n`;
  if (parsed.climbable)
    output += `\u{1F9D7} Climbable: DC ${parsed.climbDC || 10}\\n`;
  if (parsed.breakable && parsed.hp)
    output += `\u{1F494} Breakable: ${parsed.hp} HP\\n`;
  if (parsed.description)
    output += `\\n\u{1F4DC} ${parsed.description}\\n`;
  output += `\\n\\n<!-- STATE_JSON\\n${JSON.stringify(stateJson)}\\nSTATE_JSON -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleMeasureDistance(args, ctx) {
  const parsed = CombatTools.MEASURE_DISTANCE.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo = new EncounterRepository(db);
    const state2 = repo.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  const getPosition = (ref) => {
    if (ref.type === "position") {
      const [x, y] = ref.value.split(",").map(Number);
      return { x, y, name: `(${ref.value})` };
    } else {
      const participant = state.participants.find((p) => p.id === ref.value);
      if (!participant) {
        throw new Error(`Entity ${ref.value} not found in encounter`);
      }
      const pos = participant.position || { x: 0, y: 0 };
      return { x: pos.x, y: pos.y, name: participant.name };
    }
  };
  const fromPos = getPosition(parsed.from);
  const toPos = getPosition(parsed.to);
  const dx = Math.abs(toPos.x - fromPos.x);
  const dy = Math.abs(toPos.y - fromPos.y);
  const distanceSquares = Math.max(dx, dy);
  const distanceFeet = distanceSquares * 5;
  const euclideanSquares = Math.sqrt(dx * dx + dy * dy);
  const euclideanFeet = Math.round(euclideanSquares * 5);
  let output = `\\n\u{1F4CF} DISTANCE MEASURED\\n`;
  output += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n`;
  output += `\u2502 ${fromPos.name} \u2192 ${toPos.name}\\n`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n`;
  output += `\u{1F3AF} Distance: ${distanceFeet} ft (${distanceSquares} squares)\\n`;
  output += `   (Using D&D 5e diagonal = 5ft rule)\\n\\n`;
  output += `\u{1F4D0} Euclidean: ~${euclideanFeet} ft\\n`;
  output += `   (\u0394x: ${dx} squares, \u0394y: ${dy} squares)\\n`;
  let rangeCategory = "";
  if (distanceFeet <= 5)
    rangeCategory = "\u2694\uFE0F Melee range";
  else if (distanceFeet <= 30)
    rangeCategory = "\u{1F3C3} Normal movement";
  else if (distanceFeet <= 60)
    rangeCategory = "\u{1F3F9} Short bow range";
  else if (distanceFeet <= 120)
    rangeCategory = "\u{1F3AF} Longbow short range";
  else if (distanceFeet <= 150)
    rangeCategory = "\u{1F52E} Most spell range";
  else
    rangeCategory = "\u{1F30D} Long range";
  output += `\\n${rangeCategory}\\n`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleGenerateTerrainPatch(args, ctx) {
  const parsed = CombatTools.GENERATE_TERRAIN_PATCH.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo2 = new EncounterRepository(db2);
    const state2 = repo2.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  if (!state.terrain) {
    state.terrain = { obstacles: [], difficultTerrain: [], water: [] };
  }
  if (!state.props) {
    state.props = [];
  }
  if (parsed.pattern) {
    const patternGen = getPatternGenerator(parsed.pattern);
    const result = patternGen(parsed.origin.x, parsed.origin.y, parsed.width, parsed.height);
    state.terrain.obstacles.push(...result.obstacles);
    if (!state.terrain.water)
      state.terrain.water = [];
    state.terrain.water.push(...result.water);
    state.terrain.difficultTerrain.push(...result.difficultTerrain);
    for (const prop of result.props) {
      state.props.push({
        id: `prop-${Date.now()}-${Math.random().toString(36).slice(2)}`,
        label: prop.label,
        position: prop.position,
        heightFeet: prop.heightFeet,
        propType: prop.propType,
        cover: prop.cover,
        description: PATTERN_DESCRIPTIONS[parsed.pattern]
      });
    }
    const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo2 = new EncounterRepository(db2);
    repo2.saveState(parsed.encounterId, state);
    const stateJson2 = buildStateJson(state, parsed.encounterId);
    const output2 = `\u{1F3D4}\uFE0F TERRAIN PATTERN GENERATED: ${parsed.pattern.toUpperCase()}
\u{1F4D0} Area: (${parsed.origin.x},${parsed.origin.y}) to (${parsed.origin.x + parsed.width},${parsed.origin.y + parsed.height})
\u{1F9F1} Obstacles: ${result.obstacles.length}
\u{1F4A7} Water: ${result.water.length}
\u{1F33F} Difficult terrain: ${result.difficultTerrain.length}
\u{1F3D7}\uFE0F Props: ${result.props.length}

<!-- STATE_JSON
${JSON.stringify(stateJson2)}
STATE_JSON -->`;
    return {
      content: [{ type: "text", text: output2 }]
    };
  }
  const seedStr = parsed.seed || `${parsed.biome}-${Date.now()}`;
  let seedNum = 0;
  for (let i = 0; i < seedStr.length; i++) {
    seedNum = (seedNum << 5) - seedNum + seedStr.charCodeAt(i);
    seedNum = seedNum & seedNum;
  }
  const random = () => {
    seedNum = seedNum * 1103515245 + 12345 & 2147483647;
    return seedNum / 2147483647;
  };
  const centerX = parsed.origin.x + Math.floor(parsed.width / 2);
  const centerY = parsed.origin.y + Math.floor(parsed.height / 2);
  const clearRadius = Math.min(parsed.width, parsed.height) / 4;
  const isClear = (x, y) => {
    if (!parsed.clearCenter)
      return false;
    const dx = x - centerX;
    const dy = y - centerY;
    return Math.sqrt(dx * dx + dy * dy) < clearRadius;
  };
  const biomeConfigs = {
    forest: {
      obstacles: { chance: 0.05, pattern: "scatter" },
      difficult: { chance: 0.2, pattern: "scatter" },
      water: { chance: 0.02, pattern: "pools" },
      props: [
        { label: "Oak Tree", propType: "climbable", chance: 0.15, heightFeet: 25, cover: "half", climbable: true },
        { label: "Pine Tree", propType: "climbable", chance: 0.1, heightFeet: 30, cover: "half", climbable: true },
        { label: "Fallen Log", propType: "cover", chance: 0.03, heightFeet: 3, cover: "half" },
        { label: "Boulder", propType: "cover", chance: 0.02, heightFeet: 5, cover: "three_quarter" }
      ]
    },
    cave: {
      obstacles: { chance: 0.2, pattern: "edge" },
      difficult: { chance: 0.15, pattern: "scatter" },
      water: { chance: 0.1, pattern: "pools" },
      props: [
        { label: "Stalactite", propType: "hazard", chance: 0.05, heightFeet: 15 },
        { label: "Rock Pillar", propType: "structure", chance: 0.04, heightFeet: 20, cover: "full" },
        { label: "Glowing Mushroom", propType: "decoration", chance: 0.08, heightFeet: 2 }
      ]
    },
    village: {
      obstacles: { chance: 0.25, pattern: "cluster" },
      difficult: { chance: 0.05, pattern: "scatter" },
      water: { chance: 0.01, pattern: "pools" },
      props: [
        { label: "Market Stall", propType: "cover", chance: 0.04, heightFeet: 8, cover: "half" },
        { label: "Wagon", propType: "cover", chance: 0.02, heightFeet: 6, cover: "three_quarter" },
        { label: "Barrel", propType: "cover", chance: 0.06, heightFeet: 4, cover: "half" },
        { label: "Well", propType: "structure", chance: 0.01, heightFeet: 4, cover: "half" }
      ]
    },
    dungeon: {
      obstacles: { chance: 0.15, pattern: "edge" },
      difficult: { chance: 0.1, pattern: "scatter" },
      water: { chance: 0.02, pattern: "pools" },
      props: [
        { label: "Stone Pillar", propType: "structure", chance: 0.03, heightFeet: 15, cover: "half" },
        { label: "Rubble Pile", propType: "cover", chance: 0.05, heightFeet: 3, cover: "half" },
        { label: "Brazier", propType: "interactive", chance: 0.02, heightFeet: 5 },
        { label: "Spike Trap", propType: "hazard", chance: 0.02, heightFeet: 0 }
      ]
    },
    swamp: {
      obstacles: { chance: 0.1, pattern: "scatter" },
      difficult: { chance: 0.4, pattern: "cluster" },
      water: { chance: 0.35, pattern: "pools" },
      props: [
        { label: "Dead Tree", propType: "structure", chance: 0.08, heightFeet: 15, cover: "half" },
        { label: "Lily Pad", propType: "decoration", chance: 0.1, heightFeet: 0 },
        { label: "Hollow Log", propType: "cover", chance: 0.02, heightFeet: 4, cover: "three_quarter" }
      ]
    },
    battlefield: {
      obstacles: { chance: 0.1, pattern: "scatter" },
      difficult: { chance: 0.25, pattern: "scatter" },
      water: { chance: 0, pattern: "none" },
      props: [
        { label: "Barricade", propType: "cover", chance: 0.08, heightFeet: 4, cover: "three_quarter" },
        { label: "Overturned Cart", propType: "cover", chance: 0.03, heightFeet: 5, cover: "three_quarter" },
        { label: "Broken Siege Engine", propType: "cover", chance: 0.01, heightFeet: 10, cover: "full" },
        { label: "Debris Pile", propType: "cover", chance: 0.05, heightFeet: 3, cover: "half" }
      ]
    }
  };
  const config2 = biomeConfigs[parsed.biome];
  let obstaclesAdded = 0;
  let difficultAdded = 0;
  let waterAdded = 0;
  let propsAdded = 0;
  for (let y = parsed.origin.y; y < parsed.origin.y + parsed.height; y++) {
    for (let x = parsed.origin.x; x < parsed.origin.x + parsed.width; x++) {
      if (isClear(x, y))
        continue;
      const adjustedDensity = parsed.density || 0.5;
      const tileKey = `${x},${y}`;
      const edgeDist = Math.min(x - parsed.origin.x, parsed.origin.x + parsed.width - 1 - x, y - parsed.origin.y, parsed.origin.y + parsed.height - 1 - y);
      const isEdge = edgeDist < 2;
      let obstacleChance = config2.obstacles.chance * adjustedDensity;
      if (config2.obstacles.pattern === "edge" && isEdge)
        obstacleChance *= 3;
      if (random() < obstacleChance) {
        state.terrain.obstacles.push(tileKey);
        obstaclesAdded++;
        continue;
      }
      if (config2.water.pattern !== "none" && random() < config2.water.chance * adjustedDensity) {
        if (!state.terrain.water)
          state.terrain.water = [];
        state.terrain.water.push(tileKey);
        waterAdded++;
        continue;
      }
      if (random() < config2.difficult.chance * adjustedDensity) {
        if (!state.terrain.difficultTerrain)
          state.terrain.difficultTerrain = [];
        state.terrain.difficultTerrain.push(tileKey);
        difficultAdded++;
      }
      for (const propDef of config2.props) {
        if (random() < propDef.chance * adjustedDensity) {
          const propId = `prop-${parsed.biome}-${propsAdded}-${Date.now()}`;
          state.props.push({
            id: propId,
            position: tileKey,
            label: propDef.label,
            propType: propDef.propType,
            heightFeet: propDef.heightFeet,
            cover: propDef.cover || "none",
            climbable: propDef.climbable,
            climbDC: propDef.climbable ? 10 : void 0
          });
          propsAdded++;
          break;
        }
      }
    }
  }
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, state);
  const stateJson = buildStateJson(state, parsed.encounterId);
  let output = `\\n\u{1F30D} TERRAIN PATCH GENERATED\\n`;
  output += `\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\\n`;
  output += `\u2502 Biome: ${parsed.biome.toUpperCase()}\\n`;
  output += `\u2502 Area: ${parsed.width}\xD7${parsed.height} (${parsed.origin.x},${parsed.origin.y})\\n`;
  output += `\u2502 Density: ${(parsed.density || 0.5) * 100}%\\n`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\\n\\n`;
  output += `\u{1F4CA} Generated:\\n`;
  output += `   \u{1F9F1} Obstacles: ${obstaclesAdded}\\n`;
  output += `   \u{1F33F} Difficult terrain: ${difficultAdded}\\n`;
  output += `   \u{1F4A7} Water: ${waterAdded}\\n`;
  output += `   \u{1F3D7}\uFE0F Props: ${propsAdded}\\n`;
  if (parsed.clearCenter) {
    output += `\\n\u2728 Center area kept clear for party placement\\n`;
  }
  output += `\\n\\n<!-- STATE_JSON\\n${JSON.stringify(stateJson)}\\nSTATE_JSON -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleGenerateTerrainPattern(args, ctx) {
  const parsed = CombatTools.GENERATE_TERRAIN_PATTERN.inputSchema.parse(args);
  let engine = getCombatManager().get(`${ctx.sessionId}:${parsed.encounterId}`);
  if (!engine) {
    const db2 = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    const repo2 = new EncounterRepository(db2);
    const state2 = repo2.loadState(parsed.encounterId);
    if (!state2) {
      throw new Error(`Encounter ${parsed.encounterId} not found.`);
    }
    engine = new CombatEngine(parsed.encounterId, pubsub2 || void 0);
    engine.loadState(state2);
    getCombatManager().create(`${ctx.sessionId}:${parsed.encounterId}`, engine);
  }
  const state = engine.getState();
  if (!state) {
    throw new Error("No active encounter");
  }
  if (!state.terrain) {
    state.terrain = { obstacles: [], difficultTerrain: [], water: [] };
  }
  if (!state.props) {
    state.props = [];
  }
  const patternGen = getPatternGenerator(parsed.pattern);
  const result = patternGen(parsed.origin.x, parsed.origin.y, parsed.width, parsed.height);
  state.terrain.obstacles.push(...result.obstacles);
  if (!state.terrain.water)
    state.terrain.water = [];
  state.terrain.water.push(...result.water);
  if (!state.terrain.difficultTerrain)
    state.terrain.difficultTerrain = [];
  state.terrain.difficultTerrain.push(...result.difficultTerrain);
  for (const prop of result.props) {
    state.props.push({
      id: `prop-${Date.now()}-${Math.random().toString(36).slice(2)}`,
      label: prop.label,
      position: prop.position,
      heightFeet: prop.heightFeet,
      propType: prop.propType,
      cover: prop.cover,
      description: PATTERN_DESCRIPTIONS[parsed.pattern]
    });
  }
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const repo = new EncounterRepository(db);
  repo.saveState(parsed.encounterId, state);
  const stateJson = buildStateJson(state, parsed.encounterId);
  const output = `\u{1F3D4}\uFE0F TERRAIN PATTERN GENERATED: ${parsed.pattern.toUpperCase()}
\u{1F4D0} Area: (${parsed.origin.x},${parsed.origin.y}) to (${parsed.origin.x + parsed.width},${parsed.origin.y + parsed.height})
\u{1F9F1} Obstacles: ${result.obstacles.length}
\u{1F4A7} Water: ${result.water.length}
\u{1F33F} Difficult terrain: ${result.difficultTerrain.length}
\u{1F3D7}\uFE0F Props: ${result.props.length}

` + PATTERN_DESCRIPTIONS[parsed.pattern] + `

<!-- STATE_JSON
${JSON.stringify(stateJson)}
STATE_JSON -->`;
  return {
    content: [{ type: "text", text: output }]
  };
}

// dist/server/crud-tools.js
var import_crypto3 = require("crypto");
init_character_repo();
init_party();
init_spell();
init_zod();

// dist/services/starting-equipment.service.js
var import_crypto2 = require("crypto");

// dist/schema/inventory.js
init_zod();
var INVENTORY_LIMITS = {
  MAX_ITEM_VALUE: 1e7,
  // 10 million gold max per item
  MAX_STACK_SIZE: 9999,
  // Max items in a single stack
  MAX_GIVE_QUANTITY: 9999,
  // Max items that can be given at once
  DEFAULT_WEIGHT_CAPACITY: 100
  // Default carry weight (based on STR in future)
};
var ItemSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string().min(1, "Item name cannot be empty").refine((s) => s.trim().length > 0, "Item name cannot be whitespace only"),
  description: external_exports.string().optional(),
  type: external_exports.enum(["weapon", "armor", "consumable", "quest", "misc", "scroll"]),
  weight: external_exports.number().min(0).default(0),
  value: external_exports.number().min(0).max(INVENTORY_LIMITS.MAX_ITEM_VALUE, `Item value cannot exceed ${INVENTORY_LIMITS.MAX_ITEM_VALUE.toLocaleString()} gold`).default(0),
  properties: external_exports.record(external_exports.any()).optional(),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var InventoryItemSchema = external_exports.object({
  itemId: external_exports.string(),
  quantity: external_exports.number().int().min(1),
  equipped: external_exports.boolean().default(false),
  slot: external_exports.string().optional()
  // 'mainhand', 'offhand', 'armor', etc.
});
var InventorySchema = external_exports.object({
  characterId: external_exports.string(),
  items: external_exports.array(InventoryItemSchema),
  capacity: external_exports.number().default(100),
  // Weight limit
  currency: external_exports.object({
    gold: external_exports.number().int().min(0).default(0),
    silver: external_exports.number().int().min(0).default(0),
    copper: external_exports.number().int().min(0).default(0)
  }).default({})
});

// dist/storage/repos/item.repo.js
var ItemRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(item) {
    const validItem = ItemSchema.parse(item);
    const stmt = this.db.prepare(`
            INSERT INTO items (id, name, description, type, weight, value, properties, created_at, updated_at)
            VALUES (@id, @name, @description, @type, @weight, @value, @properties, @createdAt, @updatedAt)
        `);
    stmt.run({
      id: validItem.id,
      name: validItem.name,
      description: validItem.description || null,
      type: validItem.type,
      weight: validItem.weight,
      value: validItem.value,
      properties: JSON.stringify(validItem.properties || {}),
      createdAt: validItem.createdAt,
      updatedAt: validItem.updatedAt
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM items WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToItem(row);
  }
  findAll() {
    const stmt = this.db.prepare("SELECT * FROM items");
    const rows = stmt.all();
    return rows.map((row) => this.rowToItem(row));
  }
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM items WHERE id = ?");
    stmt.run(id);
  }
  update(id, updates) {
    const existing = this.findById(id);
    if (!existing)
      return null;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const updated = {
      ...existing,
      ...updates,
      updatedAt: now
    };
    const stmt = this.db.prepare(`
            UPDATE items SET
                name = @name,
                description = @description,
                type = @type,
                weight = @weight,
                value = @value,
                properties = @properties,
                updated_at = @updatedAt
            WHERE id = @id
        `);
    stmt.run({
      id: updated.id,
      name: updated.name,
      description: updated.description || null,
      type: updated.type,
      weight: updated.weight,
      value: updated.value,
      properties: JSON.stringify(updated.properties || {}),
      updatedAt: updated.updatedAt
    });
    return this.findById(id);
  }
  findByName(name) {
    const stmt = this.db.prepare("SELECT * FROM items WHERE LOWER(name) LIKE LOWER(?)");
    const rows = stmt.all(`%${name}%`);
    return rows.map((row) => this.rowToItem(row));
  }
  findByType(type) {
    const stmt = this.db.prepare("SELECT * FROM items WHERE type = ?");
    const rows = stmt.all(type);
    return rows.map((row) => this.rowToItem(row));
  }
  search(query) {
    let sql = "SELECT * FROM items WHERE 1=1";
    const params = [];
    if (query.name) {
      sql += " AND LOWER(name) LIKE LOWER(?)";
      params.push(`%${query.name}%`);
    }
    if (query.type) {
      sql += " AND type = ?";
      params.push(query.type);
    }
    if (query.minValue !== void 0) {
      sql += " AND value >= ?";
      params.push(query.minValue);
    }
    if (query.maxValue !== void 0) {
      sql += " AND value <= ?";
      params.push(query.maxValue);
    }
    const stmt = this.db.prepare(sql);
    const rows = stmt.all(...params);
    return rows.map((row) => this.rowToItem(row));
  }
  rowToItem(row) {
    return ItemSchema.parse({
      id: row.id,
      name: row.name,
      description: row.description || void 0,
      type: row.type,
      weight: row.weight,
      value: row.value,
      properties: row.properties ? JSON.parse(row.properties) : void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// dist/storage/repos/inventory.repo.js
var InventoryRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  getInventory(characterId) {
    const stmt = this.db.prepare(`
            SELECT i.*, ii.quantity, ii.equipped, ii.slot
            FROM inventory_items ii
            JOIN items i ON ii.item_id = i.id
            WHERE ii.character_id = ?
        `);
    const rows = stmt.all(characterId);
    const items = rows.map((row) => ({
      itemId: row.id,
      quantity: row.quantity,
      equipped: Boolean(row.equipped),
      slot: row.slot || void 0
    }));
    const currency = this.getCurrency(characterId);
    return InventorySchema.parse({
      characterId,
      items,
      capacity: 100,
      // Default
      currency
    });
  }
  addItem(characterId, itemId, quantity = 1) {
    const stmt = this.db.prepare(`
            INSERT INTO inventory_items (character_id, item_id, quantity)
            VALUES (?, ?, ?)
            ON CONFLICT(character_id, item_id) DO UPDATE SET
            quantity = quantity + excluded.quantity
        `);
    stmt.run(characterId, itemId, quantity);
  }
  removeItem(characterId, itemId, quantity = 1) {
    const getStmt = this.db.prepare("SELECT quantity FROM inventory_items WHERE character_id = ? AND item_id = ?");
    const row = getStmt.get(characterId, itemId);
    if (!row || row.quantity < quantity)
      return false;
    if (row.quantity === quantity) {
      const delStmt = this.db.prepare("DELETE FROM inventory_items WHERE character_id = ? AND item_id = ?");
      delStmt.run(characterId, itemId);
    } else {
      const updateStmt = this.db.prepare("UPDATE inventory_items SET quantity = quantity - ? WHERE character_id = ? AND item_id = ?");
      updateStmt.run(quantity, characterId, itemId);
    }
    return true;
  }
  equipItem(characterId, itemId, slot) {
    const unequipStmt = this.db.prepare("UPDATE inventory_items SET equipped = 0, slot = NULL WHERE character_id = ? AND slot = ?");
    unequipStmt.run(characterId, slot);
    const equipStmt = this.db.prepare("UPDATE inventory_items SET equipped = 1, slot = ? WHERE character_id = ? AND item_id = ?");
    equipStmt.run(slot, characterId, itemId);
  }
  unequipItem(characterId, itemId) {
    const stmt = this.db.prepare("UPDATE inventory_items SET equipped = 0, slot = NULL WHERE character_id = ? AND item_id = ?");
    stmt.run(characterId, itemId);
  }
  /**
   * Find all characters who own a specific item (for world-unique enforcement)
   */
  findItemOwners(itemId) {
    const stmt = this.db.prepare("SELECT character_id FROM inventory_items WHERE item_id = ?");
    const rows = stmt.all(itemId);
    return rows.map((r) => r.character_id);
  }
  transferItem(fromCharacterId, toCharacterId, itemId, quantity = 1) {
    const getStmt = this.db.prepare("SELECT quantity, equipped FROM inventory_items WHERE character_id = ? AND item_id = ?");
    const row = getStmt.get(fromCharacterId, itemId);
    if (!row || row.quantity < quantity)
      return false;
    if (row.equipped)
      return false;
    const transfer = this.db.transaction(() => {
      if (row.quantity === quantity) {
        const delStmt = this.db.prepare("DELETE FROM inventory_items WHERE character_id = ? AND item_id = ?");
        delStmt.run(fromCharacterId, itemId);
      } else {
        const updateStmt = this.db.prepare("UPDATE inventory_items SET quantity = quantity - ? WHERE character_id = ? AND item_id = ?");
        updateStmt.run(quantity, fromCharacterId, itemId);
      }
      const addStmt = this.db.prepare(`
                INSERT INTO inventory_items (character_id, item_id, quantity)
                VALUES (?, ?, ?)
                ON CONFLICT(character_id, item_id) DO UPDATE SET
                quantity = quantity + excluded.quantity
            `);
      addStmt.run(toCharacterId, itemId, quantity);
    });
    transfer();
    return true;
  }
  getInventoryWithDetails(characterId) {
    const stmt = this.db.prepare(`
            SELECT i.*, ii.quantity, ii.equipped, ii.slot
            FROM inventory_items ii
            JOIN items i ON ii.item_id = i.id
            WHERE ii.character_id = ?
            ORDER BY ii.equipped DESC, i.type, i.name
        `);
    const rows = stmt.all(characterId);
    const items = rows.map((row) => ({
      item: {
        id: row.id,
        name: row.name,
        description: row.description || void 0,
        type: row.type,
        weight: row.weight,
        value: row.value,
        properties: row.properties ? JSON.parse(row.properties) : void 0
      },
      quantity: row.quantity,
      equipped: Boolean(row.equipped),
      slot: row.slot || void 0
    }));
    const totalWeight = items.reduce((sum, i) => sum + i.item.weight * i.quantity, 0);
    const currency = this.getCurrency(characterId);
    return {
      characterId,
      items,
      totalWeight,
      capacity: 100,
      currency
    };
  }
  // ============================================================
  // CURRENCY OPERATIONS
  // ============================================================
  /**
   * Get currency for a character
   */
  getCurrency(characterId) {
    const stmt = this.db.prepare("SELECT currency FROM characters WHERE id = ?");
    const row = stmt.get(characterId);
    if (!row || !row.currency) {
      return { gold: 0, silver: 0, copper: 0 };
    }
    try {
      const parsed = JSON.parse(row.currency);
      return {
        gold: parsed.gold ?? 0,
        silver: parsed.silver ?? 0,
        copper: parsed.copper ?? 0
      };
    } catch {
      return { gold: 0, silver: 0, copper: 0 };
    }
  }
  /**
   * Set currency for a character (replaces existing)
   */
  setCurrency(characterId, currency) {
    const current = this.getCurrency(characterId);
    const updated = {
      gold: currency.gold ?? current.gold,
      silver: currency.silver ?? current.silver,
      copper: currency.copper ?? current.copper
    };
    const stmt = this.db.prepare("UPDATE characters SET currency = ? WHERE id = ?");
    stmt.run(JSON.stringify(updated), characterId);
  }
  /**
   * Add currency to a character
   */
  addCurrency(characterId, currency) {
    const current = this.getCurrency(characterId);
    const updated = {
      gold: current.gold + (currency.gold ?? 0),
      silver: current.silver + (currency.silver ?? 0),
      copper: current.copper + (currency.copper ?? 0)
    };
    const stmt = this.db.prepare("UPDATE characters SET currency = ? WHERE id = ?");
    stmt.run(JSON.stringify(updated), characterId);
    return updated;
  }
  /**
   * Remove currency from a character
   * @returns true if successful, false if insufficient funds
   */
  removeCurrency(characterId, currency) {
    const current = this.getCurrency(characterId);
    const currentTotal = current.gold * 100 + current.silver * 10 + current.copper;
    const removeTotal = (currency.gold ?? 0) * 100 + (currency.silver ?? 0) * 10 + (currency.copper ?? 0);
    if (removeTotal > currentTotal) {
      return false;
    }
    const updated = {
      gold: current.gold - (currency.gold ?? 0),
      silver: current.silver - (currency.silver ?? 0),
      copper: current.copper - (currency.copper ?? 0)
    };
    if (updated.copper < 0) {
      const needed = Math.ceil(-updated.copper / 10);
      updated.silver -= needed;
      updated.copper += needed * 10;
    }
    if (updated.silver < 0) {
      const needed = Math.ceil(-updated.silver / 10);
      updated.gold -= needed;
      updated.silver += needed * 10;
    }
    if (updated.gold < 0) {
      return false;
    }
    const stmt = this.db.prepare("UPDATE characters SET currency = ? WHERE id = ?");
    stmt.run(JSON.stringify(updated), characterId);
    return true;
  }
  /**
   * Transfer currency between characters
   * @returns true if successful, false if insufficient funds
   */
  transferCurrency(fromCharacterId, toCharacterId, currency) {
    const transfer = this.db.transaction(() => {
      if (!this.removeCurrency(fromCharacterId, currency)) {
        return false;
      }
      this.addCurrency(toCharacterId, currency);
      return true;
    });
    return transfer();
  }
  /**
   * Check if character has at least this much currency
   */
  hasCurrency(characterId, currency) {
    const current = this.getCurrency(characterId);
    const currentTotal = current.gold * 100 + current.silver * 10 + current.copper;
    const requiredTotal = (currency.gold ?? 0) * 100 + (currency.silver ?? 0) * 10 + (currency.copper ?? 0);
    return currentTotal >= requiredTotal;
  }
};

// dist/data/class-starting-data.js
var EXPLORERS_PACK = [
  "Backpack",
  "Bedroll",
  "Mess Kit",
  "Tinderbox",
  "Torches x10",
  "Rations x10",
  "Waterskin",
  "Hempen Rope (50 feet)"
];
var DUNGEONEERS_PACK = [
  "Backpack",
  "Crowbar",
  "Hammer",
  "Pitons x10",
  "Torches x10",
  "Tinderbox",
  "Rations x10",
  "Waterskin",
  "Hempen Rope (50 feet)"
];
var PRIESTS_PACK = [
  "Backpack",
  "Blanket",
  "Candles x10",
  "Tinderbox",
  "Alms Box",
  "Incense x2",
  "Censer",
  "Vestments",
  "Rations x2",
  "Waterskin"
];
var SCHOLARS_PACK = [
  "Backpack",
  "Book of Lore",
  "Ink",
  "Ink Pen",
  "Parchment x10",
  "Little Bag of Sand",
  "Small Knife"
];
var BURGLAR_PACK = [
  "Backpack",
  "Ball Bearings x1000",
  "String (10 feet)",
  "Bell",
  "Candles x5",
  "Crowbar",
  "Hammer",
  "Pitons x10",
  "Hooded Lantern",
  "Oil x2",
  "Rations x5",
  "Tinderbox",
  "Waterskin",
  "Hempen Rope (50 feet)"
];
var EquipmentPacks = {
  explorersPack: EXPLORERS_PACK,
  dungeoneersPack: DUNGEONEERS_PACK,
  priestsPack: PRIESTS_PACK,
  scholarsPack: SCHOLARS_PACK,
  burglarsPack: BURGLAR_PACK,
  diplomatsPack: ["Backpack", "Fine Clothes", "Perfume", "Sealing Wax", "Paper x5"],
  entertainersPack: ["Backpack", "Bedroll", "Costume x2", "Candles x5", "Rations x5", "Waterskin", "Disguise Kit"]
};
var FULL_CASTER_SLOTS2 = {
  1: [2, 0, 0, 0, 0, 0, 0, 0, 0],
  2: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  3: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  4: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  5: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  6: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  7: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  8: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  9: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  10: [4, 3, 3, 3, 2, 0, 0, 0, 0],
  11: [4, 3, 3, 3, 2, 1, 0, 0, 0],
  12: [4, 3, 3, 3, 2, 1, 0, 0, 0],
  13: [4, 3, 3, 3, 2, 1, 1, 0, 0],
  14: [4, 3, 3, 3, 2, 1, 1, 0, 0],
  15: [4, 3, 3, 3, 2, 1, 1, 1, 0],
  16: [4, 3, 3, 3, 2, 1, 1, 1, 0],
  17: [4, 3, 3, 3, 2, 1, 1, 1, 1],
  18: [4, 3, 3, 3, 3, 1, 1, 1, 1],
  19: [4, 3, 3, 3, 3, 2, 1, 1, 1],
  20: [4, 3, 3, 3, 3, 2, 2, 1, 1]
};
var HALF_CASTER_SLOTS2 = {
  1: [0, 0, 0, 0, 0, 0, 0, 0, 0],
  2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
  3: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  4: [3, 0, 0, 0, 0, 0, 0, 0, 0],
  5: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  6: [4, 2, 0, 0, 0, 0, 0, 0, 0],
  7: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  8: [4, 3, 0, 0, 0, 0, 0, 0, 0],
  9: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  10: [4, 3, 2, 0, 0, 0, 0, 0, 0],
  11: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  12: [4, 3, 3, 0, 0, 0, 0, 0, 0],
  13: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  14: [4, 3, 3, 1, 0, 0, 0, 0, 0],
  15: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  16: [4, 3, 3, 2, 0, 0, 0, 0, 0],
  17: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  18: [4, 3, 3, 3, 1, 0, 0, 0, 0],
  19: [4, 3, 3, 3, 2, 0, 0, 0, 0],
  20: [4, 3, 3, 3, 2, 0, 0, 0, 0]
};
var CLASS_DATA = {
  // 
  // BARBARIAN
  // 
  barbarian: {
    hitDice: "d12",
    startingHP: (conMod) => 12 + conMod,
    savingThrows: ["strength", "constitution"],
    armorProficiencies: ["light", "medium", "shields"],
    weaponProficiencies: ["simple", "martial"],
    startingEquipment: [
      { choose: { count: 1, from: [["Greataxe"], ["Martial Melee Weapon"]] } },
      { choose: { count: 1, from: [["Handaxe", "Handaxe"], ["Simple Weapon"]] } },
      { fixed: [...EXPLORERS_PACK, "Javelin", "Javelin", "Javelin", "Javelin"] }
    ]
  },
  // 
  // BARD
  // 
  bard: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["dexterity", "charisma"],
    armorProficiencies: ["light"],
    weaponProficiencies: ["simple", "hand crossbows", "longswords", "rapiers", "shortswords"],
    startingEquipment: [
      { choose: { count: 1, from: [["Rapier"], ["Longsword"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [[...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Leather Armor", "Dagger", "Lute"] }
    ],
    spellcasting: {
      ability: "cha",
      cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
      spellsKnown: [4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 15, 16, 18, 19, 19, 20, 22, 22, 22],
      slotsByLevel: FULL_CASTER_SLOTS2,
      startingCantrips: ["Vicious Mockery", "Light"],
      startingSpells: ["Healing Word", "Dissonant Whispers", "Faerie Fire", "Thunderwave"]
    }
  },
  // 
  // CLERIC
  // 
  cleric: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["wisdom", "charisma"],
    armorProficiencies: ["light", "medium", "shields"],
    weaponProficiencies: ["simple"],
    startingEquipment: [
      { choose: { count: 1, from: [["Mace"], ["Warhammer"]] } },
      { choose: { count: 1, from: [["Scale Mail"], ["Leather Armor"], ["Chain Mail"]] } },
      { choose: { count: 1, from: [["Light Crossbow", "Crossbow Bolts x20"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [[...PRIESTS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Shield", "Holy Symbol"] }
    ],
    spellcasting: {
      ability: "wis",
      cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
      spellsPrepared: true,
      // WIS mod + cleric level
      slotsByLevel: FULL_CASTER_SLOTS2,
      startingCantrips: ["Sacred Flame", "Guidance", "Spare the Dying"],
      startingSpells: ["Cure Wounds", "Bless", "Shield of Faith", "Guiding Bolt"]
    }
  },
  // 
  // DRUID
  // 
  druid: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["intelligence", "wisdom"],
    armorProficiencies: ["light", "medium", "shields"],
    weaponProficiencies: ["clubs", "daggers", "darts", "javelins", "maces", "quarterstaffs", "scimitars", "sickles", "slings", "spears"],
    startingEquipment: [
      { choose: { count: 1, from: [["Shield"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [["Scimitar"], ["Simple Melee Weapon"]] } },
      { fixed: ["Leather Armor", ...EXPLORERS_PACK, "Druidic Focus"] }
    ],
    spellcasting: {
      ability: "wis",
      cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
      spellsPrepared: true,
      slotsByLevel: FULL_CASTER_SLOTS2,
      startingCantrips: ["Produce Flame", "Druidcraft"],
      startingSpells: ["Entangle", "Healing Word", "Faerie Fire", "Thunderwave"]
    }
  },
  // 
  // FIGHTER
  // 
  fighter: {
    hitDice: "d10",
    startingHP: (conMod) => 10 + conMod,
    savingThrows: ["strength", "constitution"],
    armorProficiencies: ["light", "medium", "heavy", "shields"],
    weaponProficiencies: ["simple", "martial"],
    startingEquipment: [
      { choose: { count: 1, from: [["Chain Mail"], ["Leather Armor", "Longbow", "Arrows x20"]] } },
      { choose: { count: 1, from: [["Martial Weapon", "Shield"], ["Martial Weapon", "Martial Weapon"]] } },
      { choose: { count: 1, from: [["Light Crossbow", "Crossbow Bolts x20"], ["Handaxe", "Handaxe"]] } },
      { choose: { count: 1, from: [[...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } }
    ]
  },
  // 
  // MONK
  // 
  monk: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["strength", "dexterity"],
    armorProficiencies: [],
    weaponProficiencies: ["simple", "shortswords"],
    startingEquipment: [
      { choose: { count: 1, from: [["Shortsword"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [[...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Dart", "Dart", "Dart", "Dart", "Dart", "Dart", "Dart", "Dart", "Dart", "Dart"] }
    ]
  },
  // 
  // PALADIN
  // 
  paladin: {
    hitDice: "d10",
    startingHP: (conMod) => 10 + conMod,
    savingThrows: ["wisdom", "charisma"],
    armorProficiencies: ["light", "medium", "heavy", "shields"],
    weaponProficiencies: ["simple", "martial"],
    startingEquipment: [
      { choose: { count: 1, from: [["Martial Weapon", "Shield"], ["Martial Weapon", "Martial Weapon"]] } },
      { choose: { count: 1, from: [["Javelin", "Javelin", "Javelin", "Javelin", "Javelin"], ["Simple Melee Weapon"]] } },
      { choose: { count: 1, from: [[...PRIESTS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Chain Mail", "Holy Symbol"] }
    ],
    spellcasting: {
      ability: "cha",
      cantripsKnown: [],
      // Paladins don't get cantrips
      spellsPrepared: true,
      slotsByLevel: HALF_CASTER_SLOTS2,
      startingCantrips: [],
      startingSpells: ["Divine Smite", "Cure Wounds", "Shield of Faith", "Thunderous Smite"]
    }
  },
  // 
  // RANGER
  // 
  ranger: {
    hitDice: "d10",
    startingHP: (conMod) => 10 + conMod,
    savingThrows: ["strength", "dexterity"],
    armorProficiencies: ["light", "medium", "shields"],
    weaponProficiencies: ["simple", "martial"],
    startingEquipment: [
      { choose: { count: 1, from: [["Scale Mail"], ["Leather Armor"]] } },
      { choose: { count: 1, from: [["Shortsword", "Shortsword"], ["Simple Melee Weapon", "Simple Melee Weapon"]] } },
      { choose: { count: 1, from: [[...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Longbow", "Arrows x20", "Quiver"] }
    ],
    spellcasting: {
      ability: "wis",
      cantripsKnown: [],
      // Rangers don't get cantrips (without Druidic Warrior)
      spellsKnown: [0, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11],
      slotsByLevel: HALF_CASTER_SLOTS2,
      startingCantrips: [],
      startingSpells: ["Hunter's Mark", "Cure Wounds"]
    }
  },
  // 
  // ROGUE
  // 
  rogue: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["dexterity", "intelligence"],
    armorProficiencies: ["light"],
    weaponProficiencies: ["simple", "hand crossbows", "longswords", "rapiers", "shortswords"],
    startingEquipment: [
      { choose: { count: 1, from: [["Rapier"], ["Shortsword"]] } },
      { choose: { count: 1, from: [["Shortbow", "Quiver", "Arrows x20"], ["Shortsword"]] } },
      { choose: { count: 1, from: [[...BURGLAR_PACK], [...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Leather Armor", "Dagger", "Dagger", "Thieves' Tools"] }
    ]
  },
  // 
  // SORCERER
  // 
  sorcerer: {
    hitDice: "d6",
    startingHP: (conMod) => 6 + conMod,
    savingThrows: ["constitution", "charisma"],
    armorProficiencies: [],
    weaponProficiencies: ["daggers", "darts", "slings", "quarterstaffs", "light crossbows"],
    startingEquipment: [
      { choose: { count: 1, from: [["Light Crossbow", "Crossbow Bolts x20"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [["Component Pouch"], ["Arcane Focus"]] } },
      { choose: { count: 1, from: [[...DUNGEONEERS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Dagger", "Dagger"] }
    ],
    spellcasting: {
      ability: "cha",
      cantripsKnown: [4, 4, 4, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6],
      spellsKnown: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 12, 13, 13, 14, 14, 15, 15, 15, 15],
      slotsByLevel: FULL_CASTER_SLOTS2,
      startingCantrips: ["Fire Bolt", "Ray of Frost", "Prestidigitation", "Light"],
      startingSpells: ["Magic Missile", "Shield"]
    }
  },
  // 
  // WARLOCK
  // 
  warlock: {
    hitDice: "d8",
    startingHP: (conMod) => 8 + conMod,
    savingThrows: ["wisdom", "charisma"],
    armorProficiencies: ["light"],
    weaponProficiencies: ["simple"],
    startingEquipment: [
      { choose: { count: 1, from: [["Light Crossbow", "Crossbow Bolts x20"], ["Simple Weapon"]] } },
      { choose: { count: 1, from: [["Component Pouch"], ["Arcane Focus"]] } },
      { choose: { count: 1, from: [[...SCHOLARS_PACK], [...DUNGEONEERS_PACK]] } },
      { fixed: ["Leather Armor", "Simple Weapon", "Dagger", "Dagger"] }
    ],
    spellcasting: {
      ability: "cha",
      cantripsKnown: [2, 2, 2, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4],
      spellsKnown: [2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15],
      // Warlock has pact magic, not standard slots - handled separately
      slotsByLevel: {
        1: [1, 0, 0, 0, 0, 0, 0, 0, 0],
        2: [2, 0, 0, 0, 0, 0, 0, 0, 0],
        3: [0, 2, 0, 0, 0, 0, 0, 0, 0],
        4: [0, 2, 0, 0, 0, 0, 0, 0, 0],
        5: [0, 0, 2, 0, 0, 0, 0, 0, 0],
        6: [0, 0, 2, 0, 0, 0, 0, 0, 0],
        7: [0, 0, 0, 2, 0, 0, 0, 0, 0],
        8: [0, 0, 0, 2, 0, 0, 0, 0, 0],
        9: [0, 0, 0, 0, 2, 0, 0, 0, 0],
        10: [0, 0, 0, 0, 2, 0, 0, 0, 0],
        11: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        12: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        13: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        14: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        15: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        16: [0, 0, 0, 0, 3, 0, 0, 0, 0],
        17: [0, 0, 0, 0, 4, 0, 0, 0, 0],
        18: [0, 0, 0, 0, 4, 0, 0, 0, 0],
        19: [0, 0, 0, 0, 4, 0, 0, 0, 0],
        20: [0, 0, 0, 0, 4, 0, 0, 0, 0]
      },
      startingCantrips: ["Eldritch Blast", "Minor Illusion"],
      startingSpells: ["Hex", "Armor of Agathys"]
    }
  },
  // 
  // WIZARD
  // 
  wizard: {
    hitDice: "d6",
    startingHP: (conMod) => 6 + conMod,
    savingThrows: ["intelligence", "wisdom"],
    armorProficiencies: [],
    weaponProficiencies: ["daggers", "darts", "slings", "quarterstaffs", "light crossbows"],
    startingEquipment: [
      { choose: { count: 1, from: [["Quarterstaff"], ["Dagger"]] } },
      { choose: { count: 1, from: [["Component Pouch"], ["Arcane Focus"]] } },
      { choose: { count: 1, from: [[...SCHOLARS_PACK], [...EXPLORERS_PACK]] } },
      { fixed: ["Spellbook"] }
    ],
    spellcasting: {
      ability: "int",
      cantripsKnown: [3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
      spellsPrepared: true,
      // INT mod + wizard level
      slotsByLevel: FULL_CASTER_SLOTS2,
      startingCantrips: ["Fire Bolt", "Mage Hand", "Prestidigitation"],
      startingSpells: ["Magic Missile", "Shield", "Mage Armor", "Sleep", "Detect Magic", "Identify"]
    }
  }
};
function getClassStartingData(className) {
  const normalized = className.toLowerCase().trim();
  return CLASS_DATA[normalized] || null;
}
function getDefaultStartingEquipment(className) {
  const classData = getClassStartingData(className);
  if (!classData)
    return [];
  const equipment = [];
  for (const choice of classData.startingEquipment) {
    if (choice.fixed) {
      equipment.push(...choice.fixed);
    } else if (choice.choose) {
      const firstOption = choice.choose.from[0];
      if (firstOption) {
        equipment.push(...firstOption);
      }
    }
  }
  return equipment;
}
function getSpellSlots(className, characterLevel) {
  const classData = getClassStartingData(className);
  if (!classData?.spellcasting)
    return [0, 0, 0, 0, 0, 0, 0, 0, 0];
  const level = Math.min(Math.max(characterLevel, 1), 20);
  return classData.spellcasting.slotsByLevel[level] || [0, 0, 0, 0, 0, 0, 0, 0, 0];
}
function isSpellcaster(className) {
  const classData = getClassStartingData(className);
  return !!classData?.spellcasting;
}

// dist/services/starting-equipment.service.js
function provisionStartingEquipment(db, characterId, className, level = 1, options = {}) {
  const itemRepo = new ItemRepository(db);
  const invRepo = new InventoryRepository(db);
  const result = {
    itemsGranted: [],
    spellsGranted: [],
    cantripsGranted: [],
    spellSlots: null,
    pactMagicSlots: null,
    startingGold: 0,
    errors: []
  };
  const normalizedClass = normalizeClassName(className);
  const classData = CLASS_DATA[normalizedClass];
  if (!options.skipEquipment) {
    const equipmentList = options.customEquipment?.length ? options.customEquipment : classData ? getDefaultStartingEquipment(normalizedClass) : getGenericStartingEquipment();
    for (const itemName of equipmentList) {
      try {
        const itemId = ensureItemExists(itemRepo, itemName);
        invRepo.addItem(characterId, itemId, 1);
        result.itemsGranted.push(itemName);
      } catch (err) {
        result.errors.push(`Failed to grant "${itemName}": ${err.message}`);
      }
    }
    const goldAmount = options.startingGold ?? (classData?.startingGold ?? 10);
    try {
      invRepo.addCurrency(characterId, { gold: goldAmount });
      result.startingGold = goldAmount;
    } catch (err) {
      result.errors.push(`Failed to grant starting gold: ${err.message}`);
    }
  }
  if (!options.skipSpells && classData && isSpellcaster(normalizedClass)) {
    const slots = getSpellSlots(normalizedClass, level);
    if (slots) {
      if (normalizedClass === "warlock") {
        const slotCount = slots.find((s) => s > 0) || 1;
        const slotLevel = slots.findIndex((s) => s > 0) + 1;
        result.pactMagicSlots = { slots: slotCount, level: slotLevel || 1 };
      } else {
        result.spellSlots = slots;
      }
    }
    const cantrips = options.customCantrips?.length ? options.customCantrips : classData.startingCantrips || [];
    result.cantripsGranted = cantrips;
    const spells = options.customSpells?.length ? options.customSpells : classData.startingSpells || [];
    result.spellsGranted = spells;
  }
  return result;
}
function normalizeClassName(className) {
  const normalized = className.toLowerCase().trim();
  if (normalized in CLASS_DATA) {
    return normalized;
  }
  const aliases = {
    "mage": "wizard",
    "arcane caster": "wizard",
    "priest": "cleric",
    "healer": "cleric",
    "thief": "rogue",
    "assassin": "rogue",
    "berserker": "barbarian",
    "knight": "fighter",
    "warrior": "fighter",
    "soldier": "fighter",
    "nature priest": "druid",
    "shapeshifter": "druid",
    "holy warrior": "paladin",
    "crusader": "paladin",
    "hunter": "ranger",
    "scout": "ranger",
    "wild mage": "sorcerer",
    "bloodmage": "sorcerer",
    "hexblade": "warlock",
    "pact mage": "warlock",
    "performer": "bard",
    "skald": "bard",
    "martial artist": "monk",
    "mystic": "monk"
  };
  if (normalized in aliases) {
    return aliases[normalized];
  }
  for (const knownClass of Object.keys(CLASS_DATA)) {
    if (normalized.includes(knownClass)) {
      return knownClass;
    }
  }
  return normalized;
}
function getGenericStartingEquipment() {
  return [
    "Simple Weapon",
    "Leather Armor",
    "Backpack",
    "Bedroll",
    "Torch",
    "Rations (1 day)",
    "Waterskin"
  ];
}
function ensureItemExists(itemRepo, itemName) {
  const existing = itemRepo.findByName(itemName);
  if (existing.length > 0) {
    return existing[0].id;
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const itemData = getItemDefaults(itemName);
  const item = {
    id: (0, import_crypto2.randomUUID)(),
    name: itemName,
    description: itemData.description,
    type: itemData.type,
    weight: itemData.weight,
    value: itemData.value,
    properties: itemData.properties,
    createdAt: now,
    updatedAt: now
  };
  itemRepo.create(item);
  return item.id;
}
function getItemDefaults(itemName) {
  const name = itemName.toLowerCase();
  if (name.includes("sword") || name.includes("blade")) {
    const isTwoHanded = name.includes("great") || name.includes("two-handed");
    return {
      type: "weapon",
      weight: isTwoHanded ? 6 : 3,
      value: isTwoHanded ? 50 : 15,
      description: `A ${itemName.toLowerCase()}.`,
      properties: {
        damage: isTwoHanded ? "2d6" : "1d8",
        damageType: "slashing",
        versatile: !isTwoHanded
      }
    };
  }
  if (name.includes("axe")) {
    const isGreat = name.includes("great");
    return {
      type: "weapon",
      weight: isGreat ? 7 : 4,
      value: isGreat ? 30 : 10,
      description: `A ${itemName.toLowerCase()}.`,
      properties: {
        damage: isGreat ? "1d12" : "1d8",
        damageType: "slashing"
      }
    };
  }
  if (name.includes("bow")) {
    const isLong = name.includes("long");
    return {
      type: "weapon",
      weight: isLong ? 2 : 1,
      value: isLong ? 50 : 25,
      description: `A ${itemName.toLowerCase()}.`,
      properties: {
        damage: isLong ? "1d8" : "1d6",
        damageType: "piercing",
        range: isLong ? "150/600" : "80/320",
        ammunition: true
      }
    };
  }
  if (name.includes("crossbow")) {
    const isHand = name.includes("hand");
    const isHeavy = name.includes("heavy");
    return {
      type: "weapon",
      weight: isHand ? 3 : isHeavy ? 18 : 5,
      value: isHand ? 75 : isHeavy ? 50 : 25,
      description: `A ${itemName.toLowerCase()}.`,
      properties: {
        damage: isHand ? "1d6" : isHeavy ? "1d10" : "1d8",
        damageType: "piercing",
        ammunition: true,
        loading: true
      }
    };
  }
  if (name.includes("dagger")) {
    return {
      type: "weapon",
      weight: 1,
      value: 2,
      description: "A simple dagger.",
      properties: {
        damage: "1d4",
        damageType: "piercing",
        finesse: true,
        light: true,
        thrown: "20/60"
      }
    };
  }
  if (name.includes("quarterstaff") || name.includes("staff")) {
    return {
      type: "weapon",
      weight: 4,
      value: 2,
      description: "A wooden staff.",
      properties: {
        damage: "1d6",
        damageType: "bludgeoning",
        versatile: "1d8"
      }
    };
  }
  if (name.includes("mace")) {
    return {
      type: "weapon",
      weight: 4,
      value: 5,
      description: "A metal mace.",
      properties: {
        damage: "1d6",
        damageType: "bludgeoning"
      }
    };
  }
  if (name.includes("javelin")) {
    return {
      type: "weapon",
      weight: 2,
      value: 0.5,
      description: "A throwing javelin.",
      properties: {
        damage: "1d6",
        damageType: "piercing",
        thrown: "30/120"
      }
    };
  }
  if (name.includes("handaxe")) {
    return {
      type: "weapon",
      weight: 2,
      value: 5,
      description: "A small throwing axe.",
      properties: {
        damage: "1d6",
        damageType: "slashing",
        light: true,
        thrown: "20/60"
      }
    };
  }
  if (name.includes("rapier")) {
    return {
      type: "weapon",
      weight: 2,
      value: 25,
      description: "A slender thrusting sword.",
      properties: {
        damage: "1d8",
        damageType: "piercing",
        finesse: true
      }
    };
  }
  if (name.includes("scimitar")) {
    return {
      type: "weapon",
      weight: 3,
      value: 25,
      description: "A curved slashing blade.",
      properties: {
        damage: "1d6",
        damageType: "slashing",
        finesse: true,
        light: true
      }
    };
  }
  if (name.includes("shortbow")) {
    return {
      type: "weapon",
      weight: 2,
      value: 25,
      description: "A compact bow.",
      properties: {
        damage: "1d6",
        damageType: "piercing",
        range: "80/320",
        ammunition: true
      }
    };
  }
  if (name.includes("chain mail") || name.includes("chainmail")) {
    return {
      type: "armor",
      weight: 55,
      value: 75,
      description: "Heavy armor made of interlocking metal rings.",
      properties: { ac: 16, stealthDisadvantage: true, strengthRequired: 13 }
    };
  }
  if (name.includes("scale mail")) {
    return {
      type: "armor",
      weight: 45,
      value: 50,
      description: "Medium armor of overlapping metal scales.",
      properties: { ac: 14, maxDexBonus: 2, stealthDisadvantage: true }
    };
  }
  if (name.includes("leather armor") || name === "leather") {
    return {
      type: "armor",
      weight: 10,
      value: 10,
      description: "Light armor made of cured leather.",
      properties: { ac: 11 }
    };
  }
  if (name.includes("studded leather")) {
    return {
      type: "armor",
      weight: 13,
      value: 45,
      description: "Leather armor reinforced with metal studs.",
      properties: { ac: 12 }
    };
  }
  if (name.includes("hide armor") || name === "hide") {
    return {
      type: "armor",
      weight: 12,
      value: 10,
      description: "Medium armor made of thick animal hides.",
      properties: { ac: 12, maxDexBonus: 2 }
    };
  }
  if (name.includes("shield")) {
    return {
      type: "armor",
      weight: 6,
      value: 10,
      description: "A wooden or metal shield.",
      properties: { acBonus: 2 }
    };
  }
  if (name.includes("pack")) {
    const packItems = getPackContents(name);
    return {
      type: "misc",
      weight: 30,
      value: 10,
      description: `An adventuring pack containing: ${packItems.join(", ")}.`,
      properties: { contains: packItems }
    };
  }
  if (name.includes("arcane focus") || name.includes("component pouch")) {
    return {
      type: "misc",
      weight: 1,
      value: 10,
      description: "A spellcasting focus or component pouch.",
      properties: { spellcastingFocus: true }
    };
  }
  if (name.includes("holy symbol")) {
    return {
      type: "misc",
      weight: 1,
      value: 5,
      description: "A divine spellcasting focus.",
      properties: { spellcastingFocus: true, divine: true }
    };
  }
  if (name.includes("druidic focus")) {
    return {
      type: "misc",
      weight: 1,
      value: 5,
      description: "A natural spellcasting focus.",
      properties: { spellcastingFocus: true, druidic: true }
    };
  }
  if (name.includes("spellbook")) {
    return {
      type: "misc",
      weight: 3,
      value: 50,
      description: "A wizard's spellbook for recording spells.",
      properties: { spellbook: true }
    };
  }
  if (name.includes("lute") || name.includes("drum") || name.includes("flute") || name.includes("horn") || name.includes("instrument")) {
    return {
      type: "misc",
      weight: 2,
      value: 30,
      description: "A musical instrument.",
      properties: { instrument: true, bardFocus: true }
    };
  }
  if (name.includes("thieves' tools") || name.includes("thieves tools")) {
    return {
      type: "misc",
      weight: 1,
      value: 25,
      description: "A set of lockpicks and tools for disabling traps.",
      properties: { proficiencyRequired: true }
    };
  }
  if (name.includes("arrow")) {
    const match = name.match(/(\d+)/);
    const count = match ? parseInt(match[1]) : 20;
    return {
      type: "misc",
      weight: 1,
      value: 1,
      description: `A quiver of ${count} arrows.`,
      properties: { ammunition: true, count }
    };
  }
  if (name.includes("bolt")) {
    const match = name.match(/(\d+)/);
    const count = match ? parseInt(match[1]) : 20;
    return {
      type: "misc",
      weight: 1.5,
      value: 1,
      description: `A case of ${count} crossbow bolts.`,
      properties: { ammunition: true, count }
    };
  }
  if (name.includes("potion")) {
    return {
      type: "consumable",
      weight: 0.5,
      value: 50,
      description: "A magical potion.",
      properties: {}
    };
  }
  if (name.includes("rations")) {
    return {
      type: "consumable",
      weight: 2,
      value: 0.5,
      description: "A day's worth of travel rations.",
      properties: {}
    };
  }
  return {
    type: "misc",
    weight: 1,
    value: 1,
    description: `A ${itemName.toLowerCase()}.`,
    properties: {}
  };
}
function getPackContents(packName) {
  const name = packName.toLowerCase();
  if (name.includes("explorer")) {
    return EquipmentPacks.explorersPack;
  }
  if (name.includes("dungeoneer")) {
    return EquipmentPacks.dungeoneersPack;
  }
  if (name.includes("priest")) {
    return EquipmentPacks.priestsPack;
  }
  if (name.includes("scholar")) {
    return EquipmentPacks.scholarsPack;
  }
  if (name.includes("burglar")) {
    return EquipmentPacks.burglarsPack;
  }
  if (name.includes("diplomat")) {
    return EquipmentPacks.diplomatsPack;
  }
  if (name.includes("entertainer")) {
    return EquipmentPacks.entertainersPack;
  }
  return ["Backpack", "Bedroll", "Rations (5 days)", "Waterskin", "Torch"];
}

// dist/server/crud-tools.js
function ensureDb() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const worldRepo = new WorldRepository(db);
  const charRepo = new CharacterRepository(db);
  return { db, worldRepo, charRepo };
}
var CRUDTools = {
  // World tools
  CREATE_WORLD: {
    name: "create_world",
    description: "Create a new world in the database with name, seed, and dimensions.",
    inputSchema: WorldSchema.omit({ id: true, createdAt: true, updatedAt: true })
  },
  GET_WORLD: {
    name: "get_world",
    description: "Retrieve a world by ID.",
    inputSchema: external_exports.object({
      id: external_exports.string()
    })
  },
  LIST_WORLDS: {
    name: "list_worlds",
    description: "List all worlds.",
    inputSchema: external_exports.object({})
  },
  UPDATE_WORLD_ENVIRONMENT: {
    name: "update_world_environment",
    description: "Update environmental properties (time, weather, lighting, etc.) for a world.",
    inputSchema: external_exports.object({
      id: external_exports.string(),
      environment: external_exports.object({
        date: external_exports.string().optional(),
        timeOfDay: external_exports.string().optional(),
        season: external_exports.string().optional(),
        moonPhase: external_exports.string().optional(),
        weatherConditions: external_exports.string().optional(),
        temperature: external_exports.string().optional(),
        lighting: external_exports.string().optional()
      }).passthrough()
    })
  },
  DELETE_WORLD: {
    name: "delete_world",
    description: "Delete a world by ID.",
    inputSchema: external_exports.object({
      id: external_exports.string()
    })
  },
  // Character tools
  CREATE_CHARACTER: {
    name: "create_character",
    description: `Create a new character. Only name is required - everything else has sensible defaults.

Character types:
- pc: Player character (default)
- npc: Non-player character (ally or neutral)
- enemy: Hostile creature
- neutral: Non-hostile, non-ally

Class and race can be ANY string - use standard D&D classes/races or create custom ones.
Stats can be any positive integer (not limited to 3-18).

Example (minimal - just name):
{
  "name": "Mysterious Stranger"
}

Example (full):
{
  "name": "Valeros",
  "class": "Fighter",
  "race": "Human",
  "hp": 20,
  "maxHp": 20,
  "ac": 18,
  "level": 1,
  "stats": { "str": 16, "dex": 14, "con": 14, "int": 10, "wis": 12, "cha": 10 },
  "characterType": "pc"
}

Example (custom class/race):
{
  "name": "Whiskers",
  "class": "Chronomancer",
  "race": "Mousefolk",
  "stats": { "str": 6, "dex": 18, "con": 10, "int": 16, "wis": 14, "cha": 12 }
}`,
    // Flexible schema - only name required, everything else has defaults
    inputSchema: external_exports.object({
      name: external_exports.string().min(1).describe("Character name (required)"),
      // Class/race can be ANY string - no enum restriction
      class: external_exports.string().optional().default("Adventurer").describe("Character class - any string allowed (Fighter, Wizard, Chronomancer, Merchant...)"),
      race: external_exports.string().optional().default("Human").describe("Character race - any string allowed (Human, Elf, Mousefolk, Illithid...)"),
      background: external_exports.string().optional().default("Folk Hero"),
      alignment: external_exports.string().optional(),
      // Stats with no min/max - allow godlike or cursed entities
      stats: external_exports.object({
        str: external_exports.number().int().min(0).default(10),
        dex: external_exports.number().int().min(0).default(10),
        con: external_exports.number().int().min(0).default(10),
        int: external_exports.number().int().min(0).default(10),
        wis: external_exports.number().int().min(0).default(10),
        cha: external_exports.number().int().min(0).default(10)
      }).optional().default({ str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 }),
      // Combat stats with sensible defaults
      hp: external_exports.number().int().min(1).optional(),
      maxHp: external_exports.number().int().min(1).optional(),
      ac: external_exports.number().int().min(0).optional().default(10),
      level: external_exports.number().int().min(1).optional().default(1),
      // Type and NPC fields
      characterType: CharacterTypeSchema.optional().default("pc"),
      factionId: external_exports.string().optional(),
      behavior: external_exports.string().optional(),
      // Spellcasting
      characterClass: external_exports.string().optional(),
      knownSpells: external_exports.array(external_exports.string()).optional().default([]),
      preparedSpells: external_exports.array(external_exports.string()).optional().default([]),
      // Damage modifiers
      resistances: external_exports.array(external_exports.string()).optional().default([]),
      vulnerabilities: external_exports.array(external_exports.string()).optional().default([]),
      immunities: external_exports.array(external_exports.string()).optional().default([]),
      // Starting equipment provisioning (default: true for PCs)
      provisionEquipment: external_exports.boolean().optional().default(true).describe("Auto-grant class-appropriate starting equipment and spells. Set to false for custom/improvised characters."),
      // Custom equipment override (when provisionEquipment is true but you want specific items)
      customEquipment: external_exports.array(external_exports.string()).optional().describe("Override default starting equipment with these items (still requires provisionEquipment: true)"),
      // Starting gold override
      startingGold: external_exports.number().int().min(0).optional().describe("Override default starting gold amount")
    })
  },
  GET_CHARACTER: {
    name: "get_character",
    description: "Retrieve a character by ID.",
    inputSchema: external_exports.object({
      id: external_exports.string()
    })
  },
  UPDATE_CHARACTER: {
    name: "update_character",
    description: `Update character properties. All fields except id are optional.

For conditions, you can pass an array to SET all conditions (replacing existing), or use addConditions/removeConditions for granular control.`,
    inputSchema: external_exports.object({
      id: external_exports.string(),
      name: external_exports.string().min(1).optional(),
      race: external_exports.string().optional(),
      class: external_exports.string().optional(),
      hp: external_exports.number().int().min(0).optional(),
      maxHp: external_exports.number().int().min(1).optional(),
      ac: external_exports.number().int().min(0).optional(),
      level: external_exports.number().int().min(1).optional(),
      characterType: CharacterTypeSchema.optional(),
      stats: external_exports.object({
        str: external_exports.number().int().min(0).optional(),
        dex: external_exports.number().int().min(0).optional(),
        con: external_exports.number().int().min(0).optional(),
        int: external_exports.number().int().min(0).optional(),
        wis: external_exports.number().int().min(0).optional(),
        cha: external_exports.number().int().min(0).optional()
      }).optional(),
      // Spellcasting updates
      knownSpells: external_exports.array(external_exports.string()).optional(),
      preparedSpells: external_exports.array(external_exports.string()).optional(),
      cantripsKnown: external_exports.array(external_exports.string()).optional(),
      spellSlots: SpellSlotsSchema.optional(),
      pactMagicSlots: PactMagicSlotsSchema.optional(),
      spellcastingAbility: SpellcastingAbilitySchema.optional(),
      // Conditions/Status Effects
      conditions: external_exports.array(external_exports.object({
        name: external_exports.string(),
        duration: external_exports.number().int().optional(),
        source: external_exports.string().optional()
      })).optional().describe("Replace all conditions with this array"),
      addConditions: external_exports.array(external_exports.object({
        name: external_exports.string(),
        duration: external_exports.number().int().optional(),
        source: external_exports.string().optional()
      })).optional().describe("Add these conditions to existing ones"),
      removeConditions: external_exports.array(external_exports.string()).optional().describe("Remove conditions by name")
    })
  },
  LIST_CHARACTERS: {
    name: "list_characters",
    description: "List all characters, optionally filtered by type (pc, npc, enemy, neutral).",
    inputSchema: external_exports.object({
      characterType: CharacterTypeSchema.optional()
    })
  },
  DELETE_CHARACTER: {
    name: "delete_character",
    description: "Delete a character by ID.",
    inputSchema: external_exports.object({
      id: external_exports.string()
    })
  }
};
async function handleCreateWorld(args, _ctx) {
  const { worldRepo } = ensureDb();
  const parsed = CRUDTools.CREATE_WORLD.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const world = {
    ...parsed,
    id: (0, import_crypto3.randomUUID)(),
    createdAt: now,
    updatedAt: now
  };
  worldRepo.create(world);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(world, null, 2)
    }]
  };
}
async function handleGetWorld(args, _ctx) {
  const { worldRepo } = ensureDb();
  const parsed = CRUDTools.GET_WORLD.inputSchema.parse(args);
  const world = worldRepo.findById(parsed.id);
  if (!world) {
    throw new Error(`World not found: ${parsed.id}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(world, null, 2)
    }]
  };
}
async function handleUpdateWorldEnvironment(args, _ctx) {
  const { worldRepo } = ensureDb();
  const parsed = CRUDTools.UPDATE_WORLD_ENVIRONMENT.inputSchema.parse(args);
  const updated = worldRepo.updateEnvironment(parsed.id, parsed.environment);
  if (!updated) {
    throw new Error(`World not found: ${parsed.id}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(updated, null, 2)
    }]
  };
}
async function handleListWorlds(args, _ctx) {
  const { worldRepo } = ensureDb();
  CRUDTools.LIST_WORLDS.inputSchema.parse(args);
  const worlds = worldRepo.findAll();
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        worlds,
        count: worlds.length
      }, null, 2)
    }]
  };
}
async function handleDeleteWorld(args, _ctx) {
  const { worldRepo } = ensureDb();
  const parsed = CRUDTools.DELETE_WORLD.inputSchema.parse(args);
  worldRepo.delete(parsed.id);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: "World deleted",
        id: parsed.id
      }, null, 2)
    }]
  };
}
async function handleCreateCharacter(args, _ctx) {
  const { db, charRepo } = ensureDb();
  const parsed = CRUDTools.CREATE_CHARACTER.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const className = parsed.characterClass || parsed.class || "Adventurer";
  const conModifier = Math.floor(((parsed.stats?.con ?? 10) - 10) / 2);
  const baseHp = Math.max(1, 8 + conModifier);
  const hp = parsed.hp ?? baseHp;
  const maxHp = parsed.maxHp ?? hp;
  const characterId = (0, import_crypto3.randomUUID)();
  let provisioningResult = null;
  const shouldProvision = parsed.provisionEquipment !== false && (parsed.characterType === "pc" || parsed.characterType === void 0);
  if (shouldProvision) {
    provisioningResult = provisionStartingEquipment(db, characterId, className, parsed.level ?? 1, {
      customEquipment: parsed.customEquipment,
      customSpells: parsed.knownSpells?.length ? parsed.knownSpells : void 0,
      startingGold: parsed.startingGold
    });
  }
  const character = {
    ...parsed,
    id: characterId,
    hp,
    maxHp,
    // Map 'class' to 'characterClass' for DB compatibility
    characterClass: className,
    // Merge provisioned spells with any explicitly provided
    knownSpells: provisioningResult?.spellsGranted.length ? [.../* @__PURE__ */ new Set([...parsed.knownSpells || [], ...provisioningResult.spellsGranted])] : parsed.knownSpells || [],
    cantripsKnown: provisioningResult?.cantripsGranted.length ? [.../* @__PURE__ */ new Set([...parsed.cantripsKnown || [], ...provisioningResult.cantripsGranted])] : parsed.cantripsKnown || [],
    spellSlots: provisioningResult?.spellSlots || void 0,
    pactMagicSlots: provisioningResult?.pactMagicSlots || void 0,
    createdAt: now,
    updatedAt: now
  };
  charRepo.create(character);
  const response = { ...character };
  if (provisioningResult) {
    response._provisioning = {
      equipmentGranted: provisioningResult.itemsGranted,
      spellsGranted: provisioningResult.spellsGranted,
      cantripsGranted: provisioningResult.cantripsGranted,
      startingGold: provisioningResult.startingGold,
      errors: provisioningResult.errors.length > 0 ? provisioningResult.errors : void 0
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(response, null, 2)
    }]
  };
}
async function handleGetCharacter(args, _ctx) {
  const { charRepo } = ensureDb();
  const parsed = CRUDTools.GET_CHARACTER.inputSchema.parse(args);
  const character = charRepo.findById(parsed.id);
  if (!character) {
    throw new Error(`Character not found: ${parsed.id}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(character, null, 2)
    }]
  };
}
async function handleUpdateCharacter(args, _ctx) {
  const { charRepo } = ensureDb();
  const parsed = CRUDTools.UPDATE_CHARACTER.inputSchema.parse(args);
  const updateData = {};
  if (parsed.name !== void 0)
    updateData.name = parsed.name;
  if (parsed.race !== void 0)
    updateData.race = parsed.race;
  if (parsed.class !== void 0)
    updateData.characterClass = parsed.class;
  if (parsed.hp !== void 0)
    updateData.hp = parsed.hp;
  if (parsed.maxHp !== void 0)
    updateData.maxHp = parsed.maxHp;
  if (parsed.ac !== void 0)
    updateData.ac = parsed.ac;
  if (parsed.level !== void 0)
    updateData.level = parsed.level;
  if (parsed.characterType !== void 0)
    updateData.characterType = parsed.characterType;
  if (parsed.stats !== void 0)
    updateData.stats = parsed.stats;
  if (parsed.knownSpells !== void 0)
    updateData.knownSpells = parsed.knownSpells;
  if (parsed.preparedSpells !== void 0)
    updateData.preparedSpells = parsed.preparedSpells;
  if (parsed.cantripsKnown !== void 0)
    updateData.cantripsKnown = parsed.cantripsKnown;
  if (parsed.spellSlots !== void 0)
    updateData.spellSlots = parsed.spellSlots;
  if (parsed.pactMagicSlots !== void 0)
    updateData.pactMagicSlots = parsed.pactMagicSlots;
  if (parsed.spellcastingAbility !== void 0)
    updateData.spellcastingAbility = parsed.spellcastingAbility;
  if (parsed.conditions !== void 0) {
    updateData.conditions = parsed.conditions;
  } else if (parsed.addConditions !== void 0 || parsed.removeConditions !== void 0) {
    const existing = charRepo.findById(parsed.id);
    if (!existing) {
      throw new Error(`Character not found: ${parsed.id}`);
    }
    let currentConditions = existing.conditions || [];
    if (parsed.removeConditions && parsed.removeConditions.length > 0) {
      const toRemove = new Set(parsed.removeConditions.map((n2) => n2.toLowerCase()));
      currentConditions = currentConditions.filter((c) => !toRemove.has(c.name.toLowerCase()));
    }
    if (parsed.addConditions && parsed.addConditions.length > 0) {
      for (const newCond of parsed.addConditions) {
        const existingIdx = currentConditions.findIndex((c) => c.name.toLowerCase() === newCond.name.toLowerCase());
        if (existingIdx >= 0) {
          currentConditions[existingIdx] = { ...currentConditions[existingIdx], ...newCond };
        } else {
          currentConditions.push(newCond);
        }
      }
    }
    updateData.conditions = currentConditions;
  }
  const updated = charRepo.update(parsed.id, updateData);
  if (!updated) {
    throw new Error(`Failed to update character: ${parsed.id}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(updated, null, 2)
    }]
  };
}
async function handleListCharacters(args, _ctx) {
  const { charRepo } = ensureDb();
  const parsed = CRUDTools.LIST_CHARACTERS.inputSchema.parse(args);
  const characters = charRepo.findAll({
    characterType: parsed.characterType
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characters,
        count: characters.length
      }, null, 2)
    }]
  };
}
async function handleDeleteCharacter(args, _ctx) {
  const { db } = ensureDb();
  const parsed = CRUDTools.DELETE_CHARACTER.inputSchema.parse(args);
  const stmt = db.prepare("DELETE FROM characters WHERE id = ?");
  stmt.run(parsed.id);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: "Character deleted",
        id: parsed.id
      }, null, 2)
    }]
  };
}

// dist/server/inventory-tools.js
init_zod();
var import_crypto4 = require("crypto");
init_character_repo();
function ensureDb2() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const itemRepo = new ItemRepository(db);
  const inventoryRepo = new InventoryRepository(db);
  const charRepo = new CharacterRepository(db);
  return { itemRepo, inventoryRepo, charRepo };
}
var InventoryTools = {
  CREATE_ITEM_TEMPLATE: {
    name: "create_item_template",
    description: 'Define a new type of item (e.g., "Iron Sword").',
    inputSchema: ItemSchema.omit({ id: true, createdAt: true, updatedAt: true })
  },
  GET_ITEM: {
    name: "get_item",
    description: "Get details of a specific item by ID.",
    inputSchema: external_exports.object({
      itemId: external_exports.string().describe("The unique ID of the item to retrieve")
    })
  },
  LIST_ITEMS: {
    name: "list_items",
    description: "List all item templates in the database.",
    inputSchema: external_exports.object({
      type: external_exports.enum(["weapon", "armor", "consumable", "quest", "misc", "scroll"]).optional().describe("Filter by item type")
    })
  },
  SEARCH_ITEMS: {
    name: "search_items",
    description: "Search for items by name, type, or value range.",
    inputSchema: external_exports.object({
      name: external_exports.string().optional().describe("Search by name (partial match)"),
      type: external_exports.enum(["weapon", "armor", "consumable", "quest", "misc", "scroll"]).optional().describe("Filter by item type"),
      minValue: external_exports.number().min(0).optional().describe("Minimum item value"),
      maxValue: external_exports.number().min(0).optional().describe("Maximum item value")
    })
  },
  UPDATE_ITEM: {
    name: "update_item",
    description: "Update an existing item template.",
    inputSchema: external_exports.object({
      itemId: external_exports.string().describe("The ID of the item to update"),
      name: external_exports.string().optional(),
      description: external_exports.string().optional(),
      type: external_exports.enum(["weapon", "armor", "consumable", "quest", "misc", "scroll"]).optional(),
      weight: external_exports.number().min(0).optional(),
      value: external_exports.number().min(0).optional(),
      properties: external_exports.record(external_exports.any()).optional()
    })
  },
  DELETE_ITEM: {
    name: "delete_item",
    description: "Delete an item template from the database.",
    inputSchema: external_exports.object({
      itemId: external_exports.string().describe("The ID of the item to delete")
    })
  },
  GIVE_ITEM: {
    name: "give_item",
    description: "Add an item to a character's inventory.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      itemId: external_exports.string(),
      quantity: external_exports.number().int().min(1).default(1)
    })
  },
  REMOVE_ITEM: {
    name: "remove_item",
    description: "Remove an item from a character's inventory.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      itemId: external_exports.string(),
      quantity: external_exports.number().int().min(1).default(1)
    })
  },
  TRANSFER_ITEM: {
    name: "transfer_item",
    description: "Transfer an item from one character to another.",
    inputSchema: external_exports.object({
      fromCharacterId: external_exports.string().describe("Character giving the item"),
      toCharacterId: external_exports.string().describe("Character receiving the item"),
      itemId: external_exports.string().describe("The item to transfer"),
      quantity: external_exports.number().int().min(1).default(1).describe("How many to transfer")
    })
  },
  USE_ITEM: {
    name: "use_item",
    description: "Use a consumable item (removes it from inventory and applies effects).",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character using the item"),
      itemId: external_exports.string().describe("The consumable item to use"),
      targetId: external_exports.string().optional().describe("Optional target character for the effect")
    })
  },
  EQUIP_ITEM: {
    name: "equip_item",
    description: "Equip an item in a specific slot.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      itemId: external_exports.string(),
      slot: external_exports.enum(["mainhand", "offhand", "armor", "head", "feet", "accessory"])
    })
  },
  UNEQUIP_ITEM: {
    name: "unequip_item",
    description: "Unequip an item.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      itemId: external_exports.string()
    })
  },
  GET_INVENTORY: {
    name: "get_inventory",
    description: "List all items in a character's inventory.",
    inputSchema: external_exports.object({
      characterId: external_exports.string()
    })
  },
  GET_INVENTORY_DETAILED: {
    name: "get_inventory_detailed",
    description: "Get detailed inventory with full item info, sorted by equipped/type/name.",
    inputSchema: external_exports.object({
      characterId: external_exports.string()
    })
  }
};
async function handleCreateItemTemplate(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.CREATE_ITEM_TEMPLATE.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const item = {
    ...parsed,
    id: (0, import_crypto4.randomUUID)(),
    createdAt: now,
    updatedAt: now
  };
  itemRepo.create(item);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(item, null, 2)
    }]
  };
}
async function handleGiveItem(args, _ctx) {
  const { inventoryRepo, itemRepo } = ensureDb2();
  const parsed = InventoryTools.GIVE_ITEM.inputSchema.parse(args);
  if (parsed.quantity > INVENTORY_LIMITS.MAX_GIVE_QUANTITY) {
    throw new Error(`Cannot give more than ${INVENTORY_LIMITS.MAX_GIVE_QUANTITY} items at once. Requested quantity: ${parsed.quantity}`);
  }
  const item = itemRepo.findById(parsed.itemId);
  if (!item) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  const properties = item.properties || {};
  const isUnique = properties.unique === true;
  const isWorldUnique = properties.worldUnique === true;
  if (isUnique || isWorldUnique) {
    if (parsed.quantity > 1) {
      throw new Error(`Cannot give more than 1 of unique item "${item.name}"`);
    }
    const inventory = inventoryRepo.getInventory(parsed.characterId);
    const existingItem2 = inventory.items.find((i) => i.itemId === parsed.itemId);
    if (existingItem2) {
      throw new Error(`Character already owns unique item "${item.name}". Unique items cannot stack.`);
    }
    if (isWorldUnique) {
      const allOwners = inventoryRepo.findItemOwners(parsed.itemId);
      if (allOwners.length > 0) {
        throw new Error(`World-unique item "${item.name}" is already owned by another character. Only one can exist in the world.`);
      }
    }
  }
  const currentInventory = inventoryRepo.getInventoryWithDetails(parsed.characterId);
  const addedWeight = item.weight * parsed.quantity;
  const newTotalWeight = currentInventory.totalWeight + addedWeight;
  if (newTotalWeight > currentInventory.capacity) {
    throw new Error(`Cannot add items: would exceed weight capacity. Current: ${currentInventory.totalWeight.toFixed(1)}/${currentInventory.capacity}, Adding: ${addedWeight.toFixed(1)}, Would be: ${newTotalWeight.toFixed(1)}`);
  }
  const existingItem = currentInventory.items.find((i) => i.item.id === parsed.itemId);
  const existingQuantity = existingItem?.quantity || 0;
  const newTotal = existingQuantity + parsed.quantity;
  if (newTotal > INVENTORY_LIMITS.MAX_STACK_SIZE) {
    throw new Error(`Cannot add items: would exceed max stack size of ${INVENTORY_LIMITS.MAX_STACK_SIZE}. Current: ${existingQuantity}, Adding: ${parsed.quantity}, Would be: ${newTotal}`);
  }
  inventoryRepo.addItem(parsed.characterId, parsed.itemId, parsed.quantity);
  return {
    content: [{
      type: "text",
      text: `Added ${parsed.quantity} of item ${parsed.itemId} to character ${parsed.characterId}`
    }]
  };
}
async function handleRemoveItem(args, _ctx) {
  const { inventoryRepo } = ensureDb2();
  const parsed = InventoryTools.REMOVE_ITEM.inputSchema.parse(args);
  const success = inventoryRepo.removeItem(parsed.characterId, parsed.itemId, parsed.quantity);
  if (!success) {
    throw new Error(`Failed to remove item. Character may not have enough quantity.`);
  }
  return {
    content: [{
      type: "text",
      text: `Removed ${parsed.quantity} of item ${parsed.itemId} from character ${parsed.characterId}`
    }]
  };
}
async function handleEquipItem(args, _ctx) {
  const { inventoryRepo, itemRepo, charRepo } = ensureDb2();
  const parsed = InventoryTools.EQUIP_ITEM.inputSchema.parse(args);
  const inventory = inventoryRepo.getInventory(parsed.characterId);
  const hasItem = inventory.items.some((i) => i.itemId === parsed.itemId && i.quantity > 0);
  if (!hasItem) {
    throw new Error(`Character does not own item ${parsed.itemId}`);
  }
  const item = itemRepo.findById(parsed.itemId);
  if (!item) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  inventoryRepo.equipItem(parsed.characterId, parsed.itemId, parsed.slot);
  const character = charRepo.findById(parsed.characterId);
  if (character && item.properties) {
    const props = item.properties;
    let newAc = character.ac;
    let acMessage = "";
    if (props.acBonus && typeof props.acBonus === "number") {
      newAc = character.ac + props.acBonus;
      acMessage = ` AC increased by ${props.acBonus} (now ${newAc})`;
    }
    if (props.baseAC && typeof props.baseAC === "number" && parsed.slot === "armor") {
      const dexMod = Math.floor((character.stats.dex - 10) / 2);
      const maxDexBonus = props.maxDexBonus !== void 0 ? Number(props.maxDexBonus) : 99;
      const effectiveDexBonus = Math.min(dexMod, maxDexBonus);
      newAc = props.baseAC + (maxDexBonus > 0 ? effectiveDexBonus : 0);
      acMessage = ` AC set to ${newAc} (base ${props.baseAC}${maxDexBonus < 99 ? ` + DEX max ${maxDexBonus}` : " + DEX"})`;
    }
    if (newAc !== character.ac) {
      charRepo.update(parsed.characterId, { ac: newAc });
    }
    return {
      content: [{
        type: "text",
        text: `Equipped ${item.name} in slot ${parsed.slot}.${acMessage}`
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: `Equipped item ${parsed.itemId} in slot ${parsed.slot}`
    }]
  };
}
async function handleUnequipItem(args, _ctx) {
  const { inventoryRepo, itemRepo, charRepo } = ensureDb2();
  const parsed = InventoryTools.UNEQUIP_ITEM.inputSchema.parse(args);
  const item = itemRepo.findById(parsed.itemId);
  const inventory = inventoryRepo.getInventory(parsed.characterId);
  const equippedItem = inventory.items.find((i) => i.itemId === parsed.itemId && i.equipped);
  const slot = equippedItem?.slot;
  inventoryRepo.unequipItem(parsed.characterId, parsed.itemId);
  const character = charRepo.findById(parsed.characterId);
  if (character && item?.properties) {
    const props = item.properties;
    let newAc = character.ac;
    let acMessage = "";
    if (props.acBonus && typeof props.acBonus === "number") {
      newAc = Math.max(10, character.ac - props.acBonus);
      acMessage = ` AC decreased by ${props.acBonus} (now ${newAc})`;
    }
    if (props.baseAC && typeof props.baseAC === "number" && slot === "armor") {
      const dexMod = Math.floor((character.stats.dex - 10) / 2);
      newAc = 10 + dexMod;
      acMessage = ` AC reverted to unarmored (${newAc})`;
    }
    if (newAc !== character.ac) {
      charRepo.update(parsed.characterId, { ac: newAc });
    }
    return {
      content: [{
        type: "text",
        text: `Unequipped ${item.name}.${acMessage}`
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: `Unequipped item ${parsed.itemId}`
    }]
  };
}
async function handleGetInventory(args, _ctx) {
  const { inventoryRepo } = ensureDb2();
  const parsed = InventoryTools.GET_INVENTORY.inputSchema.parse(args);
  const inventory = inventoryRepo.getInventory(parsed.characterId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(inventory, null, 2)
    }]
  };
}
async function handleGetItem(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.GET_ITEM.inputSchema.parse(args);
  const item = itemRepo.findById(parsed.itemId);
  if (!item) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ item }, null, 2)
    }]
  };
}
async function handleListItems(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.LIST_ITEMS.inputSchema.parse(args);
  let items;
  if (parsed.type) {
    items = itemRepo.findByType(parsed.type);
  } else {
    items = itemRepo.findAll();
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ items, count: items.length }, null, 2)
    }]
  };
}
async function handleSearchItems(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.SEARCH_ITEMS.inputSchema.parse(args);
  const items = itemRepo.search(parsed);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ items, count: items.length, query: parsed }, null, 2)
    }]
  };
}
async function handleUpdateItem(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.UPDATE_ITEM.inputSchema.parse(args);
  const { itemId, ...updates } = parsed;
  const item = itemRepo.update(itemId, updates);
  if (!item) {
    throw new Error(`Item not found: ${itemId}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ item, message: "Item updated successfully" }, null, 2)
    }]
  };
}
async function handleDeleteItem(args, _ctx) {
  const { itemRepo } = ensureDb2();
  const parsed = InventoryTools.DELETE_ITEM.inputSchema.parse(args);
  const existing = itemRepo.findById(parsed.itemId);
  if (!existing) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  itemRepo.delete(parsed.itemId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ message: `Item "${existing.name}" deleted successfully`, itemId: parsed.itemId }, null, 2)
    }]
  };
}
async function handleTransferItem(args, _ctx) {
  const { inventoryRepo, itemRepo } = ensureDb2();
  const parsed = InventoryTools.TRANSFER_ITEM.inputSchema.parse(args);
  const item = itemRepo.findById(parsed.itemId);
  if (!item) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  const success = inventoryRepo.transferItem(parsed.fromCharacterId, parsed.toCharacterId, parsed.itemId, parsed.quantity);
  if (!success) {
    throw new Error(`Transfer failed. Source may not have enough quantity or item is equipped.`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Transferred ${parsed.quantity}x ${item.name}`,
        from: parsed.fromCharacterId,
        to: parsed.toCharacterId,
        item: item.name,
        quantity: parsed.quantity
      }, null, 2)
    }]
  };
}
async function handleUseItem(args, _ctx) {
  const { inventoryRepo, itemRepo } = ensureDb2();
  const parsed = InventoryTools.USE_ITEM.inputSchema.parse(args);
  const item = itemRepo.findById(parsed.itemId);
  if (!item) {
    throw new Error(`Item not found: ${parsed.itemId}`);
  }
  if (item.type !== "consumable") {
    throw new Error(`Item "${item.name}" is not a consumable (type: ${item.type})`);
  }
  const inventory = inventoryRepo.getInventory(parsed.characterId);
  const hasItem = inventory.items.some((i) => i.itemId === parsed.itemId && i.quantity > 0);
  if (!hasItem) {
    throw new Error(`Character does not have item "${item.name}"`);
  }
  const removed = inventoryRepo.removeItem(parsed.characterId, parsed.itemId, 1);
  if (!removed) {
    throw new Error(`Failed to consume item`);
  }
  const effect = item.properties?.effect || item.properties?.effects || "No defined effect";
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Used ${item.name}`,
        item: {
          id: item.id,
          name: item.name,
          description: item.description
        },
        effect,
        target: parsed.targetId || parsed.characterId,
        consumed: true
      }, null, 2)
    }]
  };
}
async function handleGetInventoryDetailed(args, _ctx) {
  const { inventoryRepo } = ensureDb2();
  const parsed = InventoryTools.GET_INVENTORY_DETAILED.inputSchema.parse(args);
  const inventory = inventoryRepo.getInventoryWithDetails(parsed.characterId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(inventory, null, 2)
    }]
  };
}

// dist/server/quest-tools.js
init_zod();
var import_crypto5 = require("crypto");

// dist/schema/quest.js
init_zod();
var QuestSchema = external_exports.object({
  id: external_exports.string(),
  worldId: external_exports.string(),
  name: external_exports.string(),
  description: external_exports.string(),
  status: external_exports.enum(["available", "active", "completed", "failed"]),
  objectives: external_exports.array(external_exports.object({
    id: external_exports.string(),
    description: external_exports.string(),
    type: external_exports.enum(["kill", "collect", "deliver", "explore", "interact", "custom"]),
    target: external_exports.string(),
    // Entity ID, item ID, location, etc.
    required: external_exports.number().int().min(1),
    current: external_exports.number().int().min(0).default(0),
    completed: external_exports.boolean().default(false)
  })),
  rewards: external_exports.object({
    experience: external_exports.number().int().min(0).default(0),
    gold: external_exports.number().int().min(0).default(0),
    items: external_exports.array(external_exports.string()).default([])
    // Item IDs
  }),
  prerequisites: external_exports.array(external_exports.string()).default([]),
  // Quest IDs that must be completed first
  giver: external_exports.string().optional(),
  // NPC ID
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var QuestLogSchema = external_exports.object({
  characterId: external_exports.string(),
  activeQuests: external_exports.array(external_exports.string()),
  // Quest IDs
  completedQuests: external_exports.array(external_exports.string()),
  failedQuests: external_exports.array(external_exports.string())
});

// dist/storage/repos/quest.repo.js
var QuestRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(quest) {
    const validQuest = QuestSchema.parse(quest);
    const stmt = this.db.prepare(`
            INSERT INTO quests (id, world_id, name, description, status, objectives, rewards, prerequisites, giver, created_at, updated_at)
            VALUES (@id, @worldId, @name, @description, @status, @objectives, @rewards, @prerequisites, @giver, @createdAt, @updatedAt)
        `);
    stmt.run({
      id: validQuest.id,
      worldId: validQuest.worldId,
      name: validQuest.name,
      description: validQuest.description,
      status: validQuest.status,
      objectives: JSON.stringify(validQuest.objectives),
      rewards: JSON.stringify(validQuest.rewards),
      prerequisites: JSON.stringify(validQuest.prerequisites),
      giver: validQuest.giver || null,
      createdAt: validQuest.createdAt,
      updatedAt: validQuest.updatedAt
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM quests WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToQuest(row);
  }
  update(id, updates) {
    const existing = this.findById(id);
    if (!existing)
      return null;
    const updated = {
      ...existing,
      ...updates,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const validQuest = QuestSchema.parse(updated);
    const stmt = this.db.prepare(`
            UPDATE quests
            SET name = ?, description = ?, status = ?, objectives = ?, rewards = ?, prerequisites = ?, giver = ?, updated_at = ?
            WHERE id = ?
        `);
    stmt.run(validQuest.name, validQuest.description, validQuest.status, JSON.stringify(validQuest.objectives), JSON.stringify(validQuest.rewards), JSON.stringify(validQuest.prerequisites), validQuest.giver || null, validQuest.updatedAt, id);
    return validQuest;
  }
  getLog(characterId) {
    const stmt = this.db.prepare("SELECT * FROM quest_logs WHERE character_id = ?");
    const row = stmt.get(characterId);
    if (!row)
      return null;
    return this.rowToQuestLog(row);
  }
  /**
   * Get full quest log with complete quest objects (not just IDs)
   * Returns quests organized by status with full details
   */
  getFullQuestLog(characterId) {
    const log = this.getLog(characterId);
    if (!log) {
      return {
        characterId,
        quests: [],
        summary: { active: 0, completed: 0, failed: 0 }
      };
    }
    const quests = [];
    for (const questId of log.activeQuests) {
      const quest = this.findById(questId);
      if (quest) {
        quests.push({
          ...quest,
          logStatus: "active"
        });
      }
    }
    for (const questId of log.completedQuests) {
      const quest = this.findById(questId);
      if (quest) {
        quests.push({
          ...quest,
          logStatus: "completed"
        });
      }
    }
    for (const questId of log.failedQuests) {
      const quest = this.findById(questId);
      if (quest) {
        quests.push({
          ...quest,
          logStatus: "failed"
        });
      }
    }
    return {
      characterId,
      quests,
      summary: {
        active: log.activeQuests.length,
        completed: log.completedQuests.length,
        failed: log.failedQuests.length
      }
    };
  }
  /**
   * Find all quests, optionally filtered by world
   */
  findAll(worldId) {
    let stmt;
    if (worldId) {
      stmt = this.db.prepare("SELECT * FROM quests WHERE world_id = ?");
      const rows = stmt.all(worldId);
      return rows.map((row) => this.rowToQuest(row));
    } else {
      stmt = this.db.prepare("SELECT * FROM quests");
      const rows = stmt.all();
      return rows.map((row) => this.rowToQuest(row));
    }
  }
  /**
   * Update a specific objective's progress
   */
  updateObjectiveProgress(questId, objectiveId, progress) {
    const quest = this.findById(questId);
    if (!quest)
      return null;
    const objectiveIndex = quest.objectives.findIndex((o) => o.id === objectiveId);
    if (objectiveIndex === -1)
      return null;
    const objective = quest.objectives[objectiveIndex];
    objective.current = Math.min(objective.required, objective.current + progress);
    if (objective.current >= objective.required) {
      objective.completed = true;
    }
    quest.objectives[objectiveIndex] = objective;
    return this.update(quest.id, { objectives: quest.objectives });
  }
  /**
   * Check if all objectives for a quest are completed
   */
  areAllObjectivesComplete(questId) {
    const quest = this.findById(questId);
    if (!quest)
      return false;
    return quest.objectives.every((o) => o.completed);
  }
  /**
   * Complete a specific objective (set current = required)
   */
  completeObjective(questId, objectiveId) {
    const quest = this.findById(questId);
    if (!quest)
      return null;
    const objectiveIndex = quest.objectives.findIndex((o) => o.id === objectiveId);
    if (objectiveIndex === -1)
      return null;
    const objective = quest.objectives[objectiveIndex];
    objective.current = objective.required;
    objective.completed = true;
    quest.objectives[objectiveIndex] = objective;
    return this.update(quest.id, { objectives: quest.objectives });
  }
  updateLog(log) {
    const validLog = QuestLogSchema.parse(log);
    const stmt = this.db.prepare(`
            INSERT INTO quest_logs (character_id, active_quests, completed_quests, failed_quests)
            VALUES (@characterId, @activeQuests, @completedQuests, @failedQuests)
            ON CONFLICT(character_id) DO UPDATE SET
                active_quests = excluded.active_quests,
                completed_quests = excluded.completed_quests,
                failed_quests = excluded.failed_quests
        `);
    stmt.run({
      characterId: validLog.characterId,
      activeQuests: JSON.stringify(validLog.activeQuests),
      completedQuests: JSON.stringify(validLog.completedQuests),
      failedQuests: JSON.stringify(validLog.failedQuests)
    });
  }
  rowToQuest(row) {
    return QuestSchema.parse({
      id: row.id,
      worldId: row.world_id,
      name: row.name,
      description: row.description,
      status: row.status,
      objectives: JSON.parse(row.objectives),
      rewards: JSON.parse(row.rewards),
      prerequisites: JSON.parse(row.prerequisites),
      giver: row.giver || void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
  rowToQuestLog(row) {
    return QuestLogSchema.parse({
      characterId: row.character_id,
      activeQuests: JSON.parse(row.active_quests),
      completedQuests: JSON.parse(row.completed_quests),
      failedQuests: JSON.parse(row.failed_quests)
    });
  }
};

// dist/server/quest-tools.js
init_character_repo();
function ensureDb3() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const questRepo = new QuestRepository(db);
  const characterRepo = new CharacterRepository(db);
  const inventoryRepo = new InventoryRepository(db);
  const itemRepo = new ItemRepository(db);
  return { questRepo, characterRepo, inventoryRepo, itemRepo };
}
var QuestTools = {
  CREATE_QUEST: {
    name: "create_quest",
    description: "Define a new quest in the world.",
    inputSchema: QuestSchema.omit({ id: true, createdAt: true, updatedAt: true })
  },
  GET_QUEST: {
    name: "get_quest",
    description: "Get a single quest by ID with full details.",
    inputSchema: external_exports.object({
      questId: external_exports.string()
    })
  },
  LIST_QUESTS: {
    name: "list_quests",
    description: "List all quests, optionally filtered by world.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().optional()
    })
  },
  ASSIGN_QUEST: {
    name: "assign_quest",
    description: "Assign a quest to a character.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      questId: external_exports.string()
    })
  },
  UPDATE_OBJECTIVE: {
    name: "update_objective",
    description: "Update progress on a quest objective.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      questId: external_exports.string(),
      objectiveId: external_exports.string(),
      progress: external_exports.number().int().min(1).default(1)
    })
  },
  COMPLETE_OBJECTIVE: {
    name: "complete_objective",
    description: "Mark an objective as fully completed.",
    inputSchema: external_exports.object({
      questId: external_exports.string(),
      objectiveId: external_exports.string()
    })
  },
  COMPLETE_QUEST: {
    name: "complete_quest",
    description: "Mark a quest as completed and grant rewards.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      questId: external_exports.string()
    })
  },
  GET_QUEST_LOG: {
    name: "get_quest_log",
    description: "Get the quest log for a character.",
    inputSchema: external_exports.object({
      characterId: external_exports.string()
    })
  }
};
async function handleCreateQuest(args, _ctx) {
  const { questRepo } = ensureDb3();
  const parsed = QuestTools.CREATE_QUEST.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const objectives = parsed.objectives.map((obj) => ({
    ...obj,
    id: obj.id || (0, import_crypto5.randomUUID)(),
    current: obj.current ?? 0,
    completed: obj.completed ?? false
  }));
  const quest = {
    ...parsed,
    objectives,
    id: (0, import_crypto5.randomUUID)(),
    createdAt: now,
    updatedAt: now
  };
  questRepo.create(quest);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(quest, null, 2)
    }]
  };
}
async function handleGetQuest(args, _ctx) {
  const { questRepo } = ensureDb3();
  const parsed = QuestTools.GET_QUEST.inputSchema.parse(args);
  const quest = questRepo.findById(parsed.questId);
  if (!quest) {
    throw new Error(`Quest ${parsed.questId} not found`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(quest, null, 2)
    }]
  };
}
async function handleListQuests(args, _ctx) {
  const { questRepo } = ensureDb3();
  const parsed = QuestTools.LIST_QUESTS.inputSchema.parse(args);
  const quests = questRepo.findAll(parsed.worldId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ quests, count: quests.length }, null, 2)
    }]
  };
}
async function handleAssignQuest(args, _ctx) {
  const { questRepo, characterRepo } = ensureDb3();
  const parsed = QuestTools.ASSIGN_QUEST.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character)
    throw new Error(`Character ${parsed.characterId} not found`);
  const quest = questRepo.findById(parsed.questId);
  if (!quest)
    throw new Error(`Quest ${parsed.questId} not found`);
  let log = questRepo.getLog(parsed.characterId);
  if (!log) {
    log = {
      characterId: parsed.characterId,
      activeQuests: [],
      completedQuests: [],
      failedQuests: []
    };
  }
  if (log.activeQuests.includes(parsed.questId)) {
    throw new Error(`Quest ${parsed.questId} is already active for character ${parsed.characterId}`);
  }
  if (log.completedQuests.includes(parsed.questId)) {
    throw new Error(`Quest ${parsed.questId} is already completed by character ${parsed.characterId}`);
  }
  for (const prereqId of quest.prerequisites) {
    if (!log.completedQuests.includes(prereqId)) {
      const prereqQuest = questRepo.findById(prereqId);
      const prereqName = prereqQuest?.name || prereqId;
      throw new Error(`Prerequisite quest "${prereqName}" not completed`);
    }
  }
  log.activeQuests.push(parsed.questId);
  questRepo.updateLog(log);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Assigned quest "${quest.name}" to ${character.name}`,
        quest
      }, null, 2)
    }]
  };
}
async function handleUpdateObjective(args, _ctx) {
  const { questRepo, characterRepo } = ensureDb3();
  const parsed = QuestTools.UPDATE_OBJECTIVE.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character)
    throw new Error(`Character ${parsed.characterId} not found`);
  const log = questRepo.getLog(parsed.characterId);
  if (!log || !log.activeQuests.includes(parsed.questId)) {
    throw new Error(`Quest ${parsed.questId} is not active for character ${parsed.characterId}`);
  }
  const quest = questRepo.findById(parsed.questId);
  if (!quest)
    throw new Error(`Quest ${parsed.questId} not found`);
  const objectiveIndex = quest.objectives.findIndex((o) => o.id === parsed.objectiveId);
  if (objectiveIndex === -1)
    throw new Error(`Objective ${parsed.objectiveId} not found in quest`);
  const updatedQuest = questRepo.updateObjectiveProgress(parsed.questId, parsed.objectiveId, parsed.progress);
  if (!updatedQuest) {
    throw new Error("Failed to update objective progress");
  }
  const objective = updatedQuest.objectives[objectiveIndex];
  const allComplete = questRepo.areAllObjectivesComplete(parsed.questId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Updated objective: ${objective.description}`,
        objective: {
          id: objective.id,
          description: objective.description,
          progress: `${objective.current}/${objective.required}`,
          completed: objective.completed
        },
        questComplete: allComplete,
        quest: updatedQuest
      }, null, 2)
    }]
  };
}
async function handleCompleteObjective(args, _ctx) {
  const { questRepo } = ensureDb3();
  const parsed = QuestTools.COMPLETE_OBJECTIVE.inputSchema.parse(args);
  const quest = questRepo.findById(parsed.questId);
  if (!quest)
    throw new Error(`Quest ${parsed.questId} not found`);
  const objectiveIndex = quest.objectives.findIndex((o) => o.id === parsed.objectiveId);
  if (objectiveIndex === -1)
    throw new Error(`Objective ${parsed.objectiveId} not found`);
  const updatedQuest = questRepo.completeObjective(parsed.questId, parsed.objectiveId);
  if (!updatedQuest) {
    throw new Error("Failed to complete objective");
  }
  const objective = updatedQuest.objectives[objectiveIndex];
  const allComplete = questRepo.areAllObjectivesComplete(parsed.questId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Completed objective: ${objective.description}`,
        objective: {
          id: objective.id,
          description: objective.description,
          completed: true
        },
        questComplete: allComplete,
        quest: updatedQuest
      }, null, 2)
    }]
  };
}
async function handleCompleteQuest(args, _ctx) {
  const { questRepo, characterRepo, inventoryRepo, itemRepo } = ensureDb3();
  const parsed = QuestTools.COMPLETE_QUEST.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character)
    throw new Error(`Character ${parsed.characterId} not found`);
  const quest = questRepo.findById(parsed.questId);
  if (!quest)
    throw new Error(`Quest ${parsed.questId} not found`);
  let log = questRepo.getLog(parsed.characterId);
  if (!log || !log.activeQuests.includes(parsed.questId)) {
    throw new Error(`Quest "${quest.name}" is not active for character ${character.name}`);
  }
  const allCompleted = quest.objectives.every((o) => o.completed);
  if (!allCompleted) {
    const incomplete = quest.objectives.filter((o) => !o.completed);
    throw new Error(`Not all objectives completed. Remaining: ${incomplete.map((o) => o.description).join(", ")}`);
  }
  const rewardsGranted = {
    items: []
  };
  if (quest.rewards.experience > 0) {
    rewardsGranted.xp = quest.rewards.experience;
  }
  if (quest.rewards.gold > 0) {
    rewardsGranted.gold = quest.rewards.gold;
  }
  for (const itemId of quest.rewards.items) {
    try {
      inventoryRepo.addItem(parsed.characterId, itemId, 1);
      const item = itemRepo.findById(itemId);
      rewardsGranted.items.push(item?.name || itemId);
    } catch (err) {
      rewardsGranted.items.push(`${itemId} (item not found)`);
    }
  }
  log.activeQuests = log.activeQuests.filter((id) => id !== parsed.questId);
  log.completedQuests.push(parsed.questId);
  questRepo.updateLog(log);
  questRepo.update(parsed.questId, { status: "completed" });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Completed quest: "${quest.name}"!`,
        character: character.name,
        rewards: {
          xp: rewardsGranted.xp || 0,
          gold: rewardsGranted.gold || 0,
          items: rewardsGranted.items
        },
        quest: {
          id: quest.id,
          name: quest.name,
          status: "completed"
        }
      }, null, 2)
    }]
  };
}
async function handleGetQuestLog(args, _ctx) {
  const { questRepo, characterRepo } = ensureDb3();
  const parsed = QuestTools.GET_QUEST_LOG.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const fullLog = questRepo.getFullQuestLog(parsed.characterId);
  const quests = fullLog.quests.map((quest) => ({
    id: quest.id,
    title: quest.name,
    name: quest.name,
    description: quest.description,
    status: quest.logStatus,
    questGiver: quest.giver,
    objectives: quest.objectives.map((obj) => ({
      id: obj.id,
      description: obj.description,
      type: obj.type,
      target: obj.target,
      current: obj.current,
      required: obj.required,
      completed: obj.completed,
      progress: `${obj.current}/${obj.required}`
    })),
    rewards: {
      experience: quest.rewards.experience,
      gold: quest.rewards.gold,
      items: quest.rewards.items
    },
    prerequisites: quest.prerequisites
  }));
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characterId: parsed.characterId,
        characterName: character.name,
        quests,
        summary: fullLog.summary
      }, null, 2)
    }]
  };
}

// dist/server/math-tools.js
init_zod();

// dist/math/dice.js
var import_seedrandom7 = __toESM(require_seedrandom2(), 1);
var DiceEngine = class {
  rng;
  seed;
  constructor(seed) {
    this.seed = seed || (/* @__PURE__ */ new Date()).toISOString();
    this.rng = (0, import_seedrandom7.default)(this.seed);
  }
  // Parse string "2d6+4" into DiceExpression object
  parse(expression) {
    const match = expression.match(/^(\d+)?d(\d+)(?:(dl|dh|kl|kh)(\d+))?([+-]\d+)?(!)?$/);
    if (!match) {
      throw new Error(`Invalid dice expression: ${expression}`);
    }
    const count = match[1] ? parseInt(match[1], 10) : 1;
    const sides = parseInt(match[2], 10);
    const modifierType = match[3];
    const modifierCount = match[4] ? parseInt(match[4], 10) : 0;
    const modifier = match[5] ? parseInt(match[5], 10) : 0;
    const explode = !!match[6];
    const result = {
      count,
      sides,
      modifier,
      explode
    };
    if (modifierType === "dl")
      result.dropLowest = modifierCount;
    else if (modifierType === "dh")
      result.dropHighest = modifierCount;
    else if (modifierType === "kl")
      result.keepLowest = modifierCount;
    else if (modifierType === "kh")
      result.keepHighest = modifierCount;
    return result;
  }
  roll(expression) {
    const expr = typeof expression === "string" ? this.parse(expression) : expression;
    const rolls = [];
    const steps = [];
    let total = 0;
    if (expr.advantage || expr.disadvantage) {
      const set1 = this.rollSet(expr);
      const set2 = this.rollSet(expr);
      steps.push(`Roll 1: [${set1.rolls.join(", ")}] = ${set1.sum}`);
      steps.push(`Roll 2: [${set2.rolls.join(", ")}] = ${set2.sum}`);
      let chosenSet;
      if (expr.advantage) {
        chosenSet = set1.sum >= set2.sum ? set1 : set2;
        steps.push(`Advantage: Taken ${chosenSet.sum}`);
      } else {
        chosenSet = set1.sum <= set2.sum ? set1 : set2;
        steps.push(`Disadvantage: Taken ${chosenSet.sum}`);
      }
      total = chosenSet.sum + expr.modifier;
      steps.push(`Total: ${chosenSet.sum} + ${expr.modifier} = ${total}`);
      rolls.push(...chosenSet.rolls);
    } else {
      const set = this.rollSet(expr);
      rolls.push(...set.rolls);
      total = set.sum + expr.modifier;
      steps.push(`Rolled ${expr.count}d${expr.sides}: [${set.rolls.join(", ")}]`);
      if (set.dropped && set.dropped.length > 0) {
        steps.push(`Kept: [${set.kept?.join(", ")}], Dropped: [${set.dropped.join(", ")}]`);
        steps.push(`Sum of kept dice: ${set.sum}`);
      }
      if (expr.modifier !== 0) {
        steps.push(`Modifier: ${expr.modifier}`);
        steps.push(`Total: ${set.sum} + ${expr.modifier} = ${total}`);
      } else {
        steps.push(`Total: ${total}`);
      }
    }
    return {
      input: typeof expression === "string" ? expression : `${expr.count}d${expr.sides}${expr.modifier >= 0 ? "+" : ""}${expr.modifier}`,
      result: total,
      steps,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      seed: this.seed,
      metadata: { rolls }
    };
  }
  rollSet(expr) {
    const rolls = [];
    for (let i = 0; i < expr.count; i++) {
      let roll = Math.floor(this.rng() * expr.sides) + 1;
      rolls.push(roll);
      if (expr.explode && roll === expr.sides) {
        let exploded = roll;
        while (exploded === expr.sides) {
          exploded = Math.floor(this.rng() * expr.sides) + 1;
          rolls.push(exploded);
        }
      }
    }
    let keptRolls = [...rolls];
    let droppedRolls = [];
    if (expr.dropLowest && expr.dropLowest > 0) {
      const sorted = [...rolls].sort((a, b) => a - b);
      droppedRolls = sorted.slice(0, expr.dropLowest);
      keptRolls = sorted.slice(expr.dropLowest);
    } else if (expr.dropHighest && expr.dropHighest > 0) {
      const sorted = [...rolls].sort((a, b) => b - a);
      droppedRolls = sorted.slice(0, expr.dropHighest);
      keptRolls = sorted.slice(expr.dropHighest);
    } else if (expr.keepLowest && expr.keepLowest > 0) {
      const sorted = [...rolls].sort((a, b) => a - b);
      keptRolls = sorted.slice(0, expr.keepLowest);
      droppedRolls = sorted.slice(expr.keepLowest);
    } else if (expr.keepHighest && expr.keepHighest > 0) {
      const sorted = [...rolls].sort((a, b) => b - a);
      keptRolls = sorted.slice(0, expr.keepHighest);
      droppedRolls = sorted.slice(expr.keepHighest);
    }
    const sum = keptRolls.reduce((acc, val) => acc + val, 0);
    return { rolls, sum, kept: keptRolls, dropped: droppedRolls.length > 0 ? droppedRolls : void 0 };
  }
};

// dist/math/probability.js
var ProbabilityEngine = class {
  diceEngine = new DiceEngine();
  getDistribution(expression) {
    const expr = typeof expression === "string" ? this.diceEngine.parse(expression) : expression;
    let dist = this.singleDieDistribution(expr.sides, !!expr.explode);
    let totalDist = dist;
    for (let i = 1; i < expr.count; i++) {
      totalDist = this.convolve(totalDist, dist);
    }
    dist = totalDist;
    if (expr.advantage) {
      dist = this.applyAdvantage(dist);
    } else if (expr.disadvantage) {
      dist = this.applyDisadvantage(dist);
    }
    if (expr.modifier !== 0) {
      dist = this.shift(dist, expr.modifier);
    }
    return dist;
  }
  calculateProbability(expression, target, comparison = "gte") {
    const dist = this.getDistribution(expression);
    let prob = 0;
    for (const [v, p] of dist) {
      let match = false;
      switch (comparison) {
        case "gte":
          match = v >= target;
          break;
        case "lte":
          match = v <= target;
          break;
        case "eq":
          match = v === target;
          break;
        case "gt":
          match = v > target;
          break;
        case "lt":
          match = v < target;
          break;
      }
      if (match)
        prob += p;
    }
    return prob;
  }
  expectedValue(expression) {
    const dist = this.getDistribution(expression);
    let ev = 0;
    for (const [v, p] of dist) {
      ev += v * p;
    }
    return ev;
  }
  compare(exprA, exprB) {
    const distA = this.getDistribution(exprA);
    const distB = this.getDistribution(exprB);
    const distNegB = /* @__PURE__ */ new Map();
    for (const [v, p] of distB) {
      distNegB.set(-v, p);
    }
    const distDiff = this.convolve(distA, distNegB);
    let prob = 0;
    for (const [v, p] of distDiff) {
      if (v > 0)
        prob += p;
    }
    return prob;
  }
  singleDieDistribution(sides, explode) {
    const dist = /* @__PURE__ */ new Map();
    if (!explode) {
      const prob = 1 / sides;
      for (let i = 1; i <= sides; i++) {
        dist.set(i, prob);
      }
      return dist;
    } else {
      let currentProb = 1 / sides;
      let offset = 0;
      const threshold = 1e-9;
      let iterations = 0;
      const maxIterations = 20;
      while (currentProb > threshold && iterations < maxIterations) {
        for (let i = 1; i < sides; i++) {
          dist.set(offset + i, currentProb);
        }
        offset += sides;
        currentProb /= sides;
        iterations++;
      }
      return dist;
    }
  }
  convolve(d1, d2) {
    const result = /* @__PURE__ */ new Map();
    for (const [v1, p1] of d1) {
      for (const [v2, p2] of d2) {
        const sum = v1 + v2;
        const p = p1 * p2;
        result.set(sum, (result.get(sum) || 0) + p);
      }
    }
    return result;
  }
  applyAdvantage(d) {
    return this.orderStatistic(d, "max");
  }
  applyDisadvantage(d) {
    return this.orderStatistic(d, "min");
  }
  orderStatistic(d, type) {
    const result = /* @__PURE__ */ new Map();
    const sortedKeys = Array.from(d.keys()).sort((a, b) => a - b);
    const cdf = /* @__PURE__ */ new Map();
    let cumProb = 0;
    for (const k of sortedKeys) {
      cumProb += d.get(k);
      cdf.set(k, cumProb);
    }
    for (let i = 0; i < sortedKeys.length; i++) {
      const k = sortedKeys[i];
      const pk = d.get(k);
      const cdfK = cdf.get(k);
      const cdfKMinus1 = i > 0 ? cdf.get(sortedKeys[i - 1]) : 0;
      let newProb;
      if (type === "max") {
        newProb = pk * (cdfK + cdfKMinus1);
      } else {
        newProb = pk * (2 - cdfK - cdfKMinus1);
      }
      result.set(k, newProb);
    }
    return result;
  }
  shift(d, amount) {
    const result = /* @__PURE__ */ new Map();
    for (const [v, p] of d) {
      result.set(v + amount, p);
    }
    return result;
  }
};

// dist/math/algebra.js
var import_nerdamer = __toESM(require_nerdamer_core(), 1);
var import_Solve = __toESM(require_Solve(), 1);
var import_Algebra = __toESM(require_Algebra(), 1);
var import_Calculus = __toESM(require_Calculus(), 1);
var AlgebraEngine = class {
  solve(equation, variable) {
    try {
      const solution = import_nerdamer.default.solve(equation, variable);
      return {
        input: `solve(${equation}, ${variable})`,
        result: solution.toString(),
        steps: [`Solved for ${variable}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      return {
        input: `solve(${equation}, ${variable})`,
        result: "Error",
        steps: [`Failed to solve: ${error.message}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
  simplify(expression) {
    try {
      const simplified = (0, import_nerdamer.default)(expression).toString();
      return {
        input: `simplify(${expression})`,
        result: simplified,
        steps: ["Simplified expression"],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      return {
        input: `simplify(${expression})`,
        result: "Error",
        steps: [`Failed to simplify: ${error.message}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
  substitute(expression, variables) {
    try {
      const stringVars = {};
      for (const [k, v] of Object.entries(variables)) {
        stringVars[k] = String(v);
      }
      const evaluated = (0, import_nerdamer.default)(expression, stringVars).evaluate();
      return {
        input: `substitute(${expression}, ${JSON.stringify(variables)})`,
        result: evaluated.text(),
        // .text() returns string representation of result
        steps: [`Substituted variables: ${JSON.stringify(variables)}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      return {
        input: `substitute(${expression}, ${JSON.stringify(variables)})`,
        result: "Error",
        steps: [`Failed to substitute: ${error.message}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
  differentiate(expression, variable = "x") {
    try {
      const result = import_nerdamer.default.diff(expression, variable);
      return {
        input: `diff(${expression}, ${variable})`,
        result: result.text(),
        steps: [`Differentiated with respect to ${variable}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      return {
        input: `diff(${expression}, ${variable})`,
        result: "Error",
        steps: [`Failed to differentiate: ${error.message}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
  integrate(expression, variable = "x") {
    try {
      const result = import_nerdamer.default.integrate(expression, variable);
      return {
        input: `integrate(${expression}, ${variable})`,
        result: result.text(),
        steps: [`Integrate with respect to ${variable}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    } catch (error) {
      return {
        input: `integrate(${expression}, ${variable})`,
        result: "Error",
        steps: [`Failed to integrate: ${error.message}`],
        timestamp: (/* @__PURE__ */ new Date()).toISOString()
      };
    }
  }
};

// dist/math/physics.js
var PhysicsEngine = class {
  // Projectile motion
  // Returns array of points {x, y, t}
  projectile(v0, angleDeg, gravity = 9.81, steps = 10, initialHeight = 0) {
    const angleRad = angleDeg * (Math.PI / 180);
    const vx = v0 * Math.cos(angleRad);
    const vy = v0 * Math.sin(angleRad);
    const totalTime = (vy + Math.sqrt(vy * vy + 2 * gravity * initialHeight)) / gravity;
    const points = [];
    const dt = totalTime / steps;
    for (let i = 0; i <= steps; i++) {
      const t = i * dt;
      const x = vx * t;
      const y = initialHeight + vy * t - 0.5 * gravity * t * t;
      points.push({ t: Number(t.toFixed(2)), x: Number(x.toFixed(2)), y: Number(y.toFixed(2)) });
    }
    const maxHeight = initialHeight + vy * vy / (2 * gravity);
    const range = vx * totalTime;
    return {
      input: `projectile(v0=${v0}, angle=${angleDeg}, g=${gravity}, h=${initialHeight})`,
      result: JSON.stringify(points),
      steps: [
        `Initial Velocity: ${v0} m/s`,
        `Angle: ${angleDeg} deg`,
        `Initial Height: ${initialHeight} m`,
        `Total Time: ${totalTime.toFixed(2)} s`,
        `Max Height: ${maxHeight.toFixed(2)} m`,
        `Range: ${range.toFixed(2)} m`
      ],
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      metadata: { points, maxHeight, range, flightTime: totalTime }
    };
  }
  // Kinematics (SUVAT)
  // s = ut + 0.5at^2
  // v = u + at
  // v^2 = u^2 + 2as
  // s = 0.5(u+v)t
  // s = vt - 0.5at^2
  // Params: u (initial velocity), v (final velocity), a (acceleration), t (time), s (displacement)
  // Pass object with knowns, solves for unknowns if possible.
  kinematics(params) {
    const { u, v, a, t, s } = params;
    const results = { ...params };
    const steps = [];
    if (v === void 0 && u !== void 0 && a !== void 0 && t !== void 0) {
      results.v = u + a * t;
      steps.push(`v = u + at => ${u} + ${a}*${t} = ${results.v}`);
    }
    if (u === void 0 && v !== void 0 && a !== void 0 && t !== void 0) {
      results.u = v - a * t;
      steps.push(`u = v - at => ${v} - ${a}*${t} = ${results.u}`);
    }
    if (t === void 0 && v !== void 0 && u !== void 0 && a !== void 0 && a !== 0) {
      results.t = (v - u) / a;
      steps.push(`t = (v - u) / a => (${v} - ${u}) / ${a} = ${results.t}`);
    }
    if (a === void 0 && v !== void 0 && u !== void 0 && t !== void 0 && t !== 0) {
      results.a = (v - u) / t;
      steps.push(`a = (v - u) / t => (${v} - ${u}) / ${t} = ${results.a}`);
    }
    if (s === void 0 && u !== void 0 && t !== void 0 && a !== void 0) {
      results.s = u * t + 0.5 * a * t * t;
      steps.push(`s = ut + 0.5at^2 => ${u}*${t} + 0.5*${a}*${t}^2 = ${results.s}`);
    }
    if (v === void 0 && u !== void 0 && a !== void 0 && s !== void 0) {
      const v2 = u * u + 2 * a * s;
      results.v = Math.sqrt(v2);
      steps.push(`v^2 = u^2 + 2as => ${u}^2 + 2*${a}*${s} = ${v2} => v = ${results.v}`);
    }
    return {
      input: `kinematics(${JSON.stringify(params)})`,
      result: JSON.stringify(results),
      steps,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  }
};

// dist/math/export.js
var import_nerdamer2 = __toESM(require_nerdamer_core(), 1);
var ExportEngine = class {
  export(result, format) {
    switch (format) {
      case "latex":
        return this.toLatex(result);
      case "mathml":
        return this.toMathML(result);
      case "plaintext":
        return this.toPlaintext(result);
      case "steps":
        return this.toSteps(result);
      case "json":
        return JSON.stringify(result);
      default:
        throw new Error(`Unsupported export format: ${format}`);
    }
  }
  toLatex(result) {
    if (typeof result.result === "string" && !result.result.startsWith("{")) {
      try {
        return (0, import_nerdamer2.default)(result.result).toTeX();
      } catch {
        return result.result;
      }
    }
    return String(result.result);
  }
  toMathML(result) {
    return `<math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>${result.result}</mtext></math>`;
  }
  toPlaintext(result) {
    return String(result.result);
  }
  toSteps(result) {
    const header = `Input: ${result.input}
Result: ${result.result}

Steps:
`;
    const steps = result.steps.map((s, i) => `${i + 1}. ${s}`).join("\n");
    return header + steps;
  }
};

// dist/math/schemas.js
init_zod();
var DiceExpressionSchema = external_exports.object({
  count: external_exports.number().int().min(1),
  sides: external_exports.number().int().min(1),
  modifier: external_exports.number().int().default(0),
  advantage: external_exports.boolean().optional(),
  disadvantage: external_exports.boolean().optional(),
  explode: external_exports.boolean().optional(),
  dropLowest: external_exports.number().int().min(0).optional(),
  dropHighest: external_exports.number().int().min(0).optional(),
  keepLowest: external_exports.number().int().min(0).optional(),
  keepHighest: external_exports.number().int().min(0).optional()
});
var DiceStringSchema = external_exports.string().regex(/^(\d+)d(\d+)(?:(dl|dh|kl|kh)(\d+))?([+-]\d+)?(!)?$/, {
  message: "Invalid dice format. Expected format like '2d6', '1d20+5', '4d6dl1', '2d20kh1', '3d8-2', '2d6!'"
});
var CalculationResultSchema = external_exports.object({
  input: external_exports.string(),
  result: external_exports.union([external_exports.number(), external_exports.string()]),
  // Result can be a number or a string (e.g. algebraic)
  steps: external_exports.array(external_exports.string()).default([]),
  timestamp: external_exports.string().datetime(),
  seed: external_exports.string().optional(),
  metadata: external_exports.record(external_exports.unknown()).optional()
});
var ProbabilityQuerySchema = external_exports.object({
  expression: external_exports.string(),
  // e.g. "1d20+5"
  target: external_exports.number(),
  comparison: external_exports.enum(["gte", "lte", "eq", "gt", "lt"]).default("gte"),
  modifiers: external_exports.array(external_exports.number()).default([])
});
var ExportFormatSchema = external_exports.enum(["latex", "mathml", "plaintext", "steps", "json"]);

// dist/storage/repos/calculation.repo.js
var CalculationRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(calculation) {
    const stmt = this.db.prepare(`
      INSERT INTO calculations (id, session_id, input, result, steps, seed, timestamp, metadata)
      VALUES (@id, @sessionId, @input, @result, @steps, @seed, @timestamp, @metadata)
    `);
    stmt.run({
      id: calculation.id,
      sessionId: calculation.sessionId || null,
      input: calculation.input,
      result: JSON.stringify(calculation.result),
      steps: calculation.steps ? JSON.stringify(calculation.steps) : null,
      seed: calculation.seed || null,
      timestamp: calculation.timestamp,
      metadata: calculation.metadata ? JSON.stringify(calculation.metadata) : null
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM calculations WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToCalculation(row);
  }
  findBySessionId(sessionId) {
    const stmt = this.db.prepare("SELECT * FROM calculations WHERE session_id = ? ORDER BY timestamp DESC");
    const rows = stmt.all(sessionId);
    return rows.map((row) => this.rowToCalculation(row));
  }
  findAll(limit = 50) {
    const stmt = this.db.prepare("SELECT * FROM calculations ORDER BY timestamp DESC LIMIT ?");
    const rows = stmt.all(limit);
    return rows.map((row) => this.rowToCalculation(row));
  }
  rowToCalculation(row) {
    let result;
    try {
      result = JSON.parse(row.result);
    } catch {
      result = row.result;
    }
    return {
      id: row.id,
      sessionId: row.session_id || void 0,
      ...CalculationResultSchema.parse({
        input: row.input,
        result,
        steps: row.steps ? JSON.parse(row.steps) : [],
        timestamp: row.timestamp,
        seed: row.seed || void 0,
        metadata: row.metadata ? JSON.parse(row.metadata) : void 0
      })
    };
  }
};

// dist/server/math-tools.js
var import_crypto6 = require("crypto");
function getRepo() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return { repo: new CalculationRepository(db), db };
}
function logCalculationEvent(db, calculationId, type, sessionId) {
  db.prepare(`
        INSERT INTO event_logs (type, payload, timestamp)
        VALUES (?, ?, ?)
    `).run("calculation", JSON.stringify({
    calculationId,
    calculationType: type,
    sessionId
  }), (/* @__PURE__ */ new Date()).toISOString());
}
var MathTools = {
  DICE_ROLL: {
    name: "dice_roll",
    description: "Roll dice using standard notation. Supports: basic rolls (2d6+3), drop lowest (4d6dl1), drop highest (4d6dh1), keep lowest (2d20kl1), keep highest (2d20kh1), advantage/disadvantage, and exploding dice (2d6!).",
    inputSchema: external_exports.object({
      expression: external_exports.string(),
      seed: external_exports.string().optional(),
      exportFormat: ExportFormatSchema.optional().default("json")
    })
  },
  PROBABILITY_CALCULATE: {
    name: "probability_calculate",
    description: "Calculate probabilities for dice rolls, including distributions and expected values.",
    inputSchema: ProbabilityQuerySchema.extend({
      exportFormat: ExportFormatSchema.optional().default("plaintext")
    })
  },
  ALGEBRA_SOLVE: {
    name: "algebra_solve",
    description: "Solve algebraic equations.",
    inputSchema: external_exports.object({
      equation: external_exports.string(),
      variable: external_exports.string().optional(),
      exportFormat: ExportFormatSchema.optional().default("plaintext")
    })
  },
  ALGEBRA_SIMPLIFY: {
    name: "algebra_simplify",
    description: "Simplify algebraic expressions.",
    inputSchema: external_exports.object({
      expression: external_exports.string(),
      exportFormat: ExportFormatSchema.optional().default("plaintext")
    })
  },
  PHYSICS_PROJECTILE: {
    name: "physics_projectile",
    description: "Calculate projectile motion trajectory.",
    inputSchema: external_exports.object({
      velocity: external_exports.number(),
      angle: external_exports.number(),
      height: external_exports.number().optional().default(0),
      gravity: external_exports.number().optional().default(9.81),
      exportFormat: ExportFormatSchema.optional().default("plaintext")
    })
  }
};
async function handleDiceRoll(args) {
  const { repo, db } = getRepo();
  const engine = new DiceEngine(args.seed);
  const exporter = new ExportEngine();
  const result = engine.roll(args.expression);
  const calculation = {
    id: (0, import_crypto6.randomUUID)(),
    sessionId: args.sessionId,
    ...result,
    seed: args.seed || result.seed
  };
  repo.create(calculation);
  logCalculationEvent(db, calculation.id, "dice_roll", args.sessionId);
  return {
    content: [
      {
        type: "text",
        text: exporter.export(calculation, args.exportFormat)
      }
    ]
  };
}
async function handleProbabilityCalculate(args) {
  const { repo, db } = getRepo();
  const engine = new ProbabilityEngine();
  const exporter = new ExportEngine();
  const prob = engine.calculateProbability(args.expression, args.target, args.comparison);
  const ev = engine.expectedValue(args.expression);
  const result = {
    input: JSON.stringify(args),
    result: prob,
    steps: [
      `Probability (${args.comparison} ${args.target}): ${(prob * 100).toFixed(2)}%`,
      `Expected Value: ${ev.toFixed(2)}`
    ],
    timestamp: (/* @__PURE__ */ new Date()).toISOString(),
    metadata: { type: "probability", probability: prob, expectedValue: ev }
  };
  const calculation = {
    id: (0, import_crypto6.randomUUID)(),
    sessionId: args.sessionId,
    ...result
  };
  repo.create(calculation);
  logCalculationEvent(db, calculation.id, "probability", args.sessionId);
  return {
    content: [
      {
        type: "text",
        text: exporter.export(calculation, args.exportFormat)
      }
    ]
  };
}
async function handleAlgebraSolve(args) {
  const { repo, db } = getRepo();
  const engine = new AlgebraEngine();
  const exporter = new ExportEngine();
  const result = engine.solve(args.equation, args.variable || "x");
  const calculation = {
    id: (0, import_crypto6.randomUUID)(),
    sessionId: args.sessionId,
    ...result
  };
  repo.create(calculation);
  logCalculationEvent(db, calculation.id, "algebra_solve", args.sessionId);
  return {
    content: [
      {
        type: "text",
        text: exporter.export(calculation, args.exportFormat)
      }
    ]
  };
}
async function handleAlgebraSimplify(args) {
  const { repo, db } = getRepo();
  const engine = new AlgebraEngine();
  const exporter = new ExportEngine();
  const result = engine.simplify(args.expression);
  const calculation = {
    id: (0, import_crypto6.randomUUID)(),
    sessionId: args.sessionId,
    ...result
  };
  repo.create(calculation);
  logCalculationEvent(db, calculation.id, "algebra_simplify", args.sessionId);
  return {
    content: [
      {
        type: "text",
        text: exporter.export(calculation, args.exportFormat)
      }
    ]
  };
}
async function handlePhysicsProjectile(args) {
  const { repo, db } = getRepo();
  const engine = new PhysicsEngine();
  const exporter = new ExportEngine();
  const result = engine.projectile(args.velocity, args.angle, args.gravity, 10, args.height);
  const calculation = {
    id: (0, import_crypto6.randomUUID)(),
    sessionId: args.sessionId,
    ...result
  };
  repo.create(calculation);
  logCalculationEvent(db, calculation.id, "physics_projectile", args.sessionId);
  return {
    content: [
      {
        type: "text",
        text: exporter.export(calculation, args.exportFormat)
      }
    ]
  };
}

// dist/server/strategy-tools.js
init_zod();

// dist/schema/nation.js
init_zod();
var NationResourcesSchema = external_exports.object({
  food: external_exports.number().min(0).default(0),
  metal: external_exports.number().min(0).default(0),
  oil: external_exports.number().min(0).default(0)
});
var NationSchema = external_exports.object({
  id: external_exports.string(),
  worldId: external_exports.string(),
  name: external_exports.string(),
  leader: external_exports.string().describe("Name of the LLM persona leading this nation"),
  ideology: external_exports.enum(["democracy", "autocracy", "theocracy", "tribal"]),
  // Personality Traits (0-100)
  aggression: external_exports.number().int().min(0).max(100),
  trust: external_exports.number().int().min(0).max(100),
  paranoia: external_exports.number().int().min(0).max(100),
  // Economy
  gdp: external_exports.number().min(0),
  resources: NationResourcesSchema,
  relations: external_exports.record(external_exports.object({
    opinion: external_exports.number(),
    alliance: external_exports.boolean(),
    truceUntil: external_exports.number().optional()
  })).default({}),
  // State
  privateMemory: external_exports.record(external_exports.any()).optional().describe("LLM-only private memory"),
  publicIntent: external_exports.string().optional().describe("Publicly declared intent"),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});

// dist/storage/repos/nation.repo.js
var NationRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(nation) {
    const validNation = NationSchema.parse(nation);
    const stmt = this.db.prepare(`
      INSERT INTO nations (
        id, world_id, name, leader, ideology, aggression, trust, paranoia,
        gdp, resources, relations, private_memory, public_intent,
        created_at, updated_at
      )
      VALUES (
        @id, @worldId, @name, @leader, @ideology, @aggression, @trust, @paranoia,
        @gdp, @resources, @relations, @privateMemory, @publicIntent,
        @createdAt, @updatedAt
      )
    `);
    stmt.run({
      ...validNation,
      resources: JSON.stringify(validNation.resources),
      relations: JSON.stringify(validNation.relations || {}),
      // Default to empty object if undefined
      privateMemory: JSON.stringify(validNation.privateMemory || {}),
      publicIntent: validNation.publicIntent || null
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM nations WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.mapRowToNation(row);
  }
  findByWorldId(worldId) {
    const stmt = this.db.prepare("SELECT * FROM nations WHERE world_id = ?");
    const rows = stmt.all(worldId);
    return rows.map((row) => this.mapRowToNation(row));
  }
  updateResources(nationId, resources) {
    const stmt = this.db.prepare(`
      UPDATE nations 
      SET resources = ?, updated_at = ?
      WHERE id = ?
    `);
    stmt.run(JSON.stringify(resources), (/* @__PURE__ */ new Date()).toISOString(), nationId);
  }
  updateTraits(nationId, traits) {
    const updates = [];
    const params = [];
    if (traits.aggression !== void 0) {
      updates.push("aggression = ?");
      params.push(traits.aggression);
    }
    if (traits.trust !== void 0) {
      updates.push("trust = ?");
      params.push(traits.trust);
    }
    if (traits.paranoia !== void 0) {
      updates.push("paranoia = ?");
      params.push(traits.paranoia);
    }
    if (updates.length === 0)
      return;
    updates.push("updated_at = ?");
    params.push((/* @__PURE__ */ new Date()).toISOString());
    params.push(nationId);
    const stmt = this.db.prepare(`UPDATE nations SET ${updates.join(", ")} WHERE id = ?`);
    stmt.run(...params);
  }
  mapRowToNation(row) {
    return NationSchema.parse({
      id: row.id,
      worldId: row.world_id,
      name: row.name,
      leader: row.leader,
      ideology: row.ideology,
      aggression: row.aggression,
      trust: row.trust,
      paranoia: row.paranoia,
      gdp: row.gdp,
      resources: JSON.parse(row.resources),
      relations: JSON.parse(row.relations || "{}"),
      // Handle potentially null relations in DB
      privateMemory: row.private_memory ? JSON.parse(row.private_memory) : void 0,
      publicIntent: row.public_intent || void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// dist/schema/diplomacy.js
init_zod();
var DiplomaticRelationSchema = external_exports.object({
  fromNationId: external_exports.string(),
  toNationId: external_exports.string(),
  opinion: external_exports.number().int().min(-100).max(100).default(0),
  isAllied: external_exports.boolean().default(false),
  truceUntil: external_exports.number().int().optional().describe("Turn number when truce expires"),
  updatedAt: external_exports.string().datetime()
});
var TerritorialClaimSchema = external_exports.object({
  id: external_exports.string(),
  nationId: external_exports.string(),
  regionId: external_exports.string(),
  claimStrength: external_exports.number().int().min(0).max(100),
  justification: external_exports.string().optional(),
  createdAt: external_exports.string().datetime()
});
var NationEventSchema = external_exports.object({
  id: external_exports.number().optional(),
  // Auto-increment in DB
  worldId: external_exports.string(),
  turnNumber: external_exports.number().int(),
  eventType: external_exports.enum([
    "ALLIANCE_FORMED",
    "ALLIANCE_BROKEN",
    "WAR_DECLARED",
    "PEACE_SIGNED",
    "REGION_CLAIMED",
    "REGION_CONQUERED",
    "REGION_TRANSFERRED",
    "DIPLOMATIC_MESSAGE",
    "RESOURCE_TRANSFER"
  ]),
  involvedNations: external_exports.array(external_exports.string()),
  details: external_exports.record(external_exports.any()),
  timestamp: external_exports.string().datetime()
});

// dist/storage/repos/diplomacy.repo.js
var DiplomacyRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  upsertRelation(relation) {
    const validRelation = DiplomaticRelationSchema.parse(relation);
    const stmt = this.db.prepare(`
      INSERT INTO diplomatic_relations (
        from_nation_id, to_nation_id, opinion, is_allied, truce_until, updated_at
      )
      VALUES (
        @fromNationId, @toNationId, @opinion, @isAllied, @truceUntil, @updatedAt
      )
      ON CONFLICT(from_nation_id, to_nation_id) DO UPDATE SET
        opinion = excluded.opinion,
        is_allied = excluded.is_allied,
        truce_until = excluded.truce_until,
        updated_at = excluded.updated_at
    `);
    stmt.run({
      ...validRelation,
      isAllied: validRelation.isAllied ? 1 : 0,
      truceUntil: validRelation.truceUntil || null
    });
  }
  getRelation(fromNationId, toNationId) {
    const stmt = this.db.prepare(`
      SELECT * FROM diplomatic_relations 
      WHERE from_nation_id = ? AND to_nation_id = ?
    `);
    const row = stmt.get(fromNationId, toNationId);
    if (!row)
      return null;
    return DiplomaticRelationSchema.parse({
      fromNationId: row.from_nation_id,
      toNationId: row.to_nation_id,
      opinion: row.opinion,
      isAllied: Boolean(row.is_allied),
      truceUntil: row.truce_until || void 0,
      updatedAt: row.updated_at
    });
  }
  createClaim(claim) {
    const validClaim = TerritorialClaimSchema.parse(claim);
    const stmt = this.db.prepare(`
      INSERT INTO territorial_claims (
        id, nation_id, region_id, claim_strength, justification, created_at
      )
      VALUES (
        @id, @nationId, @regionId, @claimStrength, @justification, @createdAt
      )
    `);
    stmt.run(validClaim);
  }
  getClaimsByRegion(regionId) {
    const stmt = this.db.prepare("SELECT * FROM territorial_claims WHERE region_id = ?");
    const rows = stmt.all(regionId);
    return rows.map((row) => TerritorialClaimSchema.parse({
      id: row.id,
      nationId: row.nation_id,
      regionId: row.region_id,
      claimStrength: row.claim_strength,
      justification: row.justification || void 0,
      createdAt: row.created_at
    }));
  }
  logEvent(event) {
    const { id, ...eventData } = event;
    const validEvent = NationEventSchema.omit({ id: true }).parse(eventData);
    const stmt = this.db.prepare(`
      INSERT INTO nation_events (
        world_id, turn_number, event_type, involved_nations, details, timestamp
      )
      VALUES (
        @worldId, @turnNumber, @eventType, @involvedNations, @details, @timestamp
      )
    `);
    stmt.run({
      ...validEvent,
      involvedNations: JSON.stringify(validEvent.involvedNations),
      details: JSON.stringify(validEvent.details)
    });
  }
  getEventsByWorld(worldId, turnNumber) {
    let query = "SELECT * FROM nation_events WHERE world_id = ?";
    const params = [worldId];
    if (turnNumber !== void 0) {
      query += " AND turn_number = ?";
      params.push(turnNumber);
    }
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    return rows.map((row) => NationEventSchema.parse({
      id: row.id,
      worldId: row.world_id,
      turnNumber: row.turn_number,
      eventType: row.event_type,
      involvedNations: JSON.parse(row.involved_nations),
      details: JSON.parse(row.details),
      timestamp: row.timestamp
    }));
  }
};

// dist/schema/region.js
init_zod();
var RegionSchema = external_exports.object({
  id: external_exports.string(),
  worldId: external_exports.string(),
  name: external_exports.string(),
  type: external_exports.enum(["kingdom", "duchy", "county", "wilderness", "water", "plains", "forest", "mountain", "desert", "city"]),
  centerX: external_exports.number(),
  centerY: external_exports.number(),
  color: external_exports.string(),
  ownerNationId: external_exports.string().nullable().optional(),
  controlLevel: external_exports.number().int().min(0).max(100).default(0),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});

// dist/storage/repos/region.repo.js
var RegionRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(region) {
    const validRegion = RegionSchema.parse(region);
    const stmt = this.db.prepare(`
      INSERT INTO regions (
        id, world_id, name, type, center_x, center_y, color, 
        owner_nation_id, control_level, created_at, updated_at
      )
      VALUES (
        @id, @worldId, @name, @type, @centerX, @centerY, @color,
        @ownerNationId, @controlLevel, @createdAt, @updatedAt
      )
    `);
    stmt.run({
      id: validRegion.id,
      worldId: validRegion.worldId,
      name: validRegion.name,
      type: validRegion.type,
      centerX: validRegion.centerX,
      centerY: validRegion.centerY,
      color: validRegion.color,
      ownerNationId: validRegion.ownerNationId || null,
      controlLevel: validRegion.controlLevel || 0,
      createdAt: validRegion.createdAt,
      updatedAt: validRegion.updatedAt
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM regions WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.mapRowToRegion(row);
  }
  findByWorldId(worldId) {
    const stmt = this.db.prepare("SELECT * FROM regions WHERE world_id = ?");
    const rows = stmt.all(worldId);
    return rows.map((row) => this.mapRowToRegion(row));
  }
  updateOwnership(regionId, ownerNationId, controlLevel) {
    const stmt = this.db.prepare(`
            UPDATE regions 
            SET owner_nation_id = ?, control_level = ?, updated_at = ?
            WHERE id = ?
        `);
    stmt.run(ownerNationId, controlLevel, (/* @__PURE__ */ new Date()).toISOString(), regionId);
  }
  findByOwner(ownerNationId) {
    const stmt = this.db.prepare("SELECT * FROM regions WHERE owner_nation_id = ?");
    const rows = stmt.all(ownerNationId);
    return rows.map((row) => this.mapRowToRegion(row));
  }
  mapRowToRegion(row) {
    return RegionSchema.parse({
      id: row.id,
      worldId: row.world_id,
      name: row.name,
      type: row.type,
      centerX: row.center_x,
      centerY: row.center_y,
      color: row.color,
      ownerNationId: row.owner_nation_id || void 0,
      controlLevel: row.control_level || 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// node_modules/uuid/dist-node/stringify.js
var byteToHex = [];
for (let i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist-node/rng.js
var import_node_crypto = require("node:crypto");
var rnds8Pool = new Uint8Array(256);
var poolPtr = rnds8Pool.length;
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    (0, import_node_crypto.randomFillSync)(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

// node_modules/uuid/dist-node/native.js
var import_node_crypto2 = require("node:crypto");
var native_default = { randomUUID: import_node_crypto2.randomUUID };

// node_modules/uuid/dist-node/v4.js
function _v4(options, buf, offset) {
  options = options || {};
  const rnds = options.random ?? options.rng?.() ?? rng();
  if (rnds.length < 16) {
    throw new Error("Random bytes length must be >= 16");
  }
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    if (offset < 0 || offset + 16 > buf.length) {
      throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);
    }
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  return _v4(options, buf, offset);
}
var v4_default = v4;

// dist/engine/strategy/nation-manager.js
var NationManager = class {
  nationRepo;
  constructor(nationRepo) {
    this.nationRepo = nationRepo;
  }
  createNation(params) {
    const nation = {
      ...params,
      id: v4_default(),
      relations: {},
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    this.nationRepo.create(nation);
    return nation;
  }
  getNation(nationId) {
    return this.nationRepo.findById(nationId);
  }
  updateNationState(nationId, updates) {
    const nation = this.nationRepo.findById(nationId);
    if (!nation)
      throw new Error(`Nation ${nationId} not found`);
    if (updates.resources) {
      this.nationRepo.updateResources(nationId, updates.resources);
    }
    if (updates.aggression !== void 0 || updates.trust !== void 0 || updates.paranoia !== void 0) {
      this.nationRepo.updateTraits(nationId, {
        aggression: updates.aggression,
        trust: updates.trust,
        paranoia: updates.paranoia
      });
    }
  }
  calculatePower(nation) {
    return nation.gdp + nation.resources.oil * 2 + nation.resources.metal;
  }
};

// dist/engine/strategy/diplomacy-engine.js
var DiplomacyEngine = class {
  diplomacyRepo;
  nationRepo;
  constructor(diplomacyRepo, nationRepo) {
    this.diplomacyRepo = diplomacyRepo;
    this.nationRepo = nationRepo;
  }
  proposeAlliance(fromNationId, toNationId) {
    const fromNation = this.nationRepo.findById(fromNationId);
    const toNation = this.nationRepo.findById(toNationId);
    if (!fromNation || !toNation)
      return { success: false, reason: "Nation not found" };
    const relation = this.diplomacyRepo.getRelation(fromNationId, toNationId);
    if (relation?.isAllied)
      return { success: false, reason: "Already allied" };
    const opinion = relation?.opinion || 0;
    const acceptanceThreshold = 50 + toNation.paranoia / 2;
    if (opinion >= acceptanceThreshold) {
      this.establishAlliance(fromNationId, toNationId);
      return { success: true };
    }
    return { success: false, reason: "Refused: Opinion too low" };
  }
  breakAlliance(fromNationId, toNationId) {
    this.diplomacyRepo.upsertRelation({
      fromNationId,
      toNationId,
      opinion: -20,
      // Penalty for breaking alliance
      isAllied: false,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.diplomacyRepo.upsertRelation({
      fromNationId: toNationId,
      toNationId: fromNationId,
      opinion: -50,
      // They hate you now
      isAllied: false,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
    this.logEvent(fromNationId, "ALLIANCE_BROKEN", [fromNationId, toNationId], { initiator: fromNationId });
  }
  adjustOpinion(fromNationId, toNationId, delta) {
    const current = this.diplomacyRepo.getRelation(fromNationId, toNationId);
    const newOpinion = Math.max(-100, Math.min(100, (current?.opinion || 0) + delta));
    this.diplomacyRepo.upsertRelation({
      fromNationId,
      toNationId,
      opinion: newOpinion,
      isAllied: current?.isAllied || false,
      truceUntil: current?.truceUntil,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  sendMessage(fromNationId, toNationId, message) {
    this.logEvent(fromNationId, "DIPLOMATIC_MESSAGE", [fromNationId, toNationId], { message });
  }
  establishAlliance(id1, id2) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    this.diplomacyRepo.upsertRelation({
      fromNationId: id1,
      toNationId: id2,
      opinion: 75,
      // Boost opinion
      isAllied: true,
      updatedAt: now
    });
    this.diplomacyRepo.upsertRelation({
      fromNationId: id2,
      toNationId: id1,
      opinion: 75,
      isAllied: true,
      updatedAt: now
    });
    this.logEvent(id1, "ALLIANCE_FORMED", [id1, id2], {});
  }
  logEvent(worldIdFromNation, type, involved, details) {
    const nation = this.nationRepo.findById(worldIdFromNation);
    if (!nation)
      return;
    this.diplomacyRepo.logEvent({
      worldId: nation.worldId,
      turnNumber: 0,
      // TODO: Get from TurnProcessor
      eventType: type,
      involvedNations: involved,
      details,
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
};

// dist/engine/strategy/conflict-resolver.js
var import_seedrandom8 = __toESM(require_seedrandom2(), 1);
var ConflictResolver = class {
  resolveRegionConflict(region, claimants, seed) {
    const rng2 = (0, import_seedrandom8.default)(seed);
    const scores = claimants.map((nation) => {
      const power = nation.gdp + nation.resources.oil * 2 + nation.resources.metal;
      const aggressionBonus = nation.aggression * 0.5;
      const paranoiaPenalty = nation.paranoia * 0.2;
      const luck = Math.floor(rng2() * 20) + 1;
      return {
        nationId: nation.id,
        score: power + aggressionBonus - paranoiaPenalty + luck,
        raw: { power, aggressionBonus, paranoiaPenalty, luck }
      };
    });
    scores.sort((a, b) => b.score - a.score);
    const winner = scores[0];
    const loser = scores[1];
    let newControlLevel = region.controlLevel;
    let winnerId = region.ownerNationId || winner.nationId;
    let log = "";
    if (winner.nationId === region.ownerNationId) {
      newControlLevel = Math.min(100, newControlLevel + 10);
      log = `Defender ${winner.nationId} repelled attack. Control increased to ${newControlLevel}.`;
    } else {
      const diff = winner.score - (loser?.score || 0);
      const damage = Math.max(10, Math.floor(diff / 2));
      newControlLevel -= damage;
      if (newControlLevel <= 0) {
        winnerId = winner.nationId;
        newControlLevel = Math.abs(newControlLevel);
        log = `Attacker ${winner.nationId} conquered region from ${region.ownerNationId || "wilderness"}!`;
      } else {
        winnerId = region.ownerNationId;
        log = `Attacker ${winner.nationId} won battle but failed to conquer. Control reduced to ${newControlLevel}.`;
      }
    }
    return {
      winnerId,
      // Battle winner, not necessarily region owner
      loserId: scores[1]?.nationId || "wilderness",
      regionId: region.id,
      newControlLevel,
      log
    };
  }
};

// dist/engine/strategy/turn-processor.js
var TurnProcessor = class {
  nationRepo;
  regionRepo;
  diplomacyRepo;
  conflictResolver;
  constructor(nationRepo, regionRepo, diplomacyRepo, conflictResolver) {
    this.nationRepo = nationRepo;
    this.regionRepo = regionRepo;
    this.diplomacyRepo = diplomacyRepo;
    this.conflictResolver = conflictResolver;
  }
  processTurn(worldId, turnNumber) {
    const nations = this.nationRepo.findByWorldId(worldId);
    this.processEconomy(nations);
    this.processConflicts(worldId, turnNumber);
    this.processConsumption(nations);
  }
  processEconomy(nations) {
    for (const nation of nations) {
      const newResources = {
        food: nation.resources.food + 10,
        metal: nation.resources.metal + 5,
        oil: nation.resources.oil + 2
      };
      this.nationRepo.updateResources(nation.id, newResources);
      nation.resources = newResources;
    }
  }
  processConflicts(worldId, turnNumber) {
    const regions = this.regionRepo.findByWorldId(worldId);
    for (const region of regions) {
      const claims = this.diplomacyRepo.getClaimsByRegion(region.id);
      if (claims.length === 0)
        continue;
      const claimantNations = claims.map((c) => this.nationRepo.findById(c.nationId)).filter((n2) => !!n2);
      if (claimantNations.length === 0)
        continue;
      if (claimantNations.length === 1 && !region.ownerNationId) {
        const winner = claimantNations[0];
        this.regionRepo.updateOwnership(region.id, winner.id, 10);
        this.diplomacyRepo.logEvent({
          worldId,
          turnNumber,
          eventType: "REGION_CLAIMED",
          involvedNations: [winner.id],
          details: { log: `${winner.name} established control over ${region.name}`, regionId: region.id },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
        continue;
      }
      if (claimantNations.length > 1 || region.ownerNationId && claimantNations[0].id !== region.ownerNationId) {
        const participants = [...claimantNations];
        if (region.ownerNationId && !participants.find((n2) => n2.id === region.ownerNationId)) {
          const owner = this.nationRepo.findById(region.ownerNationId);
          if (owner)
            participants.push(owner);
        }
        if (participants.length < 2)
          continue;
        const result = this.conflictResolver.resolveRegionConflict(region, participants, `${worldId}-${turnNumber}-${region.id}`);
        this.regionRepo.updateOwnership(region.id, result.newControlLevel <= 0 ? null : result.log.includes("conquered") ? result.winnerId : region.ownerNationId || null, result.newControlLevel);
        this.diplomacyRepo.logEvent({
          worldId,
          turnNumber,
          eventType: result.log.includes("conquered") ? "REGION_CONQUERED" : "REGION_CLAIMED",
          involvedNations: [result.winnerId, result.loserId],
          details: { log: result.log, regionId: region.id },
          timestamp: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    }
  }
  processConsumption(nations) {
    for (const nation of nations) {
      const consumed = {
        food: Math.max(0, nation.resources.food - 5),
        metal: nation.resources.metal,
        oil: nation.resources.oil
      };
      this.nationRepo.updateResources(nation.id, consumed);
    }
  }
};

// dist/engine/strategy/fog-of-war.js
var FogOfWar = class {
  diplomacyRepo;
  constructor(diplomacyRepo) {
    this.diplomacyRepo = diplomacyRepo;
  }
  filterWorldState(viewerNationId, allNations, allRegions) {
    const allies = allNations.filter((n2) => {
      if (n2.id === viewerNationId)
        return false;
      const rel = this.diplomacyRepo.getRelation(viewerNationId, n2.id);
      return rel?.isAllied;
    });
    const allyIds = new Set(allies.map((a) => a.id));
    const visibleRegionIds = /* @__PURE__ */ new Set();
    for (const r of allRegions) {
      if (r.ownerNationId === viewerNationId || r.ownerNationId && allyIds.has(r.ownerNationId)) {
        visibleRegionIds.add(r.id);
      }
    }
    const maskedNations = allNations.map((nation) => {
      if (nation.id === viewerNationId)
        return nation;
      const isAlly = allyIds.has(nation.id);
      const hasContact = isAlly;
      if (hasContact) {
        const { privateMemory, ...publicData } = nation;
        return publicData;
      } else {
        return {
          id: nation.id,
          worldId: nation.worldId,
          name: nation.name,
          leader: nation.leader,
          ideology: nation.ideology,
          publicIntent: nation.publicIntent,
          // Hide exact stats
          aggression: this.fuzz(nation.aggression),
          trust: this.fuzz(nation.trust),
          paranoia: this.fuzz(nation.paranoia),
          gdp: this.fuzz(nation.gdp),
          // Hide resources completely or fuzz them? Spec says "hide exact resource amounts"
          resources: {
            food: this.fuzz(nation.resources.food),
            metal: this.fuzz(nation.resources.metal),
            oil: this.fuzz(nation.resources.oil)
          },
          // Hide relations? Maybe show public alliances?
          relations: {},
          // Hide their private opinion map
          createdAt: nation.createdAt,
          updatedAt: nation.updatedAt
        };
      }
    });
    return {
      nations: maskedNations,
      regions: allRegions
      // For now, map is fully visible, just ownership might be stale? 
      // Actually spec says "Fog-of-war (no perfect info)". 
      // Usually map geography is known, but maybe not units (we have no units).
      // So regions are fine to show.
    };
  }
  fuzz(value) {
    if (value < 100)
      return Math.round(value / 10) * 10;
    return Math.round(value / 100) * 100;
  }
};

// dist/server/strategy-tools.js
var StrategyTools = {
  CREATE_NATION: {
    name: "create_nation",
    description: "Create a new nation in the world.",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      name: external_exports.string(),
      leader: external_exports.string(),
      ideology: external_exports.enum(["democracy", "autocracy", "theocracy", "tribal"]),
      aggression: external_exports.number().min(0).max(100),
      trust: external_exports.number().min(0).max(100),
      paranoia: external_exports.number().min(0).max(100),
      startingResources: external_exports.object({
        food: external_exports.number(),
        metal: external_exports.number(),
        oil: external_exports.number()
      }).optional()
    })
  },
  GET_STRATEGY_STATE: {
    name: "get_strategy_state",
    description: "Get the world state from the perspective of a specific nation (applies Fog of War for Grand Strategy).",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      viewerNationId: external_exports.string()
    })
  },
  GET_NATION_STATE: {
    name: "get_nation_state",
    description: "Get private state for a specific nation (LLM only).",
    inputSchema: external_exports.object({
      nationId: external_exports.string()
    })
  },
  PROPOSE_ALLIANCE: {
    name: "propose_alliance",
    description: "Propose an alliance to another nation.",
    inputSchema: external_exports.object({
      fromNationId: external_exports.string(),
      toNationId: external_exports.string()
    })
  },
  CLAIM_REGION: {
    name: "claim_region",
    description: "Assert a territorial claim on a region.",
    inputSchema: external_exports.object({
      nationId: external_exports.string(),
      regionId: external_exports.string(),
      justification: external_exports.string().optional()
    })
  },
  RESOLVE_TURN: {
    name: "resolve_turn",
    description: "Process a full turn cycle (economy, conflicts, etc.).",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      turnNumber: external_exports.number()
    })
  }
};
async function handleStrategyTool(name, args, _ctx) {
  const db = getDb();
  const nationRepo = new NationRepository(db);
  const diplomacyRepo = new DiplomacyRepository(db);
  const regionRepo = new RegionRepository(db);
  const nationManager = new NationManager(nationRepo);
  const diplomacyEngine = new DiplomacyEngine(diplomacyRepo, nationRepo);
  const conflictResolver = new ConflictResolver();
  const turnProcessor = new TurnProcessor(nationRepo, regionRepo, diplomacyRepo, conflictResolver);
  const fogOfWar = new FogOfWar(diplomacyRepo);
  switch (name) {
    case "create_nation": {
      const { startingResources, ...params } = args;
      const nation = nationManager.createNation({
        ...params,
        gdp: 1e3,
        // Default starting GDP
        resources: startingResources || { food: 100, metal: 50, oil: 10 },
        privateMemory: {},
        publicIntent: "Survival"
      });
      return { content: [{ type: "text", text: JSON.stringify(nation, null, 2) }] };
    }
    case "get_strategy_state": {
      const { worldId, viewerNationId } = args;
      const allNations = nationRepo.findByWorldId(worldId);
      const allRegions = regionRepo.findByWorldId(worldId);
      const filtered = fogOfWar.filterWorldState(viewerNationId, allNations, allRegions);
      return { content: [{ type: "text", text: JSON.stringify(filtered, null, 2) }] };
    }
    case "get_nation_state": {
      const { nationId } = args;
      const nation = nationManager.getNation(nationId);
      if (!nation)
        throw new Error("Nation not found");
      return { content: [{ type: "text", text: JSON.stringify(nation, null, 2) }] };
    }
    case "propose_alliance": {
      const { fromNationId, toNationId } = args;
      const result = diplomacyEngine.proposeAlliance(fromNationId, toNationId);
      return { content: [{ type: "text", text: JSON.stringify(result, null, 2) }] };
    }
    case "claim_region": {
      const { nationId, regionId, justification } = args;
      diplomacyRepo.createClaim({
        id: `claim-${Date.now()}-${Math.random()}`,
        // Simple ID generation
        nationId,
        regionId,
        claimStrength: 100,
        justification,
        createdAt: (/* @__PURE__ */ new Date()).toISOString()
      });
      return { content: [{ type: "text", text: `Claim registered for ${regionId}` }] };
    }
    case "resolve_turn": {
      const { worldId, turnNumber } = args;
      turnProcessor.processTurn(worldId, turnNumber);
      const events = diplomacyRepo.getEventsByWorld(worldId, turnNumber);
      return { content: [{ type: "text", text: JSON.stringify({ status: "Turn Resolved", events }, null, 2) }] };
    }
    default:
      throw new Error(`Unknown tool: ${name}`);
  }
}

// dist/server/turn-management-tools.js
init_zod();

// dist/schema/turn-state.js
init_zod();
var TurnStateSchema = external_exports.object({
  worldId: external_exports.string(),
  currentTurn: external_exports.number().int().min(1),
  turnPhase: external_exports.enum(["planning", "resolution", "finished"]),
  phaseStartedAt: external_exports.string().datetime(),
  nationsReady: external_exports.array(external_exports.string()),
  // Array of nation IDs
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var TurnActionSchema = external_exports.object({
  type: external_exports.enum(["claim_region", "propose_alliance", "break_alliance", "transfer_region", "declare_intent", "send_message", "adjust_relations"]),
  // Union of all possible action parameters
  regionId: external_exports.string().optional(),
  toNationId: external_exports.string().optional(),
  fromNationId: external_exports.string().optional(),
  justification: external_exports.string().optional(),
  intent: external_exports.string().optional(),
  message: external_exports.string().optional(),
  opinionDelta: external_exports.number().optional()
});

// dist/storage/repos/turn-state.repo.js
var TurnStateRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(turnState) {
    const valid = TurnStateSchema.parse(turnState);
    const stmt = this.db.prepare(`
            INSERT INTO turn_state (world_id, current_turn, turn_phase, phase_started_at, nations_ready, created_at, updated_at)
            VALUES (@worldId, @currentTurn, @turnPhase, @phaseStartedAt, @nationsReady, @createdAt, @updatedAt)
        `);
    stmt.run({
      ...valid,
      worldId: valid.worldId,
      currentTurn: valid.currentTurn,
      turnPhase: valid.turnPhase,
      phaseStartedAt: valid.phaseStartedAt,
      nationsReady: JSON.stringify(valid.nationsReady)
    });
  }
  findByWorldId(worldId) {
    const stmt = this.db.prepare("SELECT * FROM turn_state WHERE world_id = ?");
    const row = stmt.get(worldId);
    if (!row)
      return null;
    return this.mapRowToTurnState(row);
  }
  updatePhase(worldId, phase) {
    const stmt = this.db.prepare(`
            UPDATE turn_state 
            SET turn_phase = ?, phase_started_at = ?, updated_at = ?
            WHERE world_id = ?
        `);
    const now = (/* @__PURE__ */ new Date()).toISOString();
    stmt.run(phase, now, now, worldId);
  }
  addReadyNation(worldId, nationId) {
    const current = this.findByWorldId(worldId);
    if (!current)
      throw new Error("Turn state not found");
    if (current.nationsReady.includes(nationId))
      return;
    const updated = [...current.nationsReady, nationId];
    const stmt = this.db.prepare(`
            UPDATE turn_state 
            SET nations_ready = ?, updated_at = ?
            WHERE world_id = ?
        `);
    stmt.run(JSON.stringify(updated), (/* @__PURE__ */ new Date()).toISOString(), worldId);
  }
  clearReadyNations(worldId) {
    const stmt = this.db.prepare(`
            UPDATE turn_state 
            SET nations_ready = '[]', updated_at = ?
            WHERE world_id = ?
        `);
    stmt.run((/* @__PURE__ */ new Date()).toISOString(), worldId);
  }
  incrementTurn(worldId) {
    const stmt = this.db.prepare(`
            UPDATE turn_state 
            SET current_turn = current_turn + 1, updated_at = ?
            WHERE world_id = ?
        `);
    stmt.run((/* @__PURE__ */ new Date()).toISOString(), worldId);
  }
  mapRowToTurnState(row) {
    return TurnStateSchema.parse({
      worldId: row.world_id,
      currentTurn: row.current_turn,
      turnPhase: row.turn_phase,
      phaseStartedAt: row.phase_started_at,
      nationsReady: JSON.parse(row.nations_ready),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// dist/server/turn-management-tools.js
var TurnManagementTools = {
  INIT_TURN_STATE: {
    name: "init_turn_state",
    description: "Initialize turn management for a world (call once per world)",
    inputSchema: external_exports.object({
      worldId: external_exports.string()
    })
  },
  GET_TURN_STATUS: {
    name: "get_turn_status",
    description: "Check current turn state and which nations are ready",
    inputSchema: external_exports.object({
      worldId: external_exports.string()
    })
  },
  SUBMIT_TURN_ACTIONS: {
    name: "submit_turn_actions",
    description: "Submit actions for this turn (batched)",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      nationId: external_exports.string(),
      actions: external_exports.array(TurnActionSchema)
    })
  },
  MARK_READY: {
    name: "mark_ready",
    description: "Signal that your nation is done planning for this turn",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      nationId: external_exports.string()
    })
  },
  POLL_TURN_RESULTS: {
    name: "poll_turn_results",
    description: "Check if turn has resolved and get results",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      turnNumber: external_exports.number()
    })
  }
};
async function handleTurnManagementTool(name, args) {
  const db = getDb();
  const turnStateRepo = new TurnStateRepository(db);
  const nationRepo = new NationRepository(db);
  const diplomacyRepo = new DiplomacyRepository(db);
  const regionRepo = new RegionRepository(db);
  switch (name) {
    case "init_turn_state": {
      const { worldId } = args;
      const existing = turnStateRepo.findByWorldId(worldId);
      if (existing) {
        return { content: [{ type: "text", text: "Turn state already initialized" }] };
      }
      const now = (/* @__PURE__ */ new Date()).toISOString();
      turnStateRepo.create({
        worldId,
        currentTurn: 1,
        turnPhase: "planning",
        phaseStartedAt: now,
        nationsReady: [],
        createdAt: now,
        updatedAt: now
      });
      return { content: [{ type: "text", text: "Turn state initialized" }] };
    }
    case "get_turn_status": {
      const { worldId } = args;
      const turnState = turnStateRepo.findByWorldId(worldId);
      if (!turnState) {
        return { content: [{ type: "text", text: "Turn state not initialized" }] };
      }
      const allNations = nationRepo.findByWorldId(worldId);
      const waitingFor = allNations.filter((n2) => !turnState.nationsReady.includes(n2.id)).map((n2) => n2.name);
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            currentTurn: turnState.currentTurn,
            phase: turnState.turnPhase,
            nationsReady: turnState.nationsReady.length,
            totalNations: allNations.length,
            waitingFor,
            canSubmitActions: turnState.turnPhase === "planning"
          }, null, 2)
        }]
      };
    }
    case "submit_turn_actions": {
      const { worldId, nationId, actions } = args;
      const turnState = turnStateRepo.findByWorldId(worldId);
      if (!turnState || turnState.turnPhase !== "planning") {
        return { content: [{ type: "text", text: "Cannot submit actions (not in planning phase)" }] };
      }
      for (const action of actions) {
        switch (action.type) {
          case "claim_region":
            diplomacyRepo.createClaim({
              id: `claim-${Date.now()}-${Math.random()}`,
              nationId,
              regionId: action.regionId,
              claimStrength: 100,
              justification: action.justification,
              createdAt: (/* @__PURE__ */ new Date()).toISOString()
            });
            break;
          case "propose_alliance":
            const relation = diplomacyRepo.getRelation(nationId, action.toNationId);
            if (!relation || relation.opinion >= 50) {
              diplomacyRepo.upsertRelation({
                fromNationId: nationId,
                toNationId: action.toNationId,
                opinion: relation?.opinion || 50,
                isAllied: true,
                truceUntil: void 0,
                updatedAt: (/* @__PURE__ */ new Date()).toISOString()
              });
            }
            break;
        }
      }
      return {
        content: [{
          type: "text",
          text: `${actions.length} actions submitted for turn ${turnState.currentTurn}`
        }]
      };
    }
    case "mark_ready": {
      const { worldId, nationId } = args;
      const turnState = turnStateRepo.findByWorldId(worldId);
      if (!turnState || turnState.turnPhase !== "planning") {
        return { content: [{ type: "text", text: "Cannot mark ready (not in planning phase)" }] };
      }
      turnStateRepo.addReadyNation(worldId, nationId);
      const updated = turnStateRepo.findByWorldId(worldId);
      const allNations = nationRepo.findByWorldId(worldId);
      if (updated.nationsReady.length === allNations.length && allNations.length > 0) {
        turnStateRepo.updatePhase(worldId, "resolution");
        const conflictResolver = new ConflictResolver();
        const turnProcessor = new TurnProcessor(nationRepo, regionRepo, diplomacyRepo, conflictResolver);
        turnProcessor.processTurn(worldId, updated.currentTurn);
        turnStateRepo.updatePhase(worldId, "finished");
        turnStateRepo.incrementTurn(worldId);
        turnStateRepo.clearReadyNations(worldId);
        turnStateRepo.updatePhase(worldId, "planning");
        return {
          content: [{
            type: "text",
            text: JSON.stringify({
              message: "All nations ready! Turn resolved.",
              turnResolved: updated.currentTurn,
              nextTurn: updated.currentTurn + 1
            }, null, 2)
          }]
        };
      }
      return {
        content: [{
          type: "text",
          text: JSON.stringify({
            ready: true,
            allReady: false,
            waitingFor: allNations.filter((n2) => !updated.nationsReady.includes(n2.id)).map((n2) => n2.name)
          }, null, 2)
        }]
      };
    }
    case "poll_turn_results": {
      const { worldId, turnNumber } = args;
      const turnState = turnStateRepo.findByWorldId(worldId);
      if (!turnState) {
        return { content: [{ type: "text", text: "Turn state not found" }] };
      }
      if (turnState.currentTurn > turnNumber) {
        const events = diplomacyRepo.getEventsByWorld(worldId, turnNumber);
        return {
          content: [{
            type: "text",
            text: JSON.stringify({
              resolved: true,
              events,
              nextTurn: turnState.currentTurn,
              phase: turnState.turnPhase
            }, null, 2)
          }]
        };
      } else if (turnState.turnPhase === "resolution") {
        return {
          content: [{
            type: "text",
            text: JSON.stringify({
              resolved: false,
              phase: "resolution",
              message: "Turn is being resolved..."
            }, null, 2)
          }]
        };
      } else {
        return {
          content: [{
            type: "text",
            text: JSON.stringify({
              resolved: false,
              phase: turnState.turnPhase,
              message: "Turn not yet resolved"
            }, null, 2)
          }]
        };
      }
    }
    default:
      throw new Error(`Unknown turn management tool: ${name}`);
  }
}

// dist/server/secret-tools.js
init_zod();
var import_crypto7 = require("crypto");

// dist/schema/secret.js
init_zod();
var RevealConditionSchema = external_exports.object({
  type: external_exports.enum([
    "skill_check",
    // Player passes a skill check
    "quest_complete",
    // A specific quest is completed
    "item_interact",
    // Player interacts with an item
    "dialogue",
    // Keyword spoken in dialogue
    "location_enter",
    // Player enters a location
    "combat_end",
    // Combat encounter ends
    "time_passed",
    // In-game time passes
    "manual"
    // DM explicitly reveals
  ]),
  // Skill check specifics
  skill: external_exports.string().optional(),
  // "Insight", "Perception", "Arcana"
  dc: external_exports.number().int().min(1).optional(),
  // Difficulty class
  // Quest trigger
  questId: external_exports.string().optional(),
  // Item trigger
  itemId: external_exports.string().optional(),
  // Location trigger
  locationId: external_exports.string().optional(),
  // NPC trigger
  npcId: external_exports.string().optional(),
  // Dialogue trigger
  dialogueTrigger: external_exports.string().optional(),
  // Keyword that triggers reveal
  // Time trigger
  hoursRequired: external_exports.number().int().min(1).optional(),
  // Partial reveal (hint instead of full reveal)
  partialReveal: external_exports.boolean().default(false),
  partialText: external_exports.string().optional()
  // "You sense something is off..."
});
var SecretSchema = external_exports.object({
  id: external_exports.string(),
  worldId: external_exports.string(),
  // Classification
  type: external_exports.enum(["npc", "location", "item", "quest", "plot", "mechanic", "custom"]),
  category: external_exports.string(),
  // 'motivation', 'trap', 'puzzle', 'loot', 'weakness', 'twist', etc.
  // Content
  name: external_exports.string(),
  // "Innkeeper's True Identity"
  publicDescription: external_exports.string(),
  // What player knows
  secretDescription: external_exports.string(),
  // What AI knows (hidden)
  // Entity linking
  linkedEntityId: external_exports.string().optional(),
  // NPC ID, Item ID, etc.
  linkedEntityType: external_exports.string().optional(),
  // 'npc', 'item', 'location', 'quest'
  // Revelation state
  revealed: external_exports.boolean().default(false),
  revealedAt: external_exports.string().datetime().optional(),
  revealedBy: external_exports.string().optional(),
  // What triggered the reveal
  // Revelation conditions
  revealConditions: external_exports.array(RevealConditionSchema).default([]),
  // Sensitivity for filtering
  sensitivity: external_exports.enum(["low", "medium", "high", "critical"]).default("medium"),
  // Leak detection patterns
  leakPatterns: external_exports.array(external_exports.string()).default([]),
  // ["vampire", "undead", "blood"]
  // Metadata
  notes: external_exports.string().optional(),
  // DM notes
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var GameEventSchema = external_exports.object({
  type: external_exports.enum([
    "skill_check",
    "quest_complete",
    "item_interact",
    "dialogue",
    "location_enter",
    "combat_end",
    "time_passed"
  ]),
  // Skill check event
  skill: external_exports.string().optional(),
  result: external_exports.number().int().optional(),
  // Quest event
  questId: external_exports.string().optional(),
  // Item event
  itemId: external_exports.string().optional(),
  // Location event
  locationId: external_exports.string().optional(),
  // Dialogue event
  text: external_exports.string().optional(),
  // Time event
  hoursPassed: external_exports.number().optional(),
  // Context
  characterId: external_exports.string().optional(),
  encounterId: external_exports.string().optional()
});
var RevealResultSchema = external_exports.object({
  success: external_exports.boolean(),
  secret: SecretSchema.optional(),
  narration: external_exports.string().optional(),
  partial: external_exports.boolean().default(false),
  reason: external_exports.string().optional()
});

// dist/storage/repos/secret.repo.js
var SecretRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Create a new secret
   */
  create(secret) {
    const validSecret = SecretSchema.parse(secret);
    const stmt = this.db.prepare(`
            INSERT INTO secrets (
                id, world_id, type, category, name, 
                public_description, secret_description,
                linked_entity_id, linked_entity_type,
                revealed, revealed_at, revealed_by,
                reveal_conditions, sensitivity, leak_patterns,
                notes, created_at, updated_at
            ) VALUES (
                @id, @worldId, @type, @category, @name,
                @publicDescription, @secretDescription,
                @linkedEntityId, @linkedEntityType,
                @revealed, @revealedAt, @revealedBy,
                @revealConditions, @sensitivity, @leakPatterns,
                @notes, @createdAt, @updatedAt
            )
        `);
    stmt.run({
      id: validSecret.id,
      worldId: validSecret.worldId,
      type: validSecret.type,
      category: validSecret.category,
      name: validSecret.name,
      publicDescription: validSecret.publicDescription,
      secretDescription: validSecret.secretDescription,
      linkedEntityId: validSecret.linkedEntityId || null,
      linkedEntityType: validSecret.linkedEntityType || null,
      revealed: validSecret.revealed ? 1 : 0,
      revealedAt: validSecret.revealedAt || null,
      revealedBy: validSecret.revealedBy || null,
      revealConditions: JSON.stringify(validSecret.revealConditions),
      sensitivity: validSecret.sensitivity,
      leakPatterns: JSON.stringify(validSecret.leakPatterns),
      notes: validSecret.notes || null,
      createdAt: validSecret.createdAt,
      updatedAt: validSecret.updatedAt
    });
    return validSecret;
  }
  /**
   * Find a secret by ID
   */
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM secrets WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToSecret(row);
  }
  /**
   * Find all secrets matching filter criteria
   */
  find(filter = {}) {
    let query = "SELECT * FROM secrets WHERE 1=1";
    const params = {};
    if (filter.worldId) {
      query += " AND world_id = @worldId";
      params.worldId = filter.worldId;
    }
    if (filter.type) {
      query += " AND type = @type";
      params.type = filter.type;
    }
    if (filter.category) {
      query += " AND category = @category";
      params.category = filter.category;
    }
    if (filter.revealed !== void 0) {
      query += " AND revealed = @revealed";
      params.revealed = filter.revealed ? 1 : 0;
    }
    if (filter.sensitivity) {
      query += " AND sensitivity = @sensitivity";
      params.sensitivity = filter.sensitivity;
    }
    if (filter.linkedEntityId) {
      query += " AND linked_entity_id = @linkedEntityId";
      params.linkedEntityId = filter.linkedEntityId;
    }
    if (filter.linkedEntityType) {
      query += " AND linked_entity_type = @linkedEntityType";
      params.linkedEntityType = filter.linkedEntityType;
    }
    const stmt = this.db.prepare(query);
    const rows = stmt.all(params);
    return rows.map((row) => this.rowToSecret(row));
  }
  /**
   * Get all unrevealed secrets for a world (for LLM context injection)
   */
  getActiveSecrets(worldId) {
    return this.find({ worldId, revealed: false });
  }
  /**
   * Update a secret
   */
  update(id, updates) {
    const existing = this.findById(id);
    if (!existing)
      return null;
    const updated = {
      ...existing,
      ...updates,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const validSecret = SecretSchema.parse(updated);
    const stmt = this.db.prepare(`
            UPDATE secrets SET
                type = @type,
                category = @category,
                name = @name,
                public_description = @publicDescription,
                secret_description = @secretDescription,
                linked_entity_id = @linkedEntityId,
                linked_entity_type = @linkedEntityType,
                revealed = @revealed,
                revealed_at = @revealedAt,
                revealed_by = @revealedBy,
                reveal_conditions = @revealConditions,
                sensitivity = @sensitivity,
                leak_patterns = @leakPatterns,
                notes = @notes,
                updated_at = @updatedAt
            WHERE id = @id
        `);
    stmt.run({
      id: validSecret.id,
      type: validSecret.type,
      category: validSecret.category,
      name: validSecret.name,
      publicDescription: validSecret.publicDescription,
      secretDescription: validSecret.secretDescription,
      linkedEntityId: validSecret.linkedEntityId || null,
      linkedEntityType: validSecret.linkedEntityType || null,
      revealed: validSecret.revealed ? 1 : 0,
      revealedAt: validSecret.revealedAt || null,
      revealedBy: validSecret.revealedBy || null,
      revealConditions: JSON.stringify(validSecret.revealConditions),
      sensitivity: validSecret.sensitivity,
      leakPatterns: JSON.stringify(validSecret.leakPatterns),
      notes: validSecret.notes || null,
      updatedAt: validSecret.updatedAt
    });
    return validSecret;
  }
  /**
   * Reveal a secret
   */
  reveal(id, triggeredBy) {
    return this.update(id, {
      revealed: true,
      revealedAt: (/* @__PURE__ */ new Date()).toISOString(),
      revealedBy: triggeredBy
    });
  }
  /**
   * Delete a secret
   */
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM secrets WHERE id = ?");
    const result = stmt.run(id);
    return result.changes > 0;
  }
  /**
   * Check if any secrets should be revealed based on a game event
   */
  checkRevealConditions(worldId, event) {
    const secrets = this.getActiveSecrets(worldId);
    const toReveal = [];
    for (const secret of secrets) {
      for (const condition of secret.revealConditions) {
        if (this.conditionMet(event, condition)) {
          toReveal.push(secret);
          break;
        }
      }
    }
    return toReveal;
  }
  /**
   * Check if a specific condition is met by an event
   * Note: 'manual' type conditions are never auto-triggered
   */
  conditionMet(event, condition) {
    if (condition.type === "manual")
      return false;
    if (event.type !== condition.type)
      return false;
    switch (event.type) {
      case "skill_check":
        return event.skill?.toLowerCase() === condition.skill?.toLowerCase() && (event.result || 0) >= (condition.dc || 0);
      case "quest_complete":
        return event.questId === condition.questId;
      case "location_enter":
        return event.locationId === condition.locationId;
      case "item_interact":
        return event.itemId === condition.itemId;
      case "combat_end":
        return true;
      // Just needs the event type to match
      case "dialogue":
        return event.text?.toLowerCase().includes(condition.dialogueTrigger?.toLowerCase() || "") || false;
      case "time_passed":
        return (event.hoursPassed || 0) >= (condition.hoursRequired || 0);
      default:
        return false;
    }
  }
  /**
   * Check text for potential secret leaks
   */
  checkForLeaks(text, worldId) {
    const secrets = this.getActiveSecrets(worldId);
    const leaks = [];
    for (const secret of secrets) {
      for (const pattern of secret.leakPatterns) {
        const regex = new RegExp(`\\b${this.escapeRegex(pattern)}\\b`, "gi");
        const match = regex.test(text);
        if (match) {
          const matchResult = text.match(regex);
          const index = matchResult ? text.indexOf(matchResult[0]) : 0;
          const start = Math.max(0, index - 30);
          const end = Math.min(text.length, index + pattern.length + 30);
          const context = text.slice(start, end);
          leaks.push({
            secretId: secret.id,
            secretName: secret.name,
            pattern,
            matched: true,
            context
          });
        }
      }
    }
    return leaks;
  }
  /**
   * Format secrets for LLM context injection
   */
  formatForLLM(worldId) {
    const secrets = this.getActiveSecrets(worldId);
    if (secrets.length === 0) {
      return "";
    }
    const grouped = /* @__PURE__ */ new Map();
    for (const secret of secrets) {
      const existing = grouped.get(secret.type) || [];
      existing.push(secret);
      grouped.set(secret.type, existing);
    }
    let output = `
## SECRET INFORMATION (DO NOT REVEAL TO PLAYER)
\u26A0\uFE0F The following information is SECRET. You know this to inform your narration,
but you must NEVER directly reveal it to the player unless the reveal conditions are met.

`;
    for (const [type, typeSecrets] of grouped) {
      output += `### ${type.toUpperCase()} SECRETS

`;
      for (const secret of typeSecrets) {
        output += `**[SECRET-${secret.id.slice(0, 8)}] ${secret.name}**
`;
        output += `- Sensitivity: ${secret.sensitivity.toUpperCase()}
`;
        output += `- Public Knowledge: ${secret.publicDescription}
`;
        output += `- Hidden Truth: ${secret.secretDescription}
`;
        if (secret.leakPatterns.length > 0) {
          output += `- \u26A0\uFE0F AVOID these words: ${secret.leakPatterns.join(", ")}
`;
        }
        if (secret.revealConditions.length > 0) {
          output += `- Reveal when: ${this.formatConditions(secret.revealConditions)}
`;
        }
        output += "\n";
      }
    }
    output += `
### SECRET HANDLING RULES:
1. NEVER state secrets directly, even if the player asks
2. NEVER confirm or deny guesses about secrets  
3. You may hint through environmental details and NPC behavior
4. If reveal conditions are met, describe the revelation dramatically
5. Use secrets to make NPCs behave consistently with their hidden motivations
`;
    return output;
  }
  formatConditions(conditions) {
    return conditions.map((c) => {
      switch (c.type) {
        case "skill_check":
          return `DC ${c.dc} ${c.skill} check`;
        case "quest_complete":
          return `Complete quest`;
        case "location_enter":
          return `Enter specific location`;
        case "item_interact":
          return `Interact with item`;
        case "dialogue":
          return `Say "${c.dialogueTrigger}"`;
        case "combat_end":
          return `Combat ends`;
        case "time_passed":
          return `${c.hoursRequired} hours pass`;
        case "manual":
          return `DM reveals`;
        default:
          return c.type;
      }
    }).join(" OR ");
  }
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  rowToSecret(row) {
    return SecretSchema.parse({
      id: row.id,
      worldId: row.world_id,
      type: row.type,
      category: row.category,
      name: row.name,
      publicDescription: row.public_description,
      secretDescription: row.secret_description,
      linkedEntityId: row.linked_entity_id || void 0,
      linkedEntityType: row.linked_entity_type || void 0,
      revealed: row.revealed === 1,
      revealedAt: row.revealed_at || void 0,
      revealedBy: row.revealed_by || void 0,
      revealConditions: JSON.parse(row.reveal_conditions),
      sensitivity: row.sensitivity,
      leakPatterns: JSON.parse(row.leak_patterns),
      notes: row.notes || void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// dist/server/secret-tools.js
function ensureDb4() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const secretRepo = new SecretRepository(db);
  return { secretRepo };
}
var SecretTools = {
  CREATE_SECRET: {
    name: "create_secret",
    description: "Create a DM-only secret (NPC, location, item, plot). AI narrates around it without revealing.",
    inputSchema: external_exports.object({
      worldId: external_exports.string().describe("The world this secret belongs to"),
      type: external_exports.enum(["npc", "location", "item", "quest", "plot", "mechanic", "custom"]).describe("Category of entity this secret relates to"),
      category: external_exports.string().describe('Subcategory like "motivation", "trap", "puzzle", "weakness"'),
      name: external_exports.string().describe(`Short name for the secret, e.g. "Innkeeper's True Identity"`),
      publicDescription: external_exports.string().describe("What the player knows publicly"),
      secretDescription: external_exports.string().describe("The hidden truth only the DM knows"),
      linkedEntityId: external_exports.string().optional().describe("ID of related NPC, item, location, etc."),
      linkedEntityType: external_exports.string().optional().describe("Type of linked entity"),
      sensitivity: external_exports.enum(["low", "medium", "high", "critical"]).default("medium").describe("How important it is to keep this hidden"),
      leakPatterns: external_exports.array(external_exports.string()).default([]).describe('Keywords the AI should avoid saying, e.g. ["vampire", "undead"]'),
      revealConditions: external_exports.array(RevealConditionSchema).default([]).describe("Conditions under which this secret can be revealed"),
      notes: external_exports.string().optional().describe("DM notes about this secret")
    })
  },
  GET_SECRET: {
    name: "get_secret",
    description: "Get a single secret by ID (DM view only).",
    inputSchema: external_exports.object({
      secretId: external_exports.string()
    })
  },
  LIST_SECRETS: {
    name: "list_secrets",
    description: "List all secrets for a world. DM view - shows hidden information.",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      includeRevealed: external_exports.boolean().default(false).describe("Include already revealed secrets"),
      type: external_exports.string().optional().describe("Filter by type"),
      linkedEntityId: external_exports.string().optional().describe("Get secrets for a specific entity")
    })
  },
  UPDATE_SECRET: {
    name: "update_secret",
    description: "Update a secret's properties.",
    inputSchema: external_exports.object({
      secretId: external_exports.string(),
      publicDescription: external_exports.string().optional(),
      secretDescription: external_exports.string().optional(),
      sensitivity: external_exports.enum(["low", "medium", "high", "critical"]).optional(),
      leakPatterns: external_exports.array(external_exports.string()).optional(),
      revealConditions: external_exports.array(RevealConditionSchema).optional(),
      notes: external_exports.string().optional()
    })
  },
  DELETE_SECRET: {
    name: "delete_secret",
    description: "Delete a secret from the world.",
    inputSchema: external_exports.object({
      secretId: external_exports.string()
    })
  },
  REVEAL_SECRET: {
    name: "reveal_secret",
    description: "Reveal a secret to the player. Include the spoilerMarkdown field in your response for clickable reveal.",
    inputSchema: external_exports.object({
      secretId: external_exports.string(),
      triggeredBy: external_exports.string().describe('What triggered the reveal, e.g. "Insight check DC 15"'),
      partial: external_exports.boolean().default(false).describe("If true, only hint at the secret")
    })
  },
  CHECK_REVEAL_CONDITIONS: {
    name: "check_reveal_conditions",
    description: "Check if any secrets should be revealed based on a game event.",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      event: GameEventSchema
    })
  },
  GET_SECRETS_FOR_CONTEXT: {
    name: "get_secrets_for_context",
    description: "Get active secrets formatted for LLM context injection with DO NOT REVEAL instructions.",
    inputSchema: external_exports.object({
      worldId: external_exports.string()
    })
  },
  CHECK_FOR_LEAKS: {
    name: "check_for_leaks",
    description: "Check if text contains potential secret leaks based on leak patterns.",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      text: external_exports.string().describe("The text to check for potential leaks")
    })
  }
};
async function handleCreateSecret(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.CREATE_SECRET.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const secret = {
    ...parsed,
    id: (0, import_crypto7.randomUUID)(),
    revealed: false,
    createdAt: now,
    updatedAt: now
  };
  const created = secretRepo.create(secret);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Created secret: "${created.name}"`,
        secret: created,
        warning: "This information is hidden from players. Use leak patterns to prevent accidental disclosure."
      }, null, 2)
    }]
  };
}
async function handleGetSecret(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.GET_SECRET.inputSchema.parse(args);
  const secret = secretRepo.findById(parsed.secretId);
  if (!secret) {
    throw new Error(`Secret ${parsed.secretId} not found`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(secret, null, 2)
    }]
  };
}
async function handleListSecrets(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.LIST_SECRETS.inputSchema.parse(args);
  const secrets = secretRepo.find({
    worldId: parsed.worldId,
    revealed: parsed.includeRevealed ? void 0 : false,
    type: parsed.type,
    linkedEntityId: parsed.linkedEntityId
  });
  const grouped = /* @__PURE__ */ new Map();
  for (const secret of secrets) {
    const existing = grouped.get(secret.type) || [];
    existing.push(secret);
    grouped.set(secret.type, existing);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        worldId: parsed.worldId,
        count: secrets.length,
        secretsByType: Object.fromEntries(grouped),
        secrets: secrets.map((s) => ({
          id: s.id,
          name: s.name,
          type: s.type,
          category: s.category,
          sensitivity: s.sensitivity,
          revealed: s.revealed,
          linkedTo: s.linkedEntityId ? `${s.linkedEntityType}:${s.linkedEntityId}` : null
        }))
      }, null, 2)
    }]
  };
}
async function handleUpdateSecret(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.UPDATE_SECRET.inputSchema.parse(args);
  const { secretId, ...updates } = parsed;
  const updated = secretRepo.update(secretId, updates);
  if (!updated) {
    throw new Error(`Secret ${secretId} not found`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Updated secret: "${updated.name}"`,
        secret: updated
      }, null, 2)
    }]
  };
}
async function handleDeleteSecret(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.DELETE_SECRET.inputSchema.parse(args);
  const secret = secretRepo.findById(parsed.secretId);
  if (!secret) {
    throw new Error(`Secret ${parsed.secretId} not found`);
  }
  const deleted = secretRepo.delete(parsed.secretId);
  if (!deleted) {
    throw new Error("Failed to delete secret");
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Deleted secret: "${secret.name}"`,
        id: secret.id
      }, null, 2)
    }]
  };
}
async function handleRevealSecret(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.REVEAL_SECRET.inputSchema.parse(args);
  const secret = secretRepo.findById(parsed.secretId);
  if (!secret) {
    throw new Error(`Secret ${parsed.secretId} not found`);
  }
  if (secret.revealed) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          message: `Secret "${secret.name}" was already revealed`,
          revealedAt: secret.revealedAt,
          revealedBy: secret.revealedBy
        }, null, 2)
      }]
    };
  }
  let narration = "";
  let spoilerMarkdown = "";
  if (parsed.partial) {
    const partialCondition = secret.revealConditions.find((c) => c.partialReveal && c.partialText);
    narration = partialCondition?.partialText || `Something seems off about ${secret.publicDescription.toLowerCase()}...`;
    spoilerMarkdown = `

> \u{1F4AD} *${narration}*
`;
  } else {
    narration = generateRevealNarration(secret);
    spoilerMarkdown = `

:::spoiler[\u{1F52E} ${secret.name} - Click to Reveal]
${narration}
:::
`;
    secretRepo.reveal(parsed.secretId, parsed.triggeredBy);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: parsed.partial ? "Hint revealed" : `Secret revealed: "${secret.name}"`,
        partial: parsed.partial,
        triggeredBy: parsed.triggeredBy,
        narration,
        spoilerMarkdown,
        instruction: "Include the spoilerMarkdown in your response to the player. It will render as a clickable reveal.",
        secret: {
          id: secret.id,
          name: secret.name,
          type: secret.type,
          publicDescription: secret.publicDescription,
          secretDescription: secret.secretDescription,
          revealed: !parsed.partial
        }
      }, null, 2)
    }]
  };
}
async function handleCheckRevealConditions(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.CHECK_REVEAL_CONDITIONS.inputSchema.parse(args);
  const secretsToReveal = secretRepo.checkRevealConditions(parsed.worldId, parsed.event);
  if (secretsToReveal.length === 0) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          message: "No secrets triggered by this event",
          event: parsed.event
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `${secretsToReveal.length} secret(s) can be revealed`,
        event: parsed.event,
        secretsToReveal: secretsToReveal.map((s) => ({
          id: s.id,
          name: s.name,
          type: s.type,
          secretDescription: s.secretDescription,
          matchedConditions: s.revealConditions.filter((c) => {
            if (c.type !== parsed.event.type)
              return false;
            if (c.type === "skill_check") {
              return parsed.event.skill === c.skill && (parsed.event.result || 0) >= (c.dc || 0);
            }
            return true;
          })
        })),
        instruction: "Call reveal_secret for each secret you want to reveal"
      }, null, 2)
    }]
  };
}
async function handleGetSecretsForContext(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.GET_SECRETS_FOR_CONTEXT.inputSchema.parse(args);
  const formattedContext = secretRepo.formatForLLM(parsed.worldId);
  const secrets = secretRepo.getActiveSecrets(parsed.worldId);
  if (secrets.length === 0) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          message: "No active secrets for this world",
          worldId: parsed.worldId,
          context: ""
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        worldId: parsed.worldId,
        secretCount: secrets.length,
        context: formattedContext,
        instruction: "Inject this context into the LLM system prompt. The AI must follow DO NOT REVEAL instructions."
      }, null, 2)
    }]
  };
}
async function handleCheckForLeaks(args, _ctx) {
  const { secretRepo } = ensureDb4();
  const parsed = SecretTools.CHECK_FOR_LEAKS.inputSchema.parse(args);
  const leaks = secretRepo.checkForLeaks(parsed.text, parsed.worldId);
  if (leaks.length === 0) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          message: "No potential leaks detected",
          clean: true
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `\u26A0\uFE0F Potential leaks detected: ${leaks.length}`,
        clean: false,
        leaks: leaks.map((l) => ({
          secretName: l.secretName,
          pattern: l.pattern,
          context: l.context,
          severity: "Check if this is actually revealing the secret"
        })),
        recommendation: "Review the text and rephrase to avoid these patterns"
      }, null, 2)
    }]
  };
}
function generateRevealNarration(secret) {
  const templates = {
    "npc-motivation": `The truth becomes horrifyingly clear: ${secret.secretDescription}`,
    "npc-identity": `A shocking revelation - ${secret.secretDescription}`,
    "location-trap": `With a click and a rumble, you realize: ${secret.secretDescription}`,
    "location-hidden": `Your eyes adjust, and you discover: ${secret.secretDescription}`,
    "item-curse": `A dark aura pulses as you realize: ${secret.secretDescription}`,
    "item-power": `The true nature of the artifact reveals itself: ${secret.secretDescription}`,
    "plot-twist": `Everything you thought you knew shatters as the truth emerges: ${secret.secretDescription}`,
    "mechanic-weakness": `You've discovered a crucial weakness: ${secret.secretDescription}`
  };
  const key = `${secret.type}-${secret.category}`;
  return templates[key] || `The hidden truth about ${secret.name} is revealed: ${secret.secretDescription}`;
}

// dist/server/party-tools.js
var import_crypto8 = require("crypto");
init_zod();

// dist/storage/repos/party.repo.js
init_party();
var PartyRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  // ========== Party CRUD ==========
  create(party) {
    const validated = PartySchema.parse(party);
    const stmt = this.db.prepare(`
            INSERT INTO parties (id, name, description, world_id, status, current_location, 
                current_quest_id, formation, position_x, position_y, current_poi, created_at, updated_at, last_played_at)
            VALUES (@id, @name, @description, @worldId, @status, @currentLocation, 
                @currentQuestId, @formation, @positionX, @positionY, @currentPOI, @createdAt, @updatedAt, @lastPlayedAt)
        `);
    stmt.run({
      id: validated.id,
      name: validated.name,
      description: validated.description || null,
      worldId: validated.worldId || null,
      status: validated.status,
      currentLocation: validated.currentLocation || null,
      currentQuestId: validated.currentQuestId || null,
      formation: validated.formation,
      positionX: validated.positionX ?? null,
      positionY: validated.positionY ?? null,
      currentPOI: validated.currentPOI || null,
      createdAt: validated.createdAt,
      updatedAt: validated.updatedAt,
      lastPlayedAt: validated.lastPlayedAt || null
    });
    return validated;
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM parties WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToParty(row);
  }
  findAll(filters) {
    let query = "SELECT * FROM parties WHERE 1=1";
    const params = [];
    if (filters?.status) {
      query += " AND status = ?";
      params.push(filters.status);
    }
    if (filters?.worldId) {
      query += " AND world_id = ?";
      params.push(filters.worldId);
    }
    query += " ORDER BY last_played_at DESC NULLS LAST, updated_at DESC";
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    return rows.map((row) => this.rowToParty(row));
  }
  update(id, updates) {
    const existing = this.findById(id);
    if (!existing)
      return null;
    const updated = {
      ...existing,
      ...updates,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const validated = PartySchema.parse(updated);
    const stmt = this.db.prepare(`
            UPDATE parties SET 
                name = ?, description = ?, world_id = ?, status = ?, 
                current_location = ?, current_quest_id = ?, formation = ?,
                position_x = ?, position_y = ?, current_poi = ?,
                updated_at = ?, last_played_at = ?
            WHERE id = ?
        `);
    stmt.run(validated.name, validated.description || null, validated.worldId || null, validated.status, validated.currentLocation || null, validated.currentQuestId || null, validated.formation, validated.positionX ?? null, validated.positionY ?? null, validated.currentPOI || null, validated.updatedAt, validated.lastPlayedAt || null, id);
    return validated;
  }
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM parties WHERE id = ?");
    const result = stmt.run(id);
    return result.changes > 0;
  }
  // ========== Party Members ==========
  addMember(member) {
    const validated = PartyMemberSchema.parse(member);
    const stmt = this.db.prepare(`
            INSERT INTO party_members (id, party_id, character_id, role, is_active, 
                position, share_percentage, joined_at, notes)
            VALUES (@id, @partyId, @characterId, @role, @isActive, 
                @position, @sharePercentage, @joinedAt, @notes)
        `);
    stmt.run({
      id: validated.id,
      partyId: validated.partyId,
      characterId: validated.characterId,
      role: validated.role,
      isActive: validated.isActive ? 1 : 0,
      position: validated.position ?? null,
      sharePercentage: validated.sharePercentage,
      joinedAt: validated.joinedAt,
      notes: validated.notes || null
    });
    return validated;
  }
  removeMember(partyId, characterId) {
    const stmt = this.db.prepare("DELETE FROM party_members WHERE party_id = ? AND character_id = ?");
    const result = stmt.run(partyId, characterId);
    return result.changes > 0;
  }
  updateMember(partyId, characterId, updates) {
    const existing = this.findMember(partyId, characterId);
    if (!existing)
      return null;
    const updated = {
      ...existing,
      ...updates
    };
    const stmt = this.db.prepare(`
            UPDATE party_members SET 
                role = ?, is_active = ?, position = ?, 
                share_percentage = ?, notes = ?
            WHERE party_id = ? AND character_id = ?
        `);
    stmt.run(updated.role, updated.isActive ? 1 : 0, updated.position ?? null, updated.sharePercentage, updated.notes || null, partyId, characterId);
    return updated;
  }
  findMember(partyId, characterId) {
    const stmt = this.db.prepare("SELECT * FROM party_members WHERE party_id = ? AND character_id = ?");
    const row = stmt.get(partyId, characterId);
    if (!row)
      return null;
    return this.rowToMember(row);
  }
  findMembersByParty(partyId) {
    const stmt = this.db.prepare("SELECT * FROM party_members WHERE party_id = ? ORDER BY position ASC NULLS LAST, joined_at ASC");
    const rows = stmt.all(partyId);
    return rows.map((row) => this.rowToMember(row));
  }
  findPartiesByCharacter(characterId) {
    const stmt = this.db.prepare(`
            SELECT p.* FROM parties p
            INNER JOIN party_members pm ON p.id = pm.party_id
            WHERE pm.character_id = ?
            ORDER BY p.last_played_at DESC NULLS LAST
        `);
    const rows = stmt.all(characterId);
    return rows.map((row) => this.rowToParty(row));
  }
  // ========== Complex Queries ==========
  setLeader(partyId, characterId) {
    this.db.prepare(`
            UPDATE party_members SET role = 'member' 
            WHERE party_id = ? AND role = 'leader'
        `).run(partyId);
    const stmt = this.db.prepare(`
            UPDATE party_members SET role = 'leader' 
            WHERE party_id = ? AND character_id = ?
        `);
    const result = stmt.run(partyId, characterId);
    return result.changes > 0;
  }
  setActiveCharacter(partyId, characterId) {
    this.db.prepare(`
            UPDATE party_members SET is_active = 0 
            WHERE party_id = ? AND is_active = 1
        `).run(partyId);
    const stmt = this.db.prepare(`
            UPDATE party_members SET is_active = 1 
            WHERE party_id = ? AND character_id = ?
        `);
    const result = stmt.run(partyId, characterId);
    return result.changes > 0;
  }
  getPartyWithMembers(partyId) {
    const party = this.findById(partyId);
    if (!party)
      return null;
    const stmt = this.db.prepare(`
            SELECT 
                pm.id, pm.party_id, pm.character_id, pm.role, pm.is_active, 
                pm.position, pm.share_percentage, pm.joined_at, pm.notes,
                c.id as char_id, c.name as char_name, c.stats, c.hp, c.max_hp, 
                c.ac, c.level, c.behavior, c.character_type, c.race, c.character_class
            FROM party_members pm
            INNER JOIN characters c ON pm.character_id = c.id
            WHERE pm.party_id = ?
            ORDER BY 
                CASE pm.role WHEN 'leader' THEN 0 ELSE 1 END,
                pm.position ASC NULLS LAST,
                pm.joined_at ASC
        `);
    const rows = stmt.all(partyId);
    const members = rows.map((row) => ({
      id: row.id,
      partyId: row.party_id,
      characterId: row.character_id,
      role: row.role,
      isActive: row.is_active === 1,
      position: row.position ?? void 0,
      sharePercentage: row.share_percentage,
      joinedAt: row.joined_at,
      notes: row.notes ?? void 0,
      character: {
        id: row.char_id,
        name: row.char_name,
        hp: row.hp,
        maxHp: row.max_hp,
        ac: row.ac,
        level: row.level,
        stats: JSON.parse(row.stats),
        behavior: row.behavior ?? void 0,
        characterType: row.character_type ?? void 0,
        race: row.race ?? void 0,
        class: row.character_class ?? void 0
      }
    }));
    const leader = members.find((m) => m.role === "leader");
    const activeCharacter = members.find((m) => m.isActive);
    return {
      ...party,
      members,
      leader,
      activeCharacter,
      memberCount: members.length
    };
  }
  getUnassignedCharacters(excludeTypes) {
    let query = `
            SELECT c.id, c.name, c.level, c.character_type as characterType, c.race, c.character_class as class
            FROM characters c
            LEFT JOIN party_members pm ON c.id = pm.character_id
            WHERE pm.id IS NULL
        `;
    const params = [];
    if (excludeTypes && excludeTypes.length > 0) {
      query += ` AND (c.character_type IS NULL OR c.character_type NOT IN (${excludeTypes.map(() => "?").join(", ")}))`;
      params.push(...excludeTypes);
    }
    query += " ORDER BY c.name ASC";
    const stmt = this.db.prepare(query);
    return stmt.all(...params);
  }
  // ========== Touch for activity tracking ==========
  touchParty(partyId) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    this.db.prepare(`
            UPDATE parties SET last_played_at = ?, updated_at = ? WHERE id = ?
        `).run(now, now, partyId);
  }
  // ========== Party Position Management ==========
  updatePartyPosition(partyId, x, y, locationName, poiId) {
    const stmt = this.db.prepare(`
            UPDATE parties 
            SET position_x = ?, position_y = ?, current_location = ?, 
                current_poi = ?, updated_at = ?
            WHERE id = ?
            RETURNING *
        `);
    const result = stmt.get(x, y, locationName, poiId || null, (/* @__PURE__ */ new Date()).toISOString(), partyId);
    if (!result) {
      throw new Error(`Party not found: ${partyId}`);
    }
    return this.rowToParty(result);
  }
  getPartyPosition(partyId) {
    const stmt = this.db.prepare(`
            SELECT position_x, position_y, current_location, current_poi
            FROM parties
            WHERE id = ?
        `);
    const result = stmt.get(partyId);
    if (!result || result.position_x === null) {
      return null;
    }
    return {
      x: result.position_x,
      y: result.position_y,
      locationName: result.current_location || "Unknown Location",
      poiId: result.current_poi || void 0
    };
  }
  getPartiesWithPositions(worldId) {
    const stmt = this.db.prepare(`
            SELECT * FROM parties
            WHERE world_id = ? AND position_x IS NOT NULL
            ORDER BY updated_at DESC
        `);
    const results = stmt.all(worldId);
    return results.map((row) => ({
      ...this.rowToParty(row),
      position: {
        x: row.position_x || 0,
        y: row.position_y || 0,
        locationName: row.current_location || "Unknown Location",
        poiId: row.current_poi || void 0
      }
    }));
  }
  getPartiesNearPosition(worldId, x, y, radiusSquares = 3) {
    const stmt = this.db.prepare(`
            SELECT * FROM parties
            WHERE world_id = ?
                AND position_x IS NOT NULL
                AND ABS(position_x - ?) <= ?
                AND ABS(position_y - ?) <= ?
            ORDER BY (position_x - ?) * (position_x - ?) +
                     (position_y - ?) * (position_y - ?)
        `);
    const results = stmt.all(worldId, x, radiusSquares, y, radiusSquares, x, x, y, y);
    return results.map((row) => this.rowToParty(row));
  }
  // ========== Row converters ==========
  rowToParty(row) {
    return PartySchema.parse({
      id: row.id,
      name: row.name,
      description: row.description ?? void 0,
      worldId: row.world_id ?? void 0,
      status: row.status,
      currentLocation: row.current_location ?? void 0,
      currentQuestId: row.current_quest_id ?? void 0,
      formation: row.formation,
      positionX: row.position_x ?? void 0,
      positionY: row.position_y ?? void 0,
      currentPOI: row.current_poi ?? void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      lastPlayedAt: row.last_played_at ?? void 0
    });
  }
  rowToMember(row) {
    return PartyMemberSchema.parse({
      id: row.id,
      partyId: row.party_id,
      characterId: row.character_id,
      role: row.role,
      isActive: row.is_active === 1,
      position: row.position ?? void 0,
      sharePercentage: row.share_percentage,
      joinedAt: row.joined_at,
      notes: row.notes ?? void 0
    });
  }
};

// dist/server/party-tools.js
init_character_repo();
init_party();
function ensureDb5() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const partyRepo = new PartyRepository(db);
  const charRepo = new CharacterRepository(db);
  const questRepo = new QuestRepository(db);
  return { db, partyRepo, charRepo, questRepo };
}
var PartyTools = {
  // Party CRUD
  CREATE_PARTY: {
    name: "create_party",
    description: `Create a new party (adventuring group).

Example:
{
  "name": "The Fellowship",
  "description": "Nine companions on a quest to destroy the One Ring",
  "worldId": "middle-earth-id",
  "initialMembers": [
    { "characterId": "gandalf-id", "role": "leader" },
    { "characterId": "frodo-id", "role": "member" }
  ]
}`,
    inputSchema: external_exports.object({
      name: external_exports.string().min(1),
      description: external_exports.string().optional(),
      worldId: external_exports.string().optional(),
      initialMembers: external_exports.array(external_exports.object({
        characterId: external_exports.string(),
        role: MemberRoleSchema.optional().default("member")
      })).optional()
    })
  },
  GET_PARTY: {
    name: "get_party",
    description: "Get a party with all member details, leader, and active character info.",
    inputSchema: external_exports.object({
      partyId: external_exports.string()
    })
  },
  LIST_PARTIES: {
    name: "list_parties",
    description: "List all parties, optionally filtered by status or world.",
    inputSchema: external_exports.object({
      status: PartyStatusSchema.optional(),
      worldId: external_exports.string().optional()
    })
  },
  UPDATE_PARTY: {
    name: "update_party",
    description: "Update party properties (name, description, location, formation, status).",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      name: external_exports.string().min(1).optional(),
      description: external_exports.string().optional(),
      currentLocation: external_exports.string().optional(),
      formation: external_exports.string().optional(),
      status: PartyStatusSchema.optional()
    })
  },
  DELETE_PARTY: {
    name: "delete_party",
    description: "Delete a party. Members become unassigned (not deleted).",
    inputSchema: external_exports.object({
      partyId: external_exports.string()
    })
  },
  // Member management
  ADD_PARTY_MEMBER: {
    name: "add_party_member",
    description: "Add a character to a party with role (leader, member, companion, hireling, prisoner, mount).",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      characterId: external_exports.string(),
      role: MemberRoleSchema.optional().default("member"),
      position: external_exports.number().int().optional(),
      notes: external_exports.string().optional()
    })
  },
  REMOVE_PARTY_MEMBER: {
    name: "remove_party_member",
    description: "Remove a character from a party.",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      characterId: external_exports.string()
    })
  },
  UPDATE_PARTY_MEMBER: {
    name: "update_party_member",
    description: "Update a party member's role, position, or notes.",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      characterId: external_exports.string(),
      role: MemberRoleSchema.optional(),
      position: external_exports.number().int().optional(),
      sharePercentage: external_exports.number().int().min(0).max(100).optional(),
      notes: external_exports.string().optional()
    })
  },
  SET_PARTY_LEADER: {
    name: "set_party_leader",
    description: "Set the party leader. The character must already be a member.",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      characterId: external_exports.string()
    })
  },
  SET_ACTIVE_CHARACTER: {
    name: "set_active_character",
    description: "Set the active character (player's POV). The character must already be a member.",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      characterId: external_exports.string()
    })
  },
  GET_PARTY_MEMBERS: {
    name: "get_party_members",
    description: "Get all members of a party with their character details.",
    inputSchema: external_exports.object({
      partyId: external_exports.string()
    })
  },
  // Context for LLM
  GET_PARTY_CONTEXT: {
    name: "get_party_context",
    description: "Get party context for LLM prompts. Verbosity: minimal (~150 tokens), standard (~400), or detailed (~800).",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      verbosity: external_exports.enum(["minimal", "standard", "detailed"]).optional().default("standard")
    })
  },
  // Utility
  GET_UNASSIGNED_CHARACTERS: {
    name: "get_unassigned_characters",
    description: "Get characters not assigned to any party. Useful for adding members.",
    inputSchema: external_exports.object({
      excludeEnemies: external_exports.boolean().optional().default(true)
    })
  },
  // Party Position & Movement
  MOVE_PARTY: {
    name: "move_party",
    description: "Move a party to world map coordinates or POI. Updates location name and optional POI reference.",
    inputSchema: external_exports.object({
      partyId: external_exports.string(),
      targetX: external_exports.number().int().nonnegative(),
      targetY: external_exports.number().int().nonnegative(),
      locationName: external_exports.string().min(1),
      poiId: external_exports.string().optional()
    })
  },
  GET_PARTY_POSITION: {
    name: "get_party_position",
    description: "Get the current position of a party on the world map.",
    inputSchema: external_exports.object({
      partyId: external_exports.string()
    })
  },
  GET_PARTIES_IN_REGION: {
    name: "get_parties_in_region",
    description: "Get all parties within a certain distance of a coordinate (useful for finding nearby groups).",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      x: external_exports.number().int(),
      y: external_exports.number().int(),
      radiusSquares: external_exports.number().int().optional().default(3)
    })
  }
};
async function handleCreateParty(args, _ctx) {
  const { partyRepo, charRepo } = ensureDb5();
  const parsed = PartyTools.CREATE_PARTY.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const party = {
    id: (0, import_crypto8.randomUUID)(),
    name: parsed.name,
    description: parsed.description,
    worldId: parsed.worldId,
    status: "active",
    formation: "standard",
    createdAt: now,
    updatedAt: now,
    lastPlayedAt: now
  };
  partyRepo.create(party);
  const addedMembers = [];
  let leaderId = null;
  if (parsed.initialMembers && parsed.initialMembers.length > 0) {
    for (let i = 0; i < parsed.initialMembers.length; i++) {
      const memberInput = parsed.initialMembers[i];
      const character = charRepo.findById(memberInput.characterId);
      if (!character) {
        continue;
      }
      const member = {
        id: (0, import_crypto8.randomUUID)(),
        partyId: party.id,
        characterId: memberInput.characterId,
        role: memberInput.role || "member",
        isActive: i === 0,
        // First member is active by default
        position: i + 1,
        sharePercentage: 100,
        joinedAt: now
      };
      partyRepo.addMember(member);
      addedMembers.push({
        characterId: character.id,
        name: character.name,
        role: member.role
      });
      if (member.role === "leader") {
        leaderId = character.id;
      }
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        party: {
          id: party.id,
          name: party.name,
          description: party.description,
          status: party.status
        },
        members: addedMembers,
        memberCount: addedMembers.length,
        leaderId
      }, null, 2)
    }]
  };
}
async function handleGetParty(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.GET_PARTY.inputSchema.parse(args);
  const party = partyRepo.getPartyWithMembers(parsed.partyId);
  if (!party) {
    throw new Error(`Party not found: ${parsed.partyId}`);
  }
  partyRepo.touchParty(parsed.partyId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(party, null, 2)
    }]
  };
}
async function handleListParties(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.LIST_PARTIES.inputSchema.parse(args);
  const parties = partyRepo.findAll({
    status: parsed.status,
    worldId: parsed.worldId
  });
  const partiesWithCounts = parties.map((party) => {
    const members = partyRepo.findMembersByParty(party.id);
    return {
      ...party,
      memberCount: members.length
    };
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        parties: partiesWithCounts,
        count: partiesWithCounts.length
      }, null, 2)
    }]
  };
}
async function handleUpdateParty(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.UPDATE_PARTY.inputSchema.parse(args);
  const { partyId, ...updates } = parsed;
  const updated = partyRepo.update(partyId, updates);
  if (!updated) {
    throw new Error(`Party not found: ${partyId}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(updated, null, 2)
    }]
  };
}
async function handleDeleteParty(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.DELETE_PARTY.inputSchema.parse(args);
  const deleted = partyRepo.delete(parsed.partyId);
  if (!deleted) {
    throw new Error(`Party not found: ${parsed.partyId}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: "Party deleted",
        id: parsed.partyId
      }, null, 2)
    }]
  };
}
async function handleAddPartyMember(args, _ctx) {
  const { partyRepo, charRepo } = ensureDb5();
  const parsed = PartyTools.ADD_PARTY_MEMBER.inputSchema.parse(args);
  const party = partyRepo.findById(parsed.partyId);
  if (!party) {
    throw new Error(`Party not found: ${parsed.partyId}`);
  }
  const character = charRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character not found: ${parsed.characterId}`);
  }
  const existing = partyRepo.findMember(parsed.partyId, parsed.characterId);
  if (existing) {
    throw new Error(`Character ${character.name} is already in party ${party.name}`);
  }
  if (parsed.role === "leader") {
    partyRepo.setLeader(parsed.partyId, parsed.characterId);
  }
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const member = {
    id: (0, import_crypto8.randomUUID)(),
    partyId: parsed.partyId,
    characterId: parsed.characterId,
    role: parsed.role || "member",
    isActive: false,
    position: parsed.position,
    sharePercentage: 100,
    joinedAt: now,
    notes: parsed.notes
  };
  partyRepo.addMember(member);
  partyRepo.touchParty(parsed.partyId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Added ${character.name} to ${party.name}`,
        member: {
          characterId: character.id,
          name: character.name,
          role: member.role,
          position: member.position
        }
      }, null, 2)
    }]
  };
}
async function handleRemovePartyMember(args, _ctx) {
  const { partyRepo, charRepo } = ensureDb5();
  const parsed = PartyTools.REMOVE_PARTY_MEMBER.inputSchema.parse(args);
  const character = charRepo.findById(parsed.characterId);
  const removed = partyRepo.removeMember(parsed.partyId, parsed.characterId);
  if (!removed) {
    throw new Error(`Member not found in party`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Removed ${character?.name || parsed.characterId} from party`,
        characterId: parsed.characterId
      }, null, 2)
    }]
  };
}
async function handleUpdatePartyMember(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.UPDATE_PARTY_MEMBER.inputSchema.parse(args);
  const { partyId, characterId, ...updates } = parsed;
  const updated = partyRepo.updateMember(partyId, characterId, updates);
  if (!updated) {
    throw new Error(`Member not found in party`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(updated, null, 2)
    }]
  };
}
async function handleSetPartyLeader(args, _ctx) {
  const { partyRepo, charRepo } = ensureDb5();
  const parsed = PartyTools.SET_PARTY_LEADER.inputSchema.parse(args);
  const member = partyRepo.findMember(parsed.partyId, parsed.characterId);
  if (!member) {
    throw new Error(`Character is not a member of this party`);
  }
  const character = charRepo.findById(parsed.characterId);
  partyRepo.setLeader(parsed.partyId, parsed.characterId);
  partyRepo.touchParty(parsed.partyId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `${character?.name || parsed.characterId} is now the party leader`,
        leaderId: parsed.characterId
      }, null, 2)
    }]
  };
}
async function handleSetActiveCharacter(args, _ctx) {
  const { partyRepo, charRepo } = ensureDb5();
  const parsed = PartyTools.SET_ACTIVE_CHARACTER.inputSchema.parse(args);
  const member = partyRepo.findMember(parsed.partyId, parsed.characterId);
  if (!member) {
    throw new Error(`Character is not a member of this party`);
  }
  const character = charRepo.findById(parsed.characterId);
  partyRepo.setActiveCharacter(parsed.partyId, parsed.characterId);
  partyRepo.touchParty(parsed.partyId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `Active character set to ${character?.name || parsed.characterId}`,
        activeCharacterId: parsed.characterId
      }, null, 2)
    }]
  };
}
async function handleGetPartyMembers(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.GET_PARTY_MEMBERS.inputSchema.parse(args);
  const party = partyRepo.getPartyWithMembers(parsed.partyId);
  if (!party) {
    throw new Error(`Party not found: ${parsed.partyId}`);
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        partyId: party.id,
        partyName: party.name,
        members: party.members,
        leader: party.leader,
        activeCharacter: party.activeCharacter,
        memberCount: party.memberCount
      }, null, 2)
    }]
  };
}
async function handleGetPartyContext(args, _ctx) {
  const { partyRepo, questRepo } = ensureDb5();
  const parsed = PartyTools.GET_PARTY_CONTEXT.inputSchema.parse(args);
  const party = partyRepo.getPartyWithMembers(parsed.partyId);
  if (!party) {
    throw new Error(`Party not found: ${parsed.partyId}`);
  }
  const context = {
    party: {
      id: party.id,
      name: party.name,
      status: party.status,
      location: party.currentLocation,
      formation: party.formation
    },
    members: party.members.map((m) => ({
      name: m.character.name,
      role: m.role,
      hp: `${m.character.hp}/${m.character.maxHp}`,
      status: m.character.hp < m.character.maxHp * 0.25 ? "critical" : m.character.hp < m.character.maxHp * 0.5 ? "wounded" : m.character.hp < m.character.maxHp ? "hurt" : "healthy"
    }))
  };
  if (party.leader) {
    context.leader = {
      id: party.leader.character.id,
      name: party.leader.character.name,
      hp: party.leader.character.hp,
      maxHp: party.leader.character.maxHp,
      level: party.leader.character.level
    };
  }
  if (party.activeCharacter) {
    context.activeCharacter = {
      id: party.activeCharacter.character.id,
      name: party.activeCharacter.character.name,
      hp: party.activeCharacter.character.hp,
      maxHp: party.activeCharacter.character.maxHp,
      level: party.activeCharacter.character.level,
      conditions: party.activeCharacter.character.hp < party.activeCharacter.character.maxHp * 0.5 ? ["wounded"] : void 0
    };
  }
  if (party.currentQuestId) {
    try {
      const quest = questRepo.findById(party.currentQuestId);
      if (quest) {
        const completedCount = quest.objectives.filter((o) => o.completed).length;
        context.activeQuest = {
          name: quest.name,
          currentObjective: quest.objectives.find((o) => !o.completed)?.description,
          progress: `${Math.round(completedCount / quest.objectives.length * 100)}%`
        };
      }
    } catch (e) {
    }
  }
  partyRepo.touchParty(parsed.partyId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify(context, null, 2)
    }]
  };
}
async function handleGetUnassignedCharacters(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.GET_UNASSIGNED_CHARACTERS.inputSchema.parse(args);
  const excludeTypes = parsed.excludeEnemies ? ["enemy"] : void 0;
  const characters = partyRepo.getUnassignedCharacters(excludeTypes);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characters,
        count: characters.length
      }, null, 2)
    }]
  };
}
async function handleMoveParty(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.MOVE_PARTY.inputSchema.parse(args);
  try {
    const party = partyRepo.findById(parsed.partyId);
    if (!party) {
      throw new Error(`Party not found: ${parsed.partyId}`);
    }
    const updatedParty = partyRepo.updatePartyPosition(parsed.partyId, parsed.targetX, parsed.targetY, parsed.locationName, parsed.poiId);
    if (!updatedParty) {
      throw new Error(`Failed to update party position: ${parsed.partyId}`);
    }
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: true,
          party: updatedParty,
          newPosition: {
            x: parsed.targetX,
            y: parsed.targetY,
            location: parsed.locationName,
            poiId: parsed.poiId || null
          },
          message: `Party "${updatedParty.name}" moved to ${parsed.locationName} (${parsed.targetX}, ${parsed.targetY})`
        }, null, 2)
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: error.message || "Failed to move party"
        }, null, 2)
      }]
    };
  }
}
async function handleGetPartyPosition(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.GET_PARTY_POSITION.inputSchema.parse(args);
  try {
    const party = partyRepo.findById(parsed.partyId);
    if (!party) {
      throw new Error(`Party not found: ${parsed.partyId}`);
    }
    const position = partyRepo.getPartyPosition(parsed.partyId);
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: true,
          party: {
            id: party.id,
            name: party.name
          },
          position: position || {
            x: null,
            y: null,
            locationName: "Unknown",
            poiId: null
          }
        }, null, 2)
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: error.message || "Failed to get party position"
        }, null, 2)
      }]
    };
  }
}
async function handleGetPartiesInRegion(args, _ctx) {
  const { partyRepo } = ensureDb5();
  const parsed = PartyTools.GET_PARTIES_IN_REGION.inputSchema.parse(args);
  try {
    const parties = partyRepo.getPartiesNearPosition(parsed.worldId, parsed.x, parsed.y, parsed.radiusSquares);
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: true,
          count: parties.length,
          parties,
          message: `Found ${parties.length} parties within ${parsed.radiusSquares} squares of (${parsed.x}, ${parsed.y})`
        }, null, 2)
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: error.message || "Failed to get parties in region"
        }, null, 2)
      }]
    };
  }
}

// dist/server/rest-tools.js
init_zod();
init_character_repo();
var RestTools = {
  TAKE_LONG_REST: {
    name: "take_long_rest",
    description: "Take a long rest (8 hours). Restores HP to maximum. Future: will restore spell slots.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character taking the rest")
    })
  },
  TAKE_SHORT_REST: {
    name: "take_short_rest",
    description: "Take a short rest (1 hour). Spend hit dice to recover HP.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character taking the rest"),
      hitDiceToSpend: external_exports.number().int().min(0).max(20).default(1).describe("Number of hit dice to spend for healing (default: 1)")
    })
  }
};
function ensureDb6() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return {
    characterRepo: new CharacterRepository(db)
  };
}
function getAbilityModifier2(score) {
  return Math.floor((score - 10) / 2);
}
function rollDie(sides) {
  return Math.floor(Math.random() * sides) + 1;
}
function getHitDieSize(_characterId) {
  return 8;
}
async function handleTakeLongRest(args, _ctx) {
  const { characterRepo } = ensureDb6();
  const parsed = RestTools.TAKE_LONG_REST.inputSchema.parse(args);
  const combatManager = getCombatManager();
  if (combatManager.isCharacterInCombat(parsed.characterId)) {
    const encounters = combatManager.getEncountersForCharacter(parsed.characterId);
    throw new Error(`Cannot take a long rest while in combat! Character is currently in encounter: ${encounters.join(", ")}`);
  }
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const hpRestored = character.maxHp - character.hp;
  const newHp = character.maxHp;
  const charClass = character.characterClass || "fighter";
  const spellConfig = getSpellcastingConfig(charClass);
  let spellSlotsRestored = void 0;
  let updatedChar = { ...character, hp: newHp };
  if (spellConfig.canCast && character.level >= spellConfig.startLevel) {
    const restoredChar = restoreAllSpellSlots(character);
    if (spellConfig.pactMagic) {
      spellSlotsRestored = {
        type: "pactMagic",
        slotsRestored: restoredChar.pactMagicSlots?.max || 0,
        slotLevel: restoredChar.pactMagicSlots?.slotLevel || 0
      };
      updatedChar = { ...updatedChar, pactMagicSlots: restoredChar.pactMagicSlots };
    } else if (restoredChar.spellSlots) {
      spellSlotsRestored = {
        type: "standard",
        level1: restoredChar.spellSlots.level1.max,
        level2: restoredChar.spellSlots.level2.max,
        level3: restoredChar.spellSlots.level3.max,
        level4: restoredChar.spellSlots.level4.max,
        level5: restoredChar.spellSlots.level5.max,
        level6: restoredChar.spellSlots.level6.max,
        level7: restoredChar.spellSlots.level7.max,
        level8: restoredChar.spellSlots.level8.max,
        level9: restoredChar.spellSlots.level9.max
      };
      updatedChar = { ...updatedChar, spellSlots: restoredChar.spellSlots };
    }
    updatedChar = { ...updatedChar, concentratingOn: null, activeSpells: [] };
  }
  characterRepo.update(parsed.characterId, updatedChar);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `${character.name} completes a long rest.`,
        character: character.name,
        previousHp: character.hp,
        newHp,
        maxHp: character.maxHp,
        hpRestored,
        restType: "long",
        spellSlotsRestored
      }, null, 2)
    }]
  };
}
async function handleTakeShortRest(args, _ctx) {
  const { characterRepo } = ensureDb6();
  const parsed = RestTools.TAKE_SHORT_REST.inputSchema.parse(args);
  const combatManager = getCombatManager();
  if (combatManager.isCharacterInCombat(parsed.characterId)) {
    const encounters = combatManager.getEncountersForCharacter(parsed.characterId);
    throw new Error(`Cannot take a short rest while in combat! Character is currently in encounter: ${encounters.join(", ")}`);
  }
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const hitDiceToSpend = parsed.hitDiceToSpend ?? 1;
  const hitDieSize = getHitDieSize(parsed.characterId);
  const conModifier = getAbilityModifier2(character.stats.con);
  let totalHealing = 0;
  const rolls = [];
  for (let i = 0; i < hitDiceToSpend; i++) {
    const roll = rollDie(hitDieSize);
    rolls.push(roll);
    totalHealing += Math.max(1, roll + conModifier);
  }
  const actualHealing = Math.min(totalHealing, character.maxHp - character.hp);
  const newHp = character.hp + actualHealing;
  const charClass = character.characterClass || "fighter";
  const spellConfig = getSpellcastingConfig(charClass);
  let pactSlotsRestored = void 0;
  let updatedChar = { hp: newHp };
  if (spellConfig.pactMagic && spellConfig.canCast && character.level >= spellConfig.startLevel) {
    const restoredChar = restorePactSlots(character);
    pactSlotsRestored = {
      slotsRestored: restoredChar.pactMagicSlots?.max || 0,
      slotLevel: restoredChar.pactMagicSlots?.slotLevel || 0
    };
    updatedChar = { ...updatedChar, pactMagicSlots: restoredChar.pactMagicSlots };
  }
  characterRepo.update(parsed.characterId, updatedChar);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        message: `${character.name} completes a short rest.`,
        character: character.name,
        previousHp: character.hp,
        newHp,
        maxHp: character.maxHp,
        hpRestored: actualHealing,
        hitDiceSpent: hitDiceToSpend,
        hitDieSize: `d${hitDieSize}`,
        conModifier,
        rolls,
        restType: "short",
        pactSlotsRestored
        // Warlock only
      }, null, 2)
    }]
  };
}

// dist/server/concentration-tools.js
init_zod();
init_character_repo();
var ConcentrationTools = {
  CHECK_CONCENTRATION_SAVE: {
    name: "check_concentration_save",
    description: "Roll a Constitution saving throw to maintain concentration after taking damage. DC = 10 or half damage (whichever is higher). Automatically breaks concentration if save fails.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character maintaining concentration"),
      damageAmount: external_exports.number().int().min(0).describe("Amount of damage taken that triggered the concentration check")
    })
  },
  BREAK_CONCENTRATION: {
    name: "break_concentration",
    description: "Manually break a character's concentration on a spell. Use this for voluntary breaks, incapacitation, death, or when casting a new concentration spell.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character whose concentration is breaking"),
      reason: external_exports.enum(["damage", "incapacitated", "death", "new_spell", "voluntary", "duration"]).describe("Reason for breaking concentration"),
      damageAmount: external_exports.number().int().min(0).optional().describe("Amount of damage (only if reason is damage)")
    })
  },
  GET_CONCENTRATION_STATE: {
    name: "get_concentration_state",
    description: "Query what spell a character is currently concentrating on, including duration and targets.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character to check")
    })
  },
  CHECK_CONCENTRATION_DURATION: {
    name: "check_concentration_duration",
    description: "Check if a character's concentration has exceeded its maximum duration. Automatically breaks concentration if duration expired.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character maintaining concentration"),
      currentRound: external_exports.number().int().min(1).describe("The current combat round number")
    })
  },
  CHECK_AUTO_BREAK: {
    name: "check_automatic_concentration_break",
    description: "Check if concentration should automatically break due to death or incapacitating conditions (unconscious, stunned, paralyzed, petrified).",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character to check")
    })
  }
};
function ensureDb7() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return {
    characterRepo: new CharacterRepository(db),
    concentrationRepo: new ConcentrationRepository(db)
  };
}
async function handleCheckConcentrationSave(args, _ctx) {
  const { characterRepo, concentrationRepo } = ensureDb7();
  const parsed = ConcentrationTools.CHECK_CONCENTRATION_SAVE.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const result = checkConcentration(character, parsed.damageAmount, concentrationRepo);
  if (result.broken) {
    breakConcentration({ characterId: parsed.characterId, reason: "damage", damageAmount: parsed.damageAmount }, concentrationRepo, characterRepo);
  }
  return {
    content: [
      {
        type: "text",
        text: formatConcentrationCheckResult(result)
      }
    ]
  };
}
async function handleBreakConcentration(args, _ctx) {
  const { characterRepo, concentrationRepo } = ensureDb7();
  const parsed = BreakConcentrationRequestSchema.parse(args);
  const result = breakConcentration(parsed, concentrationRepo, characterRepo);
  return {
    content: [
      {
        type: "text",
        text: formatBreakConcentrationResult(result)
      }
    ]
  };
}
async function handleGetConcentrationState(args, _ctx) {
  const { concentrationRepo } = ensureDb7();
  const parsed = ConcentrationTools.GET_CONCENTRATION_STATE.inputSchema.parse(args);
  const concentration = getConcentration(parsed.characterId, concentrationRepo);
  if (!concentration) {
    return {
      content: [
        {
          type: "text",
          text: `Character ${parsed.characterId} is not currently concentrating on any spell.`
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: formatConcentrationState(concentration)
      }
    ]
  };
}
async function handleCheckConcentrationDuration(args, _ctx) {
  const { characterRepo, concentrationRepo } = ensureDb7();
  const parsed = ConcentrationTools.CHECK_CONCENTRATION_DURATION.inputSchema.parse(args);
  const result = checkConcentrationDuration(parsed.characterId, parsed.currentRound, concentrationRepo, characterRepo);
  if (!result) {
    return {
      content: [
        {
          type: "text",
          text: "Concentration is still within duration limit."
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: `Concentration on ${result.spell} has exceeded its duration and has ended.`
      }
    ]
  };
}
async function handleCheckAutoBreak(args, _ctx) {
  const { characterRepo, concentrationRepo } = ensureDb7();
  const parsed = ConcentrationTools.CHECK_AUTO_BREAK.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const result = checkAutomaticConcentrationBreak(character, concentrationRepo, characterRepo);
  if (!result) {
    return {
      content: [
        {
          type: "text",
          text: "No automatic concentration break required."
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: `Concentration on ${result.spell} automatically broken due to ${result.reason}.`
      }
    ]
  };
}
function formatConcentrationCheckResult(result) {
  if (result.spell === "none") {
    return "Character is not concentrating on any spell.";
  }
  if (!result.broken) {
    return `\u2705 Concentration maintained on ${result.spell}!

\u{1F3B2} Save Roll: ${result.saveRoll} + ${result.constitutionModifier} (CON) = ${result.saveTotal}
\u{1F3AF} DC: ${result.saveDC} (half of ${result.damageAmount} damage)

Concentration continues.`;
  }
  return `\u274C Concentration broken on ${result.spell}!

\u{1F3B2} Save Roll: ${result.saveRoll} + ${result.constitutionModifier} (CON) = ${result.saveTotal}
\u{1F3AF} DC: ${result.saveDC} (half of ${result.damageAmount} damage)

The spell ends immediately.`;
}
function formatBreakConcentrationResult(result) {
  if (result.spell === "none") {
    return "Character was not concentrating on any spell.";
  }
  const reasonMap = {
    damage: "failed concentration save from damage",
    incapacitated: "becoming incapacitated",
    death: "character death",
    new_spell: "casting a new concentration spell",
    voluntary: "voluntary choice",
    duration: "spell duration expiring"
  };
  const reasonText = reasonMap[result.reason] || result.reason;
  return `\u{1F494} Concentration on ${result.spell} has ended (${reasonText}).`;
}
function formatConcentrationState(concentration) {
  const durationText = concentration.maxDuration ? `${concentration.maxDuration} rounds (started round ${concentration.startedAt})` : "unlimited";
  const targetsText = concentration.targetIds && concentration.targetIds.length > 0 ? concentration.targetIds.join(", ") : "none";
  return `\u{1F52E} Active Concentration

Spell: ${concentration.activeSpell} (Level ${concentration.spellLevel})
Duration: ${durationText}
Targets: ${targetsText}

\u26A0\uFE0F Taking damage requires a Constitution save:
DC = 10 or half damage (whichever is higher)`;
}

// dist/server/scroll-tools.js
init_zod();
var import_crypto9 = require("crypto");
init_character_repo();

// dist/schema/scroll.js
init_zod();
init_spell();
var ScrollPropertiesSchema = external_exports.object({
  spellName: external_exports.string().min(1, "Spell name is required"),
  spellLevel: external_exports.number().int().min(0).max(9).describe("Spell level (0 for cantrips, 1-9 for leveled spells)"),
  scrollDC: external_exports.number().int().min(10).optional().describe("Default spell save DC if caster has no spellcasting ability"),
  scrollAttackBonus: external_exports.number().int().optional().describe("Default spell attack bonus if caster has no spellcasting ability"),
  requiresCheck: external_exports.boolean().default(false).describe("Whether scroll use requires an Arcana check"),
  checkDC: external_exports.number().int().min(10).optional().describe("DC for Arcana check to use scroll"),
  spellClass: SpellcastingClassSchema.optional().describe("Class list the spell is on (for determining if check is required)")
});
var ScrollUsageValidationSchema = external_exports.object({
  characterId: external_exports.string().describe("Character attempting to use the scroll"),
  itemId: external_exports.string().describe("ID of the scroll item"),
  spellName: external_exports.string().describe("Name of the spell on the scroll"),
  spellLevel: external_exports.number().int().min(0).max(9).describe("Level of the spell"),
  spellClass: SpellcastingClassSchema.optional().describe("Class list the spell is on"),
  targetId: external_exports.string().optional().describe("Target for the spell"),
  targetPoint: external_exports.object({
    x: external_exports.number(),
    y: external_exports.number()
  }).optional().describe("Target point for area spells")
});
var ScrollUsageResultSchema = external_exports.object({
  success: external_exports.boolean().describe("Whether the scroll was used successfully"),
  consumed: external_exports.boolean().describe("Whether the scroll was consumed (even on failure)"),
  requiresCheck: external_exports.boolean().describe("Whether an Arcana check was required"),
  checkRoll: external_exports.number().int().optional().describe("The d20 roll for the Arcana check"),
  checkTotal: external_exports.number().int().optional().describe("Total Arcana check result"),
  checkDC: external_exports.number().int().optional().describe("DC for the Arcana check"),
  checkPassed: external_exports.boolean().optional().describe("Whether the check passed"),
  reason: external_exports.enum([
    "auto_success",
    // Spell on class list and can cast that level
    "check_passed",
    // Required check and passed
    "check_failed",
    // Required check and failed
    "not_in_inventory",
    // Character doesn't have the scroll
    "spell_cast",
    // Spell successfully cast
    "invalid_scroll"
    // Scroll data is invalid
  ]).describe("Reason for the result"),
  spellCastResult: external_exports.record(external_exports.any()).optional().describe("Result of the spell cast if successful"),
  message: external_exports.string().describe("Human-readable message about the result")
});
var CreateScrollRequestSchema = external_exports.object({
  spellName: external_exports.string().min(1, "Spell name is required"),
  spellLevel: external_exports.number().int().min(0).max(9),
  scrollDC: external_exports.number().int().min(10).optional().describe("Default DC (usually 13 + spell level for crafted scrolls)"),
  scrollAttackBonus: external_exports.number().int().optional().describe("Default attack bonus (usually +5 + spell level)"),
  spellClass: SpellcastingClassSchema.optional().describe("Class list the spell is on"),
  value: external_exports.number().int().min(0).optional().describe("Gold value of the scroll"),
  description: external_exports.string().optional().describe("Custom description for the scroll")
});
var ScrollRarity;
(function(ScrollRarity2) {
  ScrollRarity2["COMMON"] = "common";
  ScrollRarity2["UNCOMMON"] = "uncommon";
  ScrollRarity2["RARE"] = "rare";
  ScrollRarity2["VERY_RARE"] = "very_rare";
  ScrollRarity2["LEGENDARY"] = "legendary";
})(ScrollRarity || (ScrollRarity = {}));
function getScrollRarity(spellLevel) {
  if (spellLevel === 0)
    return ScrollRarity.COMMON;
  if (spellLevel <= 3)
    return ScrollRarity.UNCOMMON;
  if (spellLevel <= 5)
    return ScrollRarity.RARE;
  if (spellLevel <= 8)
    return ScrollRarity.VERY_RARE;
  return ScrollRarity.LEGENDARY;
}
function calculateScrollDC(spellLevel) {
  return 13 + spellLevel;
}
function calculateScrollAttackBonus(spellLevel) {
  return 5 + spellLevel;
}
function calculateScrollValue(spellLevel) {
  const valueLookup = {
    0: 25,
    // Cantrip - Common (25-50gp)
    1: 75,
    // 1st level - Uncommon (50-100gp)
    2: 150,
    // 2nd level - Uncommon (100-200gp)
    3: 300,
    // 3rd level - Uncommon (200-400gp)
    4: 750,
    // 4th level - Rare (500-1000gp)
    5: 1500,
    // 5th level - Rare (1000-2000gp)
    6: 5e3,
    // 6th level - Very Rare (2500-7500gp)
    7: 1e4,
    // 7th level - Very Rare (5000-15000gp)
    8: 2e4,
    // 8th level - Very Rare (10000-30000gp)
    9: 5e4
    // 9th level - Legendary (25000-100000gp)
  };
  return valueLookup[spellLevel] || 100;
}

// dist/engine/magic/scroll.js
function validateScrollUse(character, scrollProperties) {
  const { spellLevel, spellClass } = scrollProperties;
  const isSpellcaster2 = character.maxSpellLevel !== void 0 && character.maxSpellLevel > 0;
  if (!isSpellcaster2) {
    const checkDC = 10 + spellLevel;
    return {
      requiresCheck: true,
      checkDC,
      reason: "not_a_spellcaster"
    };
  }
  const characterClass = character.characterClass?.toLowerCase();
  const spellClassList = spellClass?.toLowerCase();
  const isOnClassList = characterClass === spellClassList;
  if (!isOnClassList) {
    const checkDC = 10 + spellLevel;
    return {
      requiresCheck: true,
      checkDC,
      reason: "spell_not_on_class_list"
    };
  }
  const maxSpellLevel = character.maxSpellLevel || 0;
  if (spellLevel > maxSpellLevel) {
    const checkDC = 10 + spellLevel;
    return {
      requiresCheck: true,
      checkDC,
      reason: "spell_level_too_high"
    };
  }
  return {
    requiresCheck: false,
    checkDC: null,
    reason: "auto_success"
  };
}
function rollArcanaCheck(character) {
  const roll = Math.floor(Math.random() * 20) + 1;
  const intModifier = Math.floor((character.stats.int - 10) / 2);
  const proficiencyBonus = 0;
  const modifier = intModifier + proficiencyBonus;
  const total = roll + modifier;
  return { roll, total, modifier };
}
function useSpellScroll(character, scroll, inventoryRepo) {
  if (scroll.type !== "scroll") {
    return {
      success: false,
      consumed: false,
      requiresCheck: false,
      reason: "invalid_scroll",
      message: `Item "${scroll.name}" is not a scroll (type: ${scroll.type})`
    };
  }
  const scrollProps = scroll.properties;
  if (!scrollProps || !scrollProps.spellName || scrollProps.spellLevel === void 0) {
    return {
      success: false,
      consumed: false,
      requiresCheck: false,
      reason: "invalid_scroll",
      message: `Scroll "${scroll.name}" is missing required spell properties`
    };
  }
  const inventory = inventoryRepo.getInventory(character.id);
  const hasScroll = inventory.items.some((i) => i.itemId === scroll.id && i.quantity > 0);
  if (!hasScroll) {
    return {
      success: false,
      consumed: false,
      requiresCheck: false,
      reason: "not_in_inventory",
      message: `Character does not have scroll "${scroll.name}" in inventory`
    };
  }
  const validation = validateScrollUse(character, scrollProps);
  if (!validation.requiresCheck) {
    inventoryRepo.removeItem(character.id, scroll.id, 1);
    return {
      success: true,
      consumed: true,
      requiresCheck: false,
      reason: "auto_success",
      message: `Successfully used scroll of ${scrollProps.spellName}. Scroll consumed.`
    };
  }
  const checkDC = validation.checkDC;
  const arcanaCheck = rollArcanaCheck(character);
  const checkPassed = arcanaCheck.total >= checkDC;
  inventoryRepo.removeItem(character.id, scroll.id, 1);
  if (checkPassed) {
    return {
      success: true,
      consumed: true,
      requiresCheck: true,
      checkRoll: arcanaCheck.roll,
      checkTotal: arcanaCheck.total,
      checkDC,
      checkPassed: true,
      reason: "check_passed",
      message: `Arcana check passed (${arcanaCheck.total} vs DC ${checkDC}). Successfully used scroll of ${scrollProps.spellName}. Scroll consumed.`
    };
  } else {
    return {
      success: false,
      consumed: true,
      requiresCheck: true,
      checkRoll: arcanaCheck.roll,
      checkTotal: arcanaCheck.total,
      checkDC,
      checkPassed: false,
      reason: "check_failed",
      message: `Arcana check failed (${arcanaCheck.total} vs DC ${checkDC}). Scroll of ${scrollProps.spellName} wasted and consumed.`
    };
  }
}
function createSpellScroll(spellName, spellLevel, spellClass, customDC, customAttackBonus, customValue, customDescription) {
  const scrollDC = customDC || calculateScrollDC(spellLevel);
  const scrollAttackBonus = customAttackBonus || calculateScrollAttackBonus(spellLevel);
  const value = customValue || calculateScrollValue(spellLevel);
  const rarity = getScrollRarity(spellLevel);
  const scrollName = `Scroll of ${spellName}`;
  const description = customDescription || `A spell scroll containing the ${spellLevel === 0 ? "cantrip" : `${spellLevel}${getOrdinalSuffix(spellLevel)}-level spell`} ${spellName}. Rarity: ${rarity}. Spell Save DC: ${scrollDC}, Spell Attack Bonus: +${scrollAttackBonus}.`;
  const scrollProperties = {
    spellName,
    spellLevel,
    scrollDC,
    scrollAttackBonus,
    requiresCheck: false,
    // Will be determined at use time
    spellClass
  };
  return {
    name: scrollName,
    description,
    type: "scroll",
    weight: 0.1,
    // Scrolls are light
    value,
    properties: scrollProperties
  };
}
function getScrollDetails(scroll) {
  if (scroll.type !== "scroll") {
    return {
      valid: false,
      error: "Item is not a scroll"
    };
  }
  const props = scroll.properties;
  if (!props || !props.spellName || props.spellLevel === void 0) {
    return {
      valid: false,
      error: "Scroll is missing required properties"
    };
  }
  return {
    valid: true,
    spellName: props.spellName,
    spellLevel: props.spellLevel,
    scrollDC: props.scrollDC,
    scrollAttackBonus: props.scrollAttackBonus,
    spellClass: props.spellClass,
    rarity: getScrollRarity(props.spellLevel)
  };
}
function checkScrollUsability(character, scroll) {
  if (scroll.type !== "scroll") {
    return {
      canUse: false,
      requiresCheck: false,
      checkDC: null,
      reason: "invalid_scroll",
      message: "Item is not a scroll"
    };
  }
  const props = scroll.properties;
  if (!props || !props.spellName || props.spellLevel === void 0) {
    return {
      canUse: false,
      requiresCheck: false,
      checkDC: null,
      reason: "invalid_scroll",
      message: "Scroll is missing required properties"
    };
  }
  const validation = validateScrollUse(character, props);
  if (!validation.requiresCheck) {
    return {
      canUse: true,
      requiresCheck: false,
      checkDC: null,
      reason: validation.reason,
      message: `Can use scroll automatically (spell on class list and can cast ${props.spellLevel}${getOrdinalSuffix(props.spellLevel)}-level spells)`
    };
  }
  return {
    canUse: true,
    requiresCheck: true,
    checkDC: validation.checkDC,
    reason: validation.reason,
    message: `Requires DC ${validation.checkDC} Arcana check (${validation.reason.replace(/_/g, " ")})`
  };
}
function getOrdinalSuffix(n2) {
  const s = ["th", "st", "nd", "rd"];
  const v = n2 % 100;
  return s[(v - 20) % 10] || s[v] || s[0];
}

// dist/server/scroll-tools.js
var ScrollTools = {
  USE_SPELL_SCROLL: {
    name: "use_spell_scroll",
    description: "Use a spell scroll from inventory. Scroll is consumed after use (even if the Arcana check fails). If the spell is on your class list and you can cast that level, no check is required.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character using the scroll"),
      scrollItemId: external_exports.string().describe("Item ID of the scroll in inventory"),
      targetId: external_exports.string().optional().describe("Optional target character ID"),
      targetPoint: external_exports.object({
        x: external_exports.number(),
        y: external_exports.number()
      }).optional().describe("Optional target point for area spells")
    })
  },
  CREATE_SPELL_SCROLL: {
    name: "create_spell_scroll",
    description: "Create a new spell scroll item template (DM tool). The scroll can then be given to characters via give_item.",
    inputSchema: CreateScrollRequestSchema
  },
  IDENTIFY_SCROLL: {
    name: "identify_scroll",
    description: "Identify a spell scroll using Arcana check (DC 10 + spell level) or the Identify spell (automatic success).",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character attempting to identify the scroll"),
      scrollItemId: external_exports.string().describe("Item ID of the scroll"),
      useIdentifySpell: external_exports.boolean().default(false).describe("Whether using the Identify spell (auto-success)")
    })
  },
  GET_SCROLL_USE_DC: {
    name: "get_scroll_use_dc",
    description: "Calculate the DC required to use a spell scroll. Returns DC and whether a check is required based on character class/level.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character who would use the scroll"),
      scrollItemId: external_exports.string().describe("Item ID of the scroll")
    })
  },
  GET_SCROLL_DETAILS: {
    name: "get_scroll_details",
    description: "Get detailed information about a spell scroll item.",
    inputSchema: external_exports.object({
      scrollItemId: external_exports.string().describe("Item ID of the scroll")
    })
  },
  CHECK_SCROLL_USABILITY: {
    name: "check_scroll_usability",
    description: "Check if a character can use a specific scroll without consuming it. Returns whether a check is required and the DC.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character to check"),
      scrollItemId: external_exports.string().describe("Item ID of the scroll")
    })
  }
};
function ensureDb8() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return {
    characterRepo: new CharacterRepository(db),
    itemRepo: new ItemRepository(db),
    inventoryRepo: new InventoryRepository(db)
  };
}
async function handleUseSpellScroll(args, _ctx) {
  const { characterRepo, itemRepo, inventoryRepo } = ensureDb8();
  const parsed = ScrollTools.USE_SPELL_SCROLL.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const scroll = itemRepo.findById(parsed.scrollItemId);
  if (!scroll) {
    throw new Error(`Scroll item ${parsed.scrollItemId} not found`);
  }
  const result = useSpellScroll(character, scroll, inventoryRepo);
  return {
    content: [
      {
        type: "text",
        text: formatScrollUseResult(result)
      }
    ]
  };
}
async function handleCreateSpellScroll(args, _ctx) {
  const { itemRepo } = ensureDb8();
  const parsed = CreateScrollRequestSchema.parse(args);
  const scrollData = createSpellScroll(parsed.spellName, parsed.spellLevel, parsed.spellClass, parsed.scrollDC, parsed.scrollAttackBonus, parsed.value, parsed.description);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const scroll = {
    ...scrollData,
    id: (0, import_crypto9.randomUUID)(),
    createdAt: now,
    updatedAt: now
  };
  itemRepo.create(scroll);
  return {
    content: [
      {
        type: "text",
        text: formatScrollCreation(scroll)
      }
    ]
  };
}
async function handleIdentifyScroll(args, _ctx) {
  const { characterRepo, itemRepo } = ensureDb8();
  const parsed = ScrollTools.IDENTIFY_SCROLL.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const scroll = itemRepo.findById(parsed.scrollItemId);
  if (!scroll) {
    throw new Error(`Scroll item ${parsed.scrollItemId} not found`);
  }
  if (scroll.type !== "scroll") {
    throw new Error(`Item "${scroll.name}" is not a scroll`);
  }
  const scrollDetails = getScrollDetails(scroll);
  if (!scrollDetails.valid) {
    throw new Error(scrollDetails.error || "Invalid scroll");
  }
  if (parsed.useIdentifySpell) {
    return {
      content: [
        {
          type: "text",
          text: formatScrollIdentification(scrollDetails, true, null)
        }
      ]
    };
  }
  const checkDC = 10 + scrollDetails.spellLevel;
  const arcanaCheck = rollArcanaCheck(character);
  const success = arcanaCheck.total >= checkDC;
  return {
    content: [
      {
        type: "text",
        text: formatScrollIdentification(scrollDetails, success, {
          roll: arcanaCheck.roll,
          total: arcanaCheck.total,
          dc: checkDC,
          modifier: arcanaCheck.modifier
        })
      }
    ]
  };
}
async function handleGetScrollUseDC(args, _ctx) {
  const { characterRepo, itemRepo } = ensureDb8();
  const parsed = ScrollTools.GET_SCROLL_USE_DC.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const scroll = itemRepo.findById(parsed.scrollItemId);
  if (!scroll) {
    throw new Error(`Scroll item ${parsed.scrollItemId} not found`);
  }
  const usability = checkScrollUsability(character, scroll);
  return {
    content: [
      {
        type: "text",
        text: formatScrollUseDC(usability, scroll.name)
      }
    ]
  };
}
async function handleGetScrollDetails(args, _ctx) {
  const { itemRepo } = ensureDb8();
  const parsed = ScrollTools.GET_SCROLL_DETAILS.inputSchema.parse(args);
  const scroll = itemRepo.findById(parsed.scrollItemId);
  if (!scroll) {
    throw new Error(`Scroll item ${parsed.scrollItemId} not found`);
  }
  const details = getScrollDetails(scroll);
  if (!details.valid) {
    throw new Error(details.error || "Invalid scroll");
  }
  return {
    content: [
      {
        type: "text",
        text: formatScrollDetails(scroll, details)
      }
    ]
  };
}
async function handleCheckScrollUsability(args, _ctx) {
  const { characterRepo, itemRepo } = ensureDb8();
  const parsed = ScrollTools.CHECK_SCROLL_USABILITY.inputSchema.parse(args);
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const scroll = itemRepo.findById(parsed.scrollItemId);
  if (!scroll) {
    throw new Error(`Scroll item ${parsed.scrollItemId} not found`);
  }
  const usability = checkScrollUsability(character, scroll);
  return {
    content: [
      {
        type: "text",
        text: formatScrollUsability(usability, character.name, scroll.name)
      }
    ]
  };
}
function formatScrollUseResult(result) {
  if (!result.success && result.reason === "not_in_inventory") {
    return `L ${result.message}`;
  }
  if (!result.success && result.reason === "invalid_scroll") {
    return `L ${result.message}`;
  }
  if (!result.requiresCheck) {
    return ` ${result.message}

<\uFFFD Auto-success: Spell is on your class list and you can cast spells of this level.
=\uFFFD The scroll crumbles to dust after use.`;
  }
  if (result.success && result.checkPassed) {
    return ` ${result.message}

<\uFFFD Arcana Check: ${result.checkRoll} + modifier = ${result.checkTotal}
<\uFFFD DC: ${result.checkDC}
( Check passed! The spell activates.
=\uFFFD The scroll crumbles to dust after use.`;
  }
  if (!result.success && !result.checkPassed) {
    return `L ${result.message}

<\uFFFD Arcana Check: ${result.checkRoll} + modifier = ${result.checkTotal}
<\uFFFD DC: ${result.checkDC}
=\uFFFD Check failed! The spell fizzles and the scroll is wasted.
=\uFFFD The scroll crumbles to dust.`;
  }
  return result.message;
}
function formatScrollCreation(scroll) {
  const props = scroll.properties;
  return `=\uFFFD Spell Scroll Created

**${scroll.name}**
Spell: ${props.spellName} (Level ${props.spellLevel})
${props.spellClass ? `Class: ${props.spellClass}` : "Class: Universal"}

Spell Save DC: ${props.scrollDC}
Spell Attack Bonus: +${props.scrollAttackBonus}
Value: ${scroll.value} gp
Weight: ${scroll.weight} lbs

Item ID: ${scroll.id}

Use \`give_item\` to add this scroll to a character's inventory.`;
}
function formatScrollIdentification(details, success, check2) {
  if (success && !check2) {
    return `( Identify Spell - Automatic Success

=\uFFFD **Scroll Identified**
Spell: ${details.spellName}
Level: ${details.spellLevel}
${details.spellClass ? `Class: ${details.spellClass}` : ""}
Rarity: ${details.rarity}
Spell Save DC: ${details.scrollDC}
Spell Attack Bonus: +${details.scrollAttackBonus}`;
  }
  if (success && check2) {
    return ` Scroll Identified

<\uFFFD Arcana Check: ${check2.roll} + ${check2.modifier} (INT) = ${check2.total}
<\uFFFD DC: ${check2.dc}

=\uFFFD **Scroll Details**
Spell: ${details.spellName}
Level: ${details.spellLevel}
${details.spellClass ? `Class: ${details.spellClass}` : ""}
Rarity: ${details.rarity}
Spell Save DC: ${details.scrollDC}
Spell Attack Bonus: +${details.scrollAttackBonus}`;
  }
  return `L Identification Failed

<\uFFFD Arcana Check: ${check2.roll} + ${check2.modifier} (INT) = ${check2.total}
<\uFFFD DC: ${check2.dc}

The magical writing remains indecipherable. You'll need to try again or use the Identify spell.`;
}
function formatScrollUseDC(usability, scrollName) {
  if (!usability.canUse) {
    return `L Cannot use ${scrollName}

Reason: ${usability.message}`;
  }
  if (!usability.requiresCheck) {
    return ` ${scrollName} - Auto-success

No Arcana check required.
${usability.message}`;
  }
  return `=\uFFFD ${scrollName}

\uFFFD Arcana Check Required
DC: ${usability.checkDC}
Reason: ${usability.message}

Note: The scroll will be consumed even if the check fails.`;
}
function formatScrollDetails(scroll, details) {
  return `=\uFFFD **${scroll.name}**

${scroll.description || ""}

**Spell Information**
Name: ${details.spellName}
Level: ${details.spellLevel}
${details.spellClass ? `Class: ${details.spellClass}` : "Class: Universal"}
Rarity: ${details.rarity}

**Scroll Properties**
Spell Save DC: ${details.scrollDC}
Spell Attack Bonus: +${details.scrollAttackBonus}
Value: ${scroll.value} gp
Weight: ${scroll.weight} lbs

**Usage**
Use \`use_spell_scroll\` to cast the spell from this scroll.
Use \`get_scroll_use_dc\` to check if you need an Arcana check.`;
}
function formatScrollUsability(usability, characterName, scrollName) {
  if (!usability.canUse) {
    return `L ${characterName} cannot use ${scrollName}

${usability.message}`;
  }
  if (!usability.requiresCheck) {
    return ` ${characterName} can use ${scrollName}

( Auto-success: ${usability.message}

No Arcana check required. The scroll can be used immediately.`;
  }
  return `\uFFFD ${characterName} can attempt to use ${scrollName}

=\uFFFD Requires Arcana Check
DC: ${usability.checkDC}
Reason: ${usability.message}

Note: The scroll will be consumed even if the Arcana check fails.`;
}

// dist/server/aura-tools.js
init_zod();

// dist/schema/aura.js
init_zod();
var AuraTriggerSchema = external_exports.enum(["enter", "exit", "start_of_turn", "end_of_turn"]);
var AuraEffectTypeSchema = external_exports.enum(["damage", "buff", "debuff", "healing", "condition", "custom"]);
var AuraEffectSchema = external_exports.object({
  trigger: AuraTriggerSchema,
  type: AuraEffectTypeSchema,
  dice: external_exports.string().optional(),
  // e.g., "3d8" for damage/healing
  damageType: external_exports.string().optional(),
  // e.g., "radiant", "necrotic"
  saveType: external_exports.string().optional(),
  // e.g., "wisdom", "dexterity"
  saveDC: external_exports.number().int().optional(),
  conditions: external_exports.array(external_exports.string()).optional(),
  // e.g., ["frightened", "slowed"]
  description: external_exports.string().optional(),
  // Custom effect description
  bonusAmount: external_exports.number().int().optional(),
  // For buffs/debuffs
  bonusType: external_exports.string().optional()
  // e.g., "ac", "saves", "damage"
});
var AuraStateSchema = external_exports.object({
  id: external_exports.string(),
  ownerId: external_exports.string(),
  // Character who created the aura
  spellName: external_exports.string(),
  spellLevel: external_exports.number().int().min(0).max(9),
  radius: external_exports.number().int().min(1),
  // Radius in feet (5 feet = 1 square)
  affectsAllies: external_exports.boolean().default(false),
  affectsEnemies: external_exports.boolean().default(false),
  affectsSelf: external_exports.boolean().default(false),
  // Some auras affect the caster
  effects: external_exports.array(AuraEffectSchema),
  startedAt: external_exports.number().int().min(1),
  // Round number
  maxDuration: external_exports.number().int().optional(),
  // Maximum rounds (undefined = indefinite)
  requiresConcentration: external_exports.boolean().default(false)
  // Some auras need concentration
});
var AuraEffectResultSchema = external_exports.object({
  auraId: external_exports.string(),
  auraName: external_exports.string(),
  targetId: external_exports.string(),
  trigger: AuraTriggerSchema,
  effectType: AuraEffectTypeSchema,
  succeeded: external_exports.boolean(),
  // Whether the effect applied (false if saved)
  damageDealt: external_exports.number().int().optional(),
  damageType: external_exports.string().optional(),
  healingDone: external_exports.number().int().optional(),
  conditionsApplied: external_exports.array(external_exports.string()).optional(),
  saveRoll: external_exports.number().int().optional(),
  saveDC: external_exports.number().int().optional(),
  saveTotal: external_exports.number().int().optional(),
  description: external_exports.string().optional()
});
var CreateAuraRequestSchema = external_exports.object({
  ownerId: external_exports.string(),
  spellName: external_exports.string(),
  spellLevel: external_exports.number().int().min(0).max(9),
  radius: external_exports.number().int().min(1),
  affectsAllies: external_exports.boolean().default(false),
  affectsEnemies: external_exports.boolean().default(false),
  affectsSelf: external_exports.boolean().default(false),
  effects: external_exports.array(AuraEffectSchema),
  currentRound: external_exports.number().int().min(1),
  maxDuration: external_exports.number().int().optional(),
  requiresConcentration: external_exports.boolean().default(false)
});
var CheckAuraEffectsRequestSchema = external_exports.object({
  encounterId: external_exports.string(),
  x: external_exports.number().int(),
  y: external_exports.number().int(),
  trigger: AuraTriggerSchema
});

// dist/storage/repos/aura.repo.js
var AuraRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Create a new aura
   */
  create(aura) {
    const valid = AuraStateSchema.parse(aura);
    const stmt = this.db.prepare(`
            INSERT INTO auras (
                id, owner_id, spell_name, spell_level, radius,
                affects_allies, affects_enemies, affects_self,
                effects, started_at, max_duration, requires_concentration
            )
            VALUES (@id, @ownerId, @spellName, @spellLevel, @radius,
                    @affectsAllies, @affectsEnemies, @affectsSelf,
                    @effects, @startedAt, @maxDuration, @requiresConcentration)
        `);
    stmt.run({
      id: valid.id,
      ownerId: valid.ownerId,
      spellName: valid.spellName,
      spellLevel: valid.spellLevel,
      radius: valid.radius,
      affectsAllies: valid.affectsAllies ? 1 : 0,
      affectsEnemies: valid.affectsEnemies ? 1 : 0,
      affectsSelf: valid.affectsSelf ? 1 : 0,
      effects: JSON.stringify(valid.effects),
      startedAt: valid.startedAt,
      maxDuration: valid.maxDuration ?? null,
      requiresConcentration: valid.requiresConcentration ? 1 : 0
    });
  }
  /**
   * Find an aura by ID
   */
  findById(auraId) {
    const stmt = this.db.prepare(`
            SELECT * FROM auras WHERE id = ?
        `);
    const row = stmt.get(auraId);
    if (!row)
      return null;
    return this.rowToAuraState(row);
  }
  /**
   * Find all auras owned by a specific character
   */
  findByOwnerId(ownerId) {
    const stmt = this.db.prepare(`
            SELECT * FROM auras WHERE owner_id = ?
        `);
    const rows = stmt.all(ownerId);
    return rows.map((row) => this.rowToAuraState(row));
  }
  /**
   * Find all active auras (for an encounter or global check)
   */
  findAll() {
    const stmt = this.db.prepare(`SELECT * FROM auras`);
    const rows = stmt.all();
    return rows.map((row) => this.rowToAuraState(row));
  }
  /**
   * Delete an aura by ID
   */
  delete(auraId) {
    const stmt = this.db.prepare(`
            DELETE FROM auras WHERE id = ?
        `);
    const result = stmt.run(auraId);
    return result.changes > 0;
  }
  /**
   * Delete all auras owned by a character
   */
  deleteByOwnerId(ownerId) {
    const stmt = this.db.prepare(`
            DELETE FROM auras WHERE owner_id = ?
        `);
    const result = stmt.run(ownerId);
    return result.changes;
  }
  /**
   * Check if a character has any active auras
   */
  hasActiveAuras(ownerId) {
    const stmt = this.db.prepare(`
            SELECT COUNT(*) as count FROM auras WHERE owner_id = ?
        `);
    const row = stmt.get(ownerId);
    return row.count > 0;
  }
  /**
   * Convert database row to AuraState
   */
  rowToAuraState(row) {
    return AuraStateSchema.parse({
      id: row.id,
      ownerId: row.owner_id,
      spellName: row.spell_name,
      spellLevel: row.spell_level,
      radius: row.radius,
      affectsAllies: row.affects_allies === 1,
      affectsEnemies: row.affects_enemies === 1,
      affectsSelf: row.affects_self === 1,
      effects: JSON.parse(row.effects),
      startedAt: row.started_at,
      maxDuration: row.max_duration ?? void 0,
      requiresConcentration: row.requires_concentration === 1
    });
  }
};

// dist/server/aura-tools.js
init_character_repo();
init_aura();
var AuraTools = {
  CREATE_AURA: {
    name: "create_aura",
    description: "Create a new aura effect centered on a character (e.g., Spirit Guardians, Aura of Protection). Auras move with their owner and affect targets within radius. Optionally requires concentration.",
    inputSchema: external_exports.object({
      ownerId: external_exports.string().describe("The ID of the character creating the aura"),
      spellName: external_exports.string().describe("Name of the spell or ability creating the aura"),
      spellLevel: external_exports.number().int().min(0).max(9).describe("Spell level (0-9)"),
      radius: external_exports.number().int().min(1).describe("Radius in feet (e.g., 15 for Spirit Guardians)"),
      affectsAllies: external_exports.boolean().default(false).describe("Whether the aura affects allied creatures"),
      affectsEnemies: external_exports.boolean().default(false).describe("Whether the aura affects enemy creatures"),
      affectsSelf: external_exports.boolean().default(false).describe("Whether the aura affects the caster"),
      effects: external_exports.array(external_exports.object({
        trigger: AuraTriggerSchema.describe("When the effect triggers (enter, exit, start_of_turn, end_of_turn)"),
        type: external_exports.enum(["damage", "buff", "debuff", "healing", "condition", "custom"]).describe("Type of effect"),
        dice: external_exports.string().optional().describe('Dice notation for damage/healing (e.g., "3d8")'),
        damageType: external_exports.string().optional().describe('Damage type (e.g., "radiant", "necrotic")'),
        saveType: external_exports.string().optional().describe('Ability for saving throw (e.g., "wisdom", "dexterity")'),
        saveDC: external_exports.number().int().optional().describe("DC for saving throw"),
        conditions: external_exports.array(external_exports.string()).optional().describe('Conditions to apply (e.g., ["frightened"])'),
        description: external_exports.string().optional().describe("Custom effect description"),
        bonusAmount: external_exports.number().int().optional().describe("Bonus amount for buffs/debuffs"),
        bonusType: external_exports.string().optional().describe('What the bonus applies to (e.g., "ac", "saves")')
      })).describe("Array of effects the aura applies"),
      currentRound: external_exports.number().int().min(1).describe("Current combat round number"),
      maxDuration: external_exports.number().int().optional().describe("Maximum duration in rounds (omit for indefinite)"),
      requiresConcentration: external_exports.boolean().default(false).describe("Whether the aura requires concentration")
    })
  },
  GET_ACTIVE_AURAS: {
    name: "get_active_auras",
    description: "List all currently active auras and their properties.",
    inputSchema: external_exports.object({})
  },
  GET_AURAS_AFFECTING_CHARACTER: {
    name: "get_auras_affecting_character",
    description: "Check which auras are currently affecting a specific character based on their position.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The encounter ID to check within"),
      characterId: external_exports.string().describe("The character ID to check for affecting auras")
    })
  },
  PROCESS_AURA_EFFECTS: {
    name: "process_aura_effects",
    description: "Process aura effects for a target at a specific trigger (e.g., start of turn, entering an aura). Returns all effects that were triggered.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string().describe("The encounter ID"),
      targetId: external_exports.string().describe("The target character/creature ID"),
      trigger: AuraTriggerSchema.describe("When the effects trigger (enter, exit, start_of_turn, end_of_turn)")
    })
  },
  REMOVE_AURA: {
    name: "remove_aura",
    description: "Manually end an aura by ID (e.g., when concentration breaks or spell is dismissed).",
    inputSchema: external_exports.object({
      auraId: external_exports.string().describe("The ID of the aura to remove")
    })
  },
  REMOVE_CHARACTER_AURAS: {
    name: "remove_character_auras",
    description: "Remove all auras owned by a specific character (e.g., when they die or lose concentration).",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("The ID of the character whose auras to remove")
    })
  },
  EXPIRE_AURAS: {
    name: "expire_auras",
    description: "Check for and remove any auras that have exceeded their duration.",
    inputSchema: external_exports.object({
      currentRound: external_exports.number().int().min(1).describe("Current combat round number")
    })
  }
};
function ensureDb9() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return {
    auraRepo: new AuraRepository(db),
    encounterRepo: new EncounterRepository(db),
    characterRepo: new CharacterRepository(db),
    concentrationRepo: new ConcentrationRepository(db)
  };
}
async function handleCreateAura(args, _ctx) {
  const { auraRepo, characterRepo, concentrationRepo } = ensureDb9();
  const parsed = CreateAuraRequestSchema.parse(args);
  const character = characterRepo.findById(parsed.ownerId);
  if (!character) {
    throw new Error(`Character ${parsed.ownerId} not found`);
  }
  if (parsed.requiresConcentration) {
    startConcentration(
      parsed.ownerId,
      parsed.spellName,
      parsed.spellLevel,
      parsed.currentRound,
      parsed.maxDuration,
      void 0,
      // Auras don't track specific target IDs
      concentrationRepo,
      characterRepo
    );
  }
  const aura = createAura(parsed, auraRepo);
  return {
    content: [
      {
        type: "text",
        text: formatAuraCreated(aura, character.name)
      }
    ]
  };
}
async function handleGetActiveAuras(_args, _ctx) {
  const { auraRepo } = ensureDb9();
  const auras = getActiveAuras(auraRepo);
  if (auras.length === 0) {
    return {
      content: [
        {
          type: "text",
          text: "No active auras."
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: formatAuraList(auras)
      }
    ]
  };
}
async function handleGetAurasAffectingCharacter(args, _ctx) {
  const { auraRepo, encounterRepo } = ensureDb9();
  const parsed = AuraTools.GET_AURAS_AFFECTING_CHARACTER.inputSchema.parse(args);
  const encounter = encounterRepo.findById(parsed.encounterId);
  if (!encounter) {
    throw new Error(`Encounter ${parsed.encounterId} not found`);
  }
  const tokens = typeof encounter.tokens === "string" ? JSON.parse(encounter.tokens) : encounter.tokens;
  const target = tokens.find((t) => t.id === parsed.characterId);
  if (!target) {
    throw new Error(`Character ${parsed.characterId} not found in encounter`);
  }
  if (!target.position) {
    return {
      content: [
        {
          type: "text",
          text: `Character ${parsed.characterId} has no position in the encounter.`
        }
      ]
    };
  }
  const { getAurasAtPosition: getAurasAtPosition2 } = await Promise.resolve().then(() => (init_aura(), aura_exports));
  const affectingAuras = getAurasAtPosition2(tokens, target.position, auraRepo);
  if (affectingAuras.length === 0) {
    return {
      content: [
        {
          type: "text",
          text: `No auras are affecting ${target.name || parsed.characterId}.`
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: formatAffectingAuras(target.name || parsed.characterId, affectingAuras, tokens)
      }
    ]
  };
}
async function handleProcessAuraEffects(args, _ctx) {
  const { auraRepo, encounterRepo } = ensureDb9();
  const parsed = AuraTools.PROCESS_AURA_EFFECTS.inputSchema.parse(args);
  const encounter = encounterRepo.findById(parsed.encounterId);
  if (!encounter) {
    throw new Error(`Encounter ${parsed.encounterId} not found`);
  }
  const tokens = typeof encounter.tokens === "string" ? JSON.parse(encounter.tokens) : encounter.tokens;
  const results = checkAuraEffectsForTarget(tokens, parsed.targetId, parsed.trigger, auraRepo);
  if (results.length === 0) {
    return {
      content: [
        {
          type: "text",
          text: `No aura effects triggered for ${parsed.targetId} on ${parsed.trigger}.`
        }
      ]
    };
  }
  return {
    content: [
      {
        type: "text",
        text: formatAuraEffectResults(results, tokens)
      }
    ]
  };
}
async function handleRemoveAura(args, _ctx) {
  const { auraRepo, concentrationRepo, characterRepo } = ensureDb9();
  const parsed = AuraTools.REMOVE_AURA.inputSchema.parse(args);
  const aura = auraRepo.findById(parsed.auraId);
  if (!aura) {
    return {
      content: [
        {
          type: "text",
          text: `Aura ${parsed.auraId} not found (may have already expired).`
        }
      ]
    };
  }
  const auraName = aura.spellName;
  const removed = endAura(parsed.auraId, auraRepo);
  if (aura.requiresConcentration) {
    const concentration = concentrationRepo.findByCharacterId(aura.ownerId);
    if (concentration && concentration.activeSpell === aura.spellName) {
      breakConcentration({ characterId: aura.ownerId, reason: "voluntary" }, concentrationRepo, characterRepo);
    }
  }
  return {
    content: [
      {
        type: "text",
        text: removed ? `Aura "${auraName}" has been removed.` : `Failed to remove aura ${parsed.auraId}.`
      }
    ]
  };
}
async function handleRemoveCharacterAuras(args, _ctx) {
  const { auraRepo } = ensureDb9();
  const parsed = AuraTools.REMOVE_CHARACTER_AURAS.inputSchema.parse(args);
  const count = endAurasByOwner(parsed.characterId, auraRepo);
  return {
    content: [
      {
        type: "text",
        text: count > 0 ? `Removed ${count} aura(s) from character ${parsed.characterId}.` : `Character ${parsed.characterId} had no active auras.`
      }
    ]
  };
}
async function handleExpireAuras(args, _ctx) {
  const { auraRepo } = ensureDb9();
  const parsed = AuraTools.EXPIRE_AURAS.inputSchema.parse(args);
  const expiredIds = expireOldAuras(parsed.currentRound, auraRepo);
  return {
    content: [
      {
        type: "text",
        text: expiredIds.length > 0 ? `Expired ${expiredIds.length} aura(s): ${expiredIds.join(", ")}` : "No auras expired this round."
      }
    ]
  };
}
function formatAuraCreated(aura, ownerName) {
  const concentrationText = aura.requiresConcentration ? " (Requires Concentration)" : "";
  const durationText = aura.maxDuration ? ` for ${aura.maxDuration} rounds` : " (indefinite duration)";
  const targetTypes = [];
  if (aura.affectsSelf)
    targetTypes.push("self");
  if (aura.affectsAllies)
    targetTypes.push("allies");
  if (aura.affectsEnemies)
    targetTypes.push("enemies");
  return `\u2728 Aura Created: ${aura.spellName}${concentrationText}

Owner: ${ownerName}
Radius: ${aura.radius} feet
Affects: ${targetTypes.join(", ")}
Duration: Started round ${aura.startedAt}${durationText}
Effects: ${aura.effects.length} effect(s)

${aura.effects.map((e, i) => `  ${i + 1}. ${e.type} on ${e.trigger}${e.dice ? ` (${e.dice}${e.damageType ? " " + e.damageType : ""})` : ""}`).join("\n")}`;
}
function formatAuraList(auras) {
  return `Active Auras (${auras.length}):

${auras.map((aura, i) => `${i + 1}. ${aura.spellName} (ID: ${aura.id})
   Owner: ${aura.ownerId}
   Radius: ${aura.radius}ft | Started: Round ${aura.startedAt}${aura.maxDuration ? ` | Duration: ${aura.maxDuration} rounds` : ""}
   Targets: ${[aura.affectsSelf && "self", aura.affectsAllies && "allies", aura.affectsEnemies && "enemies"].filter(Boolean).join(", ")}
   Effects: ${aura.effects.length}`).join("\n\n")}`;
}
function formatAffectingAuras(targetName, auras, tokens) {
  return `Auras Affecting ${targetName}:

${auras.map((aura, i) => {
    const owner = tokens.find((t) => t.id === aura.ownerId);
    return `${i + 1}. ${aura.spellName} (Owner: ${owner?.name || aura.ownerId})
   Radius: ${aura.radius}ft
   Effects: ${aura.effects.map((e) => `${e.type} on ${e.trigger}`).join(", ")}`;
  }).join("\n\n")}`;
}
function formatAuraEffectResults(results, tokens) {
  if (results.length === 0) {
    return "No aura effects were triggered.";
  }
  const target = tokens.find((t) => t.id === results[0].targetId);
  const targetName = target?.name || results[0].targetId;
  return `Aura Effects on ${targetName}:

${results.map((result, i) => {
    let text = `${i + 1}. ${result.auraName} (${result.trigger})`;
    if (result.saveRoll !== void 0 && result.saveDC !== void 0) {
      text += `
   Save: ${result.saveRoll} + mod = ${result.saveTotal} vs DC ${result.saveDC} - ${result.succeeded ? "SUCCESS" : "FAILURE"}`;
    }
    if (result.damageDealt !== void 0) {
      text += `
   Damage: ${result.damageDealt} ${result.damageType || ""}`;
    }
    if (result.healingDone !== void 0) {
      text += `
   Healing: ${result.healingDone}`;
    }
    if (result.conditionsApplied && result.conditionsApplied.length > 0) {
      text += `
   Conditions: ${result.conditionsApplied.join(", ")}`;
    }
    if (result.description) {
      text += `
   ${result.description}`;
    }
    return text;
  }).join("\n\n")}`;
}

// dist/server/npc-memory-tools.js
init_zod();

// dist/storage/repos/npc-memory.repo.js
var NpcMemoryRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  // ============================================================
  // RELATIONSHIP METHODS
  // ============================================================
  /**
   * Get relationship between PC and NPC
   * Returns null if no relationship exists (they're strangers)
   */
  getRelationship(characterId, npcId) {
    const stmt = this.db.prepare(`
            SELECT * FROM npc_relationships
            WHERE character_id = ? AND npc_id = ?
        `);
    const row = stmt.get(characterId, npcId);
    if (!row)
      return null;
    return this.rowToRelationship(row);
  }
  /**
   * Create or update relationship between PC and NPC
   */
  upsertRelationship(relationship) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const existing = this.getRelationship(relationship.characterId, relationship.npcId);
    if (existing) {
      const stmt = this.db.prepare(`
                UPDATE npc_relationships
                SET familiarity = ?,
                    disposition = ?,
                    notes = ?,
                    last_interaction_at = ?,
                    interaction_count = interaction_count + 1
                WHERE character_id = ? AND npc_id = ?
            `);
      stmt.run(relationship.familiarity, relationship.disposition, relationship.notes ?? existing.notes, now, relationship.characterId, relationship.npcId);
    } else {
      const stmt = this.db.prepare(`
                INSERT INTO npc_relationships (character_id, npc_id, familiarity, disposition, notes, first_met_at, last_interaction_at, interaction_count)
                VALUES (?, ?, ?, ?, ?, ?, ?, 1)
            `);
      stmt.run(relationship.characterId, relationship.npcId, relationship.familiarity, relationship.disposition, relationship.notes ?? null, now, now);
    }
    return this.getRelationship(relationship.characterId, relationship.npcId);
  }
  /**
   * Get all NPCs a character has interacted with
   */
  getCharacterRelationships(characterId) {
    const stmt = this.db.prepare(`
            SELECT * FROM npc_relationships
            WHERE character_id = ?
            ORDER BY last_interaction_at DESC
        `);
    const rows = stmt.all(characterId);
    return rows.map((row) => this.rowToRelationship(row));
  }
  /**
   * Get all characters who have interacted with an NPC
   */
  getNpcRelationships(npcId) {
    const stmt = this.db.prepare(`
            SELECT * FROM npc_relationships
            WHERE npc_id = ?
            ORDER BY last_interaction_at DESC
        `);
    const rows = stmt.all(npcId);
    return rows.map((row) => this.rowToRelationship(row));
  }
  // ============================================================
  // CONVERSATION MEMORY METHODS
  // ============================================================
  /**
   * Record a conversation memory
   */
  recordMemory(memory) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            INSERT INTO conversation_memories (character_id, npc_id, summary, importance, topics, created_at)
            VALUES (?, ?, ?, ?, ?, ?)
        `);
    const result = stmt.run(memory.characterId, memory.npcId, memory.summary, memory.importance, JSON.stringify(memory.topics), now);
    return {
      ...memory,
      id: result.lastInsertRowid,
      createdAt: now
    };
  }
  /**
   * Get conversation history between PC and NPC
   */
  getConversationHistory(characterId, npcId, options) {
    let query = `
            SELECT * FROM conversation_memories
            WHERE character_id = ? AND npc_id = ?
        `;
    const params = [characterId, npcId];
    if (options?.minImportance) {
      const importanceOrder = {
        "low": 1,
        "medium": 2,
        "high": 3,
        "critical": 4
      };
      const minLevel = importanceOrder[options.minImportance];
      query += ` AND CASE importance
                WHEN 'low' THEN 1
                WHEN 'medium' THEN 2
                WHEN 'high' THEN 3
                WHEN 'critical' THEN 4
            END >= ?`;
      params.push(minLevel);
    }
    query += ` ORDER BY id DESC`;
    if (options?.limit) {
      query += ` LIMIT ?`;
      params.push(options.limit);
    }
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    return rows.map((row) => this.rowToMemory(row));
  }
  /**
   * Get recent interactions across all NPCs for a character
   */
  getRecentInteractions(characterId, limit = 10) {
    const stmt = this.db.prepare(`
            SELECT * FROM conversation_memories
            WHERE character_id = ?
            ORDER BY id DESC
            LIMIT ?
        `);
    const rows = stmt.all(characterId, limit);
    return rows.map((row) => this.rowToMemory(row));
  }
  /**
   * Search memories by topic
   */
  searchByTopic(characterId, topic) {
    const stmt = this.db.prepare(`
            SELECT * FROM conversation_memories
            WHERE character_id = ?
            AND topics LIKE ?
            ORDER BY id DESC
        `);
    const rows = stmt.all(characterId, `%"${topic}"%`);
    return rows.map((row) => this.rowToMemory(row));
  }
  // ============================================================
  // HELPER METHODS
  // ============================================================
  rowToRelationship(row) {
    return {
      characterId: row.character_id,
      npcId: row.npc_id,
      familiarity: row.familiarity,
      disposition: row.disposition,
      notes: row.notes,
      firstMetAt: row.first_met_at,
      lastInteractionAt: row.last_interaction_at,
      interactionCount: row.interaction_count
    };
  }
  rowToMemory(row) {
    return {
      id: row.id,
      characterId: row.character_id,
      npcId: row.npc_id,
      summary: row.summary,
      importance: row.importance,
      topics: JSON.parse(row.topics),
      createdAt: row.created_at
    };
  }
};

// dist/server/npc-memory-tools.js
init_character_repo();

// dist/schema/spatial.js
init_zod();
var TravelTerrainSchema = external_exports.enum([
  "paved",
  // Roads, city streets - fast travel
  "dirt",
  // Dirt roads, well-worn paths - normal travel
  "wilderness",
  // Overgrown trails, rough terrain - slow travel
  "indoor"
  // Inside buildings - instant/minimal travel
]);
var ExitSchema = external_exports.object({
  direction: external_exports.enum([
    "north",
    "south",
    "east",
    "west",
    "up",
    "down",
    "northeast",
    "northwest",
    "southeast",
    "southwest"
  ]),
  targetNodeId: external_exports.string().uuid(),
  type: external_exports.enum(["OPEN", "LOCKED", "HIDDEN"]),
  dc: external_exports.number().int().min(5).max(30).optional().describe("DC for Perception to detect HIDDEN exits or Lockpicking for LOCKED"),
  description: external_exports.string().optional().describe('Narrative description of the exit (e.g., "A heavy oak door leads north")'),
  // Travel metadata
  travelTime: external_exports.number().int().min(0).optional().describe("Time to traverse in minutes (0 for instant, e.g., doorways)"),
  terrain: TravelTerrainSchema.optional().describe("Type of terrain affecting travel speed and difficulty"),
  difficulty: external_exports.number().int().min(5).max(30).optional().describe("DC for Navigation or Survival checks if terrain is challenging")
});
var BiomeTypeSchema = external_exports.enum([
  "forest",
  "mountain",
  "urban",
  "dungeon",
  "coastal",
  "cavern",
  "divine",
  "arcane"
]);
var AtmosphericSchema = external_exports.enum([
  "DARKNESS",
  "FOG",
  "ANTIMAGIC",
  "SILENCE",
  "BRIGHT",
  "MAGICAL"
]);
var RoomNodeSchema = external_exports.object({
  id: external_exports.string().uuid(),
  // Narrative identity
  name: external_exports.string().min(1, "Room name cannot be empty").max(100, "Room name too long").refine((s) => s.trim().length > 0, "Room name cannot be whitespace only"),
  baseDescription: external_exports.string().min(10, "Description must be detailed").max(2e3, "Description too long").refine((s) => s.trim().length >= 10, "Description must have at least 10 non-whitespace characters"),
  // World context
  biomeContext: BiomeTypeSchema.describe("Linked to src/engine/worldgen biome definitions"),
  // Atmospheric effects
  atmospherics: external_exports.array(AtmosphericSchema).default([]).describe("Environmental effects that modify perception and abilities"),
  // Network membership and local coordinates
  networkId: external_exports.string().uuid().optional().describe("ID of node network this room belongs to (town, road, dungeon)"),
  localX: external_exports.number().int().min(0).optional().describe("X coordinate within node network (relative to network origin)"),
  localY: external_exports.number().int().min(0).optional().describe("Y coordinate within node network (relative to network origin)"),
  // Connections
  exits: external_exports.array(ExitSchema).default([]),
  // Entities present
  entityIds: external_exports.array(external_exports.string().uuid()).default([]).describe("Foreign keys to characters/NPCs/items in this room"),
  // Metadata
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime(),
  visitedCount: external_exports.number().int().min(0).default(0),
  lastVisitedAt: external_exports.string().datetime().optional()
});
var NodeNetworkSchema = external_exports.object({
  id: external_exports.string().uuid(),
  name: external_exports.string().min(1, "Network name cannot be empty").max(100, "Network name too long"),
  type: external_exports.enum(["cluster", "linear"]).describe("cluster = town/dungeon, linear = road/path"),
  worldId: external_exports.string().describe("ID of the world this network belongs to"),
  // Primary location on world map
  centerX: external_exports.number().int().min(0).describe("Center X coordinate on world map"),
  centerY: external_exports.number().int().min(0).describe("Center Y coordinate on world map"),
  // Optional bounding box for large networks
  boundingBox: external_exports.object({
    minX: external_exports.number().int().min(0),
    maxX: external_exports.number().int().min(0),
    minY: external_exports.number().int().min(0),
    maxY: external_exports.number().int().min(0)
  }).optional().describe("Bounding box for networks spanning multiple tiles"),
  // Metadata
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});

// dist/storage/repos/spatial.repo.js
var SpatialRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  create(room) {
    const validRoom = RoomNodeSchema.parse(room);
    const stmt = this.db.prepare(`
            INSERT INTO room_nodes (
                id, name, base_description, biome_context, atmospherics,
                exits, entity_ids, created_at, updated_at, visited_count, last_visited_at,
                network_id, local_x, local_y
            )
            VALUES (
                @id, @name, @baseDescription, @biomeContext, @atmospherics,
                @exits, @entityIds, @createdAt, @updatedAt, @visitedCount, @lastVisitedAt,
                @networkId, @localX, @localY
            )
        `);
    stmt.run({
      id: validRoom.id,
      name: validRoom.name,
      baseDescription: validRoom.baseDescription,
      biomeContext: validRoom.biomeContext,
      atmospherics: JSON.stringify(validRoom.atmospherics),
      exits: JSON.stringify(validRoom.exits),
      entityIds: JSON.stringify(validRoom.entityIds),
      createdAt: validRoom.createdAt,
      updatedAt: validRoom.updatedAt,
      visitedCount: validRoom.visitedCount,
      lastVisitedAt: validRoom.lastVisitedAt || null,
      networkId: validRoom.networkId || null,
      localX: validRoom.localX !== void 0 ? validRoom.localX : null,
      localY: validRoom.localY !== void 0 ? validRoom.localY : null
    });
  }
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM room_nodes WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToRoomNode(row);
  }
  findAll() {
    const stmt = this.db.prepare("SELECT * FROM room_nodes ORDER BY name");
    const rows = stmt.all();
    return rows.map((row) => this.rowToRoomNode(row));
  }
  findByBiome(biome) {
    const stmt = this.db.prepare("SELECT * FROM room_nodes WHERE biome_context = ? ORDER BY name");
    const rows = stmt.all(biome);
    return rows.map((row) => this.rowToRoomNode(row));
  }
  update(id, updates) {
    const existing = this.findById(id);
    if (!existing)
      return null;
    const updated = {
      ...existing,
      ...updates,
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    const validRoom = RoomNodeSchema.parse(updated);
    const stmt = this.db.prepare(`
            UPDATE room_nodes
            SET name = ?, base_description = ?, biome_context = ?,
                atmospherics = ?, exits = ?, entity_ids = ?,
                visited_count = ?, last_visited_at = ?, updated_at = ?,
                network_id = ?, local_x = ?, local_y = ?
            WHERE id = ?
        `);
    stmt.run(validRoom.name, validRoom.baseDescription, validRoom.biomeContext, JSON.stringify(validRoom.atmospherics), JSON.stringify(validRoom.exits), JSON.stringify(validRoom.entityIds), validRoom.visitedCount, validRoom.lastVisitedAt || null, validRoom.updatedAt, validRoom.networkId || null, validRoom.localX !== void 0 ? validRoom.localX : null, validRoom.localY !== void 0 ? validRoom.localY : null, id);
    return validRoom;
  }
  delete(id) {
    const stmt = this.db.prepare("DELETE FROM room_nodes WHERE id = ?");
    const result = stmt.run(id);
    return result.changes > 0;
  }
  // Helper methods for entity management
  addEntityToRoom(roomId, entityId) {
    const room = this.findById(roomId);
    if (!room)
      throw new Error(`Room ${roomId} not found`);
    if (!room.entityIds.includes(entityId)) {
      room.entityIds.push(entityId);
      this.update(roomId, { entityIds: room.entityIds });
    }
  }
  removeEntityFromRoom(roomId, entityId) {
    const room = this.findById(roomId);
    if (!room)
      throw new Error(`Room ${roomId} not found`);
    room.entityIds = room.entityIds.filter((id) => id !== entityId);
    this.update(roomId, { entityIds: room.entityIds });
  }
  getEntitiesInRoom(roomId) {
    const room = this.findById(roomId);
    if (!room)
      return [];
    return room.entityIds;
  }
  // Helper methods for exit management
  addExit(roomId, exit) {
    const room = this.findById(roomId);
    if (!room)
      throw new Error(`Room ${roomId} not found`);
    room.exits.push(exit);
    this.update(roomId, { exits: room.exits });
  }
  findConnectedRooms(roomId) {
    const room = this.findById(roomId);
    if (!room)
      return [];
    const connectedRooms = [];
    for (const exit of room.exits) {
      const targetRoom = this.findById(exit.targetNodeId);
      if (targetRoom) {
        connectedRooms.push(targetRoom);
      }
    }
    return connectedRooms;
  }
  incrementVisitCount(roomId) {
    const room = this.findById(roomId);
    if (!room)
      throw new Error(`Room ${roomId} not found`);
    this.update(roomId, {
      visitedCount: room.visitedCount + 1,
      lastVisitedAt: (/* @__PURE__ */ new Date()).toISOString()
    });
  }
  // ============================================================
  // LOCAL COORDINATE QUERIES (within networks)
  // ============================================================
  findRoomsByLocalCoordinates(networkId, x, y) {
    const stmt = this.db.prepare("SELECT * FROM room_nodes WHERE network_id = ? AND local_x = ? AND local_y = ? ORDER BY name");
    const rows = stmt.all(networkId, x, y);
    return rows.map((row) => this.rowToRoomNode(row));
  }
  // ============================================================
  // NETWORK COORDINATE QUERIES (world map coordinates)
  // ============================================================
  findNetworksInBoundingBox(minX, maxX, minY, maxY) {
    const stmt = this.db.prepare(`
            SELECT * FROM node_networks
            WHERE center_x >= ? AND center_x <= ?
              AND center_y >= ? AND center_y <= ?
            ORDER BY center_x, center_y, name
        `);
    const rows = stmt.all(minX, maxX, minY, maxY);
    return rows.map((row) => this.rowToNodeNetwork(row));
  }
  findNearestNetwork(x, y) {
    const stmt = this.db.prepare(`
            SELECT *,
                   ((center_x - ?) * (center_x - ?) + (center_y - ?) * (center_y - ?)) as distance_squared
            FROM node_networks
            ORDER BY distance_squared
            LIMIT 1
        `);
    const row = stmt.get(x, x, y, y);
    if (!row)
      return null;
    return this.rowToNodeNetwork(row);
  }
  // ============================================================
  // NODE NETWORK METHODS
  // ============================================================
  createNetwork(network) {
    const validNetwork = NodeNetworkSchema.parse(network);
    const stmt = this.db.prepare(`
            INSERT INTO node_networks (
                id, name, type, world_id, center_x, center_y,
                bounding_box, created_at, updated_at
            )
            VALUES (
                @id, @name, @type, @worldId, @centerX, @centerY,
                @boundingBox, @createdAt, @updatedAt
            )
        `);
    stmt.run({
      id: validNetwork.id,
      name: validNetwork.name,
      type: validNetwork.type,
      worldId: validNetwork.worldId,
      centerX: validNetwork.centerX,
      centerY: validNetwork.centerY,
      boundingBox: validNetwork.boundingBox ? JSON.stringify(validNetwork.boundingBox) : null,
      createdAt: validNetwork.createdAt,
      updatedAt: validNetwork.updatedAt
    });
  }
  findNetworkById(id) {
    const stmt = this.db.prepare("SELECT * FROM node_networks WHERE id = ?");
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToNodeNetwork(row);
  }
  findRoomsByNetwork(networkId) {
    const stmt = this.db.prepare("SELECT * FROM room_nodes WHERE network_id = ? ORDER BY name");
    const rows = stmt.all(networkId);
    return rows.map((row) => this.rowToRoomNode(row));
  }
  findNetworksAtCoordinates(x, y) {
    const stmt = this.db.prepare(`
            SELECT * FROM node_networks
            WHERE center_x = ? AND center_y = ?
        `);
    const rows = stmt.all(x, y);
    const boundedNetworks = this.db.prepare(`
            SELECT * FROM node_networks
            WHERE bounding_box IS NOT NULL
        `).all();
    const allNetworks = [...rows];
    for (const row of boundedNetworks) {
      if (row.bounding_box) {
        const bbox = JSON.parse(row.bounding_box);
        if (x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY) {
          if (!allNetworks.find((n2) => n2.id === row.id)) {
            allNetworks.push(row);
          }
        }
      }
    }
    return allNetworks.map((row) => this.rowToNodeNetwork(row));
  }
  rowToRoomNode(row) {
    return RoomNodeSchema.parse({
      id: row.id,
      name: row.name,
      baseDescription: row.base_description,
      biomeContext: row.biome_context,
      atmospherics: JSON.parse(row.atmospherics),
      exits: JSON.parse(row.exits),
      entityIds: JSON.parse(row.entity_ids),
      createdAt: row.created_at,
      updatedAt: row.updated_at,
      visitedCount: row.visited_count,
      lastVisitedAt: row.last_visited_at || void 0,
      networkId: row.network_id || void 0,
      localX: row.local_x !== null ? row.local_x : void 0,
      localY: row.local_y !== null ? row.local_y : void 0
    });
  }
  rowToNodeNetwork(row) {
    return NodeNetworkSchema.parse({
      id: row.id,
      name: row.name,
      type: row.type,
      worldId: row.world_id,
      centerX: row.center_x,
      centerY: row.center_y,
      boundingBox: row.bounding_box ? JSON.parse(row.bounding_box) : void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    });
  }
};

// dist/engine/social/hearing.js
var BASE_HEARING_RANGES = {
  // Noisy environments
  urban: {
    WHISPER: 5,
    // Crowded tavern, market chatter
    TALK: 15,
    // Need to speak up
    SHOUT: 40
    // Cuts through noise
  },
  // Quiet natural environments
  forest: {
    WHISPER: 10,
    // Birds, wind, but mostly quiet
    TALK: 60,
    // Sound carries well
    SHOUT: 300
    // Echo through trees
  },
  mountain: {
    WHISPER: 15,
    // Thin air, less interference
    TALK: 100,
    // Wide open spaces
    SHOUT: 500
    // Mountain echo
  },
  coastal: {
    WHISPER: 5,
    // Crashing waves drown it out
    TALK: 30,
    // Have to compete with ocean
    SHOUT: 150
    // Carries over water
  },
  // Underground/enclosed
  dungeon: {
    WHISPER: 10,
    // Stone echoes whispers
    TALK: 40,
    // Moderate echo
    SHOUT: 120
    // Loud echo down corridors
  },
  cavern: {
    WHISPER: 15,
    // Huge echo chamber
    TALK: 80,
    // Sound bounces everywhere
    SHOUT: 400
    // Massive echo
  },
  // Magical environments
  divine: {
    WHISPER: 10,
    // Sacred silence
    TALK: 50,
    // Reverent acoustics
    SHOUT: 200
    // Booming temple voice
  },
  arcane: {
    WHISPER: 8,
    // Magic dampens sound slightly
    TALK: 40,
    // Unpredictable acoustics
    SHOUT: 180
    // Magical amplification
  }
};
function calculateHearingRadius(config2) {
  let range = BASE_HEARING_RANGES[config2.biomeContext][config2.volume];
  if (config2.atmospherics.includes("SILENCE")) {
    range = Math.floor(range * 0.5);
  }
  return range;
}

// dist/engine/social/stealth-perception.js
function getModifier(abilityScore) {
  return Math.floor((abilityScore - 10) / 2);
}
function rollD20() {
  return Math.floor(Math.random() * 20) + 1;
}
function rollStealthVsPerception(speaker, listener, environmentModifier = 0) {
  const speakerRoll = rollD20();
  const dexModifier = getModifier(speaker.stats.dex);
  const speakerStealthBonus = speaker.stealthBonus || 0;
  const speakerModifier = dexModifier + speakerStealthBonus;
  const speakerTotal = speakerRoll + speakerModifier;
  const listenerRoll = rollD20();
  const wisModifier = getModifier(listener.stats.wis);
  const listenerPerceptionBonus = listener.perceptionBonus || 0;
  const listenerModifier = wisModifier + listenerPerceptionBonus + environmentModifier;
  const listenerTotal = listenerRoll + listenerModifier;
  const success = listenerTotal >= speakerTotal;
  const margin = listenerTotal - speakerTotal;
  return {
    speakerRoll,
    speakerModifier,
    speakerTotal,
    listenerRoll,
    listenerModifier,
    listenerTotal,
    success,
    margin
  };
}
function getEnvironmentModifier(atmospherics) {
  let modifier = 0;
  if (atmospherics.includes("SILENCE")) {
    modifier += 5;
  }
  return modifier;
}
function isDeafened(character) {
  return character.conditions?.some((c) => c.name === "DEAFENED") || false;
}

// dist/server/npc-memory-tools.js
var NpcMemoryTools = {
  GET_NPC_RELATIONSHIP: {
    name: "get_npc_relationship",
    description: "Get relationship status (familiarity, disposition) between a PC and NPC.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      npcId: external_exports.string().describe("ID of the NPC")
    })
  },
  UPDATE_NPC_RELATIONSHIP: {
    name: "update_npc_relationship",
    description: "Update or create a PC-NPC relationship. Familiarity: stranger\u2192acquaintance\u2192friend\u2192close_friend/rival/enemy.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      npcId: external_exports.string().describe("ID of the NPC"),
      familiarity: external_exports.enum(["stranger", "acquaintance", "friend", "close_friend", "rival", "enemy"]).describe("Level of familiarity"),
      disposition: external_exports.enum(["hostile", "unfriendly", "neutral", "friendly", "helpful"]).describe("NPC's attitude toward the character"),
      notes: external_exports.string().optional().describe("Additional notes about the relationship")
    })
  },
  RECORD_CONVERSATION_MEMORY: {
    name: "record_conversation_memory",
    description: "Record a significant conversation/interaction. Importance: low (chat), medium, high (plot), critical.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      npcId: external_exports.string().describe("ID of the NPC"),
      summary: external_exports.string().describe("Summary of the conversation/interaction"),
      importance: external_exports.enum(["low", "medium", "high", "critical"]).default("medium").describe("How important this memory is"),
      topics: external_exports.array(external_exports.string()).default([]).describe('Keywords/topics for searching (e.g., ["quest", "dragon", "treasure"])')
    })
  },
  GET_CONVERSATION_HISTORY: {
    name: "get_conversation_history",
    description: "Get conversation history between PC and NPC. Filter by minimum importance level.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      npcId: external_exports.string().describe("ID of the NPC"),
      minImportance: external_exports.enum(["low", "medium", "high", "critical"]).optional().describe("Minimum importance to include"),
      limit: external_exports.number().int().positive().optional().describe("Maximum number of memories to return")
    })
  },
  GET_RECENT_INTERACTIONS: {
    name: "get_recent_interactions",
    description: "Get recent conversation memories across all NPCs for context building.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      limit: external_exports.number().int().positive().default(10).describe("Maximum number of memories to return")
    })
  },
  GET_NPC_CONTEXT: {
    name: "get_npc_context",
    description: "Get relationship + conversation history for LLM NPC dialogue prompts.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the player character"),
      npcId: external_exports.string().describe("ID of the NPC"),
      memoryLimit: external_exports.number().int().positive().default(5).describe("Maximum number of memories to include")
    })
  },
  // PHASE-2: Social Hearing Mechanics
  INTERACT_SOCIALLY: {
    name: "interact_socially",
    description: "Social interaction with spatial awareness. Handles hearing range, stealth vs perception, and memory recording.",
    inputSchema: external_exports.object({
      speakerId: external_exports.string().describe("ID of the character speaking"),
      targetId: external_exports.string().optional().describe("ID of the intended recipient (optional for broadcasts)"),
      content: external_exports.string().min(1).describe("What is being said"),
      volume: external_exports.enum(["WHISPER", "TALK", "SHOUT"]).describe("Volume level of speech"),
      intent: external_exports.string().optional().describe("Social intent: gossip, interrogate, negotiate, threaten, etc.")
    })
  }
};
function getRepo2() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return new NpcMemoryRepository(db);
}
async function handleGetNpcRelationship(args, _ctx) {
  const parsed = NpcMemoryTools.GET_NPC_RELATIONSHIP.inputSchema.parse(args);
  const repo = getRepo2();
  const relationship = repo.getRelationship(parsed.characterId, parsed.npcId);
  if (!relationship) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          characterId: parsed.characterId,
          npcId: parsed.npcId,
          familiarity: "stranger",
          disposition: "neutral",
          notes: null,
          firstMetAt: null,
          lastInteractionAt: null,
          interactionCount: 0,
          isNew: true
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        ...relationship,
        isNew: false
      }, null, 2)
    }]
  };
}
async function handleUpdateNpcRelationship(args, _ctx) {
  const parsed = NpcMemoryTools.UPDATE_NPC_RELATIONSHIP.inputSchema.parse(args);
  const repo = getRepo2();
  const relationship = repo.upsertRelationship({
    characterId: parsed.characterId,
    npcId: parsed.npcId,
    familiarity: parsed.familiarity,
    disposition: parsed.disposition,
    notes: parsed.notes ?? null
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        relationship
      }, null, 2)
    }]
  };
}
async function handleRecordConversationMemory(args, _ctx) {
  const parsed = NpcMemoryTools.RECORD_CONVERSATION_MEMORY.inputSchema.parse(args);
  const repo = getRepo2();
  const memory = repo.recordMemory({
    characterId: parsed.characterId,
    npcId: parsed.npcId,
    summary: parsed.summary,
    importance: parsed.importance,
    topics: parsed.topics
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        memory
      }, null, 2)
    }]
  };
}
async function handleGetConversationHistory(args, _ctx) {
  const parsed = NpcMemoryTools.GET_CONVERSATION_HISTORY.inputSchema.parse(args);
  const repo = getRepo2();
  const memories = repo.getConversationHistory(parsed.characterId, parsed.npcId, {
    minImportance: parsed.minImportance,
    limit: parsed.limit
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characterId: parsed.characterId,
        npcId: parsed.npcId,
        count: memories.length,
        memories
      }, null, 2)
    }]
  };
}
async function handleGetRecentInteractions(args, _ctx) {
  const parsed = NpcMemoryTools.GET_RECENT_INTERACTIONS.inputSchema.parse(args);
  const repo = getRepo2();
  const memories = repo.getRecentInteractions(parsed.characterId, parsed.limit);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characterId: parsed.characterId,
        count: memories.length,
        memories
      }, null, 2)
    }]
  };
}
async function handleGetNpcContext(args, _ctx) {
  const parsed = NpcMemoryTools.GET_NPC_CONTEXT.inputSchema.parse(args);
  const repo = getRepo2();
  const relationship = repo.getRelationship(parsed.characterId, parsed.npcId);
  const memories = repo.getConversationHistory(parsed.characterId, parsed.npcId, { limit: parsed.memoryLimit });
  const context = {
    relationship: relationship ?? {
      characterId: parsed.characterId,
      npcId: parsed.npcId,
      familiarity: "stranger",
      disposition: "neutral",
      notes: null,
      firstMetAt: null,
      lastInteractionAt: null,
      interactionCount: 0
    },
    recentMemories: memories,
    // Generate LLM-ready summary
    contextSummary: buildContextSummary(relationship, memories)
  };
  return {
    content: [{
      type: "text",
      text: JSON.stringify(context, null, 2)
    }]
  };
}
async function handleInteractSocially(args, _ctx) {
  const parsed = NpcMemoryTools.INTERACT_SOCIALLY.inputSchema.parse(args);
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  const charRepo = new CharacterRepository(db);
  const spatialRepo = new SpatialRepository(db);
  const memoryRepo = new NpcMemoryRepository(db);
  const speaker = charRepo.findById(parsed.speakerId);
  if (!speaker) {
    throw new Error(`Speaker with ID ${parsed.speakerId} not found`);
  }
  if (!speaker.currentRoomId) {
    throw new Error(`Speaker ${speaker.name} is not in any room`);
  }
  const room = spatialRepo.findById(speaker.currentRoomId);
  if (!room) {
    throw new Error(`Room ${speaker.currentRoomId} not found`);
  }
  let target = null;
  if (parsed.targetId) {
    target = charRepo.findById(parsed.targetId);
    if (!target) {
      throw new Error(`Target with ID ${parsed.targetId} not found`);
    }
  }
  const hearingRadius = calculateHearingRadius({
    volume: parsed.volume,
    biomeContext: room.biomeContext,
    atmospherics: room.atmospherics
  });
  const envModifier = getEnvironmentModifier(room.atmospherics);
  const potentialListeners = room.entityIds.filter((id) => id !== parsed.speakerId).map((id) => charRepo.findById(id)).filter((char) => char !== null);
  const hearingResults = [];
  if (target && target.currentRoomId === room.id) {
    hearingResults.push({
      listenerId: target.id,
      listenerName: target.name,
      heardFully: true
    });
    memoryRepo.recordMemory({
      characterId: target.id,
      npcId: speaker.id,
      summary: `${speaker.name} said (${parsed.volume.toLowerCase()}): "${parsed.content}"${parsed.intent ? ` [Intent: ${parsed.intent}]` : ""}`,
      importance: parsed.volume === "SHOUT" ? "high" : "medium",
      topics: parsed.intent ? [parsed.intent] : []
    });
  }
  const eavesdroppers = potentialListeners.filter((listener) => listener.id !== parsed.targetId && !isDeafened(listener));
  for (const listener of eavesdroppers) {
    const roll = rollStealthVsPerception(speaker, listener, envModifier);
    if (roll.success) {
      hearingResults.push({
        listenerId: listener.id,
        listenerName: listener.name,
        heardFully: false,
        opposedRoll: {
          speakerRoll: roll.speakerRoll,
          speakerTotal: roll.speakerTotal,
          listenerRoll: roll.listenerRoll,
          listenerTotal: roll.listenerTotal,
          success: roll.success,
          margin: roll.margin
        }
      });
      memoryRepo.recordMemory({
        characterId: listener.id,
        npcId: speaker.id,
        summary: `Overheard ${speaker.name} ${parsed.volume === "WHISPER" ? "whispering" : parsed.volume === "SHOUT" ? "shouting" : "talking"}${target ? ` to ${target.name}` : ""} about something${parsed.intent ? ` (${parsed.intent})` : ""}`,
        importance: parsed.volume === "SHOUT" ? "medium" : "low",
        topics: parsed.intent ? [parsed.intent, "eavesdropped"] : ["eavesdropped"]
      });
    } else {
      hearingResults.push({
        listenerId: listener.id,
        listenerName: listener.name,
        heardFully: false,
        opposedRoll: {
          speakerRoll: roll.speakerRoll,
          speakerTotal: roll.speakerTotal,
          listenerRoll: roll.listenerRoll,
          listenerTotal: roll.listenerTotal,
          success: roll.success,
          margin: roll.margin
        }
      });
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        speaker: {
          id: speaker.id,
          name: speaker.name
        },
        target: target ? {
          id: target.id,
          name: target.name,
          heard: true
        } : null,
        volume: parsed.volume,
        hearingRadius,
        room: {
          id: room.id,
          name: room.name,
          biome: room.biomeContext,
          atmospherics: room.atmospherics
        },
        listeners: hearingResults,
        totalListeners: hearingResults.length,
        whoHeard: hearingResults.filter((r) => r.heardFully || r.opposedRoll?.success).length,
        whoMissed: hearingResults.filter((r) => !r.heardFully && !r.opposedRoll?.success).length
      }, null, 2)
    }]
  };
}
function buildContextSummary(relationship, memories) {
  const lines = [];
  if (relationship) {
    lines.push(`RELATIONSHIP: ${relationship.familiarity} (${relationship.disposition})`);
    lines.push(`Previous interactions: ${relationship.interactionCount}`);
    if (relationship.notes) {
      lines.push(`Notes: ${relationship.notes}`);
    }
  } else {
    lines.push(`RELATIONSHIP: First meeting (stranger, neutral)`);
  }
  if (memories.length > 0) {
    lines.push("");
    lines.push("PREVIOUS CONVERSATIONS:");
    for (const memory of memories) {
      const importance = memory.importance === "critical" ? "!!!" : memory.importance === "high" ? "!!" : memory.importance === "medium" ? "!" : "";
      lines.push(`${importance} ${memory.summary}`);
      if (memory.topics.length > 0) {
        lines.push(`  Topics: ${memory.topics.join(", ")}`);
      }
    }
  }
  return lines.join("\n");
}

// dist/server/theft-tools.js
init_zod();

// dist/schema/theft.js
init_zod();
var HeatLevelSchema = external_exports.enum(["burning", "hot", "warm", "cool", "cold"]);
var StolenItemRecordSchema = external_exports.object({
  id: external_exports.string(),
  itemId: external_exports.string(),
  stolenFrom: external_exports.string().describe("Original owner character ID"),
  stolenBy: external_exports.string().describe("Thief character ID"),
  stolenAt: external_exports.string().datetime(),
  stolenLocation: external_exports.string().nullable().describe("Region/structure ID where theft occurred"),
  // Heat system
  heatLevel: HeatLevelSchema.default("burning"),
  heatUpdatedAt: external_exports.string().datetime(),
  // Detection
  reportedToGuards: external_exports.boolean().default(false),
  bounty: external_exports.number().int().min(0).default(0),
  witnesses: external_exports.array(external_exports.string()).default([]).describe("NPC IDs who witnessed the theft"),
  // Resolution
  recovered: external_exports.boolean().default(false),
  recoveredAt: external_exports.string().datetime().nullable(),
  fenced: external_exports.boolean().default(false),
  fencedAt: external_exports.string().datetime().nullable(),
  fencedTo: external_exports.string().nullable().describe("Fence NPC ID"),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var FenceNpcSchema = external_exports.object({
  npcId: external_exports.string(),
  factionId: external_exports.string().nullable().describe("e.g., 'thieves-guild'"),
  buyRate: external_exports.number().min(0.1).max(1).default(0.4).describe("Fraction of item value they pay"),
  maxHeatLevel: HeatLevelSchema.default("hot").describe("Maximum heat they will accept"),
  dailyHeatCapacity: external_exports.number().int().min(0).default(100).describe("Total heat points they can absorb per day"),
  currentDailyHeat: external_exports.number().int().min(0).default(0),
  lastResetAt: external_exports.string().datetime(),
  specializations: external_exports.array(external_exports.string()).default([]).describe("Item types they prefer"),
  cooldownDays: external_exports.number().int().min(0).default(7).describe("Days to remove stolen flag"),
  reputation: external_exports.number().int().min(0).max(100).default(50).describe("Fence reliability")
});
var HEAT_VALUES = {
  burning: 100,
  hot: 50,
  warm: 25,
  cool: 10,
  cold: 5
};
var HEAT_DECAY_RULES = {
  burning_to_hot: 1,
  // 1 day
  hot_to_warm: 3,
  // 3 days
  warm_to_cool: 7,
  // 1 week
  cool_to_cold: 14,
  // 2 weeks
  cold_fully: 30
  // Never fully clears for unique items
};
var HEAT_LEVEL_ORDER = ["cold", "cool", "warm", "hot", "burning"];
function compareHeatLevels(a, b) {
  return HEAT_LEVEL_ORDER.indexOf(a) - HEAT_LEVEL_ORDER.indexOf(b);
}

// dist/storage/repos/theft.repo.js
var TheftRepository = class {
  db;
  inventoryRepo;
  constructor(db) {
    this.db = db;
    this.inventoryRepo = new InventoryRepository(db);
  }
  // ============================================================
  // STOLEN ITEM OPERATIONS
  // ============================================================
  /**
   * Record a theft event
   * @param transferItem - If true, physically moves item from victim to thief inventory
   */
  recordTheft(record2) {
    if (record2.stolenFrom === record2.stolenBy) {
      throw new Error("A character cannot steal from themselves");
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const id = v4_default();
    const stmt = this.db.prepare(`
            INSERT INTO stolen_items (
                id, item_id, stolen_from, stolen_by, stolen_at, stolen_location,
                heat_level, heat_updated_at, witnesses, created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, 'burning', ?, ?, ?, ?)
        `);
    stmt.run(id, record2.itemId, record2.stolenFrom, record2.stolenBy, now, record2.stolenLocation ?? null, now, JSON.stringify(record2.witnesses ?? []), now, now);
    let transferred = false;
    if (record2.transferItem) {
      const qty = record2.quantity ?? 1;
      const removed = this.inventoryRepo.removeItem(record2.stolenFrom, record2.itemId, qty);
      if (removed) {
        this.inventoryRepo.addItem(record2.stolenBy, record2.itemId, qty);
        transferred = true;
      }
    }
    return { ...this.getTheftRecord(record2.itemId), transferred };
  }
  /**
   * Check if an item is currently stolen (not recovered or cleared)
   */
  isStolen(itemId) {
    const stmt = this.db.prepare(`
            SELECT id FROM stolen_items
            WHERE item_id = ? AND recovered = 0
        `);
    const row = stmt.get(itemId);
    return !!row;
  }
  /**
   * Get theft record for an item
   */
  getTheftRecord(itemId) {
    const stmt = this.db.prepare(`
            SELECT * FROM stolen_items
            WHERE item_id = ? AND recovered = 0
            ORDER BY created_at DESC LIMIT 1
        `);
    const row = stmt.get(itemId);
    if (!row)
      return null;
    return this.rowToStolenItem(row);
  }
  /**
   * Get all stolen items currently held by a character
   */
  getStolenItemsHeldBy(characterId) {
    const stmt = this.db.prepare(`
            SELECT si.* FROM stolen_items si
            JOIN inventory_items ii ON si.item_id = ii.item_id
            WHERE ii.character_id = ? AND si.recovered = 0
        `);
    const rows = stmt.all(characterId);
    return rows.map((r) => this.rowToStolenItem(r));
  }
  /**
   * Get all items stolen FROM a character
   */
  getItemsStolenFrom(characterId) {
    const stmt = this.db.prepare(`
            SELECT * FROM stolen_items
            WHERE stolen_from = ? AND recovered = 0
        `);
    const rows = stmt.all(characterId);
    return rows.map((r) => this.rowToStolenItem(r));
  }
  /**
   * Get all active theft records (not recovered)
   */
  getAllActiveThefts() {
    const stmt = this.db.prepare(`
            SELECT * FROM stolen_items WHERE recovered = 0
        `);
    const rows = stmt.all();
    return rows.map((r) => this.rowToStolenItem(r));
  }
  /**
   * Update heat level
   */
  updateHeatLevel(itemId, newHeat) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE stolen_items
            SET heat_level = ?, heat_updated_at = ?, updated_at = ?
            WHERE item_id = ? AND recovered = 0
        `);
    stmt.run(newHeat, now, now, itemId);
  }
  /**
   * Report theft to guards
   */
  reportToGuards(itemId, bounty = 0) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE stolen_items
            SET reported_to_guards = 1, bounty = ?, updated_at = ?
            WHERE item_id = ? AND recovered = 0
        `);
    stmt.run(bounty, now, itemId);
  }
  /**
   * Mark item as recovered
   */
  markRecovered(itemId) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE stolen_items
            SET recovered = 1, recovered_at = ?, updated_at = ?
            WHERE item_id = ? AND recovered = 0
        `);
    stmt.run(now, now, itemId);
  }
  /**
   * Mark item as fenced
   */
  markFenced(itemId, fenceId) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE stolen_items
            SET fenced = 1, fenced_at = ?, fenced_to = ?, updated_at = ?
            WHERE item_id = ? AND recovered = 0
        `);
    stmt.run(now, fenceId, now, itemId);
  }
  /**
   * Clear stolen flag completely (after cooldown)
   */
  clearStolenFlag(itemId) {
    const stmt = this.db.prepare(`
            DELETE FROM stolen_items WHERE item_id = ?
        `);
    stmt.run(itemId);
  }
  /**
   * Process heat decay for all stolen items
   */
  processHeatDecay(daysAdvanced) {
    const changes = [];
    const items = this.getAllActiveThefts();
    const now = /* @__PURE__ */ new Date();
    for (const item of items) {
      const heatUpdated = new Date(item.heatUpdatedAt);
      const daysSinceUpdate = Math.floor((now.getTime() - heatUpdated.getTime()) / (1e3 * 60 * 60 * 24)) + daysAdvanced;
      let currentHeat = item.heatLevel;
      let newHeat = currentHeat;
      if (currentHeat === "burning" && daysSinceUpdate >= HEAT_DECAY_RULES.burning_to_hot) {
        newHeat = "hot";
      } else if (currentHeat === "hot" && daysSinceUpdate >= HEAT_DECAY_RULES.hot_to_warm) {
        newHeat = "warm";
      } else if (currentHeat === "warm" && daysSinceUpdate >= HEAT_DECAY_RULES.warm_to_cool) {
        newHeat = "cool";
      } else if (currentHeat === "cool" && daysSinceUpdate >= HEAT_DECAY_RULES.cool_to_cold) {
        newHeat = "cold";
      }
      if (newHeat !== currentHeat) {
        this.updateHeatLevel(item.itemId, newHeat);
        changes.push({ itemId: item.itemId, oldHeat: currentHeat, newHeat });
      }
    }
    return changes;
  }
  // ============================================================
  // FENCE OPERATIONS
  // ============================================================
  /**
   * Register an NPC as a fence
   * EDGE-006: Throws error if NPC has been a theft victim
   */
  registerFence(fence) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const victimCheck = this.db.prepare("SELECT COUNT(*) as count FROM stolen_items WHERE stolen_from = ?").get(fence.npcId);
    if (victimCheck.count > 0) {
      throw new Error("Cannot register a theft victim as a fence");
    }
    const stmt = this.db.prepare(`
            INSERT INTO fence_npcs (
                npc_id, faction_id, buy_rate, max_heat_level, daily_heat_capacity,
                current_daily_heat, last_reset_at, specializations, cooldown_days, reputation
            ) VALUES (?, ?, ?, ?, ?, 0, ?, ?, ?, ?)
        `);
    stmt.run(fence.npcId, fence.factionId ?? null, fence.buyRate ?? 0.4, fence.maxHeatLevel ?? "hot", fence.dailyHeatCapacity ?? 100, now, JSON.stringify(fence.specializations ?? []), fence.cooldownDays ?? 7, fence.reputation ?? 50);
    return this.getFence(fence.npcId);
  }
  /**
   * Get fence data for an NPC
   */
  getFence(npcId) {
    const stmt = this.db.prepare(`SELECT * FROM fence_npcs WHERE npc_id = ?`);
    const row = stmt.get(npcId);
    if (!row)
      return null;
    return this.rowToFence(row);
  }
  /**
   * List all fences
   */
  listFences(factionId) {
    let stmt;
    if (factionId) {
      stmt = this.db.prepare(`SELECT * FROM fence_npcs WHERE faction_id = ?`);
      const rows = stmt.all(factionId);
      return rows.map((r) => this.rowToFence(r));
    } else {
      stmt = this.db.prepare(`SELECT * FROM fence_npcs`);
      const rows = stmt.all();
      return rows.map((r) => this.rowToFence(r));
    }
  }
  /**
   * Check if fence will accept an item
   */
  canFenceAccept(fenceId, stolenRecord, itemValue) {
    const fence = this.getFence(fenceId);
    if (!fence) {
      return { accepted: false, reason: "Not a registered fence" };
    }
    if (compareHeatLevels(stolenRecord.heatLevel, fence.maxHeatLevel) > 0) {
      return { accepted: false, reason: `Item too hot (${stolenRecord.heatLevel}), fence only accepts ${fence.maxHeatLevel} or cooler` };
    }
    const heatValue = HEAT_VALUES[stolenRecord.heatLevel];
    if (fence.currentDailyHeat + heatValue > fence.dailyHeatCapacity) {
      return { accepted: false, reason: "Fence at daily capacity" };
    }
    const price = Math.floor(itemValue * fence.buyRate);
    return { accepted: true, price };
  }
  /**
   * Record a fence transaction
   * @param paySeller - If true, transfers gold from fence to seller
   * @param sellerId - Required if paySeller is true
   * @param price - Required if paySeller is true (amount to pay)
   */
  recordFenceTransaction(fenceId, itemId, itemHeatLevel, options) {
    const fence = this.getFence(fenceId);
    if (!fence)
      return { fenced: false, paid: false };
    const heatValue = HEAT_VALUES[itemHeatLevel];
    const stmt = this.db.prepare(`
            UPDATE fence_npcs
            SET current_daily_heat = current_daily_heat + ?
            WHERE npc_id = ?
        `);
    stmt.run(heatValue, fenceId);
    this.markFenced(itemId, fenceId);
    let paid = false;
    if (options?.paySeller && options?.sellerId && options?.price) {
      this.inventoryRepo.addCurrency(options.sellerId, { gold: options.price });
      paid = true;
    }
    return { fenced: true, paid, amountPaid: paid ? options?.price : void 0 };
  }
  /**
   * Reset daily heat capacity for all fences
   */
  resetFenceDailyCapacity() {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE fence_npcs
            SET current_daily_heat = 0, last_reset_at = ?
        `);
    stmt.run(now);
  }
  // ============================================================
  // HELPER METHODS
  // ============================================================
  rowToStolenItem(row) {
    return {
      id: row.id,
      itemId: row.item_id,
      stolenFrom: row.stolen_from,
      stolenBy: row.stolen_by,
      stolenAt: row.stolen_at,
      stolenLocation: row.stolen_location,
      heatLevel: row.heat_level,
      heatUpdatedAt: row.heat_updated_at,
      reportedToGuards: row.reported_to_guards === 1,
      bounty: row.bounty,
      witnesses: JSON.parse(row.witnesses),
      recovered: row.recovered === 1,
      recoveredAt: row.recovered_at,
      fenced: row.fenced === 1,
      fencedAt: row.fenced_at,
      fencedTo: row.fenced_to,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
  rowToFence(row) {
    return {
      npcId: row.npc_id,
      factionId: row.faction_id,
      buyRate: row.buy_rate,
      maxHeatLevel: row.max_heat_level,
      dailyHeatCapacity: row.daily_heat_capacity,
      currentDailyHeat: row.current_daily_heat,
      lastResetAt: row.last_reset_at,
      specializations: JSON.parse(row.specializations),
      cooldownDays: row.cooldown_days,
      reputation: row.reputation
    };
  }
};

// dist/server/theft-tools.js
var TheftTools = {
  STEAL_ITEM: {
    name: "steal_item",
    description: `Record a theft event. Marks an item as stolen from one character and creates a "hot" theft record.

The theft creates a provenance record that:
- Can be detected by the original owner
- May trigger guard searches
- Affects NPC disposition if detected
- Heat decays over time (burning \u2192 hot \u2192 warm \u2192 cool \u2192 cold)

Example:
{
  "thiefId": "rogue-1",
  "victimId": "merchant-1",
  "itemId": "ruby-necklace",
  "witnesses": ["guard-1"],
  "locationId": "marketplace"
}`,
    inputSchema: external_exports.object({
      thiefId: external_exports.string().describe("Character performing the theft"),
      victimId: external_exports.string().describe("Character being stolen from"),
      itemId: external_exports.string().describe("Item being stolen"),
      witnesses: external_exports.array(external_exports.string()).optional().describe("NPCs who witnessed the theft"),
      locationId: external_exports.string().optional().describe("Where the theft occurred")
    })
  },
  CHECK_ITEM_STOLEN: {
    name: "check_item_stolen",
    description: "Check if an item is stolen and get its provenance details.",
    inputSchema: external_exports.object({
      itemId: external_exports.string()
    })
  },
  CHECK_STOLEN_ITEMS_ON_CHARACTER: {
    name: "check_stolen_items_on_character",
    description: "Check if a character carries stolen items. Useful for guard searches.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      checkerId: external_exports.string().optional().describe("The NPC/guard doing the checking")
    })
  },
  CHECK_ITEM_RECOGNITION: {
    name: "check_item_recognition",
    description: "Check if NPC recognizes stolen item. Owner always recognizes; guards check vs heat/bounty.",
    inputSchema: external_exports.object({
      npcId: external_exports.string().describe("NPC who might recognize the item"),
      characterId: external_exports.string().describe("Character carrying the item"),
      itemId: external_exports.string().describe("Item to check")
    })
  },
  SELL_TO_FENCE: {
    name: "sell_to_fence",
    description: "Sell stolen item to a fence NPC for reduced price. Clears stolen flag after cooldown.",
    inputSchema: external_exports.object({
      sellerId: external_exports.string(),
      fenceId: external_exports.string(),
      itemId: external_exports.string(),
      itemValue: external_exports.number().int().min(0).describe("Base value of the item in gold")
    })
  },
  REGISTER_FENCE: {
    name: "register_fence",
    description: "Register an NPC as a fence (buys stolen goods).",
    inputSchema: external_exports.object({
      npcId: external_exports.string(),
      factionId: external_exports.string().optional(),
      buyRate: external_exports.number().min(0.1).max(1).optional().default(0.4),
      maxHeatLevel: HeatLevelSchema.optional().default("hot"),
      dailyHeatCapacity: external_exports.number().int().min(0).optional().default(100),
      specializations: external_exports.array(external_exports.string()).optional(),
      cooldownDays: external_exports.number().int().min(0).optional().default(7)
    })
  },
  REPORT_THEFT: {
    name: "report_theft",
    description: "Report a theft to guards, setting bounty and increasing detection chance.",
    inputSchema: external_exports.object({
      reporterId: external_exports.string(),
      itemId: external_exports.string(),
      bountyOffered: external_exports.number().int().min(0).optional().default(0)
    })
  },
  ADVANCE_HEAT_DECAY: {
    name: "advance_heat_decay",
    description: "Process heat decay for all stolen items when game time advances.",
    inputSchema: external_exports.object({
      daysAdvanced: external_exports.number().int().min(1)
    })
  },
  GET_FENCE: {
    name: "get_fence",
    description: "Get information about a fence NPC.",
    inputSchema: external_exports.object({
      npcId: external_exports.string()
    })
  },
  LIST_FENCES: {
    name: "list_fences",
    description: "List all registered fences, optionally filtered by faction.",
    inputSchema: external_exports.object({
      factionId: external_exports.string().optional()
    })
  }
};
function getRepo3() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return new TheftRepository(db);
}
async function handleStealItem(args, _ctx) {
  const parsed = TheftTools.STEAL_ITEM.inputSchema.parse(args);
  const repo = getRepo3();
  if (parsed.thiefId === parsed.victimId) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "A character cannot steal from themselves"
        }, null, 2)
      }]
    };
  }
  const record2 = repo.recordTheft({
    itemId: parsed.itemId,
    stolenFrom: parsed.victimId,
    stolenBy: parsed.thiefId,
    stolenLocation: parsed.locationId ?? null,
    witnesses: parsed.witnesses ?? []
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        record: record2,
        message: `Item ${parsed.itemId} marked as stolen from ${parsed.victimId} by ${parsed.thiefId}`,
        heatLevel: record2.heatLevel,
        witnesses: record2.witnesses.length
      }, null, 2)
    }]
  };
}
async function handleCheckItemStolen(args, _ctx) {
  const parsed = TheftTools.CHECK_ITEM_STOLEN.inputSchema.parse(args);
  const repo = getRepo3();
  const record2 = repo.getTheftRecord(parsed.itemId);
  const isStolen = record2 !== null;
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        itemId: parsed.itemId,
        isStolen,
        record: record2 ?? void 0,
        heatLevel: record2?.heatLevel ?? null,
        originalOwner: record2?.stolenFrom ?? null,
        thief: record2?.stolenBy ?? null,
        reportedToGuards: record2?.reportedToGuards ?? false,
        bounty: record2?.bounty ?? 0
      }, null, 2)
    }]
  };
}
async function handleCheckStolenItemsOnCharacter(args, _ctx) {
  const parsed = TheftTools.CHECK_STOLEN_ITEMS_ON_CHARACTER.inputSchema.parse(args);
  const repo = getRepo3();
  const stolenItems = repo.getStolenItemsHeldBy(parsed.characterId);
  let detectionRisk = "none";
  let hottest = "cold";
  for (const item of stolenItems) {
    if (compareHeatLevels(item.heatLevel, hottest) > 0) {
      hottest = item.heatLevel;
    }
  }
  if (hottest === "burning")
    detectionRisk = "very high";
  else if (hottest === "hot")
    detectionRisk = "high";
  else if (hottest === "warm")
    detectionRisk = "moderate";
  else if (hottest === "cool")
    detectionRisk = "low";
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        characterId: parsed.characterId,
        stolenItemCount: stolenItems.length,
        detectionRisk,
        hottestItem: hottest,
        items: stolenItems.map((i) => ({
          itemId: i.itemId,
          heatLevel: i.heatLevel,
          stolenFrom: i.stolenFrom,
          reportedToGuards: i.reportedToGuards,
          bounty: i.bounty
        }))
      }, null, 2)
    }]
  };
}
async function handleCheckItemRecognition(args, _ctx) {
  const parsed = TheftTools.CHECK_ITEM_RECOGNITION.inputSchema.parse(args);
  const repo = getRepo3();
  const record2 = repo.getTheftRecord(parsed.itemId);
  if (!record2) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          itemId: parsed.itemId,
          recognized: false,
          isStolen: false,
          reason: "Item is not stolen"
        }, null, 2)
      }]
    };
  }
  if (parsed.npcId === record2.stolenFrom) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          itemId: parsed.itemId,
          recognized: true,
          isStolen: true,
          recognizedBy: "original_owner",
          message: "That belongs to me! THIEF!",
          reaction: "hostile",
          stolenFrom: record2.stolenFrom,
          stolenAt: record2.stolenAt
        }, null, 2)
      }]
    };
  }
  if (record2.witnesses.includes(parsed.npcId)) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          itemId: parsed.itemId,
          recognized: true,
          isStolen: true,
          recognizedBy: "witness",
          message: "I saw you steal that!",
          reaction: "suspicious"
        }, null, 2)
      }]
    };
  }
  const heatValue = HEAT_VALUES[record2.heatLevel];
  const recognitionChance = Math.min(100, heatValue + record2.bounty / 10);
  const roll = Math.random() * 100;
  if (roll < recognitionChance) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          itemId: parsed.itemId,
          recognized: true,
          isStolen: true,
          recognizedBy: "suspicion",
          roll: Math.floor(roll),
          threshold: Math.floor(recognitionChance),
          message: "That looks suspicious...",
          reaction: "suspicious"
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        itemId: parsed.itemId,
        recognized: false,
        isStolen: true,
        roll: Math.floor(roll),
        threshold: Math.floor(recognitionChance),
        reason: "NPC did not recognize the item"
      }, null, 2)
    }]
  };
}
async function handleSellToFence(args, _ctx) {
  const parsed = TheftTools.SELL_TO_FENCE.inputSchema.parse(args);
  const repo = getRepo3();
  const record2 = repo.getTheftRecord(parsed.itemId);
  if (!record2) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          reason: "Item is not stolen - no need for a fence"
        }, null, 2)
      }]
    };
  }
  const check2 = repo.canFenceAccept(parsed.fenceId, record2, parsed.itemValue);
  if (!check2.accepted) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          reason: check2.reason
        }, null, 2)
      }]
    };
  }
  repo.recordFenceTransaction(parsed.fenceId, parsed.itemId, record2.heatLevel);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        itemId: parsed.itemId,
        fenceId: parsed.fenceId,
        price: check2.price,
        baseValue: parsed.itemValue,
        heatLevel: record2.heatLevel,
        message: `Sold for ${check2.price} gold (${Math.floor(check2.price / parsed.itemValue * 100)}% of value)`
      }, null, 2)
    }]
  };
}
async function handleRegisterFence(args, _ctx) {
  const parsed = TheftTools.REGISTER_FENCE.inputSchema.parse(args);
  const repo = getRepo3();
  const stolenFromVictim = repo.getItemsStolenFrom(parsed.npcId);
  if (stolenFromVictim.length > 0) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Cannot register a theft victim as a fence",
          reason: `${parsed.npcId} has had ${stolenFromVictim.length} item(s) stolen from them`,
          suggestion: "Theft victims cannot act as fences for narrative consistency"
        }, null, 2)
      }]
    };
  }
  const fence = repo.registerFence({
    npcId: parsed.npcId,
    factionId: parsed.factionId ?? null,
    buyRate: parsed.buyRate,
    maxHeatLevel: parsed.maxHeatLevel,
    dailyHeatCapacity: parsed.dailyHeatCapacity,
    specializations: parsed.specializations ?? [],
    cooldownDays: parsed.cooldownDays
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        fence,
        message: `${parsed.npcId} registered as a fence`
      }, null, 2)
    }]
  };
}
async function handleReportTheft(args, _ctx) {
  const parsed = TheftTools.REPORT_THEFT.inputSchema.parse(args);
  const repo = getRepo3();
  const record2 = repo.getTheftRecord(parsed.itemId);
  if (!record2) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          reason: "No theft record found for this item"
        }, null, 2)
      }]
    };
  }
  repo.reportToGuards(parsed.itemId, parsed.bountyOffered ?? 0);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        itemId: parsed.itemId,
        reportedBy: parsed.reporterId,
        bounty: parsed.bountyOffered ?? 0,
        message: "Theft reported to guards"
      }, null, 2)
    }]
  };
}
async function handleAdvanceHeatDecay(args, _ctx) {
  const parsed = TheftTools.ADVANCE_HEAT_DECAY.inputSchema.parse(args);
  const repo = getRepo3();
  const changes = repo.processHeatDecay(parsed.daysAdvanced);
  repo.resetFenceDailyCapacity();
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        daysAdvanced: parsed.daysAdvanced,
        itemsDecayed: changes.length,
        changes: changes.map((c) => ({
          itemId: c.itemId,
          from: c.oldHeat,
          to: c.newHeat
        }))
      }, null, 2)
    }]
  };
}
async function handleGetFence(args, _ctx) {
  const parsed = TheftTools.GET_FENCE.inputSchema.parse(args);
  const repo = getRepo3();
  const fence = repo.getFence(parsed.npcId);
  if (!fence) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          found: false,
          npcId: parsed.npcId,
          message: "NPC is not a registered fence"
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        found: true,
        fence
      }, null, 2)
    }]
  };
}
async function handleListFences(args, _ctx) {
  const parsed = TheftTools.LIST_FENCES.inputSchema.parse(args);
  const repo = getRepo3();
  const fences = repo.listFences(parsed.factionId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        count: fences.length,
        factionFilter: parsed.factionId ?? "all",
        fences
      }, null, 2)
    }]
  };
}

// dist/server/corpse-tools.js
init_zod();

// dist/schema/corpse.js
init_zod();
var CorpseStateSchema = external_exports.enum(["fresh", "decaying", "skeletal", "gone"]);
var CorpseSchema = external_exports.object({
  id: external_exports.string(),
  characterId: external_exports.string().describe("Original character/creature ID"),
  characterName: external_exports.string(),
  characterType: external_exports.enum(["pc", "npc", "enemy", "neutral"]),
  creatureType: external_exports.string().optional().describe('Creature type for loot table lookup (e.g., "goblin", "dragon")'),
  cr: external_exports.number().optional().describe("Challenge rating for loot scaling"),
  // Location
  worldId: external_exports.string().nullable(),
  regionId: external_exports.string().nullable(),
  position: external_exports.object({
    x: external_exports.number(),
    y: external_exports.number()
  }).nullable(),
  encounterId: external_exports.string().nullable().describe("Encounter where death occurred"),
  // State
  state: CorpseStateSchema.default("fresh"),
  stateUpdatedAt: external_exports.string().datetime(),
  // Loot
  lootGenerated: external_exports.boolean().default(false),
  looted: external_exports.boolean().default(false),
  lootedBy: external_exports.string().nullable(),
  lootedAt: external_exports.string().datetime().nullable(),
  // Currency (from loot generation)
  currency: external_exports.object({
    gold: external_exports.number().int().min(0).default(0),
    silver: external_exports.number().int().min(0).default(0),
    copper: external_exports.number().int().min(0).default(0)
  }).default({ gold: 0, silver: 0, copper: 0 }),
  currencyLooted: external_exports.boolean().default(false),
  // Harvesting
  harvestable: external_exports.boolean().default(false),
  harvestableResources: external_exports.array(external_exports.object({
    resourceType: external_exports.string(),
    quantity: external_exports.number().int(),
    harvested: external_exports.boolean().default(false)
  })).default([]),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var LootTableEntrySchema = external_exports.object({
  itemId: external_exports.string().nullable().describe("Specific item ID, or null for template-based"),
  itemTemplateId: external_exports.string().nullable().describe("Item template to instantiate"),
  itemName: external_exports.string().optional().describe("Name for dynamic item creation"),
  quantity: external_exports.object({
    min: external_exports.number().int().min(0),
    max: external_exports.number().int().min(0)
  }),
  weight: external_exports.number().min(0).max(1).describe("Drop probability 0-1"),
  conditions: external_exports.array(external_exports.string()).optional().describe("Conditions for this drop")
});
var LootTableSchema = external_exports.object({
  id: external_exports.string(),
  name: external_exports.string(),
  creatureTypes: external_exports.array(external_exports.string()).describe('Creature types this applies to (e.g., "goblin", "dragon")'),
  crRange: external_exports.object({
    min: external_exports.number().min(0),
    max: external_exports.number().min(0)
  }).optional(),
  guaranteedDrops: external_exports.array(LootTableEntrySchema).default([]),
  randomDrops: external_exports.array(LootTableEntrySchema).default([]),
  currencyRange: external_exports.object({
    gold: external_exports.object({ min: external_exports.number(), max: external_exports.number() }),
    silver: external_exports.object({ min: external_exports.number(), max: external_exports.number() }).optional(),
    copper: external_exports.object({ min: external_exports.number(), max: external_exports.number() }).optional()
  }).optional(),
  harvestableResources: external_exports.array(external_exports.object({
    resourceType: external_exports.string(),
    quantity: external_exports.object({ min: external_exports.number(), max: external_exports.number() }),
    dcRequired: external_exports.number().int().optional()
  })).optional(),
  createdAt: external_exports.string().datetime(),
  updatedAt: external_exports.string().datetime()
});
var CORPSE_DECAY_RULES = {
  fresh_to_decaying: 24,
  // 1 day
  decaying_to_skeletal: 168,
  // 1 week
  skeletal_to_gone: 720
  // 30 days
};
var DEFAULT_LOOT_TABLES = [
  {
    name: "Goblin Loot",
    creatureTypes: ["goblin", "hobgoblin"],
    crRange: { min: 0, max: 2 },
    guaranteedDrops: [],
    randomDrops: [
      { itemId: null, itemTemplateId: null, itemName: "Rusty Scimitar", quantity: { min: 0, max: 1 }, weight: 0.3 },
      { itemId: null, itemTemplateId: null, itemName: "Shortbow", quantity: { min: 0, max: 1 }, weight: 0.2 },
      { itemId: null, itemTemplateId: null, itemName: "Crude Arrow", quantity: { min: 1, max: 10 }, weight: 0.5 }
    ],
    currencyRange: {
      gold: { min: 0, max: 2 },
      silver: { min: 1, max: 10 },
      copper: { min: 5, max: 30 }
    },
    harvestableResources: [
      { resourceType: "goblin ear", quantity: { min: 1, max: 2 }, dcRequired: 10 }
    ]
  },
  {
    name: "Orc Loot",
    creatureTypes: ["orc", "orog"],
    crRange: { min: 0.5, max: 3 },
    guaranteedDrops: [],
    randomDrops: [
      { itemId: null, itemTemplateId: null, itemName: "Greataxe", quantity: { min: 0, max: 1 }, weight: 0.4 },
      { itemId: null, itemTemplateId: null, itemName: "Javelin", quantity: { min: 1, max: 4 }, weight: 0.5 }
    ],
    currencyRange: {
      gold: { min: 1, max: 5 },
      silver: { min: 5, max: 20 }
    },
    harvestableResources: [
      { resourceType: "orc tusk", quantity: { min: 1, max: 2 }, dcRequired: 12 }
    ]
  },
  {
    name: "Dragon Loot",
    creatureTypes: ["dragon", "drake", "wyvern"],
    crRange: { min: 5, max: 30 },
    guaranteedDrops: [
      { itemId: null, itemTemplateId: null, itemName: "Dragon Scale", quantity: { min: 3, max: 10 }, weight: 1 }
    ],
    randomDrops: [
      { itemId: null, itemTemplateId: null, itemName: "Dragon Tooth", quantity: { min: 1, max: 4 }, weight: 0.6 },
      { itemId: null, itemTemplateId: null, itemName: "Dragon Blood Vial", quantity: { min: 0, max: 2 }, weight: 0.3 }
    ],
    currencyRange: {
      gold: { min: 500, max: 5e3 }
    },
    harvestableResources: [
      { resourceType: "dragon hide", quantity: { min: 5, max: 20 }, dcRequired: 15 },
      { resourceType: "dragon heart", quantity: { min: 1, max: 1 }, dcRequired: 20 }
    ]
  },
  {
    name: "Undead Loot",
    creatureTypes: ["skeleton", "zombie", "ghoul"],
    crRange: { min: 0, max: 5 },
    guaranteedDrops: [],
    randomDrops: [
      { itemId: null, itemTemplateId: null, itemName: "Bone Fragment", quantity: { min: 1, max: 5 }, weight: 0.7 },
      { itemId: null, itemTemplateId: null, itemName: "Tattered Cloth", quantity: { min: 0, max: 1 }, weight: 0.3 }
    ],
    currencyRange: {
      gold: { min: 0, max: 3 },
      silver: { min: 0, max: 10 }
    },
    harvestableResources: [
      { resourceType: "ectoplasm", quantity: { min: 0, max: 1 }, dcRequired: 14 }
    ]
  },
  {
    name: "Wolf Loot",
    creatureTypes: ["wolf", "dire wolf", "worg"],
    crRange: { min: 0.25, max: 3 },
    guaranteedDrops: [],
    randomDrops: [],
    currencyRange: void 0,
    harvestableResources: [
      { resourceType: "wolf pelt", quantity: { min: 1, max: 1 }, dcRequired: 10 },
      { resourceType: "wolf fang", quantity: { min: 2, max: 4 }, dcRequired: 8 }
    ]
  }
];

// dist/storage/repos/corpse.repo.js
var CorpseRepository = class {
  db;
  inventoryRepo;
  constructor(db) {
    this.db = db;
    this.inventoryRepo = new InventoryRepository(db);
  }
  /**
   * Create a corpse when a character dies
   */
  createFromDeath(characterId, characterName, characterType, options = {}) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const id = v4_default();
    const stmt = this.db.prepare(`
            INSERT INTO corpses (
                id, character_id, character_name, character_type, creature_type, cr,
                world_id, region_id, position_x, position_y, encounter_id,
                state, state_updated_at, harvestable, harvestable_resources,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 'fresh', ?, 0, '[]', ?, ?)
        `);
    stmt.run(id, characterId, characterName, characterType, options.creatureType ?? null, options.cr ?? null, options.worldId ?? null, options.regionId ?? null, options.position?.x ?? null, options.position?.y ?? null, options.encounterId ?? null, now, now, now);
    return this.findById(id);
  }
  /**
   * Get corpse by ID
   */
  findById(id) {
    const stmt = this.db.prepare(`SELECT * FROM corpses WHERE id = ?`);
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToCorpse(row);
  }
  /**
   * Get corpse for a specific character
   */
  findByCharacterId(characterId) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpses
            WHERE character_id = ? AND state != 'gone'
            ORDER BY created_at DESC LIMIT 1
        `);
    const row = stmt.get(characterId);
    if (!row)
      return null;
    return this.rowToCorpse(row);
  }
  /**
   * Get all corpses in an encounter
   */
  findByEncounterId(encounterId) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpses
            WHERE encounter_id = ? AND state != 'gone'
        `);
    const rows = stmt.all(encounterId);
    return rows.map((r) => this.rowToCorpse(r));
  }
  /**
   * Get corpses in a region
   */
  findByRegion(worldId, regionId) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpses
            WHERE world_id = ? AND region_id = ? AND state != 'gone'
        `);
    const rows = stmt.all(worldId, regionId);
    return rows.map((r) => this.rowToCorpse(r));
  }
  /**
   * Get corpses at or near a specific position
   */
  findNearPosition(worldId, x, y, radius = 3) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpses
            WHERE world_id = ?
              AND state != 'gone'
              AND position_x IS NOT NULL
              AND position_y IS NOT NULL
              AND ABS(position_x - ?) <= ?
              AND ABS(position_y - ?) <= ?
        `);
    const rows = stmt.all(worldId, x, radius, y, radius);
    return rows.map((r) => this.rowToCorpse(r));
  }
  /**
   * Add item to corpse inventory
   */
  addToCorpseInventory(corpseId, itemId, quantity = 1) {
    const stmt = this.db.prepare(`
            INSERT INTO corpse_inventory (corpse_id, item_id, quantity, looted)
            VALUES (?, ?, ?, 0)
            ON CONFLICT(corpse_id, item_id) DO UPDATE SET quantity = quantity + ?
        `);
    stmt.run(corpseId, itemId, quantity, quantity);
  }
  /**
   * Get items in corpse inventory
   */
  getCorpseInventory(corpseId) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpse_inventory
            WHERE corpse_id = ?
        `);
    const rows = stmt.all(corpseId);
    return rows.map((r) => ({
      itemId: r.item_id,
      quantity: r.quantity,
      looted: r.looted === 1
    }));
  }
  /**
   * Get unlootable items from corpse
   */
  getAvailableLoot(corpseId) {
    const stmt = this.db.prepare(`
            SELECT * FROM corpse_inventory
            WHERE corpse_id = ? AND looted = 0
        `);
    const rows = stmt.all(corpseId);
    return rows.map((r) => ({
      itemId: r.item_id,
      quantity: r.quantity
    }));
  }
  /**
   * Loot an item from a corpse
   * @param transferToLooter - If true, adds item to looter's inventory
   */
  lootItem(corpseId, itemId, looterId, quantity, transferToLooter) {
    const corpse = this.findById(corpseId);
    if (!corpse) {
      return { success: false, itemId, quantity: 0, transferred: false, reason: "Corpse not found" };
    }
    if (corpse.state === "gone") {
      return { success: false, itemId, quantity: 0, transferred: false, reason: "Corpse has decayed completely" };
    }
    const inventory = this.getAvailableLoot(corpseId);
    const item = inventory.find((i) => i.itemId === itemId);
    if (!item) {
      return { success: false, itemId, quantity: 0, transferred: false, reason: "Item not on corpse or already looted" };
    }
    const toLoot = quantity ?? item.quantity;
    if (toLoot > item.quantity) {
      return { success: false, itemId, quantity: 0, transferred: false, reason: `Only ${item.quantity} available` };
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (toLoot === item.quantity) {
      const stmt = this.db.prepare(`
                UPDATE corpse_inventory SET looted = 1 WHERE corpse_id = ? AND item_id = ?
            `);
      stmt.run(corpseId, itemId);
    } else {
      const stmt = this.db.prepare(`
                UPDATE corpse_inventory SET quantity = quantity - ? WHERE corpse_id = ? AND item_id = ?
            `);
      stmt.run(toLoot, corpseId, itemId);
    }
    const updateStmt = this.db.prepare(`
            UPDATE corpses SET looted_by = ?, looted_at = ?, updated_at = ? WHERE id = ?
        `);
    updateStmt.run(looterId, now, now, corpseId);
    const remaining = this.getAvailableLoot(corpseId);
    if (remaining.length === 0) {
      const lootedStmt = this.db.prepare(`
                UPDATE corpses SET looted = 1, updated_at = ? WHERE id = ?
            `);
      lootedStmt.run(now, corpseId);
    }
    let transferred = false;
    if (transferToLooter) {
      this.inventoryRepo.addItem(looterId, itemId, toLoot);
      transferred = true;
    }
    return { success: true, itemId, quantity: toLoot, transferred };
  }
  /**
   * Loot all items from a corpse
   * @param transferToLooter - If true, adds all items to looter's inventory
   */
  lootAll(corpseId, looterId, transferToLooter) {
    const available = this.getAvailableLoot(corpseId);
    const looted = [];
    for (const item of available) {
      const result = this.lootItem(corpseId, item.itemId, looterId, item.quantity, transferToLooter);
      if (result.success) {
        looted.push({ itemId: result.itemId, quantity: result.quantity, transferred: result.transferred });
      }
    }
    return looted;
  }
  /**
   * Loot currency from a corpse
   * @param transferToLooter - If true, adds currency to looter's inventory
   */
  lootCurrency(corpseId, looterId, transferToLooter) {
    const corpse = this.findById(corpseId);
    if (!corpse) {
      return { success: false, currency: { gold: 0, silver: 0, copper: 0 }, transferred: false, reason: "Corpse not found" };
    }
    if (corpse.currencyLooted) {
      return { success: false, currency: { gold: 0, silver: 0, copper: 0 }, transferred: false, reason: "Currency already looted" };
    }
    const currency = corpse.currency;
    if (currency.gold === 0 && currency.silver === 0 && currency.copper === 0) {
      return { success: false, currency: { gold: 0, silver: 0, copper: 0 }, transferred: false, reason: "No currency on corpse" };
    }
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE corpses SET currency_looted = 1, updated_at = ? WHERE id = ?
        `);
    stmt.run(now, corpseId);
    let transferred = false;
    if (transferToLooter) {
      this.inventoryRepo.addCurrency(looterId, currency);
      transferred = true;
    }
    return { success: true, currency, transferred };
  }
  /**
   * Generate loot for a corpse based on creature type
   */
  generateLoot(corpseId, creatureType, cr) {
    const corpse = this.findById(corpseId);
    if (!corpse || corpse.lootGenerated) {
      return { itemsAdded: [], currency: { gold: 0, silver: 0, copper: 0 }, harvestable: [] };
    }
    const lootTable = this.findLootTableByCreatureType(creatureType, cr);
    if (!lootTable) {
      this.markLootGenerated(corpseId);
      return { itemsAdded: [], currency: { gold: 0, silver: 0, copper: 0 }, harvestable: [] };
    }
    const itemsAdded = [];
    const harvestable = [];
    for (const drop of lootTable.guaranteedDrops) {
      const qty = this.rollQuantity(drop.quantity.min, drop.quantity.max);
      if (qty > 0 && drop.itemName) {
        itemsAdded.push({ name: drop.itemName, quantity: qty });
      }
    }
    for (const drop of lootTable.randomDrops) {
      if (Math.random() <= drop.weight) {
        const qty = this.rollQuantity(drop.quantity.min, drop.quantity.max);
        if (qty > 0 && drop.itemName) {
          itemsAdded.push({ name: drop.itemName, quantity: qty });
        }
      }
    }
    let gold = 0, silver = 0, copper = 0;
    if (lootTable.currencyRange) {
      gold = this.rollQuantity(lootTable.currencyRange.gold.min, lootTable.currencyRange.gold.max);
      if (lootTable.currencyRange.silver) {
        silver = this.rollQuantity(lootTable.currencyRange.silver.min, lootTable.currencyRange.silver.max);
      }
      if (lootTable.currencyRange.copper) {
        copper = this.rollQuantity(lootTable.currencyRange.copper.min, lootTable.currencyRange.copper.max);
      }
    }
    if (lootTable.harvestableResources) {
      for (const resource of lootTable.harvestableResources) {
        const qty = this.rollQuantity(resource.quantity.min, resource.quantity.max);
        if (qty > 0) {
          harvestable.push({ resourceType: resource.resourceType, quantity: qty });
        }
      }
    }
    if (harvestable.length > 0) {
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const stmt = this.db.prepare(`
                UPDATE corpses
                SET harvestable = 1, harvestable_resources = ?, updated_at = ?
                WHERE id = ?
            `);
      stmt.run(JSON.stringify(harvestable.map((h) => ({ ...h, harvested: false }))), now, corpseId);
    }
    this.markLootGenerated(corpseId, { gold, silver, copper });
    return { itemsAdded, currency: { gold, silver, copper }, harvestable };
  }
  /**
   * Harvest a resource from a corpse
   * @param createItem - If true, creates an item in the items table and adds to harvester inventory
   */
  harvestResource(corpseId, resourceType, harvesterId, options) {
    const corpse = this.findById(corpseId);
    if (!corpse) {
      return { success: false, quantity: 0, resourceType, transferred: false, reason: "Corpse not found" };
    }
    if (!corpse.harvestable) {
      return { success: false, quantity: 0, resourceType, transferred: false, reason: "Corpse has no harvestable resources" };
    }
    if (corpse.state === "skeletal" || corpse.state === "gone") {
      return { success: false, quantity: 0, resourceType, transferred: false, reason: "Corpse too decayed to harvest" };
    }
    const resources = corpse.harvestableResources;
    const resource = resources.find((r) => r.resourceType === resourceType && !r.harvested);
    if (!resource) {
      return { success: false, quantity: 0, resourceType, transferred: false, reason: "Resource not available or already harvested" };
    }
    if (options?.skillCheck) {
      if (options.skillCheck.roll < options.skillCheck.dc) {
        return { success: false, quantity: 0, resourceType, transferred: false, reason: `Failed skill check (${options.skillCheck.roll} vs DC ${options.skillCheck.dc})` };
      }
    }
    resource.harvested = true;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE corpses
            SET harvestable_resources = ?, updated_at = ?
            WHERE id = ?
        `);
    stmt.run(JSON.stringify(resources), now, corpseId);
    let itemId;
    let transferred = false;
    if (options?.createItem) {
      itemId = v4_default();
      const createStmt = this.db.prepare(`
                INSERT INTO items (id, name, description, type, weight, value, created_at, updated_at)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            `);
      createStmt.run(
        itemId,
        resourceType,
        // Use resource type as item name (e.g., "wolf pelt")
        `Harvested ${resourceType} from a corpse`,
        "misc",
        1,
        10,
        // Default value, could be parameterized
        now,
        now
      );
      this.inventoryRepo.addItem(harvesterId, itemId, resource.quantity);
      transferred = true;
    }
    return { success: true, quantity: resource.quantity, resourceType, itemId, transferred };
  }
  /**
   * Process corpse decay based on time passed
   */
  processDecay(hoursAdvanced) {
    const changes = [];
    const stmt = this.db.prepare(`SELECT * FROM corpses WHERE state != 'gone'`);
    const corpses = stmt.all();
    const now = /* @__PURE__ */ new Date();
    for (const row of corpses) {
      const stateUpdated = new Date(row.state_updated_at);
      const hoursSinceUpdate = Math.floor((now.getTime() - stateUpdated.getTime()) / (1e3 * 60 * 60)) + hoursAdvanced;
      let currentState = row.state;
      let newState = currentState;
      if (currentState === "fresh" && hoursSinceUpdate >= CORPSE_DECAY_RULES.fresh_to_decaying) {
        newState = "decaying";
      } else if (currentState === "decaying" && hoursSinceUpdate >= CORPSE_DECAY_RULES.decaying_to_skeletal) {
        newState = "skeletal";
      } else if (currentState === "skeletal" && hoursSinceUpdate >= CORPSE_DECAY_RULES.skeletal_to_gone) {
        newState = "gone";
      }
      if (newState !== currentState) {
        this.updateState(row.id, newState);
        changes.push({ corpseId: row.id, oldState: currentState, newState });
      }
    }
    return changes;
  }
  /**
   * Update corpse state
   */
  updateState(corpseId, newState) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE corpses SET state = ?, state_updated_at = ?, updated_at = ? WHERE id = ?
        `);
    stmt.run(newState, now, now, corpseId);
  }
  /**
   * Clean up gone corpses
   */
  cleanupGoneCorpses() {
    const deleteInventory = this.db.prepare(`
            DELETE FROM corpse_inventory WHERE corpse_id IN (SELECT id FROM corpses WHERE state = 'gone')
        `);
    deleteInventory.run();
    const deleteCorpses = this.db.prepare(`DELETE FROM corpses WHERE state = 'gone'`);
    const result = deleteCorpses.run();
    return result.changes;
  }
  /**
   * Mark corpse as loot generated
   */
  markLootGenerated(corpseId, currency) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    if (currency && (currency.gold > 0 || currency.silver > 0 || currency.copper > 0)) {
      const stmt = this.db.prepare(`
                UPDATE corpses SET loot_generated = 1, currency = ?, updated_at = ? WHERE id = ?
            `);
      stmt.run(JSON.stringify(currency), now, corpseId);
    } else {
      const stmt = this.db.prepare(`
                UPDATE corpses SET loot_generated = 1, updated_at = ? WHERE id = ?
            `);
      stmt.run(now, corpseId);
    }
  }
  // ============================================================
  // LOOT TABLE OPERATIONS
  // ============================================================
  /**
   * Create a loot table
   */
  createLootTable(table) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const id = v4_default();
    const stmt = this.db.prepare(`
            INSERT INTO loot_tables (
                id, name, creature_types, cr_min, cr_max,
                guaranteed_drops, random_drops, currency_range, harvestable_resources,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `);
    stmt.run(id, table.name, JSON.stringify(table.creatureTypes), table.crRange?.min ?? null, table.crRange?.max ?? null, JSON.stringify(table.guaranteedDrops), JSON.stringify(table.randomDrops), table.currencyRange ? JSON.stringify(table.currencyRange) : null, table.harvestableResources ? JSON.stringify(table.harvestableResources) : null, now, now);
    return this.findLootTableById(id);
  }
  /**
   * Find loot table by ID
   */
  findLootTableById(id) {
    const stmt = this.db.prepare(`SELECT * FROM loot_tables WHERE id = ?`);
    const row = stmt.get(id);
    if (!row)
      return null;
    return this.rowToLootTable(row);
  }
  /**
   * Find loot table by creature type
   */
  findLootTableByCreatureType(creatureType, cr) {
    const stmt = this.db.prepare(`SELECT * FROM loot_tables`);
    const rows = stmt.all();
    for (const row of rows) {
      const table = this.rowToLootTable(row);
      if (table.creatureTypes.includes(creatureType.toLowerCase())) {
        if (cr !== void 0 && table.crRange) {
          if (cr >= table.crRange.min && cr <= table.crRange.max) {
            return table;
          }
        } else {
          return table;
        }
      }
    }
    for (const defaultTable of DEFAULT_LOOT_TABLES) {
      if (defaultTable.creatureTypes.includes(creatureType.toLowerCase())) {
        if (cr !== void 0 && defaultTable.crRange) {
          if (cr >= defaultTable.crRange.min && cr <= defaultTable.crRange.max) {
            return {
              id: `default-${defaultTable.name.toLowerCase().replace(/\s+/g, "-")}`,
              ...defaultTable,
              createdAt: (/* @__PURE__ */ new Date()).toISOString(),
              updatedAt: (/* @__PURE__ */ new Date()).toISOString()
            };
          }
        } else {
          return {
            id: `default-${defaultTable.name.toLowerCase().replace(/\s+/g, "-")}`,
            ...defaultTable,
            createdAt: (/* @__PURE__ */ new Date()).toISOString(),
            updatedAt: (/* @__PURE__ */ new Date()).toISOString()
          };
        }
      }
    }
    return null;
  }
  /**
   * List all loot tables
   */
  listLootTables() {
    const stmt = this.db.prepare(`SELECT * FROM loot_tables`);
    const rows = stmt.all();
    return rows.map((r) => this.rowToLootTable(r));
  }
  // ============================================================
  // HELPER METHODS
  // ============================================================
  rollQuantity(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }
  rowToCorpse(row) {
    let currency = { gold: 0, silver: 0, copper: 0 };
    if (row.currency) {
      try {
        const parsed = JSON.parse(row.currency);
        currency = {
          gold: parsed.gold ?? 0,
          silver: parsed.silver ?? 0,
          copper: parsed.copper ?? 0
        };
      } catch {
      }
    }
    return {
      id: row.id,
      characterId: row.character_id,
      characterName: row.character_name,
      characterType: row.character_type,
      creatureType: row.creature_type ?? void 0,
      cr: row.cr ?? void 0,
      worldId: row.world_id,
      regionId: row.region_id,
      position: row.position_x !== null && row.position_y !== null ? { x: row.position_x, y: row.position_y } : null,
      encounterId: row.encounter_id,
      state: row.state,
      stateUpdatedAt: row.state_updated_at,
      lootGenerated: row.loot_generated === 1,
      looted: row.looted === 1,
      lootedBy: row.looted_by,
      lootedAt: row.looted_at,
      currency,
      currencyLooted: row.currency_looted === 1,
      harvestable: row.harvestable === 1,
      harvestableResources: JSON.parse(row.harvestable_resources),
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
  rowToLootTable(row) {
    return {
      id: row.id,
      name: row.name,
      creatureTypes: JSON.parse(row.creature_types),
      crRange: row.cr_min !== null && row.cr_max !== null ? { min: row.cr_min, max: row.cr_max } : void 0,
      guaranteedDrops: JSON.parse(row.guaranteed_drops),
      randomDrops: JSON.parse(row.random_drops),
      currencyRange: row.currency_range ? JSON.parse(row.currency_range) : void 0,
      harvestableResources: row.harvestable_resources ? JSON.parse(row.harvestable_resources) : void 0,
      createdAt: row.created_at,
      updatedAt: row.updated_at
    };
  }
};

// dist/server/corpse-tools.js
var CorpseTools = {
  GET_CORPSE: {
    name: "get_corpse",
    description: "Get details about a corpse, including loot and harvestable resources.",
    inputSchema: external_exports.object({
      corpseId: external_exports.string()
    })
  },
  GET_CORPSE_BY_CHARACTER: {
    name: "get_corpse_by_character",
    description: "Get the corpse of a specific character (if they are dead).",
    inputSchema: external_exports.object({
      characterId: external_exports.string()
    })
  },
  LIST_CORPSES_IN_ENCOUNTER: {
    name: "list_corpses_in_encounter",
    description: "List all corpses from a combat encounter.",
    inputSchema: external_exports.object({
      encounterId: external_exports.string()
    })
  },
  LIST_CORPSES_NEARBY: {
    name: "list_corpses_nearby",
    description: "List corpses near a position in the world.",
    inputSchema: external_exports.object({
      worldId: external_exports.string(),
      x: external_exports.number().int(),
      y: external_exports.number().int(),
      radius: external_exports.number().int().min(1).max(20).default(3)
    })
  },
  LOOT_CORPSE: {
    name: "loot_corpse",
    description: "Loot items from a corpse. Specify itemId for specific item, or use lootAll for everything.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("Character doing the looting"),
      corpseId: external_exports.string(),
      itemId: external_exports.string().optional().describe("Specific item to loot"),
      quantity: external_exports.number().int().min(1).optional(),
      lootAll: external_exports.boolean().optional().describe("Loot everything from the corpse")
    })
  },
  HARVEST_CORPSE: {
    name: "harvest_corpse",
    description: "Harvest resources from a corpse (scales, pelts). May require skill check.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      corpseId: external_exports.string(),
      resourceType: external_exports.string(),
      skillRoll: external_exports.number().int().optional().describe("Result of skill check if required"),
      skillDC: external_exports.number().int().optional().describe("DC of the skill check")
    })
  },
  CREATE_CORPSE: {
    name: "create_corpse",
    description: "Manually create a corpse for a dead character.",
    inputSchema: external_exports.object({
      characterId: external_exports.string(),
      characterName: external_exports.string(),
      characterType: external_exports.enum(["pc", "npc", "enemy", "neutral"]),
      creatureType: external_exports.string().optional().describe("Creature type for loot table lookup"),
      cr: external_exports.number().optional().describe("Challenge rating for loot scaling"),
      worldId: external_exports.string().optional(),
      regionId: external_exports.string().optional(),
      encounterId: external_exports.string().optional(),
      position: external_exports.object({ x: external_exports.number(), y: external_exports.number() }).optional()
    })
  },
  GENERATE_LOOT: {
    name: "generate_loot",
    description: "Generate loot for a corpse based on creature type and CR.",
    inputSchema: external_exports.object({
      corpseId: external_exports.string(),
      creatureType: external_exports.string(),
      cr: external_exports.number().optional()
    })
  },
  GET_CORPSE_INVENTORY: {
    name: "get_corpse_inventory",
    description: "Get the inventory of a corpse (items available to loot).",
    inputSchema: external_exports.object({
      corpseId: external_exports.string()
    })
  },
  CREATE_LOOT_TABLE: {
    name: "create_loot_table",
    description: "Create a loot table for a creature type.",
    inputSchema: LootTableSchema.omit({ id: true, createdAt: true, updatedAt: true })
  },
  GET_LOOT_TABLE: {
    name: "get_loot_table",
    description: "Get a loot table by ID or creature type.",
    inputSchema: external_exports.object({
      id: external_exports.string().optional(),
      creatureType: external_exports.string().optional(),
      cr: external_exports.number().optional()
    })
  },
  LIST_LOOT_TABLES: {
    name: "list_loot_tables",
    description: "List all registered loot tables.",
    inputSchema: external_exports.object({})
  },
  ADVANCE_CORPSE_DECAY: {
    name: "advance_corpse_decay",
    description: "Process corpse decay when game time advances.",
    inputSchema: external_exports.object({
      hoursAdvanced: external_exports.number().int().min(1)
    })
  },
  CLEANUP_CORPSES: {
    name: "cleanup_corpses",
    description: "Remove corpses that have fully decayed (state = gone).",
    inputSchema: external_exports.object({})
  }
};
function getRepo4() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return new CorpseRepository(db);
}
async function handleGetCorpse(args, _ctx) {
  const parsed = CorpseTools.GET_CORPSE.inputSchema.parse(args);
  const repo = getRepo4();
  const corpse = repo.findById(parsed.corpseId);
  if (!corpse) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          found: false,
          corpseId: parsed.corpseId,
          message: "Corpse not found"
        }, null, 2)
      }]
    };
  }
  const inventory = repo.getAvailableLoot(parsed.corpseId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        found: true,
        corpse,
        availableLoot: inventory,
        canLoot: corpse.state !== "gone" && inventory.length > 0,
        canHarvest: corpse.harvestable && corpse.state !== "skeletal" && corpse.state !== "gone"
      }, null, 2)
    }]
  };
}
async function handleGetCorpseByCharacter(args, _ctx) {
  const parsed = CorpseTools.GET_CORPSE_BY_CHARACTER.inputSchema.parse(args);
  const repo = getRepo4();
  const corpse = repo.findByCharacterId(parsed.characterId);
  if (!corpse) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          found: false,
          characterId: parsed.characterId,
          message: "No corpse found for this character"
        }, null, 2)
      }]
    };
  }
  const inventory = repo.getAvailableLoot(corpse.id);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        found: true,
        corpse,
        availableLoot: inventory
      }, null, 2)
    }]
  };
}
async function handleListCorpsesInEncounter(args, _ctx) {
  const parsed = CorpseTools.LIST_CORPSES_IN_ENCOUNTER.inputSchema.parse(args);
  const repo = getRepo4();
  const corpses = repo.findByEncounterId(parsed.encounterId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        encounterId: parsed.encounterId,
        count: corpses.length,
        corpses: corpses.map((c) => ({
          id: c.id,
          characterName: c.characterName,
          characterType: c.characterType,
          state: c.state,
          looted: c.looted,
          position: c.position
        }))
      }, null, 2)
    }]
  };
}
async function handleListCorpsesNearby(args, _ctx) {
  const parsed = CorpseTools.LIST_CORPSES_NEARBY.inputSchema.parse(args);
  const repo = getRepo4();
  const corpses = repo.findNearPosition(parsed.worldId, parsed.x, parsed.y, parsed.radius);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        worldId: parsed.worldId,
        center: { x: parsed.x, y: parsed.y },
        radius: parsed.radius,
        count: corpses.length,
        corpses: corpses.map((c) => ({
          id: c.id,
          characterName: c.characterName,
          state: c.state,
          looted: c.looted,
          position: c.position,
          distance: c.position ? Math.sqrt(Math.pow(c.position.x - parsed.x, 2) + Math.pow(c.position.y - parsed.y, 2)) : null
        }))
      }, null, 2)
    }]
  };
}
async function handleLootCorpse(args, _ctx) {
  const parsed = CorpseTools.LOOT_CORPSE.inputSchema.parse(args);
  const repo = getRepo4();
  if (parsed.lootAll) {
    const looted = repo.lootAll(parsed.corpseId, parsed.characterId);
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: true,
          lootedBy: parsed.characterId,
          corpseId: parsed.corpseId,
          itemsLooted: looted,
          totalItems: looted.length
        }, null, 2)
      }]
    };
  }
  if (!parsed.itemId) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          reason: "Must specify itemId or set lootAll: true"
        }, null, 2)
      }]
    };
  }
  const result = repo.lootItem(parsed.corpseId, parsed.itemId, parsed.characterId, parsed.quantity);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: result.success,
        lootedBy: parsed.characterId,
        corpseId: parsed.corpseId,
        itemId: result.itemId,
        quantity: result.quantity,
        reason: result.reason
      }, null, 2)
    }]
  };
}
async function handleHarvestCorpse(args, _ctx) {
  const parsed = CorpseTools.HARVEST_CORPSE.inputSchema.parse(args);
  const repo = getRepo4();
  const skillCheck = parsed.skillRoll !== void 0 && parsed.skillDC !== void 0 ? { roll: parsed.skillRoll, dc: parsed.skillDC } : void 0;
  const result = repo.harvestResource(parsed.corpseId, parsed.resourceType, parsed.characterId, { skillCheck });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: result.success,
        harvestedBy: parsed.characterId,
        corpseId: parsed.corpseId,
        resourceType: result.resourceType,
        quantity: result.quantity,
        skillCheck: skillCheck ? {
          roll: skillCheck.roll,
          dc: skillCheck.dc,
          passed: skillCheck.roll >= skillCheck.dc
        } : "not required",
        reason: result.reason
      }, null, 2)
    }]
  };
}
async function handleCreateCorpse(args, _ctx) {
  const parsed = CorpseTools.CREATE_CORPSE.inputSchema.parse(args);
  const repo = getRepo4();
  const corpse = repo.createFromDeath(parsed.characterId, parsed.characterName, parsed.characterType, {
    creatureType: parsed.creatureType,
    cr: parsed.cr,
    worldId: parsed.worldId,
    regionId: parsed.regionId,
    encounterId: parsed.encounterId,
    position: parsed.position
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        corpse,
        message: `Corpse created for ${parsed.characterName}`
      }, null, 2)
    }]
  };
}
async function handleGenerateLoot(args, _ctx) {
  const parsed = CorpseTools.GENERATE_LOOT.inputSchema.parse(args);
  const repo = getRepo4();
  const result = repo.generateLoot(parsed.corpseId, parsed.creatureType, parsed.cr);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        corpseId: parsed.corpseId,
        creatureType: parsed.creatureType,
        cr: parsed.cr,
        loot: {
          items: result.itemsAdded,
          currency: result.currency,
          harvestable: result.harvestable
        }
      }, null, 2)
    }]
  };
}
async function handleGetCorpseInventory(args, _ctx) {
  const parsed = CorpseTools.GET_CORPSE_INVENTORY.inputSchema.parse(args);
  const repo = getRepo4();
  const inventory = repo.getCorpseInventory(parsed.corpseId);
  const available = repo.getAvailableLoot(parsed.corpseId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        corpseId: parsed.corpseId,
        totalItems: inventory.length,
        availableToLoot: available.length,
        inventory,
        available
      }, null, 2)
    }]
  };
}
async function handleCreateLootTable(args, _ctx) {
  const parsed = CorpseTools.CREATE_LOOT_TABLE.inputSchema.parse(args);
  const repo = getRepo4();
  const table = repo.createLootTable(parsed);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        lootTable: table,
        message: `Loot table "${table.name}" created for creature types: ${table.creatureTypes.join(", ")}`
      }, null, 2)
    }]
  };
}
async function handleGetLootTable(args, _ctx) {
  const parsed = CorpseTools.GET_LOOT_TABLE.inputSchema.parse(args);
  const repo = getRepo4();
  let table = null;
  if (parsed.id) {
    table = repo.findLootTableById(parsed.id);
  } else if (parsed.creatureType) {
    table = repo.findLootTableByCreatureType(parsed.creatureType, parsed.cr);
  }
  if (!table) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          found: false,
          message: "No matching loot table found"
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        found: true,
        lootTable: table
      }, null, 2)
    }]
  };
}
async function handleListLootTables(args, _ctx) {
  CorpseTools.LIST_LOOT_TABLES.inputSchema.parse(args);
  const repo = getRepo4();
  const tables = repo.listLootTables();
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        count: tables.length,
        tables: tables.map((t) => ({
          id: t.id,
          name: t.name,
          creatureTypes: t.creatureTypes,
          crRange: t.crRange
        }))
      }, null, 2)
    }]
  };
}
async function handleAdvanceCorpseDecay(args, _ctx) {
  const parsed = CorpseTools.ADVANCE_CORPSE_DECAY.inputSchema.parse(args);
  const repo = getRepo4();
  const changes = repo.processDecay(parsed.hoursAdvanced);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        hoursAdvanced: parsed.hoursAdvanced,
        corpsesDecayed: changes.length,
        changes: changes.map((c) => ({
          corpseId: c.corpseId,
          from: c.oldState,
          to: c.newState
        }))
      }, null, 2)
    }]
  };
}
async function handleCleanupCorpses(args, _ctx) {
  CorpseTools.CLEANUP_CORPSES.inputSchema.parse(args);
  const repo = getRepo4();
  const count = repo.cleanupGoneCorpses();
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        corpsesRemoved: count
      }, null, 2)
    }]
  };
}

// dist/server/improvisation-tools.js
init_zod();
var import_seedrandom9 = __toESM(require_seedrandom2(), 1);

// dist/schema/improvisation.js
init_zod();
var SkillNameSchema = external_exports.enum([
  "athletics",
  "acrobatics",
  "sleight_of_hand",
  "stealth",
  "arcana",
  "history",
  "investigation",
  "nature",
  "religion",
  "animal_handling",
  "insight",
  "medicine",
  "perception",
  "survival",
  "deception",
  "intimidation",
  "performance",
  "persuasion"
]);
var AbilityNameSchema = external_exports.enum([
  "strength",
  "dexterity",
  "constitution",
  "intelligence",
  "wisdom",
  "charisma"
]);
var DamageTypeSchema2 = external_exports.enum([
  "slashing",
  "piercing",
  "bludgeoning",
  "fire",
  "cold",
  "lightning",
  "thunder",
  "acid",
  "poison",
  "necrotic",
  "radiant",
  "force",
  "psychic"
]);
var ConditionTypeSchema = external_exports.enum([
  "blinded",
  "charmed",
  "deafened",
  "frightened",
  "grappled",
  "incapacitated",
  "invisible",
  "paralyzed",
  "petrified",
  "poisoned",
  "prone",
  "restrained",
  "stunned",
  "unconscious",
  "exhaustion"
]);
var SpellSchoolSchema2 = external_exports.enum([
  "abjuration",
  "conjuration",
  "divination",
  "enchantment",
  "evocation",
  "illusion",
  "necromancy",
  "transmutation"
]);
var ActorTypeSchema = external_exports.enum(["character", "npc"]);
var SkillCheckSchema = external_exports.object({
  skill: SkillNameSchema,
  dc: external_exports.number().int().min(5).max(30),
  advantage: external_exports.boolean().optional(),
  disadvantage: external_exports.boolean().optional()
});
var SavingThrowSchema = external_exports.object({
  ability: AbilityNameSchema,
  dc: external_exports.number().int().min(1).max(30),
  half_damage_on_save: external_exports.boolean().optional()
});
var AreaOfEffectSchema = external_exports.object({
  shape: external_exports.enum(["line", "cone", "sphere", "cube"]),
  size: external_exports.number().int().min(5).describe("Size in feet")
});
var StuntConsequencesSchema = external_exports.object({
  success_damage: external_exports.string().optional().describe('Dice notation: "2d6"'),
  failure_damage: external_exports.string().optional().describe("Self-damage on critical fail"),
  damage_type: DamageTypeSchema2.optional(),
  apply_condition: ConditionTypeSchema.optional(),
  condition_duration: external_exports.number().int().min(1).optional().describe("Duration in rounds"),
  saving_throw: SavingThrowSchema.optional(),
  area_of_effect: AreaOfEffectSchema.optional()
});
var ResolveImprovisedStuntArgsSchema = external_exports.object({
  encounter_id: external_exports.number().int(),
  actor_id: external_exports.number().int(),
  actor_type: ActorTypeSchema,
  target_ids: external_exports.array(external_exports.number().int()).optional(),
  target_types: external_exports.array(ActorTypeSchema).optional(),
  narrative_intent: external_exports.string().describe("What the player wants to do"),
  skill_check: SkillCheckSchema,
  action_cost: external_exports.enum(["action", "bonus_action", "reaction", "free"]),
  consequences: StuntConsequencesSchema,
  environmental_destruction: external_exports.boolean().optional(),
  narrative_on_success: external_exports.string().optional(),
  narrative_on_failure: external_exports.string().optional()
});
var StuntResultSchema = external_exports.object({
  success: external_exports.boolean(),
  roll: external_exports.number().int(),
  modifier: external_exports.number().int(),
  total: external_exports.number().int(),
  dc: external_exports.number().int(),
  critical_success: external_exports.boolean(),
  critical_failure: external_exports.boolean(),
  damage_dealt: external_exports.number().int().optional(),
  targets_affected: external_exports.array(external_exports.object({
    id: external_exports.number().int(),
    name: external_exports.string(),
    damage_taken: external_exports.number().int(),
    saved: external_exports.boolean().optional(),
    condition_applied: external_exports.string().optional()
  })).optional(),
  self_damage: external_exports.number().int().optional(),
  narrative: external_exports.string(),
  audit_log: external_exports.any()
});
var SourceTypeSchema = external_exports.enum(["divine", "arcane", "natural", "cursed", "psionic", "unknown"]);
var EffectCategorySchema = external_exports.enum(["boon", "curse", "neutral", "transformative"]);
var PowerLevelSchema = external_exports.number().int().min(1).max(5);
var MechanicTypeSchema = external_exports.enum([
  "attack_bonus",
  "damage_bonus",
  "ac_bonus",
  "saving_throw_bonus",
  "skill_bonus",
  "advantage_on",
  "disadvantage_on",
  "damage_resistance",
  "damage_vulnerability",
  "damage_immunity",
  "damage_over_time",
  "healing_over_time",
  "extra_action",
  "prevent_action",
  "movement_modifier",
  "sense_granted",
  "sense_removed",
  "speak_language",
  "cannot_speak",
  "custom_trigger"
]);
var EffectMechanicSchema = external_exports.object({
  type: MechanicTypeSchema,
  value: external_exports.union([external_exports.number(), external_exports.string()]),
  condition: external_exports.string().optional().describe('e.g., "against undead"')
});
var DurationTypeSchema = external_exports.enum(["rounds", "minutes", "hours", "days", "permanent", "until_removed"]);
var TriggerEventSchema = external_exports.enum([
  "always_active",
  "start_of_turn",
  "end_of_turn",
  "on_attack",
  "on_hit",
  "on_miss",
  "on_damage_taken",
  "on_heal",
  "on_rest",
  "on_spell_cast",
  "on_death"
]);
var EffectTriggerSchema = external_exports.object({
  event: TriggerEventSchema,
  condition: external_exports.string().optional()
});
var RemovalConditionTypeSchema = external_exports.enum([
  "duration_expires",
  "dispelled",
  "specific_action",
  "quest_complete",
  "death",
  "rest"
]);
var RemovalConditionSchema = external_exports.object({
  type: RemovalConditionTypeSchema,
  description: external_exports.string().optional(),
  difficulty_class: external_exports.number().int().optional()
});
var CustomEffectSourceSchema = external_exports.object({
  type: SourceTypeSchema,
  entity_id: external_exports.string().optional(),
  entity_name: external_exports.string().optional()
});
var CustomEffectDurationSchema = external_exports.object({
  type: DurationTypeSchema,
  value: external_exports.number().int().optional()
});
var ApplyCustomEffectArgsSchema = external_exports.object({
  target_id: external_exports.string(),
  target_type: ActorTypeSchema,
  name: external_exports.string(),
  description: external_exports.string(),
  source: CustomEffectSourceSchema,
  category: EffectCategorySchema,
  power_level: PowerLevelSchema,
  mechanics: external_exports.array(EffectMechanicSchema),
  duration: CustomEffectDurationSchema,
  triggers: external_exports.array(EffectTriggerSchema),
  removal_conditions: external_exports.array(RemovalConditionSchema),
  stackable: external_exports.boolean().optional().default(false),
  max_stacks: external_exports.number().int().min(1).optional().default(1)
});
var CustomEffectSchema = external_exports.object({
  id: external_exports.number().int(),
  target_id: external_exports.string(),
  target_type: ActorTypeSchema,
  name: external_exports.string(),
  description: external_exports.string().nullable(),
  source_type: SourceTypeSchema,
  source_entity_id: external_exports.string().nullable(),
  source_entity_name: external_exports.string().nullable(),
  category: EffectCategorySchema,
  power_level: PowerLevelSchema,
  mechanics: external_exports.array(EffectMechanicSchema),
  duration_type: DurationTypeSchema,
  duration_value: external_exports.number().int().nullable(),
  rounds_remaining: external_exports.number().int().nullable(),
  triggers: external_exports.array(EffectTriggerSchema),
  removal_conditions: external_exports.array(RemovalConditionSchema),
  stackable: external_exports.boolean(),
  max_stacks: external_exports.number().int(),
  current_stacks: external_exports.number().int(),
  is_active: external_exports.boolean(),
  created_at: external_exports.string(),
  expires_at: external_exports.string().nullable()
});
var SpellEffectTypeSchema = external_exports.enum(["damage", "healing", "status", "utility", "summon", "hybrid"]);
var TargetingTypeSchema = external_exports.enum(["self", "single", "multiple", "area", "line", "cone"]);
var SynthesisEffectSchema = external_exports.object({
  type: SpellEffectTypeSchema,
  dice: external_exports.string().optional().describe('Dice notation: "3d8"'),
  damage_type: DamageTypeSchema2.optional(),
  condition: external_exports.string().optional(),
  condition_duration: external_exports.string().optional()
});
var SynthesisTargetingSchema = external_exports.object({
  type: TargetingTypeSchema,
  range: external_exports.number().int().min(0).describe("Range in feet"),
  area_size: external_exports.number().int().optional().describe("AoE size in feet"),
  max_targets: external_exports.number().int().optional()
});
var SynthesisSavingThrowSchema = external_exports.object({
  ability: AbilityNameSchema,
  effect_on_save: external_exports.enum(["none", "half", "negates"])
});
var SynthesisMaterialComponentSchema = external_exports.object({
  description: external_exports.string(),
  consumed: external_exports.boolean(),
  value: external_exports.number().int().optional().describe("Value in gold pieces")
});
var SynthesisComponentsSchema = external_exports.object({
  verbal: external_exports.boolean(),
  somatic: external_exports.boolean(),
  material: SynthesisMaterialComponentSchema.optional()
});
var AttemptArcaneSynthesisArgsSchema = external_exports.object({
  encounter_id: external_exports.number().int().optional().describe("+2 DC if in combat"),
  caster_id: external_exports.string(),
  caster_type: ActorTypeSchema,
  narrative_intent: external_exports.string().describe("What spell effect the player wants"),
  proposed_name: external_exports.string().optional(),
  estimated_level: external_exports.number().int().min(1).max(9),
  school: SpellSchoolSchema2,
  effect_specification: SynthesisEffectSchema,
  targeting: SynthesisTargetingSchema,
  saving_throw: SynthesisSavingThrowSchema.optional(),
  components: SynthesisComponentsSchema,
  concentration: external_exports.boolean(),
  duration: external_exports.string(),
  circumstance_modifiers: external_exports.array(external_exports.string()).optional().describe('e.g., "near ley line", "blood moon"'),
  target_ids: external_exports.array(external_exports.string()).optional(),
  target_types: external_exports.array(ActorTypeSchema).optional()
});
var SynthesisOutcomeSchema = external_exports.enum(["mastery", "success", "fizzle", "backfire", "catastrophic"]);
var WildSurgeEffectSchema = external_exports.object({
  roll: external_exports.number().int().min(1).max(20),
  name: external_exports.string(),
  effect: external_exports.string()
});
var ArcaneSynthesisResultSchema = external_exports.object({
  outcome: SynthesisOutcomeSchema,
  roll: external_exports.number().int(),
  modifier: external_exports.number().int(),
  total: external_exports.number().int(),
  dc: external_exports.number().int(),
  dc_breakdown: external_exports.object({
    base: external_exports.number().int(),
    spell_level: external_exports.number().int(),
    in_combat: external_exports.number().int().optional(),
    novel_effect: external_exports.number().int().optional(),
    material_reduction: external_exports.number().int().optional(),
    related_spell: external_exports.number().int().optional(),
    school_specialization: external_exports.number().int().optional(),
    ley_line: external_exports.number().int().optional(),
    celestial_event: external_exports.number().int().optional(),
    desperation: external_exports.number().int().optional()
  }),
  spell_worked: external_exports.boolean(),
  spell_mastered: external_exports.boolean(),
  damage_dealt: external_exports.number().int().optional(),
  healing_done: external_exports.number().int().optional(),
  targets_affected: external_exports.array(external_exports.object({
    id: external_exports.string(),
    name: external_exports.string(),
    effect: external_exports.string()
  })).optional(),
  backfire_damage: external_exports.number().int().optional(),
  wild_surge: WildSurgeEffectSchema.optional(),
  spell_slot_consumed: external_exports.boolean(),
  narrative: external_exports.string(),
  audit_log: external_exports.any()
});
var SynthesizedSpellSchema = external_exports.object({
  id: external_exports.number().int(),
  character_id: external_exports.string(),
  name: external_exports.string(),
  level: external_exports.number().int().min(1).max(9),
  school: SpellSchoolSchema2,
  effect_type: SpellEffectTypeSchema,
  effect_dice: external_exports.string().nullable(),
  damage_type: DamageTypeSchema2.nullable(),
  targeting_type: TargetingTypeSchema,
  targeting_range: external_exports.number().int(),
  targeting_area_size: external_exports.number().int().nullable(),
  targeting_max_targets: external_exports.number().int().nullable(),
  saving_throw_ability: AbilityNameSchema.nullable(),
  saving_throw_effect: external_exports.string().nullable(),
  components_verbal: external_exports.boolean(),
  components_somatic: external_exports.boolean(),
  components_material: SynthesisMaterialComponentSchema.nullable(),
  concentration: external_exports.boolean(),
  duration: external_exports.string(),
  synthesis_dc: external_exports.number().int(),
  created_at: external_exports.string(),
  mastered_at: external_exports.string(),
  times_cast: external_exports.number().int()
});
var WILD_SURGE_TABLE = [
  { roll: 1, name: "Inverted Intent", effect: "Damage heals, healing damages. All effects are reversed for 1 minute." },
  { roll: 2, name: "Arcane Feedback", effect: "1d6 force damage per spell level to caster." },
  { roll: 3, name: "Spell Vampirism", effect: "ALL spell slots of that level are drained." },
  { roll: 4, name: "Temporal Stutter", effect: "Caster skips next turn, frozen in time." },
  { roll: 5, name: "Dimensional Hiccup", effect: "Teleport 3d6\xD75 feet in a random direction." },
  { roll: 6, name: "Polymorphic Instability", effect: "Transform into a small beast for 1 minute." },
  { roll: 7, name: "Magical Beacon", effect: "60ft bright light emanates from caster. Attacks have advantage vs caster for 1 minute." },
  { roll: 8, name: "Elemental Attunement", effect: "Vulnerability to a random damage type for 1 hour." },
  { roll: 9, name: "Sympathetic Link", effect: "Caster takes half of any damage they deal for 1 minute." },
  { roll: 10, name: "Wild Growth", effect: "30ft radius becomes difficult terrain (vines/plants) for 10 minutes." },
  { roll: 11, name: "Silence of the Void", effect: "20ft radius silence centered on caster for 1 minute." },
  { roll: 12, name: "Magical Exhaustion", effect: "Caster gains 2 levels of exhaustion." },
  { roll: 13, name: "Summoned Attention", effect: "A hostile minor elemental (CR 1/4) appears within 30ft." },
  { roll: 14, name: "Memory Leak", effect: "Forget one random prepared spell until next long rest." },
  { roll: 15, name: "Arcane Allergy", effect: "Cannot cast spells from this school for 24 hours." },
  { roll: 16, name: "Magical Magnetism", effect: "All metal objects within 30ft fly toward caster, dealing 2d6 bludgeoning damage." },
  { roll: 17, name: "Prismatic Flash", effect: "Color Spray effect hits everyone within 15ft (including caster)." },
  { roll: 18, name: "Gravity Reversal", effect: "Fall upward 30ft, then fall back down. Take appropriate fall damage." },
  { roll: 19, name: "Soul Echo", effect: "A ghostly duplicate mirrors caster actions for 1 minute (no extra effect, just visual)." },
  { roll: 20, name: "Complete Magical Inversion", effect: "Dispel all magic within 60ft. Magic items suppressed for 1 hour." }
];
var SKILL_TO_ABILITY = {
  athletics: "strength",
  acrobatics: "dexterity",
  sleight_of_hand: "dexterity",
  stealth: "dexterity",
  arcana: "intelligence",
  history: "intelligence",
  investigation: "intelligence",
  nature: "intelligence",
  religion: "intelligence",
  animal_handling: "wisdom",
  insight: "wisdom",
  medicine: "wisdom",
  perception: "wisdom",
  survival: "wisdom",
  deception: "charisma",
  intimidation: "charisma",
  performance: "charisma",
  persuasion: "charisma"
};

// dist/storage/repos/custom-effects.repo.js
var CustomEffectsRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Apply a new custom effect to a target
   */
  apply(args) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    let expiresAt = null;
    if (args.duration.type !== "permanent" && args.duration.type !== "until_removed" && args.duration.value) {
      const expireDate = /* @__PURE__ */ new Date();
      switch (args.duration.type) {
        case "minutes":
          expireDate.setMinutes(expireDate.getMinutes() + args.duration.value);
          break;
        case "hours":
          expireDate.setHours(expireDate.getHours() + args.duration.value);
          break;
        case "days":
          expireDate.setDate(expireDate.getDate() + args.duration.value);
          break;
      }
      if (args.duration.type !== "rounds") {
        expiresAt = expireDate.toISOString();
      }
    }
    const existing = this.findByTargetAndName(args.target_id, args.target_type, args.name);
    if (existing && !args.stackable) {
      return this.refreshDuration(existing.id, args.duration.value || null);
    }
    if (existing && args.stackable && existing.current_stacks < (args.max_stacks ?? 1)) {
      return this.incrementStacks(existing.id);
    }
    const stmt = this.db.prepare(`
            INSERT INTO custom_effects (
                target_id, target_type, name, description,
                source_type, source_entity_id, source_entity_name,
                category, power_level, mechanics,
                duration_type, duration_value, rounds_remaining,
                triggers, removal_conditions,
                stackable, max_stacks, current_stacks,
                is_active, created_at, expires_at
            ) VALUES (
                @targetId, @targetType, @name, @description,
                @sourceType, @sourceEntityId, @sourceEntityName,
                @category, @powerLevel, @mechanics,
                @durationType, @durationValue, @roundsRemaining,
                @triggers, @removalConditions,
                @stackable, @maxStacks, @currentStacks,
                @isActive, @createdAt, @expiresAt
            )
        `);
    const result = stmt.run({
      targetId: args.target_id,
      targetType: args.target_type,
      name: args.name,
      description: args.description,
      sourceType: args.source.type,
      sourceEntityId: args.source.entity_id || null,
      sourceEntityName: args.source.entity_name || null,
      category: args.category,
      powerLevel: args.power_level,
      mechanics: JSON.stringify(args.mechanics),
      durationType: args.duration.type,
      durationValue: args.duration.value || null,
      roundsRemaining: args.duration.type === "rounds" ? args.duration.value : null,
      triggers: JSON.stringify(args.triggers),
      removalConditions: JSON.stringify(args.removal_conditions),
      stackable: args.stackable ? 1 : 0,
      maxStacks: args.max_stacks ?? 1,
      currentStacks: 1,
      isActive: 1,
      createdAt: now,
      expiresAt
    });
    return this.findById(result.lastInsertRowid);
  }
  /**
   * Find an effect by ID
   */
  findById(id) {
    const stmt = this.db.prepare("SELECT * FROM custom_effects WHERE id = ?");
    const row = stmt.get(id);
    return row ? this.rowToEffect(row) : null;
  }
  /**
   * Find effect by target and name
   */
  findByTargetAndName(targetId, targetType, name) {
    const stmt = this.db.prepare(`
            SELECT * FROM custom_effects
            WHERE target_id = ? AND target_type = ? AND name = ? AND is_active = 1
        `);
    const row = stmt.get(targetId, targetType, name);
    return row ? this.rowToEffect(row) : null;
  }
  /**
   * Get all active effects on a target
   */
  getEffectsOnTarget(targetId, targetType, filters) {
    let query = "SELECT * FROM custom_effects WHERE target_id = ? AND target_type = ?";
    const params = [targetId, targetType];
    if (filters?.category) {
      query += " AND category = ?";
      params.push(filters.category);
    }
    if (filters?.source_type) {
      query += " AND source_type = ?";
      params.push(filters.source_type);
    }
    if (filters?.is_active !== void 0) {
      query += " AND is_active = ?";
      params.push(filters.is_active ? 1 : 0);
    } else {
      query += " AND is_active = 1";
    }
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    return rows.map((row) => this.rowToEffect(row));
  }
  /**
   * Get effects by trigger event
   */
  getEffectsByTrigger(targetId, targetType, event) {
    const effects = this.getEffectsOnTarget(targetId, targetType);
    return effects.filter((effect) => effect.triggers.some((trigger) => trigger.event === event || trigger.event === "always_active"));
  }
  /**
   * Remove an effect by ID
   */
  remove(id) {
    const stmt = this.db.prepare("DELETE FROM custom_effects WHERE id = ?");
    const result = stmt.run(id);
    return result.changes > 0;
  }
  /**
   * Remove effect by target and name
   */
  removeByName(targetId, targetType, name) {
    const stmt = this.db.prepare(`
            DELETE FROM custom_effects
            WHERE target_id = ? AND target_type = ? AND name = ?
        `);
    const result = stmt.run(targetId, targetType, name);
    return result.changes > 0;
  }
  /**
   * Deactivate an effect (keep record but mark inactive)
   */
  deactivate(id) {
    const stmt = this.db.prepare("UPDATE custom_effects SET is_active = 0 WHERE id = ?");
    stmt.run(id);
    return this.findById(id);
  }
  /**
   * Advance round-based durations, deactivating expired effects
   */
  advanceRounds(targetId, targetType, rounds = 1) {
    const effects = this.getEffectsOnTarget(targetId, targetType);
    const advanced = [];
    const expired = [];
    for (const effect of effects) {
      if (effect.duration_type === "rounds" && effect.rounds_remaining !== null) {
        const newRoundsRemaining = effect.rounds_remaining - rounds;
        if (newRoundsRemaining <= 0) {
          this.deactivate(effect.id);
          expired.push({ ...effect, is_active: false, rounds_remaining: 0 });
        } else {
          const stmt = this.db.prepare("UPDATE custom_effects SET rounds_remaining = ? WHERE id = ?");
          stmt.run(newRoundsRemaining, effect.id);
          advanced.push({ ...effect, rounds_remaining: newRoundsRemaining });
        }
      } else {
        advanced.push(effect);
      }
    }
    return { advanced, expired };
  }
  /**
   * Refresh duration on an existing effect
   */
  refreshDuration(id, newDurationValue) {
    const effect = this.findById(id);
    if (!effect) {
      throw new Error(`Effect ${id} not found`);
    }
    if (effect.duration_type === "rounds") {
      const stmt = this.db.prepare("UPDATE custom_effects SET rounds_remaining = ? WHERE id = ?");
      stmt.run(newDurationValue, id);
    } else if (effect.duration_type !== "permanent" && effect.duration_type !== "until_removed") {
      const expireDate = /* @__PURE__ */ new Date();
      const value = newDurationValue || effect.duration_value || 1;
      switch (effect.duration_type) {
        case "minutes":
          expireDate.setMinutes(expireDate.getMinutes() + value);
          break;
        case "hours":
          expireDate.setHours(expireDate.getHours() + value);
          break;
        case "days":
          expireDate.setDate(expireDate.getDate() + value);
          break;
      }
      const stmt = this.db.prepare("UPDATE custom_effects SET expires_at = ?, duration_value = ? WHERE id = ?");
      stmt.run(expireDate.toISOString(), value, id);
    }
    return this.findById(id);
  }
  /**
   * Increment stacks on a stackable effect
   */
  incrementStacks(id) {
    const effect = this.findById(id);
    if (!effect) {
      throw new Error(`Effect ${id} not found`);
    }
    if (!effect.stackable) {
      throw new Error(`Effect ${effect.name} is not stackable`);
    }
    if (effect.current_stacks >= effect.max_stacks) {
      return this.refreshDuration(id, effect.duration_value);
    }
    const stmt = this.db.prepare("UPDATE custom_effects SET current_stacks = current_stacks + 1 WHERE id = ?");
    stmt.run(id);
    return this.findById(id);
  }
  /**
   * Decrement stacks on a stackable effect (removes if reaches 0)
   */
  decrementStacks(id) {
    const effect = this.findById(id);
    if (!effect) {
      return null;
    }
    if (effect.current_stacks <= 1) {
      this.remove(id);
      return null;
    }
    const stmt = this.db.prepare("UPDATE custom_effects SET current_stacks = current_stacks - 1 WHERE id = ?");
    stmt.run(id);
    return this.findById(id);
  }
  /**
   * Check and remove expired time-based effects
   */
  cleanupExpired() {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
            UPDATE custom_effects
            SET is_active = 0
            WHERE is_active = 1 AND expires_at IS NOT NULL AND expires_at < ?
        `);
    const result = stmt.run(now);
    return result.changes;
  }
  /**
   * Get all active effects with a specific mechanic type
   */
  getEffectsByMechanicType(targetId, targetType, mechanicType) {
    const effects = this.getEffectsOnTarget(targetId, targetType);
    return effects.filter((effect) => effect.mechanics.some((m) => m.type === mechanicType));
  }
  /**
   * Calculate total bonus from all effects of a given mechanic type
   */
  calculateTotalBonus(targetId, targetType, mechanicType, condition) {
    const effects = this.getEffectsByMechanicType(targetId, targetType, mechanicType);
    let total = 0;
    for (const effect of effects) {
      for (const mechanic of effect.mechanics) {
        if (mechanic.type === mechanicType) {
          if (condition && mechanic.condition && !mechanic.condition.includes(condition)) {
            continue;
          }
          if (typeof mechanic.value === "number") {
            total += mechanic.value * effect.current_stacks;
          }
        }
      }
    }
    return total;
  }
  /**
   * Convert database row to CustomEffect object
   */
  rowToEffect(row) {
    return CustomEffectSchema.parse({
      id: row.id,
      target_id: row.target_id,
      target_type: row.target_type,
      name: row.name,
      description: row.description,
      source_type: row.source_type,
      source_entity_id: row.source_entity_id,
      source_entity_name: row.source_entity_name,
      category: row.category,
      power_level: row.power_level,
      mechanics: JSON.parse(row.mechanics),
      duration_type: row.duration_type,
      duration_value: row.duration_value,
      rounds_remaining: row.rounds_remaining,
      triggers: JSON.parse(row.triggers),
      removal_conditions: JSON.parse(row.removal_conditions),
      stackable: row.stackable === 1,
      max_stacks: row.max_stacks,
      current_stacks: row.current_stacks,
      is_active: row.is_active === 1,
      created_at: row.created_at,
      expires_at: row.expires_at
    });
  }
};

// dist/server/improvisation-tools.js
init_character_repo();
function ensureDb10() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const effectsRepo = new CustomEffectsRepository(db);
  const charRepo = new CharacterRepository(db);
  return { db, effectsRepo, charRepo };
}
function rollDice3(notation, rng2) {
  const match = notation.match(/^(\d+)d(\d+)([+-]\d+)?$/i);
  if (!match) {
    throw new Error(`Invalid dice notation: ${notation}`);
  }
  const count = parseInt(match[1], 10);
  const sides = parseInt(match[2], 10);
  const modifier = match[3] ? parseInt(match[3], 10) : 0;
  const rolls = [];
  const random = rng2 || Math.random;
  for (let i = 0; i < count; i++) {
    rolls.push(Math.floor(random() * sides) + 1);
  }
  const sum = rolls.reduce((a, b) => a + b, 0);
  return {
    total: Math.max(0, sum + modifier),
    // Minimum 0
    rolls,
    notation
  };
}
function rollD202(advantage, disadvantage, rng2) {
  const random = rng2 || Math.random;
  const roll1 = Math.floor(random() * 20) + 1;
  if (!advantage && !disadvantage) {
    return { roll: roll1, rolls: [roll1] };
  }
  const roll2 = Math.floor(random() * 20) + 1;
  if (advantage && !disadvantage) {
    return { roll: Math.max(roll1, roll2), rolls: [roll1, roll2] };
  }
  if (disadvantage && !advantage) {
    return { roll: Math.min(roll1, roll2), rolls: [roll1, roll2] };
  }
  return { roll: roll1, rolls: [roll1] };
}
function getSkillModifier(stats, skill) {
  const ability = SKILL_TO_ABILITY[skill];
  const abilityScore = stats[ability.substring(0, 3)] ?? stats[ability] ?? 10;
  return Math.floor((abilityScore - 10) / 2);
}
function getAbilityModifier4(score) {
  return Math.floor((score - 10) / 2);
}
var ImprovisationTools = {
  // ========================================================================
  // RULE OF COOL - IMPROVISED STUNTS
  // ========================================================================
  RESOLVE_IMPROVISED_STUNT: {
    name: "resolve_improvised_stunt",
    description: `Resolve a creative player action using the Rule of Cool.

When a player says "I want to kick the brazier of coals into the zombie horde" or
"I swing from the chandelier and kick both guards," this tool handles it mechanically.

DC Guidelines:
- 5: Trivial (kick open unlocked door)
- 10: Easy (swing from rope)
- 15: Medium (kick stuck mine cart)
- 20: Hard (catch thrown weapon)
- 25: Very Hard (run across crumbling bridge)
- 30: Nearly Impossible (catch arrow mid-flight)

Damage Guidelines:
- 1d4: Nuisance (thrown mug)
- 1d6: Light (chair smash)
- 2d6: Moderate (barrel roll)
- 3d6: Heavy (mine cart)
- 4d6: Severe (chandelier drop)
- 6d6: Massive (collapsing pillar)
- 8d6+: Catastrophic (building collapse)

Example:
{
  "encounter_id": 1,
  "actor_id": 1,
  "actor_type": "character",
  "target_ids": [5, 6],
  "target_types": ["npc", "npc"],
  "narrative_intent": "I kick the brazier of hot coals into the zombie horde",
  "skill_check": { "skill": "athletics", "dc": 15 },
  "action_cost": "action",
  "consequences": {
    "success_damage": "2d6",
    "damage_type": "fire",
    "area_of_effect": { "shape": "cone", "size": 15 }
  }
}`,
    inputSchema: ResolveImprovisedStuntArgsSchema
  },
  // ========================================================================
  // CUSTOM EFFECTS SYSTEM
  // ========================================================================
  APPLY_CUSTOM_EFFECT: {
    name: "apply_custom_effect",
    description: `Apply a custom effect (divine boon, curse, transformation) to a target.

Power Level Guidelines:
1: Hours duration, +1/-1 bonus, minor condition (Lucky charm)
2: Days duration, +2/-2 bonus, advantage/disadvantage (Battle blessing)
3: Weeks duration, +3/-3 bonus, resistance/vulnerability (Champion's mantle)
4: Months duration, +5/-5 bonus, immunity, extra actions (Avatar's grace)
5: Permanent, reality-warping effects (Demigod status)

Mechanic Types:
- attack_bonus, damage_bonus, ac_bonus, saving_throw_bonus, skill_bonus
- advantage_on, disadvantage_on
- damage_resistance, damage_vulnerability, damage_immunity
- damage_over_time, healing_over_time
- extra_action, prevent_action, movement_modifier
- sense_granted, sense_removed, speak_language, cannot_speak
- custom_trigger

Example:
{
  "target_id": "char-123",
  "target_type": "character",
  "name": "Blessing of the Sun God",
  "description": "Golden light surrounds you, burning undead on contact",
  "source": { "type": "divine", "entity_name": "Pelor" },
  "category": "boon",
  "power_level": 3,
  "mechanics": [
    { "type": "damage_bonus", "value": 2, "condition": "against undead" },
    { "type": "damage_resistance", "value": "radiant" }
  ],
  "duration": { "type": "days", "value": 7 },
  "triggers": [{ "event": "on_attack", "condition": "against undead" }],
  "removal_conditions": [{ "type": "dispelled", "difficulty_class": 15 }]
}`,
    inputSchema: ApplyCustomEffectArgsSchema
  },
  GET_CUSTOM_EFFECTS: {
    name: "get_custom_effects",
    description: "Get all active effects on a target, with optional filtering.",
    inputSchema: external_exports.object({
      target_id: external_exports.string(),
      target_type: external_exports.enum(["character", "npc"]),
      category: external_exports.enum(["boon", "curse", "neutral", "transformative"]).optional(),
      source_type: external_exports.enum(["divine", "arcane", "natural", "cursed", "psionic", "unknown"]).optional(),
      include_inactive: external_exports.boolean().optional().default(false)
    })
  },
  REMOVE_CUSTOM_EFFECT: {
    name: "remove_custom_effect",
    description: "Remove a custom effect by ID or by name.",
    inputSchema: external_exports.object({
      effect_id: external_exports.number().int().optional(),
      target_id: external_exports.string().optional(),
      target_type: external_exports.enum(["character", "npc"]).optional(),
      effect_name: external_exports.string().optional()
    })
  },
  PROCESS_EFFECT_TRIGGERS: {
    name: "process_effect_triggers",
    description: "Fire effect triggers at specific events (start_of_turn, on_attack, on_damage_taken, etc). Returns activated effects.",
    inputSchema: external_exports.object({
      target_id: external_exports.string(),
      target_type: external_exports.enum(["character", "npc"]),
      event: external_exports.enum([
        "always_active",
        "start_of_turn",
        "end_of_turn",
        "on_attack",
        "on_hit",
        "on_miss",
        "on_damage_taken",
        "on_heal",
        "on_rest",
        "on_spell_cast",
        "on_death"
      ]),
      context: external_exports.record(external_exports.any()).optional().describe("Additional context for condition checking")
    })
  },
  ADVANCE_EFFECT_DURATIONS: {
    name: "advance_effect_durations",
    description: "Advance round-based effect durations. Call at end of each round.",
    inputSchema: external_exports.object({
      target_id: external_exports.string(),
      target_type: external_exports.enum(["character", "npc"]),
      rounds: external_exports.number().int().min(1).default(1)
    })
  },
  // ========================================================================
  // ARCANE SYNTHESIS - DYNAMIC SPELL CREATION
  // ========================================================================
  ATTEMPT_ARCANE_SYNTHESIS: {
    name: "attempt_arcane_synthesis",
    description: `Attempt to create a spell on the fly through Arcane Synthesis.

DC Calculation:
Base DC = 10 + (Spell Level \xD7 2)

Modifiers:
+2 if in combat (encounter_id provided)
+3 if novel effect (no similar spell known)
-1 per 100gp of material component (max -5)
-2 if related spell known
-2 if school specialization
-3 if near ley line/magical nexus
-2 if celestial event (blood moon, eclipse)
+2 if desperation/urgency

Outcomes:
- Mastery (nat 20 OR beat DC by 10+): Spell works AND permanently learned
- Success (beat DC): Spell works this time only
- Fizzle (within 5 of DC): Slot consumed, no effect, minor mishap
- Backfire (fail by 5-10): Spell damages caster (level \xD7 d6)
- Catastrophic (nat 1 OR fail by 10+): WILD SURGE!

Spell Level Damage Guidelines:
Level 1: Single 3d6, AoE 2d6 (10ft)
Level 2: Single 4d6, AoE 3d6 (15ft)
Level 3: Single 8d6, AoE 6d6 (20ft)
Level 4: Single 10d6, AoE 8d6 (30ft)
Level 5+: Progressively more powerful

Example:
{
  "caster_id": "wizard-1",
  "caster_type": "character",
  "narrative_intent": "I weave shadows together to blind the orc chieftain",
  "proposed_name": "Shadow Blind",
  "estimated_level": 2,
  "school": "illusion",
  "effect_specification": {
    "type": "status",
    "condition": "blinded",
    "condition_duration": "1 minute"
  },
  "targeting": { "type": "single", "range": 60 },
  "saving_throw": { "ability": "wisdom", "effect_on_save": "negates" },
  "components": { "verbal": true, "somatic": true },
  "concentration": true,
  "duration": "1 minute"
}`,
    inputSchema: AttemptArcaneSynthesisArgsSchema
  },
  GET_SYNTHESIZED_SPELLS: {
    name: "get_synthesized_spells",
    description: "Get all spells a character has permanently learned through Arcane Synthesis.",
    inputSchema: external_exports.object({
      character_id: external_exports.string(),
      school: external_exports.enum([
        "abjuration",
        "conjuration",
        "divination",
        "enchantment",
        "evocation",
        "illusion",
        "necromancy",
        "transmutation"
      ]).optional()
    })
  }
};
async function handleResolveImprovisedStunt(args, _ctx) {
  const parsed = ImprovisationTools.RESOLVE_IMPROVISED_STUNT.inputSchema.parse(args);
  const { charRepo } = ensureDb10();
  const seed = `stunt-${parsed.encounter_id}-${parsed.actor_id}-${Date.now()}`;
  const rng2 = (0, import_seedrandom9.default)(seed);
  let skillModifier = 0;
  try {
    const actor = charRepo.findById(String(parsed.actor_id));
    if (actor?.stats) {
      skillModifier = getSkillModifier(actor.stats, parsed.skill_check.skill);
    }
  } catch {
  }
  const d20Result = rollD202(parsed.skill_check.advantage, parsed.skill_check.disadvantage, rng2);
  const total = d20Result.roll + skillModifier;
  const isNat20 = d20Result.roll === 20;
  const isNat1 = d20Result.roll === 1;
  const beatDC = total >= parsed.skill_check.dc;
  const criticalSuccess = isNat20 || beatDC && total >= parsed.skill_check.dc + 10;
  const criticalFailure = isNat1 || !beatDC && total <= parsed.skill_check.dc - 10;
  const success = isNat20 || beatDC && !isNat1;
  const result = {
    success,
    roll: d20Result.roll,
    modifier: skillModifier,
    total,
    dc: parsed.skill_check.dc,
    critical_success: criticalSuccess,
    critical_failure: criticalFailure,
    narrative: "",
    audit_log: {
      seed,
      d20_rolls: d20Result.rolls,
      skill: parsed.skill_check.skill,
      advantage: parsed.skill_check.advantage,
      disadvantage: parsed.skill_check.disadvantage
    }
  };
  if (success && parsed.consequences.success_damage) {
    const damageRoll = rollDice3(parsed.consequences.success_damage, rng2);
    let baseDamage = damageRoll.total;
    if (criticalSuccess) {
      baseDamage *= 2;
    }
    result.damage_dealt = baseDamage;
    result.targets_affected = [];
    const targetNames = /* @__PURE__ */ new Map();
    if (parsed.target_ids) {
      for (let i = 0; i < parsed.target_ids.length; i++) {
        const targetId = parsed.target_ids[i];
        try {
          const char = charRepo.findById(String(targetId));
          targetNames.set(targetId, char?.name || `Target ${i + 1}`);
        } catch {
          targetNames.set(targetId, `Target ${i + 1}`);
        }
      }
    }
    if (parsed.target_ids && parsed.target_types) {
      for (let i = 0; i < parsed.target_ids.length; i++) {
        let targetDamage = baseDamage;
        let saved = false;
        if (parsed.consequences.saving_throw) {
          const saveRoll = Math.floor(rng2() * 20) + 1;
          saved = saveRoll >= parsed.consequences.saving_throw.dc;
          if (saved && parsed.consequences.saving_throw.half_damage_on_save) {
            targetDamage = Math.floor(targetDamage / 2);
          } else if (saved) {
            targetDamage = 0;
          }
        }
        result.targets_affected.push({
          id: parsed.target_ids[i],
          name: targetNames.get(parsed.target_ids[i]) || `Target ${i + 1}`,
          damage_taken: targetDamage,
          saved,
          condition_applied: !saved && parsed.consequences.apply_condition ? parsed.consequences.apply_condition : void 0
        });
      }
    }
    result.narrative = parsed.narrative_on_success || `The stunt succeeds spectacularly! ${result.damage_dealt} ${parsed.consequences.damage_type || ""} damage dealt.`;
  } else if (!success) {
    if (criticalFailure && parsed.consequences.failure_damage) {
      const selfDamage = rollDice3(parsed.consequences.failure_damage, rng2);
      result.self_damage = selfDamage.total;
      result.narrative = parsed.narrative_on_failure || `Critical failure! The stunt backfires, dealing ${result.self_damage} damage to the actor.`;
    } else {
      result.narrative = parsed.narrative_on_failure || `The stunt fails. The attempt doesn't produce the intended effect.`;
    }
  }
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F3AD} IMPROVISED STUNT - RULE OF COOL
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `\u{1F4DC} Intent: "${parsed.narrative_intent}"

`;
  output += `\u{1F3B2} ${parsed.skill_check.skill.toUpperCase()} Check (DC ${parsed.skill_check.dc})
`;
  output += `   Roll: ${d20Result.roll}${d20Result.rolls.length > 1 ? ` (${d20Result.rolls.join(", ")})` : ""}`;
  output += ` + ${skillModifier} = ${total}
`;
  if (isNat20)
    output += `   \u2B50 NATURAL 20!
`;
  if (isNat1)
    output += `   \u{1F4A5} NATURAL 1!
`;
  output += `
`;
  if (result.critical_success) {
    output += `\u2728 CRITICAL SUCCESS!
`;
  } else if (result.success) {
    output += `\u2713 SUCCESS
`;
  } else if (result.critical_failure) {
    output += `\u{1F4A5} CRITICAL FAILURE!
`;
  } else {
    output += `\u2717 FAILURE
`;
  }
  output += `
${result.narrative}
`;
  if (result.targets_affected && result.targets_affected.length > 0) {
    output += `
\u{1F3AF} Targets:
`;
    for (const target of result.targets_affected) {
      output += `   \u2022 ${target.name}: ${target.damage_taken} damage`;
      if (target.saved)
        output += ` (saved)`;
      if (target.condition_applied)
        output += ` [${target.condition_applied}]`;
      output += `
`;
    }
  }
  if (result.self_damage) {
    output += `
\u26A0\uFE0F Self-damage: ${result.self_damage}
`;
  }
  output += `
<!-- STUNT_AUDIT
${JSON.stringify(result.audit_log, null, 2)}
STUNT_AUDIT -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleApplyCustomEffect(args, _ctx) {
  const parsed = ImprovisationTools.APPLY_CUSTOM_EFFECT.inputSchema.parse(args);
  const { effectsRepo } = ensureDb10();
  const effect = effectsRepo.apply(parsed);
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u2728 CUSTOM EFFECT APPLIED
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  const categoryIcon = {
    boon: "\u{1F31F}",
    curse: "\u{1F480}",
    neutral: "\u2696\uFE0F",
    transformative: "\u{1F52E}"
  }[effect.category];
  output += `${categoryIcon} ${effect.name}
`;
  output += `   ${effect.description || "No description"}

`;
  output += `\u{1F4CA} Details:
`;
  output += `   Source: ${effect.source_type}${effect.source_entity_name ? ` (${effect.source_entity_name})` : ""}
`;
  output += `   Power Level: ${"\u2605".repeat(effect.power_level)}${"\u2606".repeat(5 - effect.power_level)}
`;
  output += `   Duration: ${effect.duration_type}${effect.duration_value ? ` (${effect.duration_value})` : ""}
`;
  if (effect.rounds_remaining !== null) {
    output += `   Rounds Remaining: ${effect.rounds_remaining}
`;
  }
  if (effect.stackable) {
    output += `   Stacks: ${effect.current_stacks}/${effect.max_stacks}
`;
  }
  output += `
\u{1F4CB} Mechanics:
`;
  for (const mechanic of effect.mechanics) {
    output += `   \u2022 ${mechanic.type}: ${mechanic.value}${mechanic.condition ? ` (${mechanic.condition})` : ""}
`;
  }
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleGetCustomEffects(args, _ctx) {
  const parsed = ImprovisationTools.GET_CUSTOM_EFFECTS.inputSchema.parse(args);
  const { effectsRepo } = ensureDb10();
  const effects = effectsRepo.getEffectsOnTarget(parsed.target_id, parsed.target_type, {
    category: parsed.category,
    source_type: parsed.source_type,
    is_active: parsed.include_inactive ? void 0 : true
  });
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F4CB} EFFECTS ON ${parsed.target_id}
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  if (effects.length === 0) {
    output += `No active effects found.
`;
  } else {
    const boons = effects.filter((e) => e.category === "boon");
    const curses = effects.filter((e) => e.category === "curse");
    const others = effects.filter((e) => e.category !== "boon" && e.category !== "curse");
    if (boons.length > 0) {
      output += `\u{1F31F} BOONS:
`;
      for (const effect of boons) {
        output += formatEffectSummary(effect);
      }
      output += `
`;
    }
    if (curses.length > 0) {
      output += `\u{1F480} CURSES:
`;
      for (const effect of curses) {
        output += formatEffectSummary(effect);
      }
      output += `
`;
    }
    if (others.length > 0) {
      output += `\u2696\uFE0F OTHER EFFECTS:
`;
      for (const effect of others) {
        output += formatEffectSummary(effect);
      }
    }
  }
  output += `
<!-- EFFECT_DATA
${JSON.stringify(effects, null, 2)}
EFFECT_DATA -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
function formatEffectSummary(effect) {
  let str = `   \u2022 ${effect.name}`;
  if (effect.power_level) {
    str += ` [${"\u2605".repeat(effect.power_level)}]`;
  }
  if (effect.rounds_remaining !== null) {
    str += ` (${effect.rounds_remaining} rounds)`;
  } else if (effect.duration_type !== "permanent" && effect.duration_type !== "until_removed") {
    str += ` (${effect.duration_type})`;
  }
  if (!effect.is_active) {
    str += ` [INACTIVE]`;
  }
  str += `
`;
  return str;
}
async function handleRemoveCustomEffect(args, _ctx) {
  const parsed = ImprovisationTools.REMOVE_CUSTOM_EFFECT.inputSchema.parse(args);
  if (parsed.effect_id === void 0 && !(parsed.target_id && parsed.target_type && parsed.effect_name)) {
    throw new Error("Must provide either effect_id or (target_id, target_type, effect_name)");
  }
  const { effectsRepo } = ensureDb10();
  let removed = false;
  let effectName = "";
  if (parsed.effect_id !== void 0) {
    const effect = effectsRepo.findById(parsed.effect_id);
    effectName = effect?.name || `ID ${parsed.effect_id}`;
    removed = effectsRepo.remove(parsed.effect_id);
  } else if (parsed.target_id && parsed.target_type && parsed.effect_name) {
    effectName = parsed.effect_name;
    removed = effectsRepo.removeByName(parsed.target_id, parsed.target_type, parsed.effect_name);
  }
  let output = `
`;
  if (removed) {
    output += `\u2713 Effect "${effectName}" has been removed.
`;
  } else {
    output += `\u26A0\uFE0F Effect "${effectName}" not found or already removed.
`;
  }
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleProcessEffectTriggers(args, _ctx) {
  const parsed = ImprovisationTools.PROCESS_EFFECT_TRIGGERS.inputSchema.parse(args);
  const { effectsRepo } = ensureDb10();
  const triggeredEffects = effectsRepo.getEffectsByTrigger(parsed.target_id, parsed.target_type, parsed.event);
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u26A1 EFFECT TRIGGERS: ${parsed.event.toUpperCase()}
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  if (triggeredEffects.length === 0) {
    output += `No effects triggered by ${parsed.event}.
`;
  } else {
    output += `${triggeredEffects.length} effect(s) triggered:

`;
    for (const effect of triggeredEffects) {
      output += `\u{1F52E} ${effect.name}
`;
      for (const mechanic of effect.mechanics) {
        output += `   \u2192 ${mechanic.type}: ${mechanic.value}`;
        if (mechanic.condition) {
          output += ` (${mechanic.condition})`;
        }
        output += `
`;
      }
      output += `
`;
    }
  }
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleAdvanceEffectDurations(args, _ctx) {
  const parsed = ImprovisationTools.ADVANCE_EFFECT_DURATIONS.inputSchema.parse(args);
  const { effectsRepo } = ensureDb10();
  const { advanced, expired } = effectsRepo.advanceRounds(parsed.target_id, parsed.target_type, parsed.rounds);
  const cleanedUp = effectsRepo.cleanupExpired();
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u23F1\uFE0F EFFECT DURATIONS ADVANCED
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `Advanced ${parsed.rounds} round(s).

`;
  if (expired.length > 0) {
    output += `\u{1F4A8} EXPIRED EFFECTS:
`;
    for (const effect of expired) {
      output += `   \u2022 ${effect.name}
`;
    }
    output += `
`;
  }
  if (advanced.length > 0) {
    output += `\u{1F4CB} REMAINING EFFECTS:
`;
    for (const effect of advanced) {
      if (effect.rounds_remaining !== null) {
        output += `   \u2022 ${effect.name}: ${effect.rounds_remaining} rounds remaining
`;
      } else {
        output += `   \u2022 ${effect.name}: ${effect.duration_type}
`;
      }
    }
  }
  if (cleanedUp > 0) {
    output += `
(Also cleaned up ${cleanedUp} time-expired effect(s))
`;
  }
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleAttemptArcaneSynthesis(args, _ctx) {
  const parsed = ImprovisationTools.ATTEMPT_ARCANE_SYNTHESIS.inputSchema.parse(args);
  const { db, charRepo } = ensureDb10();
  const seed = `synthesis-${parsed.caster_id}-${Date.now()}`;
  const rng2 = (0, import_seedrandom9.default)(seed);
  let spellcastingModifier = 0;
  let casterName = "Caster";
  let knownSpells = [];
  try {
    const caster = charRepo.findById(parsed.caster_id);
    if (caster) {
      casterName = caster.name;
      knownSpells = caster.knownSpells || [];
      const stats = caster.stats;
      const intScore = stats.int ?? stats.intelligence ?? 10;
      spellcastingModifier = getAbilityModifier4(intScore);
      const profBonus = Math.floor((caster.level || 1) / 4) + 2;
      spellcastingModifier += profBonus;
    }
  } catch {
  }
  let dc = 10 + parsed.estimated_level * 2;
  const dcBreakdown = {
    base: 10,
    spell_level: parsed.estimated_level * 2
  };
  if (parsed.encounter_id !== void 0) {
    dc += 2;
    dcBreakdown.in_combat = 2;
  }
  const hasRelatedSpell = knownSpells.some((spell) => spell.toLowerCase().includes(parsed.school) || spell.toLowerCase().includes(parsed.effect_specification.type));
  if (!hasRelatedSpell) {
    dc += 3;
    dcBreakdown.novel_effect = 3;
  } else {
    dc -= 2;
    dcBreakdown.related_spell = -2;
  }
  if (parsed.components.material?.value) {
    const reduction = Math.min(5, Math.floor(parsed.components.material.value / 100));
    dc -= reduction;
    dcBreakdown.material_reduction = -reduction;
  }
  if (parsed.circumstance_modifiers) {
    for (const modifier of parsed.circumstance_modifiers) {
      const lowerMod = modifier.toLowerCase();
      if (lowerMod.includes("ley line") || lowerMod.includes("magical nexus")) {
        dc -= 3;
        dcBreakdown.ley_line = -3;
      }
      if (lowerMod.includes("blood moon") || lowerMod.includes("eclipse") || lowerMod.includes("celestial")) {
        dc -= 2;
        dcBreakdown.celestial_event = -2;
      }
      if (lowerMod.includes("desperation") || lowerMod.includes("urgency")) {
        dc += 2;
        dcBreakdown.desperation = 2;
      }
    }
  }
  const d20Roll = Math.floor(rng2() * 20) + 1;
  const total = d20Roll + spellcastingModifier;
  const isNat20 = d20Roll === 20;
  const isNat1 = d20Roll === 1;
  const beatDC = total >= dc;
  const margin = total - dc;
  let outcome;
  if (isNat20 || margin >= 10) {
    outcome = "mastery";
  } else if (beatDC) {
    outcome = "success";
  } else if (margin >= -5) {
    outcome = "fizzle";
  } else if (isNat1 || margin <= -10) {
    outcome = "catastrophic";
  } else {
    outcome = "backfire";
  }
  const result = {
    outcome,
    roll: d20Roll,
    modifier: spellcastingModifier,
    total,
    dc,
    dc_breakdown: dcBreakdown,
    spell_worked: outcome === "mastery" || outcome === "success",
    spell_mastered: outcome === "mastery",
    spell_slot_consumed: outcome !== "mastery",
    // Mastery doesn't consume slot
    narrative: "",
    audit_log: { seed, caster: casterName, dc_calculation: dcBreakdown }
  };
  const spellName = parsed.proposed_name || `${casterName}'s ${parsed.school} ${parsed.effect_specification.type}`;
  switch (outcome) {
    case "mastery": {
      result.narrative = `MASTERY! ${casterName} has not only cast the spell successfully, but has permanently learned "${spellName}"!`;
      const stmt = db.prepare(`
                INSERT INTO synthesized_spells (
                    character_id, name, level, school, effect_type, effect_dice, damage_type,
                    targeting_type, targeting_range, targeting_area_size, targeting_max_targets,
                    saving_throw_ability, saving_throw_effect,
                    components_verbal, components_somatic, components_material,
                    concentration, duration, synthesis_dc, created_at, mastered_at, times_cast
                ) VALUES (
                    @characterId, @name, @level, @school, @effectType, @effectDice, @damageType,
                    @targetingType, @targetingRange, @targetingAreaSize, @targetingMaxTargets,
                    @savingThrowAbility, @savingThrowEffect,
                    @componentsVerbal, @componentsSomatic, @componentsMaterial,
                    @concentration, @duration, @synthesisDc, @createdAt, @masteredAt, @timesCast
                )
            `);
      try {
        stmt.run({
          characterId: parsed.caster_id,
          name: spellName,
          level: parsed.estimated_level,
          school: parsed.school,
          effectType: parsed.effect_specification.type,
          effectDice: parsed.effect_specification.dice || null,
          damageType: parsed.effect_specification.damage_type || null,
          targetingType: parsed.targeting.type,
          targetingRange: parsed.targeting.range,
          targetingAreaSize: parsed.targeting.area_size || null,
          targetingMaxTargets: parsed.targeting.max_targets || null,
          savingThrowAbility: parsed.saving_throw?.ability || null,
          savingThrowEffect: parsed.saving_throw?.effect_on_save || null,
          componentsVerbal: parsed.components.verbal ? 1 : 0,
          componentsSomatic: parsed.components.somatic ? 1 : 0,
          componentsMaterial: parsed.components.material ? JSON.stringify(parsed.components.material) : null,
          concentration: parsed.concentration ? 1 : 0,
          duration: parsed.duration,
          synthesisDc: dc,
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          masteredAt: (/* @__PURE__ */ new Date()).toISOString(),
          timesCast: 1
        });
      } catch {
      }
      if (parsed.effect_specification.dice) {
        const effectRoll = rollDice3(parsed.effect_specification.dice, rng2);
        if (parsed.effect_specification.type === "damage") {
          result.damage_dealt = effectRoll.total;
        } else if (parsed.effect_specification.type === "healing") {
          result.healing_done = effectRoll.total;
        }
      }
      break;
    }
    case "success": {
      result.narrative = `Success! ${casterName} successfully channels the magical energy. "${spellName}" takes effect!`;
      if (parsed.effect_specification.dice) {
        const effectRoll = rollDice3(parsed.effect_specification.dice, rng2);
        if (parsed.effect_specification.type === "damage") {
          result.damage_dealt = effectRoll.total;
        } else if (parsed.effect_specification.type === "healing") {
          result.healing_done = effectRoll.total;
        }
      }
      break;
    }
    case "fizzle": {
      result.narrative = `Fizzle. The magic slips away as ${casterName} attempts to shape it. The spell slot is consumed, but nothing happens.`;
      break;
    }
    case "backfire": {
      const backfireDamage = rollDice3(`${parsed.estimated_level}d6`, rng2);
      result.backfire_damage = backfireDamage.total;
      result.narrative = `BACKFIRE! The spell turns against ${casterName}, dealing ${result.backfire_damage} force damage!`;
      break;
    }
    case "catastrophic": {
      const surgeRoll = Math.floor(rng2() * 20) + 1;
      const wildSurge = WILD_SURGE_TABLE.find((ws) => ws.roll === surgeRoll) || WILD_SURGE_TABLE[0];
      result.wild_surge = wildSurge;
      result.narrative = `CATASTROPHIC FAILURE! WILD SURGE!

${wildSurge.name}: ${wildSurge.effect}`;
      break;
    }
  }
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F52E} ARCANE SYNTHESIS
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  output += `\u{1F4DC} Intent: "${parsed.narrative_intent}"
`;
  output += `\u{1F4DA} School: ${parsed.school.charAt(0).toUpperCase() + parsed.school.slice(1)}
`;
  output += `\u26A1 Level: ${parsed.estimated_level}

`;
  output += `\u{1F3B2} Synthesis Check (DC ${dc})
`;
  output += `   Roll: ${d20Roll} + ${spellcastingModifier} = ${total}
`;
  if (isNat20)
    output += `   \u2B50 NATURAL 20!
`;
  if (isNat1)
    output += `   \u{1F4A5} NATURAL 1!
`;
  output += `
\u{1F4CA} DC Breakdown:
`;
  output += `   Base: ${dcBreakdown.base}
`;
  output += `   Spell Level (\xD72): +${dcBreakdown.spell_level}
`;
  if (dcBreakdown.in_combat)
    output += `   In Combat: +${dcBreakdown.in_combat}
`;
  if (dcBreakdown.novel_effect)
    output += `   Novel Effect: +${dcBreakdown.novel_effect}
`;
  if (dcBreakdown.related_spell)
    output += `   Related Spell Known: ${dcBreakdown.related_spell}
`;
  if (dcBreakdown.material_reduction)
    output += `   Material Components: ${dcBreakdown.material_reduction}
`;
  if (dcBreakdown.ley_line)
    output += `   Ley Line: ${dcBreakdown.ley_line}
`;
  if (dcBreakdown.celestial_event)
    output += `   Celestial Event: ${dcBreakdown.celestial_event}
`;
  if (dcBreakdown.desperation)
    output += `   Desperation: +${dcBreakdown.desperation}
`;
  output += `
`;
  const outcomeEmoji = {
    mastery: "\u2B50",
    success: "\u2713",
    fizzle: "\u{1F4A8}",
    backfire: "\u{1F4A5}",
    catastrophic: "\u{1F300}"
  }[outcome];
  output += `${outcomeEmoji} OUTCOME: ${outcome.toUpperCase()}

`;
  output += `${result.narrative}
`;
  if (result.damage_dealt) {
    output += `
\u{1F4A5} Damage: ${result.damage_dealt}${parsed.effect_specification.damage_type ? ` ${parsed.effect_specification.damage_type}` : ""}
`;
  }
  if (result.healing_done) {
    output += `
\u{1F49A} Healing: ${result.healing_done}
`;
  }
  if (result.backfire_damage) {
    output += `
\u26A0\uFE0F Backfire Damage to Caster: ${result.backfire_damage}
`;
  }
  if (result.wild_surge) {
    output += `
\u{1F300} WILD SURGE (Roll: ${result.wild_surge.roll})
`;
    output += `   ${result.wild_surge.name}
`;
    output += `   ${result.wild_surge.effect}
`;
  }
  if (result.spell_mastered) {
    output += `
\u{1F4D6} "${spellName}" has been added to your spellbook!
`;
  }
  if (!result.spell_slot_consumed) {
    output += `
\u2728 Spell slot preserved (mastery bonus)!
`;
  }
  output += `
<!-- SYNTHESIS_AUDIT
${JSON.stringify(result.audit_log, null, 2)}
SYNTHESIS_AUDIT -->`;
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}
async function handleGetSynthesizedSpells(args, _ctx) {
  const parsed = ImprovisationTools.GET_SYNTHESIZED_SPELLS.inputSchema.parse(args);
  const { db } = ensureDb10();
  let query = "SELECT * FROM synthesized_spells WHERE character_id = ?";
  const params = [parsed.character_id];
  if (parsed.school) {
    query += " AND school = ?";
    params.push(parsed.school);
  }
  query += " ORDER BY level, name";
  const stmt = db.prepare(query);
  const rows = stmt.all(...params);
  let output = `
\u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510
`;
  output += `\u2502 \u{1F4D6} SYNTHESIZED SPELLBOOK
`;
  output += `\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518

`;
  if (rows.length === 0) {
    output += `No synthesized spells found.
`;
    output += `
Master spells through Arcane Synthesis to add them here!
`;
  } else {
    const byLevel = {};
    for (const row of rows) {
      if (!byLevel[row.level])
        byLevel[row.level] = [];
      byLevel[row.level].push(row);
    }
    for (const level of Object.keys(byLevel).map(Number).sort()) {
      output += `\u2550\u2550\u2550 LEVEL ${level} \u2550\u2550\u2550
`;
      for (const spell of byLevel[level]) {
        output += `
\u{1F4DC} ${spell.name}
`;
        output += `   School: ${spell.school}
`;
        output += `   Effect: ${spell.effect_type}`;
        if (spell.effect_dice)
          output += ` (${spell.effect_dice})`;
        if (spell.damage_type)
          output += ` ${spell.damage_type}`;
        output += `
`;
        output += `   Range: ${spell.targeting_range}ft (${spell.targeting_type})
`;
        if (spell.concentration)
          output += `   \u26A1 Concentration
`;
        output += `   Duration: ${spell.duration}
`;
        output += `   Times Cast: ${spell.times_cast}
`;
      }
      output += `
`;
    }
  }
  return {
    content: [{
      type: "text",
      text: output
    }]
  };
}

// dist/server/spatial-tools.js
init_zod();
init_character_repo();
var SpatialTools = {
  LOOK_AT_SURROUNDINGS: {
    name: "look_at_surroundings",
    description: "Get filtered room description accounting for darkness, fog, and perception. Returns exits and entities.",
    inputSchema: external_exports.object({
      observerId: external_exports.string().uuid().describe("ID of the character observing their surroundings")
    })
  },
  GENERATE_ROOM_NODE: {
    name: "generate_room_node",
    description: "Create a persistent room with immutable description. Optionally links to previous room.",
    inputSchema: external_exports.object({
      name: external_exports.string().min(1).max(100).describe(`Name of the room (e.g., "The Dragon's Rest Tavern")`),
      baseDescription: external_exports.string().min(10).max(2e3).describe("Detailed description of the room (immutable once created)"),
      biomeContext: external_exports.enum(["forest", "mountain", "urban", "dungeon", "coastal", "cavern", "divine", "arcane"]).describe("Biome/environment type"),
      atmospherics: external_exports.array(external_exports.enum(["DARKNESS", "FOG", "ANTIMAGIC", "SILENCE", "BRIGHT", "MAGICAL"])).default([]).describe("Environmental effects in this room"),
      previousNodeId: external_exports.string().uuid().optional().describe("If specified, creates an exit FROM this room TO the new room"),
      direction: external_exports.enum(["north", "south", "east", "west", "up", "down", "northeast", "northwest", "southeast", "southwest"]).optional().describe("Direction of the exit from previousNodeId to the new room")
    })
  },
  GET_ROOM_EXITS: {
    name: "get_room_exits",
    description: "Get all exits from a room. Use look_at_surroundings for perception-filtered exits.",
    inputSchema: external_exports.object({
      roomId: external_exports.string().uuid().describe("ID of the room to get exits for")
    })
  },
  MOVE_CHARACTER_TO_ROOM: {
    name: "move_character_to_room",
    description: "Move a character to a room and increment its visit count.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().uuid().describe("ID of the character to move"),
      roomId: external_exports.string().uuid().describe("ID of the destination room")
    })
  }
};
function getSpatialRepo() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return new SpatialRepository(db);
}
function getCharacterRepo() {
  const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
  return new CharacterRepository(db);
}
function rollD203() {
  return Math.floor(Math.random() * 20) + 1;
}
function getModifier2(abilityScore) {
  return Math.floor((abilityScore - 10) / 2);
}
async function handleLookAtSurroundings(args, _ctx) {
  const parsed = SpatialTools.LOOK_AT_SURROUNDINGS.inputSchema.parse(args);
  const spatialRepo = getSpatialRepo();
  const characterRepo = getCharacterRepo();
  const observer = characterRepo.findById(parsed.observerId);
  if (!observer) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Observer not found"
        }, null, 2)
      }]
    };
  }
  const currentRoomId = observer.currentRoomId;
  if (!currentRoomId) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Observer is not in any room. Use move_character_to_room first."
        }, null, 2)
      }]
    };
  }
  const currentRoom = spatialRepo.findById(currentRoomId);
  if (!currentRoom) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Observer's current room not found in database"
        }, null, 2)
      }]
    };
  }
  const isInDarkness = currentRoom.atmospherics.includes("DARKNESS");
  const hasLight = observer.conditions?.some((c) => c.name === "HAS_LIGHT") || observer.conditions?.some((c) => c.name === "DARKVISION");
  if (isInDarkness && !hasLight) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: true,
          description: "It's pitch black. You can't see anything.",
          exits: [],
          entities: [],
          atmospherics: currentRoom.atmospherics,
          roomId: currentRoom.id,
          roomName: currentRoom.name
        }, null, 2)
      }]
    };
  }
  const perceptionModifier = getModifier2(observer.stats.wis);
  const visibleExits = currentRoom.exits.filter((exit) => {
    if (exit.type === "OPEN")
      return true;
    if (exit.type === "LOCKED")
      return false;
    if (exit.type === "HIDDEN") {
      const perceptionRoll = rollD203() + perceptionModifier;
      return perceptionRoll >= (exit.dc || 15);
    }
    return false;
  });
  const formattedExits = visibleExits.map((e) => ({
    direction: e.direction,
    type: e.type,
    description: e.description || `A ${e.type.toLowerCase()} passage leads ${e.direction}`,
    targetNodeId: e.targetNodeId
  }));
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        roomId: currentRoom.id,
        roomName: currentRoom.name,
        description: currentRoom.baseDescription,
        exits: formattedExits,
        entities: currentRoom.entityIds,
        atmospherics: currentRoom.atmospherics,
        biomeContext: currentRoom.biomeContext,
        visitedCount: currentRoom.visitedCount
      }, null, 2)
    }]
  };
}
async function handleGenerateRoomNode(args, _ctx) {
  const parsed = SpatialTools.GENERATE_ROOM_NODE.inputSchema.parse(args);
  const spatialRepo = getSpatialRepo();
  const newRoom = {
    id: crypto.randomUUID(),
    name: parsed.name,
    baseDescription: parsed.baseDescription,
    biomeContext: parsed.biomeContext,
    atmospherics: parsed.atmospherics,
    exits: [],
    entityIds: [],
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    updatedAt: (/* @__PURE__ */ new Date()).toISOString(),
    visitedCount: 0,
    lastVisitedAt: void 0
  };
  spatialRepo.create(newRoom);
  if (parsed.previousNodeId && parsed.direction) {
    const prevRoom = spatialRepo.findById(parsed.previousNodeId);
    if (prevRoom) {
      const exit = {
        direction: parsed.direction,
        targetNodeId: newRoom.id,
        type: "OPEN"
      };
      spatialRepo.addExit(parsed.previousNodeId, exit);
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        roomId: newRoom.id,
        name: newRoom.name,
        description: newRoom.baseDescription,
        biomeContext: newRoom.biomeContext,
        atmospherics: newRoom.atmospherics,
        linkedToPrevious: !!(parsed.previousNodeId && parsed.direction)
      }, null, 2)
    }]
  };
}
async function handleGetRoomExits(args, _ctx) {
  const parsed = SpatialTools.GET_ROOM_EXITS.inputSchema.parse(args);
  const spatialRepo = getSpatialRepo();
  const room = spatialRepo.findById(parsed.roomId);
  if (!room) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Room not found"
        }, null, 2)
      }]
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        roomId: room.id,
        roomName: room.name,
        exits: room.exits.map((e) => ({
          direction: e.direction,
          targetNodeId: e.targetNodeId,
          type: e.type,
          dc: e.dc,
          description: e.description
        }))
      }, null, 2)
    }]
  };
}
async function handleMoveCharacterToRoom(args, _ctx) {
  const parsed = SpatialTools.MOVE_CHARACTER_TO_ROOM.inputSchema.parse(args);
  const spatialRepo = getSpatialRepo();
  const characterRepo = getCharacterRepo();
  const character = characterRepo.findById(parsed.characterId);
  if (!character) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Character not found"
        }, null, 2)
      }]
    };
  }
  const room = spatialRepo.findById(parsed.roomId);
  if (!room) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          success: false,
          error: "Room not found"
        }, null, 2)
      }]
    };
  }
  const oldRoomId = character.currentRoomId;
  if (oldRoomId) {
    try {
      spatialRepo.removeEntityFromRoom(oldRoomId, parsed.characterId);
    } catch (e) {
    }
  }
  const updatedChar = {
    ...character,
    currentRoomId: parsed.roomId
  };
  characterRepo.update(parsed.characterId, updatedChar);
  spatialRepo.addEntityToRoom(parsed.roomId, parsed.characterId);
  spatialRepo.incrementVisitCount(parsed.roomId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        characterId: parsed.characterId,
        characterName: character.name,
        newRoomId: parsed.roomId,
        newRoomName: room.name,
        visitedCount: room.visitedCount + 1
      }, null, 2)
    }]
  };
}

// dist/server/batch-tools.js
var import_crypto11 = require("crypto");
init_character_repo();
init_party();
init_zod();
function ensureDb11() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const charRepo = new CharacterRepository(db);
  return { db, charRepo };
}
var BatchCharacterSchema = external_exports.object({
  name: external_exports.string().min(1),
  class: external_exports.string().optional().default("Adventurer"),
  race: external_exports.string().optional().default("Human"),
  level: external_exports.number().int().min(1).optional().default(1),
  hp: external_exports.number().int().min(1).optional(),
  maxHp: external_exports.number().int().min(1).optional(),
  ac: external_exports.number().int().min(0).optional().default(10),
  stats: external_exports.object({
    str: external_exports.number().int().min(0).default(10),
    dex: external_exports.number().int().min(0).default(10),
    con: external_exports.number().int().min(0).default(10),
    int: external_exports.number().int().min(0).default(10),
    wis: external_exports.number().int().min(0).default(10),
    cha: external_exports.number().int().min(0).default(10)
  }).optional(),
  characterType: CharacterTypeSchema.optional().default("pc"),
  background: external_exports.string().optional()
});
var BatchTools = {
  BATCH_CREATE_CHARACTERS: {
    name: "batch_create_characters",
    description: `Create multiple characters at once. Perfect for generating a party, a squad of enemies, or a group of NPCs.

Maximum 20 characters per call. Each character needs at minimum a name.

Example - Create a 4-person adventuring party:
{
  "characters": [
    { "name": "Valeros", "class": "Fighter", "race": "Human" },
    { "name": "Kyra", "class": "Cleric", "race": "Human" },
    { "name": "Merisiel", "class": "Rogue", "race": "Elf" },
    { "name": "Ezren", "class": "Wizard", "race": "Human" }
  ]
}

Example - Create enemy goblins:
{
  "characters": [
    { "name": "Goblin Warrior 1", "class": "Warrior", "race": "Goblin", "characterType": "enemy", "hp": 7, "ac": 15 },
    { "name": "Goblin Warrior 2", "class": "Warrior", "race": "Goblin", "characterType": "enemy", "hp": 7, "ac": 15 },
    { "name": "Goblin Boss", "class": "Champion", "race": "Goblin", "characterType": "enemy", "hp": 21, "ac": 17 }
  ]
}`,
    inputSchema: external_exports.object({
      characters: external_exports.array(BatchCharacterSchema).min(1).max(20).describe("Array of characters to create (1-20)")
    })
  },
  BATCH_CREATE_NPCS: {
    name: "batch_create_npcs",
    description: `Generate NPCs for a settlement or location. Creates a group of NPCs with specified roles.

Roles are flexible strings - use any profession like "blacksmith", "innkeeper", "guard captain", etc.

Example - Populate a village:
{
  "locationName": "Thornwood Village",
  "npcs": [
    { "name": "Marta", "role": "Innkeeper", "race": "Human" },
    { "name": "Grom", "role": "Blacksmith", "race": "Dwarf" },
    { "name": "Elara", "role": "Herbalist", "race": "Half-Elf" },
    { "name": "Captain Vance", "role": "Guard Captain", "race": "Human" }
  ]
}`,
    inputSchema: external_exports.object({
      locationName: external_exports.string().optional().describe("Name of the location these NPCs belong to"),
      npcs: external_exports.array(external_exports.object({
        name: external_exports.string().min(1),
        role: external_exports.string().describe("NPC profession or role"),
        race: external_exports.string().optional().default("Human"),
        behavior: external_exports.string().optional().describe("NPC personality or behavior pattern"),
        factionId: external_exports.string().optional()
      })).min(1).max(50).describe("Array of NPCs to create (1-50)")
    })
  },
  BATCH_DISTRIBUTE_ITEMS: {
    name: "batch_distribute_items",
    description: `Give items to multiple characters at once. Perfect for starting equipment, loot distribution, or quest rewards.

Example - Give starting equipment:
{
  "distributions": [
    { "characterId": "char-1", "items": ["Longsword", "Chain Mail", "Shield"] },
    { "characterId": "char-2", "items": ["Staff", "Spellbook", "Component Pouch"] },
    { "characterId": "char-3", "items": ["Shortbow", "Leather Armor", "Thieves' Tools"] }
  ]
}

Example - Distribute loot:
{
  "distributions": [
    { "characterId": "party-leader", "items": ["Gold Ring", "Healing Potion"] },
    { "characterId": "wizard", "items": ["Scroll of Fireball", "Wand of Magic Missiles"] }
  ]
}`,
    inputSchema: external_exports.object({
      distributions: external_exports.array(external_exports.object({
        characterId: external_exports.string().describe("ID of the character to receive items"),
        items: external_exports.array(external_exports.string()).min(1).describe("List of item names to give")
      })).min(1).max(20).describe("Distribution list (1-20 recipients)")
    })
  }
};
async function handleBatchCreateCharacters(args, _ctx) {
  const { charRepo } = ensureDb11();
  const parsed = BatchTools.BATCH_CREATE_CHARACTERS.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const createdCharacters = [];
  const errors = [];
  for (const charData of parsed.characters) {
    try {
      const stats = charData.stats ?? { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 };
      const conModifier = Math.floor((stats.con - 10) / 2);
      const baseHp = Math.max(1, 8 + conModifier);
      const hp = charData.hp ?? baseHp;
      const maxHp = charData.maxHp ?? hp;
      const character = {
        ...charData,
        id: (0, import_crypto11.randomUUID)(),
        stats,
        hp,
        maxHp,
        characterClass: charData.class || "Adventurer",
        createdAt: now,
        updatedAt: now
      };
      charRepo.create(character);
      createdCharacters.push({
        id: character.id,
        name: charData.name,
        class: charData.class,
        race: charData.race,
        characterType: charData.characterType
      });
    } catch (err) {
      errors.push(`Failed to create ${charData.name}: ${err.message}`);
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: errors.length === 0,
        created: createdCharacters,
        createdCount: createdCharacters.length,
        errors: errors.length > 0 ? errors : void 0
      }, null, 2)
    }]
  };
}
async function handleBatchCreateNpcs(args, _ctx) {
  const { charRepo } = ensureDb11();
  const parsed = BatchTools.BATCH_CREATE_NPCS.inputSchema.parse(args);
  const now = (/* @__PURE__ */ new Date()).toISOString();
  const createdNpcs = [];
  const errors = [];
  for (const npcData of parsed.npcs) {
    try {
      const npc = {
        id: (0, import_crypto11.randomUUID)(),
        name: npcData.name,
        race: npcData.race,
        characterClass: npcData.role,
        // Use role as class
        characterType: "npc",
        behavior: npcData.behavior,
        factionId: npcData.factionId,
        hp: 10,
        maxHp: 10,
        ac: 10,
        level: 1,
        stats: { str: 10, dex: 10, con: 10, int: 10, wis: 10, cha: 10 },
        createdAt: now,
        updatedAt: now,
        // Store location reference in metadata
        metadata: parsed.locationName ? { location: parsed.locationName } : void 0
      };
      charRepo.create(npc);
      createdNpcs.push({
        id: npc.id,
        name: npcData.name,
        role: npcData.role,
        race: npcData.race,
        location: parsed.locationName
      });
    } catch (err) {
      errors.push(`Failed to create NPC ${npcData.name}: ${err.message}`);
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: errors.length === 0,
        locationName: parsed.locationName,
        created: createdNpcs,
        createdCount: createdNpcs.length,
        errors: errors.length > 0 ? errors : void 0
      }, null, 2)
    }]
  };
}
async function handleBatchDistributeItems(args, _ctx) {
  const { db } = ensureDb11();
  const parsed = BatchTools.BATCH_DISTRIBUTE_ITEMS.inputSchema.parse(args);
  const distributions = [];
  const errors = [];
  for (const dist of parsed.distributions) {
    try {
      const charStmt = db.prepare("SELECT * FROM characters WHERE id = ?");
      const character = charStmt.get(dist.characterId);
      if (!character) {
        errors.push(`Character not found: ${dist.characterId}`);
        continue;
      }
      let inventory = [];
      if (character.inventory) {
        try {
          inventory = JSON.parse(character.inventory);
        } catch {
          inventory = [];
        }
      }
      inventory.push(...dist.items);
      const updateStmt = db.prepare("UPDATE characters SET inventory = ?, updatedAt = ? WHERE id = ?");
      updateStmt.run(JSON.stringify(inventory), (/* @__PURE__ */ new Date()).toISOString(), dist.characterId);
      distributions.push({
        characterId: dist.characterId,
        characterName: character.name,
        itemsGiven: dist.items,
        newInventorySize: inventory.length
      });
    } catch (err) {
      errors.push(`Failed to distribute to ${dist.characterId}: ${err.message}`);
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: errors.length === 0,
        distributions,
        totalItemsDistributed: distributions.reduce((sum, d) => sum + d.itemsGiven.length, 0),
        errors: errors.length > 0 ? errors : void 0
      }, null, 2)
    }]
  };
}

// dist/server/workflow-tools.js
init_zod();
var import_fs3 = require("fs");
var import_path2 = require("path");
var import_url = require("url");
var yaml = __toESM(require_dist2(), 1);

// dist/workflow/schema.js
init_zod();
var WorkflowStepSchema = external_exports.object({
  name: external_exports.string().describe("Step name (for reference in dependencies)"),
  tool: external_exports.string().describe("Tool name to execute"),
  params: external_exports.record(external_exports.any()).describe("Parameters to pass to the tool"),
  dependsOn: external_exports.array(external_exports.string()).optional().describe("Step names this step depends on"),
  condition: external_exports.string().optional().describe("JavaScript expression to evaluate (must return true to execute)"),
  storeAs: external_exports.string().optional().describe("Save result to this variable name for interpolation")
});
var WorkflowSchema = external_exports.object({
  name: external_exports.string(),
  description: external_exports.string(),
  version: external_exports.string().default("1.0.0"),
  author: external_exports.string().optional(),
  // Input parameters the workflow accepts
  parameters: external_exports.record(external_exports.object({
    type: external_exports.enum(["string", "number", "boolean", "array"]),
    description: external_exports.string(),
    default: external_exports.any().optional(),
    required: external_exports.boolean().default(true)
  })).optional(),
  // Steps to execute
  steps: external_exports.array(WorkflowStepSchema).min(1),
  // Output - what to return
  output: external_exports.object({
    include: external_exports.array(external_exports.string()).describe("Step names whose results to include"),
    summary: external_exports.string().optional().describe("Template string for summary")
  }).optional()
});

// dist/workflow/executor.js
function interpolate(template, variables) {
  return template.replace(/\{\{(\w+)\}\}/g, (match, key) => {
    if (key in variables) {
      return typeof variables[key] === "string" ? variables[key] : JSON.stringify(variables[key]);
    }
    return match;
  });
}
function interpolateObject(obj, variables) {
  if (typeof obj === "string") {
    return interpolate(obj, variables);
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => interpolateObject(item, variables));
  }
  if (obj && typeof obj === "object") {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = interpolateObject(value, variables);
    }
    return result;
  }
  return obj;
}
function topologicalSort(steps) {
  const stepMap = /* @__PURE__ */ new Map();
  const visited = /* @__PURE__ */ new Set();
  const result = [];
  for (const step of steps) {
    stepMap.set(step.name, step);
  }
  function visit(name) {
    if (visited.has(name))
      return;
    visited.add(name);
    const step = stepMap.get(name);
    if (!step)
      return;
    for (const dep of step.dependsOn || []) {
      visit(dep);
    }
    result.push(step);
  }
  for (const step of steps) {
    visit(step.name);
  }
  return result;
}
var WorkflowExecutor = class {
  ctx;
  variables = {};
  constructor(ctx) {
    this.ctx = ctx;
  }
  /**
   * Execute a workflow definition
   */
  async execute(workflow, params = {}) {
    const startTime = Date.now();
    const stepResults = [];
    const errors = [];
    this.variables = { ...params };
    if (workflow.parameters) {
      for (const [key, def] of Object.entries(workflow.parameters)) {
        if (!(key in this.variables) && def.default !== void 0) {
          this.variables[key] = def.default;
        }
        if (def.required && !(key in this.variables)) {
          errors.push(`Missing required parameter: ${key}`);
        }
      }
    }
    if (errors.length > 0) {
      return {
        workflowName: workflow.name,
        success: false,
        stepResults: [],
        totalDuration: Date.now() - startTime,
        errors
      };
    }
    const sortedSteps = topologicalSort(workflow.steps);
    for (const step of sortedSteps) {
      const stepResult = await this.executeStep(step);
      stepResults.push(stepResult);
      if (!stepResult.success) {
        errors.push(`Step '${step.name}' failed: ${stepResult.error}`);
        break;
      }
      if (step.storeAs && stepResult.result) {
        this.variables[step.storeAs] = stepResult.result;
      }
    }
    let output = void 0;
    if (workflow.output) {
      output = {};
      for (const stepName of workflow.output.include) {
        const result = stepResults.find((r) => r.stepName === stepName);
        if (result) {
          output[stepName] = result.result;
        }
      }
      if (workflow.output.summary) {
        output.summary = interpolate(workflow.output.summary, this.variables);
      }
    }
    return {
      workflowName: workflow.name,
      success: errors.length === 0,
      stepResults,
      totalDuration: Date.now() - startTime,
      output,
      errors
    };
  }
  async executeStep(step) {
    const startTime = Date.now();
    if (step.condition) {
      try {
        const conditionFn = new Function("vars", `with(vars) { return ${step.condition}; }`);
        if (!conditionFn(this.variables)) {
          return {
            stepName: step.name,
            success: true,
            result: { skipped: true, reason: "Condition not met" },
            duration: Date.now() - startTime
          };
        }
      } catch (err) {
        return {
          stepName: step.name,
          success: false,
          error: `Condition evaluation failed: ${err.message}`,
          duration: Date.now() - startTime
        };
      }
    }
    const handler = getToolHandler(step.tool);
    if (!handler) {
      return {
        stepName: step.name,
        success: false,
        error: `Tool not found: ${step.tool}`,
        duration: Date.now() - startTime
      };
    }
    try {
      const interpolatedParams = interpolateObject(step.params, this.variables);
      const result = await handler(interpolatedParams, this.ctx);
      let parsedResult = result;
      if (result?.content?.[0]?.text) {
        try {
          parsedResult = JSON.parse(result.content[0].text);
        } catch {
          parsedResult = result.content[0].text;
        }
      }
      return {
        stepName: step.name,
        success: true,
        result: parsedResult,
        duration: Date.now() - startTime
      };
    } catch (err) {
      return {
        stepName: step.name,
        success: false,
        error: err.message,
        duration: Date.now() - startTime
      };
    }
  }
};

// dist/server/workflow-tools.js
var import_meta = {};
var __dirnameCompat;
try {
  __dirnameCompat = (0, import_path2.dirname)((0, import_url.fileURLToPath)(import_meta.url));
} catch {
  __dirnameCompat = process.cwd();
}
function getTemplatesDir() {
  const candidates = [
    (0, import_path2.join)(process.cwd(), "templates", "workflows"),
    (0, import_path2.join)(__dirnameCompat, "..", "..", "templates", "workflows"),
    (0, import_path2.join)(__dirnameCompat, "templates", "workflows")
  ];
  for (const dir of candidates) {
    if ((0, import_fs3.existsSync)(dir)) {
      return dir;
    }
  }
  return candidates[0];
}
var TEMPLATES_DIR = getTemplatesDir();
var WorkflowTools = {
  EXECUTE_WORKFLOW: {
    name: "execute_workflow",
    description: `Execute a workflow from a template or inline definition.

Workflows automate multi-step operations like creating a full party, setting up an encounter, or populating a village.

Example - Execute starter_party template:
{
  "template": "starter_party",
  "params": {
    "partyName": "The Brave Ones"
  }
}

Example - Execute inline workflow:
{
  "workflow": {
    "name": "Quick Fight",
    "description": "Setup a quick goblin fight",
    "steps": [
      {
        "name": "create_goblins",
        "tool": "batch_create_characters",
        "params": {
          "characters": [
            { "name": "Goblin 1", "characterType": "enemy" },
            { "name": "Goblin 2", "characterType": "enemy" }
          ]
        }
      }
    ]
  }
}`,
    inputSchema: external_exports.object({
      template: external_exports.string().optional().describe("Name of template file (without .yaml)"),
      workflow: WorkflowSchema.optional().describe("Inline workflow definition"),
      params: external_exports.record(external_exports.any()).optional().describe("Parameters to pass to the workflow")
    }).refine((data) => data.template || data.workflow, { message: "Either template or workflow must be provided" })
  },
  LIST_TEMPLATES: {
    name: "list_templates",
    description: `List all available workflow templates.

Returns template names, descriptions, and required parameters.`,
    inputSchema: external_exports.object({
      category: external_exports.string().optional().describe("Filter by category")
    })
  },
  GET_TEMPLATE: {
    name: "get_template",
    description: `Get details of a specific workflow template including full schema and parameters.`,
    inputSchema: external_exports.object({
      name: external_exports.string().describe("Template name (without .yaml)")
    })
  }
};
async function handleExecuteWorkflow(args, ctx) {
  const parsed = WorkflowTools.EXECUTE_WORKFLOW.inputSchema.parse(args);
  let workflow;
  if (parsed.template) {
    const templatePath = (0, import_path2.join)(TEMPLATES_DIR, `${parsed.template}.yaml`);
    if (!(0, import_fs3.existsSync)(templatePath)) {
      throw new Error(`Template not found: ${parsed.template}`);
    }
    const content = (0, import_fs3.readFileSync)(templatePath, "utf-8");
    const raw = yaml.parse(content);
    workflow = WorkflowSchema.parse(raw);
  } else if (parsed.workflow) {
    workflow = parsed.workflow;
  } else {
    throw new Error("Either template or workflow must be provided");
  }
  const executor = new WorkflowExecutor(ctx);
  const result = await executor.execute(workflow, parsed.params || {});
  return {
    content: [{
      type: "text",
      text: JSON.stringify(result, null, 2)
    }]
  };
}
async function handleListTemplates(args, _ctx) {
  WorkflowTools.LIST_TEMPLATES.inputSchema.parse(args);
  const templates = [];
  if (!(0, import_fs3.existsSync)(TEMPLATES_DIR)) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({
          templates: [],
          message: "No templates directory found"
        }, null, 2)
      }]
    };
  }
  const files = (0, import_fs3.readdirSync)(TEMPLATES_DIR).filter((f) => f.endsWith(".yaml"));
  for (const file of files) {
    try {
      const content = (0, import_fs3.readFileSync)((0, import_path2.join)(TEMPLATES_DIR, file), "utf-8");
      const raw = yaml.parse(content);
      templates.push({
        name: file.replace(".yaml", ""),
        description: raw.description || "",
        version: raw.version || "1.0.0",
        author: raw.author,
        parameters: raw.parameters ? Object.keys(raw.parameters) : [],
        stepCount: raw.steps?.length || 0
      });
    } catch {
    }
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        templates,
        count: templates.length
      }, null, 2)
    }]
  };
}
async function handleGetTemplate(args, _ctx) {
  const parsed = WorkflowTools.GET_TEMPLATE.inputSchema.parse(args);
  const templatePath = (0, import_path2.join)(TEMPLATES_DIR, `${parsed.name}.yaml`);
  if (!(0, import_fs3.existsSync)(templatePath)) {
    throw new Error(`Template not found: ${parsed.name}`);
  }
  const content = (0, import_fs3.readFileSync)(templatePath, "utf-8");
  const raw = yaml.parse(content);
  const workflow = WorkflowSchema.parse(raw);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        name: workflow.name,
        description: workflow.description,
        version: workflow.version,
        author: workflow.author,
        parameters: workflow.parameters,
        steps: workflow.steps.map((s) => ({
          name: s.name,
          tool: s.tool,
          dependsOn: s.dependsOn
        })),
        output: workflow.output
      }, null, 2)
    }]
  };
}

// dist/server/event-inbox-tools.js
init_zod();

// dist/storage/repos/event-inbox.repo.js
var EventInboxRepository = class {
  db;
  constructor(db) {
    this.db = db;
  }
  /**
   * Push an event to the inbox
   */
  push(event) {
    const stmt = this.db.prepare(`
      INSERT INTO event_inbox (event_type, payload, source_type, source_id, priority, expires_at)
      VALUES (?, ?, ?, ?, ?, ?)
    `);
    const result = stmt.run(event.eventType, JSON.stringify(event.payload), event.sourceType || null, event.sourceId || null, event.priority || 0, event.expiresAt || null);
    return result.lastInsertRowid;
  }
  /**
   * Poll for unread events, ordered by priority then time
   */
  poll(limit = 20) {
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const stmt = this.db.prepare(`
      SELECT * FROM event_inbox
      WHERE consumed_at IS NULL
        AND (expires_at IS NULL OR expires_at > ?)
      ORDER BY priority DESC, created_at ASC
      LIMIT ?
    `);
    const rows = stmt.all(now, limit);
    return rows.map((row) => this.rowToEvent(row));
  }
  /**
   * Mark events as consumed (read)
   */
  markConsumed(ids) {
    if (ids.length === 0)
      return 0;
    const now = (/* @__PURE__ */ new Date()).toISOString();
    const placeholders = ids.map(() => "?").join(",");
    const stmt = this.db.prepare(`
      UPDATE event_inbox
      SET consumed_at = ?
      WHERE id IN (${placeholders})
    `);
    const result = stmt.run(now, ...ids);
    return result.changes;
  }
  /**
   * Poll and immediately mark as consumed (atomic)
   */
  pollAndConsume(limit = 20) {
    const events = this.poll(limit);
    const ids = events.map((e) => e.id).filter(Boolean);
    if (ids.length > 0) {
      this.markConsumed(ids);
    }
    return events;
  }
  /**
   * Get recent event history (including consumed)
   */
  getHistory(options = {}) {
    const { limit = 50, eventType, sourceType, includeConsumed = true } = options;
    let query = "SELECT * FROM event_inbox WHERE 1=1";
    const params = [];
    if (!includeConsumed) {
      query += " AND consumed_at IS NULL";
    }
    if (eventType) {
      query += " AND event_type = ?";
      params.push(eventType);
    }
    if (sourceType) {
      query += " AND source_type = ?";
      params.push(sourceType);
    }
    query += " ORDER BY created_at DESC LIMIT ?";
    params.push(limit);
    const stmt = this.db.prepare(query);
    const rows = stmt.all(...params);
    return rows.map((row) => this.rowToEvent(row));
  }
  /**
   * Clean up old consumed events
   */
  cleanup(olderThanDays = 7) {
    const cutoff = /* @__PURE__ */ new Date();
    cutoff.setDate(cutoff.getDate() - olderThanDays);
    const stmt = this.db.prepare(`
      DELETE FROM event_inbox
      WHERE consumed_at IS NOT NULL
        AND created_at < ?
    `);
    const result = stmt.run(cutoff.toISOString());
    return result.changes;
  }
  /**
   * Get count of pending (unconsumed) events
   */
  getPendingCount() {
    const stmt = this.db.prepare(`
      SELECT COUNT(*) as count FROM event_inbox
      WHERE consumed_at IS NULL
    `);
    const row = stmt.get();
    return row.count;
  }
  rowToEvent(row) {
    return {
      id: row.id,
      eventType: row.event_type,
      payload: JSON.parse(row.payload),
      sourceType: row.source_type,
      sourceId: row.source_id || void 0,
      priority: row.priority,
      createdAt: row.created_at,
      consumedAt: row.consumed_at,
      expiresAt: row.expires_at
    };
  }
};

// dist/server/event-inbox-tools.js
var EventTypeEnum = external_exports.enum([
  "npc_action",
  "combat_update",
  "world_change",
  "quest_update",
  "time_passage",
  "environmental",
  "system"
]);
var SourceTypeEnum = external_exports.enum(["npc", "combat", "world", "system", "scheduler"]);
var EventInboxTools = {
  POLL_EVENTS: {
    name: "poll_events",
    description: `Poll the event inbox for unread events. Returns events and marks them as consumed.
    
Events are generated by NPCs, combat, world systems, and schedulers. They represent
things that happened "while the player wasn't looking" - making NPCs feel autonomous.

Example response:
[
  { "eventType": "npc_action", "payload": { "npcName": "Bartender", "action": "wipes a glass nervously" }},
  { "eventType": "quest_update", "payload": { "questName": "Missing Merchant", "update": "New rumor heard" }}
]`,
    inputSchema: external_exports.object({
      limit: external_exports.number().int().min(1).max(50).default(20).describe("Maximum events to return")
    })
  },
  PUSH_EVENT: {
    name: "push_event",
    description: `Push an event to the inbox. Used by DM or internal systems to queue events.

NPCs "doing things" on their own, combat updates, world changes - all go here.
Frontend polls this to show what happened.`,
    inputSchema: external_exports.object({
      eventType: EventTypeEnum,
      payload: external_exports.record(external_exports.any()).describe("Event data (JSON object)"),
      sourceType: SourceTypeEnum.optional(),
      sourceId: external_exports.string().optional().describe("ID of source NPC/entity"),
      priority: external_exports.number().int().min(0).max(10).default(0).describe("0=normal, 10=urgent"),
      expiresAt: external_exports.string().optional().describe("ISO timestamp when event expires")
    })
  },
  GET_EVENT_HISTORY: {
    name: "get_event_history",
    description: "Get recent event history with optional filters.",
    inputSchema: external_exports.object({
      limit: external_exports.number().int().min(1).max(100).default(50),
      eventType: EventTypeEnum.optional(),
      sourceType: SourceTypeEnum.optional(),
      includeConsumed: external_exports.boolean().default(true)
    })
  },
  GET_PENDING_COUNT: {
    name: "get_pending_event_count",
    description: "Get the count of unread events in the inbox.",
    inputSchema: external_exports.object({})
  }
};
async function handlePollEvents(args, _ctx) {
  const repo = new EventInboxRepository(getDb());
  const events = repo.pollAndConsume(args.limit);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        count: events.length,
        events: events.map((e) => ({
          id: e.id,
          eventType: e.eventType,
          payload: e.payload,
          sourceType: e.sourceType,
          sourceId: e.sourceId,
          priority: e.priority,
          createdAt: e.createdAt
        }))
      }, null, 2)
    }]
  };
}
async function handlePushEvent(args, _ctx) {
  const repo = new EventInboxRepository(getDb());
  const id = repo.push({
    eventType: args.eventType,
    payload: args.payload,
    sourceType: args.sourceType,
    sourceId: args.sourceId,
    priority: args.priority,
    expiresAt: args.expiresAt
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        eventId: id,
        message: `Event queued with ID ${id}`
      })
    }]
  };
}
async function handleGetEventHistory(args, _ctx) {
  const repo = new EventInboxRepository(getDb());
  const events = repo.getHistory({
    limit: args.limit,
    eventType: args.eventType,
    sourceType: args.sourceType,
    includeConsumed: args.includeConsumed
  });
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        count: events.length,
        events
      }, null, 2)
    }]
  };
}
async function handleGetPendingCount(_args, _ctx) {
  const repo = new EventInboxRepository(getDb());
  const count = repo.getPendingCount();
  return {
    content: [{
      type: "text",
      text: JSON.stringify({ pendingEvents: count })
    }]
  };
}

// dist/server/context-tools.js
init_zod();
var GetNarrativeContextSchema = external_exports.object({
  worldId: external_exports.string().describe("Active world ID"),
  characterId: external_exports.string().optional().describe("Active character ID (if any)"),
  encounterId: external_exports.string().optional().describe("Active encounter ID (if any)"),
  maxEvents: external_exports.number().default(5).describe("Number of recent history events to include")
});
var ContextTools = {
  GET_NARRATIVE_CONTEXT: {
    name: "get_narrative_context",
    description: "Aggregates comprehensive narrative context (Character, World, Combat, Secrets) for the LLM system prompt.",
    inputSchema: GetNarrativeContextSchema
  }
};
async function handleGetNarrativeContext(args, _ctx) {
  const parsed = ContextTools.GET_NARRATIVE_CONTEXT.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const sections = [];
  try {
    const world = db.prepare("SELECT * FROM worlds WHERE id = ?").get(parsed.worldId);
    if (world) {
      let envContext = `Active World: ${world.name}`;
      const env = typeof world.environment === "string" ? JSON.parse(world.environment) : world.environment;
      if (env) {
        const parts = [
          env.date ? `Date: ${env.date.full_date || env.date}` : null,
          env.time_of_day ? `Time: ${env.time_of_day}` : null,
          env.weather ? `Weather: ${env.weather.condition || env.weather}` : null,
          env.location ? `Location: ${env.location}` : null
        ].filter(Boolean);
        if (parts.length > 0) {
          envContext += `
${parts.join(" | ")}`;
        }
      }
      sections.push({
        title: "\u{1F30D} WORLD & ENVIRONMENT",
        content: envContext,
        priority: 10
      });
    }
  } catch (e) {
    console.warn("Failed to load world context", e);
  }
  if (parsed.characterId) {
    try {
      const char = db.prepare("SELECT * FROM characters WHERE id = ?").get(parsed.characterId);
      if (char) {
        const hp = typeof char.hp === "string" ? JSON.parse(char.hp) : char.hp;
        const stats = typeof char.stats === "string" ? JSON.parse(char.stats) : char.stats;
        let charSummaries = ` Active Character: ${char.name} (Lvl ${char.level} ${char.race} ${char.class})`;
        charSummaries += `
HP: ${hp.current}/${hp.max} | AC: ${char.ac || 10}`;
        if (stats) {
          charSummaries += `
STR:${stats.str} DEX:${stats.dex} CON:${stats.con} INT:${stats.int} WIS:${stats.wis} CHA:${stats.cha}`;
        }
        sections.push({
          title: "\u{1F464} ACTIVE CHARACTER",
          content: charSummaries,
          priority: 20
        });
      }
    } catch (e) {
      console.warn("Failed to load character context", e);
    }
  }
  if (parsed.encounterId) {
    try {
      const encounter = db.prepare("SELECT * FROM encounters WHERE id = ?").get(parsed.encounterId);
      if (encounter && encounter.status === "active") {
        const state = typeof encounter.state === "string" ? JSON.parse(encounter.state) : encounter.state;
        let combatSummary = `\u26A0\uFE0F COMBAT ACTIVE (Round ${state.round})`;
        const participants = state.participants || [];
        const activeCount = participants.filter((p) => p.hp > 0).length;
        combatSummary += `
${activeCount} active combatants.`;
        if (state.currentTurn !== void 0 && participants[state.currentTurn]) {
          combatSummary += `
Current Turn: ${participants[state.currentTurn].name}`;
        }
        sections.push({
          title: "\u2694\uFE0F COMBAT SITUATION",
          content: combatSummary,
          priority: 100
          // Highest priority
        });
      }
    } catch (e) {
      console.warn("Failed to load combat context", e);
    }
  }
  try {
    const secretRepo = new SecretRepository(db);
    const secretParams = secretRepo.formatForLLM(parsed.worldId);
    if (secretParams && secretParams.length > 50) {
      sections.push({
        title: "\u{1F512} GM SECRETS (HIDDEN)",
        content: secretParams,
        priority: 90
      });
    }
  } catch (e) {
    console.warn("Failed to load secret context", e);
  }
  sections.sort((a, b) => b.priority - a.priority);
  const finalContext = sections.map((s) => `--- ${s.title} ---
${s.content}`).join("\n\n");
  return {
    content: [{
      type: "text",
      text: finalContext
    }]
  };
}

// dist/server/progression-tools.js
init_zod();
init_character_repo();
var XP_TABLE = {
  1: 0,
  2: 300,
  3: 900,
  4: 2700,
  5: 6500,
  6: 14e3,
  7: 23e3,
  8: 34e3,
  9: 48e3,
  10: 64e3,
  11: 85e3,
  12: 1e5,
  13: 12e4,
  14: 14e4,
  15: 165e3,
  16: 195e3,
  17: 225e3,
  18: 265e3,
  19: 305e3,
  20: 355e3
};
var ProgressionTools = {
  ADD_XP: {
    name: "add_xp",
    description: "Add experience points to a character. Checks for level-up thresholds.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the character"),
      amount: external_exports.number().int().min(1).describe("Amount of XP to add")
    })
  },
  GET_LEVEL_PROGRESSION: {
    name: "get_level_progression",
    description: "Get level progression details including XP needed for next level.",
    inputSchema: external_exports.object({
      level: external_exports.number().int().min(1).max(20).describe("Current level to check progression for")
    })
  },
  LEVEL_UP: {
    name: "level_up",
    description: "Increment character level and optionally update stats like HP.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the character"),
      hpIncrease: external_exports.number().int().min(0).optional().describe("Amount to increase Max HP by (if any)"),
      targetLevel: external_exports.number().int().min(2).max(20).optional().describe("Explicit target level (default: current + 1)")
    })
  }
};
async function handleAddXp(args, _ctx) {
  const parsed = ProgressionTools.ADD_XP.inputSchema.parse(args);
  const db = getDb();
  const repo = new CharacterRepository(db);
  const char = repo.findById(parsed.characterId);
  if (!char) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const currentXp = char.xp || 0;
  const newXp = currentXp + parsed.amount;
  const currentLevel = char.level;
  const nextLevelXp = XP_TABLE[currentLevel + 1];
  let message = `Added ${parsed.amount} XP. Total: ${newXp}.`;
  let canLevelUp = false;
  if (nextLevelXp && newXp >= nextLevelXp) {
    canLevelUp = true;
    message += ` \u{1F31F} LEVEL UP AVAILABLE! Reached threshold for Level ${currentLevel + 1}.`;
  }
  repo.update(char.id, { xp: newXp });
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          characterId: char.id,
          name: char.name,
          oldXp: currentXp,
          newXp,
          level: currentLevel,
          canLevelUp,
          nextLevelXp,
          message
        }, null, 2)
      }
    ]
  };
}
async function handleGetLevelProgression(args, _ctx) {
  const parsed = ProgressionTools.GET_LEVEL_PROGRESSION.inputSchema.parse(args);
  const level = parsed.level;
  if (level >= 20) {
    return {
      content: [{ type: "text", text: JSON.stringify({ level: 20, maxLevel: true, xpForCurrent: XP_TABLE[20] }) }]
    };
  }
  const currentXpBase = XP_TABLE[level];
  const nextLevelXp = XP_TABLE[level + 1];
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          level,
          xpRequiredForLevel: currentXpBase,
          xpForNextLevel: nextLevelXp,
          xpToNext: nextLevelXp - currentXpBase
        }, null, 2)
      }
    ]
  };
}
async function handleLevelUp(args, _ctx) {
  const parsed = ProgressionTools.LEVEL_UP.inputSchema.parse(args);
  const db = getDb();
  const repo = new CharacterRepository(db);
  const char = repo.findById(parsed.characterId);
  if (!char) {
    throw new Error(`Character ${parsed.characterId} not found`);
  }
  const currentLevel = char.level;
  const targetLevel = parsed.targetLevel || currentLevel + 1;
  if (targetLevel <= currentLevel) {
    throw new Error(`Target level ${targetLevel} must be greater than current level ${currentLevel}`);
  }
  const updates = {
    level: targetLevel
  };
  if (parsed.hpIncrease) {
    updates.maxHp = (char.maxHp || 0) + parsed.hpIncrease;
    updates.hp = (char.hp || 0) + parsed.hpIncrease;
    updates.hp = (char.hp || 0) + parsed.hpIncrease;
  }
  repo.update(char.id, updates);
  return {
    content: [
      {
        type: "text",
        text: JSON.stringify({
          characterId: char.id,
          name: char.name,
          oldLevel: currentLevel,
          newLevel: targetLevel,
          hpIncrease: parsed.hpIncrease || 0,
          newMaxHp: updates.maxHp || char.maxHp,
          message: `Leveled up to ${targetLevel}!`
        }, null, 2)
      }
    ]
  };
}

// dist/server/skill-check-tools.js
init_zod();
init_character_repo();
var SkillEnum = external_exports.enum([
  "acrobatics",
  "animal_handling",
  "arcana",
  "athletics",
  "deception",
  "history",
  "insight",
  "intimidation",
  "investigation",
  "medicine",
  "nature",
  "perception",
  "performance",
  "persuasion",
  "religion",
  "sleight_of_hand",
  "stealth",
  "survival"
]);
var AbilityEnum = external_exports.enum(["str", "dex", "con", "int", "wis", "cha"]);
var SKILL_ABILITY_MAP = {
  athletics: "str",
  acrobatics: "dex",
  sleight_of_hand: "dex",
  stealth: "dex",
  arcana: "int",
  history: "int",
  investigation: "int",
  nature: "int",
  religion: "int",
  animal_handling: "wis",
  insight: "wis",
  medicine: "wis",
  perception: "wis",
  survival: "wis",
  deception: "cha",
  intimidation: "cha",
  performance: "cha",
  persuasion: "cha"
};
function ensureDb12() {
  const dbPath = process.env.NODE_ENV === "test" ? ":memory:" : process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db";
  const db = getDb(dbPath);
  const charRepo = new CharacterRepository(db);
  const invRepo = new InventoryRepository(db);
  return { charRepo, invRepo };
}
function hasArmorStealthDisadvantage(invRepo, characterId) {
  try {
    const inventory = invRepo.getInventoryWithDetails(characterId);
    for (const entry of inventory.items) {
      if (entry.equipped && entry.item.type === "armor") {
        const props = entry.item.properties;
        if (props && props.stealthDisadvantage === true) {
          return { hasDisadvantage: true, armorName: entry.item.name };
        }
      }
    }
    return { hasDisadvantage: false };
  } catch {
    return { hasDisadvantage: false };
  }
}
function getProficiencyBonus(level) {
  return Math.floor((level - 1) / 4) + 2;
}
function getAbilityModifier5(abilityScore) {
  return Math.floor((abilityScore - 10) / 2);
}
var SkillCheckTools = {
  ROLL_SKILL_CHECK: {
    name: "roll_skill_check",
    description: `Roll a skill check using character stats. Automatically applies ability modifier and proficiency bonus if proficient.
Example: roll_skill_check with characterId and skill="perception" for active character's Perception check.`,
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the character making the check"),
      skill: SkillEnum.describe("Skill to roll (e.g., perception, stealth, athletics)"),
      advantage: external_exports.boolean().optional().default(false).describe("Roll with advantage"),
      disadvantage: external_exports.boolean().optional().default(false).describe("Roll with disadvantage"),
      dc: external_exports.number().int().min(1).optional().describe("Difficulty Class - if provided, returns pass/fail"),
      bonusModifier: external_exports.number().int().optional().default(0).describe("Additional situational modifier")
    })
  },
  ROLL_ABILITY_CHECK: {
    name: "roll_ability_check",
    description: "Roll a raw ability check (no skill proficiency). Uses only the ability modifier.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the character making the check"),
      ability: AbilityEnum.describe("Ability score to use (str, dex, con, int, wis, cha)"),
      advantage: external_exports.boolean().optional().default(false),
      disadvantage: external_exports.boolean().optional().default(false),
      dc: external_exports.number().int().min(1).optional(),
      bonusModifier: external_exports.number().int().optional().default(0)
    })
  },
  ROLL_SAVING_THROW: {
    name: "roll_saving_throw",
    description: "Roll a saving throw. Applies proficiency bonus if character has save proficiency.",
    inputSchema: external_exports.object({
      characterId: external_exports.string().describe("ID of the character making the save"),
      ability: AbilityEnum.describe("Saving throw type (str, dex, con, int, wis, cha)"),
      advantage: external_exports.boolean().optional().default(false),
      disadvantage: external_exports.boolean().optional().default(false),
      dc: external_exports.number().int().min(1).optional().describe("DC to beat"),
      bonusModifier: external_exports.number().int().optional().default(0)
    })
  }
};
async function handleRollSkillCheck(args, _ctx) {
  const { charRepo, invRepo } = ensureDb12();
  const parsed = SkillCheckTools.ROLL_SKILL_CHECK.inputSchema.parse(args);
  const character = charRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character not found: ${parsed.characterId}`);
  }
  const ability = SKILL_ABILITY_MAP[parsed.skill];
  const abilityScore = character.stats[ability];
  const abilityMod = getAbilityModifier5(abilityScore);
  const skillProfs = character.skillProficiencies || [];
  const expertise = character.expertise || [];
  const isProficient = skillProfs.includes(parsed.skill);
  const hasExpertise = expertise.includes(parsed.skill);
  const profBonus = getProficiencyBonus(character.level);
  let totalMod = abilityMod + parsed.bonusModifier;
  if (hasExpertise) {
    totalMod += profBonus * 2;
  } else if (isProficient) {
    totalMod += profBonus;
  }
  let armorDisadvantage = { hasDisadvantage: false };
  if (parsed.skill === "stealth") {
    armorDisadvantage = hasArmorStealthDisadvantage(invRepo, parsed.characterId);
  }
  let hasAdvantage = parsed.advantage === true;
  let hasDisadvantage = parsed.disadvantage === true || armorDisadvantage.hasDisadvantage;
  if (hasAdvantage && hasDisadvantage) {
    hasAdvantage = false;
    hasDisadvantage = false;
  }
  const dice = new DiceEngine();
  const diceExpr = {
    count: 1,
    sides: 20,
    modifier: totalMod,
    explode: false,
    advantage: hasAdvantage,
    disadvantage: hasDisadvantage
  };
  const result = dice.roll(diceExpr);
  const skillName = parsed.skill.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  const abilityName = ability.toUpperCase();
  const rollTotal = typeof result.result === "number" ? result.result : parseInt(String(result.result), 10);
  const rolls = result.metadata?.rolls;
  const response = {
    character: character.name,
    skill: skillName,
    ability: abilityName,
    roll: rollTotal,
    breakdown: {
      d20: rolls?.[0] ?? rollTotal - totalMod,
      abilityMod,
      proficiencyBonus: hasExpertise ? profBonus * 2 : isProficient ? profBonus : 0,
      bonusModifier: parsed.bonusModifier,
      total: rollTotal
    },
    proficient: isProficient,
    expertise: hasExpertise,
    advantage: hasAdvantage,
    disadvantage: hasDisadvantage
  };
  if (armorDisadvantage.hasDisadvantage) {
    response.armorDisadvantage = true;
    response.armorName = armorDisadvantage.armorName;
  }
  if (parsed.dc !== void 0) {
    response.dc = parsed.dc;
    response.success = rollTotal >= parsed.dc;
    response.margin = rollTotal - parsed.dc;
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(response, null, 2)
    }]
  };
}
async function handleRollAbilityCheck(args, _ctx) {
  const { charRepo } = ensureDb12();
  const parsed = SkillCheckTools.ROLL_ABILITY_CHECK.inputSchema.parse(args);
  const character = charRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character not found: ${parsed.characterId}`);
  }
  const abilityScore = character.stats[parsed.ability];
  const abilityMod = getAbilityModifier5(abilityScore);
  const totalMod = abilityMod + parsed.bonusModifier;
  const dice = new DiceEngine();
  const diceExpr = {
    count: 1,
    sides: 20,
    modifier: totalMod,
    explode: false,
    advantage: parsed.advantage && !parsed.disadvantage,
    disadvantage: parsed.disadvantage && !parsed.advantage
  };
  const result = dice.roll(diceExpr);
  const rollTotal = typeof result.result === "number" ? result.result : parseInt(String(result.result), 10);
  const rolls = result.metadata?.rolls;
  const abilityName = parsed.ability.toUpperCase();
  const response = {
    character: character.name,
    ability: abilityName,
    roll: rollTotal,
    breakdown: {
      d20: rolls?.[0] ?? rollTotal - totalMod,
      abilityMod,
      bonusModifier: parsed.bonusModifier,
      total: rollTotal
    },
    advantage: parsed.advantage,
    disadvantage: parsed.disadvantage
  };
  if (parsed.dc !== void 0) {
    response.dc = parsed.dc;
    response.success = rollTotal >= parsed.dc;
    response.margin = rollTotal - parsed.dc;
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(response, null, 2)
    }]
  };
}
async function handleRollSavingThrow(args, _ctx) {
  const { charRepo } = ensureDb12();
  const parsed = SkillCheckTools.ROLL_SAVING_THROW.inputSchema.parse(args);
  const character = charRepo.findById(parsed.characterId);
  if (!character) {
    throw new Error(`Character not found: ${parsed.characterId}`);
  }
  const abilityScore = character.stats[parsed.ability];
  const abilityMod = getAbilityModifier5(abilityScore);
  const saveProfs = character.saveProficiencies || [];
  const isProficient = saveProfs.includes(parsed.ability);
  const profBonus = isProficient ? getProficiencyBonus(character.level) : 0;
  const totalMod = abilityMod + profBonus + parsed.bonusModifier;
  const dice = new DiceEngine();
  const diceExpr = {
    count: 1,
    sides: 20,
    modifier: totalMod,
    explode: false,
    advantage: parsed.advantage && !parsed.disadvantage,
    disadvantage: parsed.disadvantage && !parsed.advantage
  };
  const result = dice.roll(diceExpr);
  const rollTotal = typeof result.result === "number" ? result.result : parseInt(String(result.result), 10);
  const rolls = result.metadata?.rolls;
  const abilityName = parsed.ability.toUpperCase();
  const response = {
    character: character.name,
    savingThrow: `${abilityName} Save`,
    roll: rollTotal,
    breakdown: {
      d20: rolls?.[0] ?? rollTotal - totalMod,
      abilityMod,
      proficiencyBonus: profBonus,
      bonusModifier: parsed.bonusModifier,
      total: rollTotal
    },
    proficient: isProficient,
    advantage: parsed.advantage,
    disadvantage: parsed.disadvantage
  };
  if (parsed.dc !== void 0) {
    response.dc = parsed.dc;
    response.success = rollTotal >= parsed.dc;
    response.margin = rollTotal - parsed.dc;
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify(response, null, 2)
    }]
  };
}

// dist/server/narrative-tools.js
init_zod();
var NoteTypeEnum = external_exports.enum([
  "plot_thread",
  "canonical_moment",
  "npc_voice",
  "foreshadowing",
  "session_log"
]);
var NoteStatusEnum = external_exports.enum([
  "active",
  "resolved",
  "dormant",
  "archived"
]);
var VisibilityEnum = external_exports.enum([
  "dm_only",
  "player_visible"
]);
var PlotThreadMetadata = external_exports.object({
  urgency: external_exports.enum(["low", "medium", "high", "critical"]).optional(),
  hooks: external_exports.array(external_exports.string()).optional().default([]),
  resolution_conditions: external_exports.array(external_exports.string()).optional().default([])
});
var CanonicalMomentMetadata = external_exports.object({
  speaker: external_exports.string().optional(),
  participants: external_exports.array(external_exports.string()).optional().default([]),
  location: external_exports.string().optional(),
  session_number: external_exports.number().optional()
});
var NpcVoiceMetadata = external_exports.object({
  speech_pattern: external_exports.string().optional(),
  vocabulary: external_exports.array(external_exports.string()).optional().default([]),
  mannerisms: external_exports.array(external_exports.string()).optional().default([]),
  current_goal: external_exports.string().optional(),
  secrets: external_exports.array(external_exports.string()).optional().default([])
});
var ForeshadowingMetadata = external_exports.object({
  target: external_exports.string().describe("What this foreshadows"),
  hints_given: external_exports.array(external_exports.string()).optional().default([]),
  hints_remaining: external_exports.array(external_exports.string()).optional().default([]),
  trigger: external_exports.string().optional().describe("When to reveal fully")
});
var SessionLogMetadata = external_exports.object({
  session_number: external_exports.number().optional(),
  xp_awarded: external_exports.number().optional(),
  player_count: external_exports.number().optional()
});
var AddNarrativeNoteSchema = external_exports.object({
  worldId: external_exports.string().describe("World/campaign ID to associate the note with"),
  type: NoteTypeEnum.describe("Category of note"),
  content: external_exports.string().min(1).describe("Main text content of the note"),
  metadata: external_exports.record(external_exports.any()).optional().default({}).describe("Type-specific structured data"),
  visibility: VisibilityEnum.optional().default("dm_only"),
  tags: external_exports.array(external_exports.string()).optional().default([]).describe('Tags for filtering (e.g., "faction:legion")'),
  entityId: external_exports.string().optional().describe("Link to a character/NPC/location"),
  entityType: external_exports.enum(["character", "npc", "location", "item"]).optional(),
  status: NoteStatusEnum.optional().default("active")
});
var SearchNarrativeNotesSchema = external_exports.object({
  worldId: external_exports.string().describe("World/campaign ID"),
  query: external_exports.string().optional().describe("Text search in content"),
  type: NoteTypeEnum.optional().describe("Filter by note type"),
  status: NoteStatusEnum.optional().describe("Filter by status"),
  tags: external_exports.array(external_exports.string()).optional().describe("Filter by tags (AND logic)"),
  entityId: external_exports.string().optional().describe("Filter by linked entity"),
  visibility: VisibilityEnum.optional().describe("Filter by visibility"),
  limit: external_exports.number().optional().default(20).describe("Max results to return"),
  orderBy: external_exports.enum(["created_at", "updated_at"]).optional().default("created_at")
});
var UpdateNarrativeNoteSchema = external_exports.object({
  noteId: external_exports.string().describe("ID of the note to update"),
  content: external_exports.string().optional().describe("New content (if changing)"),
  metadata: external_exports.record(external_exports.any()).optional().describe("Merge into existing metadata"),
  status: NoteStatusEnum.optional().describe("Change status (e.g., resolve a plot thread)"),
  visibility: VisibilityEnum.optional(),
  tags: external_exports.array(external_exports.string()).optional().describe("Replace tags")
});
var GetNarrativeNoteSchema = external_exports.object({
  noteId: external_exports.string().describe("ID of the note to retrieve")
});
var DeleteNarrativeNoteSchema = external_exports.object({
  noteId: external_exports.string().describe("ID of the note to delete")
});
var GetNarrativeContextSchema2 = external_exports.object({
  worldId: external_exports.string().describe("World/campaign ID"),
  includeTypes: external_exports.array(NoteTypeEnum).optional().default(["plot_thread", "canonical_moment", "npc_voice", "foreshadowing"]),
  maxPerType: external_exports.number().optional().default(5).describe("Max notes per type to include"),
  statusFilter: external_exports.array(NoteStatusEnum).optional().default(["active"]).describe("Only include notes with these statuses"),
  forPlayer: external_exports.boolean().optional().default(false).describe("If true, only return player_visible notes")
});
var NarrativeTools = {
  ADD_NARRATIVE_NOTE: {
    name: "add_narrative_note",
    description: "Create a typed narrative note (plot thread, canonical moment, NPC voice, foreshadowing, or session log). Used to build long-term narrative memory.",
    inputSchema: AddNarrativeNoteSchema
  },
  SEARCH_NARRATIVE_NOTES: {
    name: "search_narrative_notes",
    description: "Search and filter narrative notes by type, status, tags, or text content. Returns matching notes for context building.",
    inputSchema: SearchNarrativeNotesSchema
  },
  UPDATE_NARRATIVE_NOTE: {
    name: "update_narrative_note",
    description: "Update an existing narrative note. Common use: marking a plot_thread as resolved.",
    inputSchema: UpdateNarrativeNoteSchema
  },
  GET_NARRATIVE_NOTE: {
    name: "get_narrative_note",
    description: "Retrieve a single narrative note by ID.",
    inputSchema: GetNarrativeNoteSchema
  },
  DELETE_NARRATIVE_NOTE: {
    name: "delete_narrative_note",
    description: "Delete a narrative note. Use sparingly - prefer archiving via status update.",
    inputSchema: DeleteNarrativeNoteSchema
  },
  GET_NARRATIVE_CONTEXT: {
    name: "get_narrative_context_notes",
    description: "Retrieve aggregated narrative context for LLM prompt injection. Returns active plot threads, recent canonical moments, NPC voices, and pending foreshadowing.",
    inputSchema: GetNarrativeContextSchema2
  }
};
async function handleAddNarrativeNote(args, _ctx) {
  const parsed = NarrativeTools.ADD_NARRATIVE_NOTE.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const id = v4_default();
  const now = (/* @__PURE__ */ new Date()).toISOString();
  let validatedMetadata = parsed.metadata;
  try {
    switch (parsed.type) {
      case "plot_thread":
        validatedMetadata = PlotThreadMetadata.parse(parsed.metadata);
        break;
      case "canonical_moment":
        validatedMetadata = CanonicalMomentMetadata.parse(parsed.metadata);
        break;
      case "npc_voice":
        validatedMetadata = NpcVoiceMetadata.parse(parsed.metadata);
        break;
      case "foreshadowing":
        validatedMetadata = ForeshadowingMetadata.parse(parsed.metadata);
        break;
      case "session_log":
        validatedMetadata = SessionLogMetadata.parse(parsed.metadata);
        break;
    }
  } catch (e) {
    console.warn(`[NarrativeNote] Metadata validation warning for type ${parsed.type}:`, e);
  }
  db.prepare(`
    INSERT INTO narrative_notes (id, world_id, type, content, metadata, visibility, tags, entity_id, entity_type, status, created_at, updated_at)
    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
  `).run(id, parsed.worldId, parsed.type, parsed.content, JSON.stringify(validatedMetadata), parsed.visibility, JSON.stringify(parsed.tags), parsed.entityId || null, parsed.entityType || null, parsed.status, now, now);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        noteId: id,
        type: parsed.type,
        message: `Created ${parsed.type} note: "${parsed.content.substring(0, 50)}..."`
      })
    }]
  };
}
async function handleSearchNarrativeNotes(args, _ctx) {
  const parsed = NarrativeTools.SEARCH_NARRATIVE_NOTES.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  let sql = `SELECT * FROM narrative_notes WHERE world_id = ?`;
  const params = [parsed.worldId];
  if (parsed.type) {
    sql += ` AND type = ?`;
    params.push(parsed.type);
  }
  if (parsed.status) {
    sql += ` AND status = ?`;
    params.push(parsed.status);
  }
  if (parsed.visibility) {
    sql += ` AND visibility = ?`;
    params.push(parsed.visibility);
  }
  if (parsed.entityId) {
    sql += ` AND entity_id = ?`;
    params.push(parsed.entityId);
  }
  if (parsed.query) {
    sql += ` AND content LIKE ?`;
    params.push(`%${parsed.query}%`);
  }
  if (parsed.tags && parsed.tags.length > 0) {
    for (const tag of parsed.tags) {
      sql += ` AND tags LIKE ?`;
      params.push(`%"${tag}"%`);
    }
  }
  sql += ` ORDER BY ${parsed.orderBy} DESC LIMIT ?`;
  params.push(parsed.limit);
  const notes = db.prepare(sql).all(...params);
  const results = notes.map((note) => ({
    ...note,
    metadata: JSON.parse(note.metadata || "{}"),
    tags: JSON.parse(note.tags || "[]")
  }));
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        count: results.length,
        notes: results
      })
    }]
  };
}
async function handleUpdateNarrativeNote(args, _ctx) {
  const parsed = NarrativeTools.UPDATE_NARRATIVE_NOTE.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const existing = db.prepare("SELECT * FROM narrative_notes WHERE id = ?").get(parsed.noteId);
  if (!existing) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ success: false, error: "Note not found" })
      }],
      isError: true
    };
  }
  const updates = [];
  const params = [];
  if (parsed.content !== void 0) {
    updates.push("content = ?");
    params.push(parsed.content);
  }
  if (parsed.status !== void 0) {
    updates.push("status = ?");
    params.push(parsed.status);
  }
  if (parsed.visibility !== void 0) {
    updates.push("visibility = ?");
    params.push(parsed.visibility);
  }
  if (parsed.tags !== void 0) {
    updates.push("tags = ?");
    params.push(JSON.stringify(parsed.tags));
  }
  if (parsed.metadata !== void 0) {
    const existingMeta = JSON.parse(existing.metadata || "{}");
    const merged = { ...existingMeta, ...parsed.metadata };
    updates.push("metadata = ?");
    params.push(JSON.stringify(merged));
  }
  if (updates.length === 0) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ success: true, message: "No updates provided" })
      }]
    };
  }
  updates.push("updated_at = ?");
  params.push((/* @__PURE__ */ new Date()).toISOString());
  params.push(parsed.noteId);
  db.prepare(`UPDATE narrative_notes SET ${updates.join(", ")} WHERE id = ?`).run(...params);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: true,
        noteId: parsed.noteId,
        message: `Updated note. Changes: ${updates.slice(0, -1).join(", ")}`
      })
    }]
  };
}
async function handleGetNarrativeNote(args, _ctx) {
  const parsed = NarrativeTools.GET_NARRATIVE_NOTE.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const note = db.prepare("SELECT * FROM narrative_notes WHERE id = ?").get(parsed.noteId);
  if (!note) {
    return {
      content: [{
        type: "text",
        text: JSON.stringify({ success: false, error: "Note not found" })
      }],
      isError: true
    };
  }
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        ...note,
        metadata: JSON.parse(note.metadata || "{}"),
        tags: JSON.parse(note.tags || "[]")
      })
    }]
  };
}
async function handleDeleteNarrativeNote(args, _ctx) {
  const parsed = NarrativeTools.DELETE_NARRATIVE_NOTE.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const result = db.prepare("DELETE FROM narrative_notes WHERE id = ?").run(parsed.noteId);
  return {
    content: [{
      type: "text",
      text: JSON.stringify({
        success: result.changes > 0,
        deleted: result.changes > 0,
        message: result.changes > 0 ? "Note deleted" : "Note not found"
      })
    }]
  };
}
async function handleGetNarrativeContextNotes(args, _ctx) {
  const parsed = NarrativeTools.GET_NARRATIVE_CONTEXT.inputSchema.parse(args);
  const db = getDb(process.env.RPG_DATA_DIR ? `${process.env.RPG_DATA_DIR}/rpg.db` : "rpg.db");
  const sections = [];
  const typePriority = {
    "foreshadowing": 100,
    "plot_thread": 90,
    "npc_voice": 80,
    "canonical_moment": 70,
    "session_log": 50
  };
  const typeLabels = {
    "foreshadowing": "\u{1F52E} FORESHADOWING HINTS",
    "plot_thread": "\u{1F4DC} ACTIVE PLOT THREADS",
    "npc_voice": "\u{1F5E3}\uFE0F NPC VOICE NOTES",
    "canonical_moment": "\u2B50 CANONICAL MOMENTS",
    "session_log": "\u{1F4DD} SESSION LOGS"
  };
  for (const noteType of parsed.includeTypes) {
    let sql = `SELECT * FROM narrative_notes WHERE world_id = ? AND type = ?`;
    const params = [parsed.worldId, noteType];
    if (parsed.statusFilter.length > 0) {
      sql += ` AND status IN (${parsed.statusFilter.map(() => "?").join(",")})`;
      params.push(...parsed.statusFilter);
    }
    if (parsed.forPlayer) {
      sql += ` AND visibility = 'player_visible'`;
    }
    sql += ` ORDER BY created_at DESC LIMIT ?`;
    params.push(parsed.maxPerType);
    const notes = db.prepare(sql).all(...params);
    if (notes.length > 0) {
      sections.push({
        title: typeLabels[noteType] || noteType.toUpperCase(),
        notes: notes.map((n2) => ({
          id: n2.id,
          content: n2.content,
          metadata: JSON.parse(n2.metadata || "{}"),
          tags: JSON.parse(n2.tags || "[]"),
          status: n2.status,
          entityId: n2.entity_id,
          entityType: n2.entity_type,
          createdAt: n2.created_at
        })),
        priority: typePriority[noteType] || 0
      });
    }
  }
  sections.sort((a, b) => b.priority - a.priority);
  let contextText = "";
  for (const section of sections) {
    contextText += `--- ${section.title} ---
`;
    for (const note of section.notes) {
      contextText += `\u2022 ${note.content}`;
      if (note.metadata && Object.keys(note.metadata).length > 0) {
        const metaStr = Object.entries(note.metadata).filter(([_, v]) => v !== void 0 && v !== null && (Array.isArray(v) ? v.length > 0 : true)).map(([k, v]) => `${k}: ${Array.isArray(v) ? v.join(", ") : v}`).join(" | ");
        if (metaStr)
          contextText += ` [${metaStr}]`;
      }
      if (note.tags && note.tags.length > 0) {
        contextText += ` #${note.tags.join(" #")}`;
      }
      contextText += "\n";
    }
    contextText += "\n";
  }
  return {
    content: [{
      type: "text",
      text: contextText.trim() || "(No narrative notes found for this world)"
    }]
  };
}

// dist/server/tool-registry.js
function meta(name, description, category, keywords, capabilities, contextAware = false, estimatedTokenCost = "medium", deferLoading = true) {
  return {
    name,
    description,
    category,
    keywords,
    capabilities,
    contextAware,
    estimatedTokenCost,
    usageExample: `${name}({ ... })`,
    deferLoading
  };
}
var cachedRegistry = null;
function buildToolRegistry() {
  if (cachedRegistry)
    return cachedRegistry;
  cachedRegistry = {
    // === WORLD TOOLS ===
    [Tools.GENERATE_WORLD.name]: {
      metadata: meta(Tools.GENERATE_WORLD.name, Tools.GENERATE_WORLD.description, "world", ["world", "generation", "seed", "terrain", "biome", "procedural"], ["Procedural world generation", "Biome distribution", "River generation"], true, "high"),
      schema: Tools.GENERATE_WORLD.inputSchema,
      handler: handleGenerateWorld
    },
    [Tools.GET_WORLD_STATE.name]: {
      metadata: meta(Tools.GET_WORLD_STATE.name, Tools.GET_WORLD_STATE.description, "world", ["world", "state", "query", "environment"], ["World state retrieval", "Environment info"], true, "high"),
      schema: Tools.GET_WORLD_STATE.inputSchema,
      handler: handleGetWorldState
    },
    [Tools.APPLY_MAP_PATCH.name]: {
      metadata: meta(Tools.APPLY_MAP_PATCH.name, Tools.APPLY_MAP_PATCH.description, "world", ["map", "patch", "edit", "terrain", "structure"], ["Terrain modification", "Structure placement"], false, "medium"),
      schema: Tools.APPLY_MAP_PATCH.inputSchema,
      handler: handleApplyMapPatch
    },
    [Tools.GET_WORLD_MAP_OVERVIEW.name]: {
      metadata: meta(Tools.GET_WORLD_MAP_OVERVIEW.name, Tools.GET_WORLD_MAP_OVERVIEW.description, "world", ["map", "overview", "biome", "region", "statistics"], ["Map overview", "Biome distribution"], true, "high"),
      schema: Tools.GET_WORLD_MAP_OVERVIEW.inputSchema,
      handler: handleGetWorldMapOverview
    },
    [Tools.GET_REGION_MAP.name]: {
      metadata: meta(Tools.GET_REGION_MAP.name, Tools.GET_REGION_MAP.description, "world", ["region", "map", "terrain", "tiles"], ["Regional mapping", "Tile details"], false, "medium"),
      schema: Tools.GET_REGION_MAP.inputSchema,
      handler: handleGetRegionMap
    },
    [Tools.GET_WORLD_TILES.name]: {
      metadata: meta(Tools.GET_WORLD_TILES.name, Tools.GET_WORLD_TILES.description, "world", ["tiles", "grid", "render", "map", "visualization"], ["Full tile grid", "Visualization data"], true, "high"),
      schema: Tools.GET_WORLD_TILES.inputSchema,
      handler: handleGetWorldTiles
    },
    [Tools.PREVIEW_MAP_PATCH.name]: {
      metadata: meta(Tools.PREVIEW_MAP_PATCH.name, Tools.PREVIEW_MAP_PATCH.description, "world", ["preview", "patch", "simulate", "dsl"], ["Non-destructive preview", "DSL validation"], false, "low"),
      schema: Tools.PREVIEW_MAP_PATCH.inputSchema,
      handler: handlePreviewMapPatch
    },
    [Tools.FIND_VALID_POI_LOCATION.name]: {
      metadata: meta(Tools.FIND_VALID_POI_LOCATION.name, Tools.FIND_VALID_POI_LOCATION.description, "world", ["poi", "location", "placement", "terrain", "valid"], ["Terrain-aware placement", "Suitability scoring"], false, "medium"),
      schema: Tools.FIND_VALID_POI_LOCATION.inputSchema,
      handler: handleFindValidPoiLocation
    },
    [Tools.SUGGEST_POI_LOCATIONS.name]: {
      metadata: meta(Tools.SUGGEST_POI_LOCATIONS.name, Tools.SUGGEST_POI_LOCATIONS.description, "world", ["poi", "suggestions", "locations", "batch", "placement"], ["Multiple suggestions", "Suitability ranking"], false, "medium"),
      schema: Tools.SUGGEST_POI_LOCATIONS.inputSchema,
      handler: handleSuggestPoiLocations
    },
    // === COMBAT TOOLS ===
    [CombatTools.CREATE_ENCOUNTER.name]: {
      metadata: meta(CombatTools.CREATE_ENCOUNTER.name, CombatTools.CREATE_ENCOUNTER.description, "combat", ["encounter", "combat", "battle", "initiative", "fight"], ["Initiative rolling", "Participant setup", "Combat state"], false, "medium", false),
      schema: CombatTools.CREATE_ENCOUNTER.inputSchema,
      handler: handleCreateEncounter
    },
    [CombatTools.GET_ENCOUNTER_STATE.name]: {
      metadata: meta(CombatTools.GET_ENCOUNTER_STATE.name, CombatTools.GET_ENCOUNTER_STATE.description, "combat", ["encounter", "state", "turn", "status", "combat"], ["Encounter status", "Combatant info", "Turn order"], true, "high", false),
      schema: CombatTools.GET_ENCOUNTER_STATE.inputSchema,
      handler: handleGetEncounterState
    },
    [CombatTools.EXECUTE_COMBAT_ACTION.name]: {
      metadata: meta(CombatTools.EXECUTE_COMBAT_ACTION.name, CombatTools.EXECUTE_COMBAT_ACTION.description, "combat", ["action", "attack", "heal", "move", "combat", "damage"], ["Attack resolution", "Damage calculation", "Movement"], false, "medium"),
      schema: CombatTools.EXECUTE_COMBAT_ACTION.inputSchema,
      handler: handleExecuteCombatAction
    },
    [CombatTools.ADVANCE_TURN.name]: {
      metadata: meta(CombatTools.ADVANCE_TURN.name, CombatTools.ADVANCE_TURN.description, "combat", ["turn", "advance", "next", "combat", "initiative"], ["Turn progression", "Initiative tracking"], false, "low"),
      schema: CombatTools.ADVANCE_TURN.inputSchema,
      handler: handleAdvanceTurn
    },
    [CombatTools.END_ENCOUNTER.name]: {
      metadata: meta(CombatTools.END_ENCOUNTER.name, CombatTools.END_ENCOUNTER.description, "combat", ["end", "encounter", "combat", "conclude", "finish"], ["Combat resolution", "Cleanup"], false, "low"),
      schema: CombatTools.END_ENCOUNTER.inputSchema,
      handler: handleEndEncounter
    },
    [CombatTools.LOAD_ENCOUNTER.name]: {
      metadata: meta(CombatTools.LOAD_ENCOUNTER.name, CombatTools.LOAD_ENCOUNTER.description, "combat", ["load", "encounter", "restore", "resume"], ["Encounter persistence"], false, "medium"),
      schema: CombatTools.LOAD_ENCOUNTER.inputSchema,
      handler: handleLoadEncounter
    },
    [CombatTools.ROLL_DEATH_SAVE.name]: {
      metadata: meta(CombatTools.ROLL_DEATH_SAVE.name, CombatTools.ROLL_DEATH_SAVE.description, "combat", ["death", "save", "dying", "unconscious", "d20"], ["Death saving throw", "Unconsciousness tracking"], false, "low"),
      schema: CombatTools.ROLL_DEATH_SAVE.inputSchema,
      handler: handleRollDeathSave
    },
    [CombatTools.EXECUTE_LAIR_ACTION.name]: {
      metadata: meta(CombatTools.EXECUTE_LAIR_ACTION.name, CombatTools.EXECUTE_LAIR_ACTION.description, "combat", ["lair", "action", "legendary", "environment", "boss"], ["Lair action resolution", "Environmental effects"], false, "medium"),
      schema: CombatTools.EXECUTE_LAIR_ACTION.inputSchema,
      handler: handleExecuteLairAction
    },
    // === COMBAT VISUALIZATION TOOLS ===
    [CombatTools.RENDER_MAP.name]: {
      metadata: meta(CombatTools.RENDER_MAP.name, CombatTools.RENDER_MAP.description, "combat", ["map", "grid", "visualization", "ascii", "combat", "position", "spatial"], ["Combat map visualization", "Participant positions", "Terrain display"], true, "medium"),
      schema: CombatTools.RENDER_MAP.inputSchema,
      handler: handleRenderMap
    },
    [CombatTools.CALCULATE_AOE.name]: {
      metadata: meta(CombatTools.CALCULATE_AOE.name, CombatTools.CALCULATE_AOE.description, "combat", ["aoe", "area", "effect", "fireball", "cone", "line", "spell", "radius"], ["AoE calculation", "Target detection", "Spell area"], false, "medium"),
      schema: CombatTools.CALCULATE_AOE.inputSchema,
      handler: handleCalculateAoe
    },
    [CombatTools.UPDATE_TERRAIN.name]: {
      metadata: meta(CombatTools.UPDATE_TERRAIN.name, CombatTools.UPDATE_TERRAIN.description, "combat", ["terrain", "update", "add", "remove", "obstacle", "water", "difficult", "battlefield"], ["Dynamic terrain", "On-the-fly map editing", "Mid-combat terrain changes"], false, "medium"),
      schema: CombatTools.UPDATE_TERRAIN.inputSchema,
      handler: handleUpdateTerrain
    },
    [CombatTools.PLACE_PROP.name]: {
      metadata: meta(CombatTools.PLACE_PROP.name, CombatTools.PLACE_PROP.description, "combat", ["prop", "object", "terrain", "tree", "ladder", "building", "cover", "improv", "battlefield"], ["Improvised props", "Battlefield objects", "Cover placement"], false, "medium"),
      schema: CombatTools.PLACE_PROP.inputSchema,
      handler: handlePlaceProp
    },
    [CombatTools.MEASURE_DISTANCE.name]: {
      metadata: meta(CombatTools.MEASURE_DISTANCE.name, CombatTools.MEASURE_DISTANCE.description, "combat", ["distance", "measure", "range", "feet", "squares", "movement", "spatial"], ["Distance calculation", "Range measurement", "Movement planning"], true, "low"),
      schema: CombatTools.MEASURE_DISTANCE.inputSchema,
      handler: handleMeasureDistance
    },
    [CombatTools.GENERATE_TERRAIN_PATCH.name]: {
      metadata: meta(CombatTools.GENERATE_TERRAIN_PATCH.name, CombatTools.GENERATE_TERRAIN_PATCH.description, "combat", ["terrain", "biome", "generate", "procedural", "forest", "cave", "dungeon", "village", "swamp", "battlefield"], ["Procedural terrain generation", "Biome presets", "Mass terrain placement"], false, "medium"),
      schema: CombatTools.GENERATE_TERRAIN_PATCH.inputSchema,
      handler: handleGenerateTerrainPatch
    },
    [CombatTools.GENERATE_TERRAIN_PATTERN.name]: {
      metadata: meta(CombatTools.GENERATE_TERRAIN_PATTERN.name, CombatTools.GENERATE_TERRAIN_PATTERN.description, "combat", ["terrain", "pattern", "generate", "river", "canyon", "arena", "valley", "geometric", "layout"], ["Geometric terrain patterns", "Consistent layouts", "River valleys, canyons, arenas"], false, "medium"),
      schema: CombatTools.GENERATE_TERRAIN_PATTERN.inputSchema,
      handler: handleGenerateTerrainPattern
    },
    // === CHARACTER/CRUD TOOLS ===
    [CRUDTools.CREATE_WORLD.name]: {
      metadata: meta(CRUDTools.CREATE_WORLD.name, CRUDTools.CREATE_WORLD.description, "world", ["world", "create", "new", "initialize"], ["World creation", "Initialization"], false, "medium"),
      schema: CRUDTools.CREATE_WORLD.inputSchema,
      handler: handleCreateWorld
    },
    [CRUDTools.GET_WORLD.name]: {
      metadata: meta(CRUDTools.GET_WORLD.name, CRUDTools.GET_WORLD.description, "world", ["world", "get", "retrieve", "fetch"], ["World retrieval"], false, "medium"),
      schema: CRUDTools.GET_WORLD.inputSchema,
      handler: handleGetWorld
    },
    [CRUDTools.LIST_WORLDS.name]: {
      metadata: meta(CRUDTools.LIST_WORLDS.name, CRUDTools.LIST_WORLDS.description, "world", ["world", "list", "all", "query"], ["World listing"], false, "medium"),
      schema: CRUDTools.LIST_WORLDS.inputSchema,
      handler: handleListWorlds
    },
    [CRUDTools.UPDATE_WORLD_ENVIRONMENT.name]: {
      metadata: meta(CRUDTools.UPDATE_WORLD_ENVIRONMENT.name, CRUDTools.UPDATE_WORLD_ENVIRONMENT.description, "world", ["world", "environment", "time", "weather", "season"], ["Environmental updates", "Season/time"], false, "low"),
      schema: CRUDTools.UPDATE_WORLD_ENVIRONMENT.inputSchema,
      handler: handleUpdateWorldEnvironment
    },
    [CRUDTools.DELETE_WORLD.name]: {
      metadata: meta(CRUDTools.DELETE_WORLD.name, CRUDTools.DELETE_WORLD.description, "world", ["world", "delete", "remove"], ["World deletion"], false, "low"),
      schema: CRUDTools.DELETE_WORLD.inputSchema,
      handler: handleDeleteWorld
    },
    [CRUDTools.CREATE_CHARACTER.name]: {
      metadata: meta(CRUDTools.CREATE_CHARACTER.name, CRUDTools.CREATE_CHARACTER.description, "character", ["character", "create", "new", "player", "npc", "pc"], ["Character creation", "Class/race setup"], false, "medium", false),
      schema: CRUDTools.CREATE_CHARACTER.inputSchema,
      handler: handleCreateCharacter
    },
    [CRUDTools.GET_CHARACTER.name]: {
      metadata: meta(CRUDTools.GET_CHARACTER.name, CRUDTools.GET_CHARACTER.description, "character", ["character", "get", "retrieve", "info", "sheet"], ["Character retrieval", "Full character sheet"], false, "medium", false),
      schema: CRUDTools.GET_CHARACTER.inputSchema,
      handler: handleGetCharacter
    },
    [CRUDTools.UPDATE_CHARACTER.name]: {
      metadata: meta(CRUDTools.UPDATE_CHARACTER.name, CRUDTools.UPDATE_CHARACTER.description, "character", ["character", "update", "modify", "change", "edit"], ["Character modification", "Stat updates"], false, "medium"),
      schema: CRUDTools.UPDATE_CHARACTER.inputSchema,
      handler: handleUpdateCharacter
    },
    [CRUDTools.LIST_CHARACTERS.name]: {
      metadata: meta(CRUDTools.LIST_CHARACTERS.name, CRUDTools.LIST_CHARACTERS.description, "character", ["character", "list", "all", "query", "search"], ["Character listing", "Filtering"], true, "medium"),
      schema: CRUDTools.LIST_CHARACTERS.inputSchema,
      handler: handleListCharacters
    },
    [CRUDTools.DELETE_CHARACTER.name]: {
      metadata: meta(CRUDTools.DELETE_CHARACTER.name, CRUDTools.DELETE_CHARACTER.description, "character", ["character", "delete", "remove"], ["Character deletion"], false, "low"),
      schema: CRUDTools.DELETE_CHARACTER.inputSchema,
      handler: handleDeleteCharacter
    },
    // === PROGRESSION TOOLS ===
    [ProgressionTools.ADD_XP.name]: {
      metadata: meta(ProgressionTools.ADD_XP.name, ProgressionTools.ADD_XP.description, "character", ["xp", "experience", "level", "progression", "growth"], ["XP tracking", "Level up detection"], false, "low"),
      schema: ProgressionTools.ADD_XP.inputSchema,
      handler: handleAddXp
    },
    [ProgressionTools.GET_LEVEL_PROGRESSION.name]: {
      metadata: meta(ProgressionTools.GET_LEVEL_PROGRESSION.name, ProgressionTools.GET_LEVEL_PROGRESSION.description, "character", ["level", "progression", "xp", "next", "threshold"], ["XP requirements lookup"], true, "low"),
      schema: ProgressionTools.GET_LEVEL_PROGRESSION.inputSchema,
      handler: handleGetLevelProgression
    },
    [ProgressionTools.LEVEL_UP.name]: {
      metadata: meta(ProgressionTools.LEVEL_UP.name, ProgressionTools.LEVEL_UP.description, "character", ["level", "up", "increase", "stats", "hp"], ["Level increment", "Stat updates"], false, "medium"),
      schema: ProgressionTools.LEVEL_UP.inputSchema,
      handler: handleLevelUp
    },
    // === NARRATIVE MEMORY TOOLS ===
    [NarrativeTools.ADD_NARRATIVE_NOTE.name]: {
      metadata: meta(NarrativeTools.ADD_NARRATIVE_NOTE.name, NarrativeTools.ADD_NARRATIVE_NOTE.description, "narrative", ["narrative", "note", "plot", "thread", "story", "memory", "session", "canonical"], ["Plot tracking", "Canonical moments", "NPC voices", "Foreshadowing"], false, "low"),
      schema: NarrativeTools.ADD_NARRATIVE_NOTE.inputSchema,
      handler: handleAddNarrativeNote
    },
    [NarrativeTools.SEARCH_NARRATIVE_NOTES.name]: {
      metadata: meta(NarrativeTools.SEARCH_NARRATIVE_NOTES.name, NarrativeTools.SEARCH_NARRATIVE_NOTES.description, "narrative", ["narrative", "search", "filter", "notes", "memory", "query"], ["Note retrieval", "Filtering by type/tag"], true, "medium"),
      schema: NarrativeTools.SEARCH_NARRATIVE_NOTES.inputSchema,
      handler: handleSearchNarrativeNotes
    },
    [NarrativeTools.UPDATE_NARRATIVE_NOTE.name]: {
      metadata: meta(NarrativeTools.UPDATE_NARRATIVE_NOTE.name, NarrativeTools.UPDATE_NARRATIVE_NOTE.description, "narrative", ["narrative", "update", "resolve", "status", "edit"], ["Note status updates", "Plot resolution"], false, "low"),
      schema: NarrativeTools.UPDATE_NARRATIVE_NOTE.inputSchema,
      handler: handleUpdateNarrativeNote
    },
    [NarrativeTools.GET_NARRATIVE_NOTE.name]: {
      metadata: meta(NarrativeTools.GET_NARRATIVE_NOTE.name, NarrativeTools.GET_NARRATIVE_NOTE.description, "narrative", ["narrative", "get", "retrieve", "note"], ["Single note retrieval"], false, "low"),
      schema: NarrativeTools.GET_NARRATIVE_NOTE.inputSchema,
      handler: handleGetNarrativeNote
    },
    [NarrativeTools.DELETE_NARRATIVE_NOTE.name]: {
      metadata: meta(NarrativeTools.DELETE_NARRATIVE_NOTE.name, NarrativeTools.DELETE_NARRATIVE_NOTE.description, "narrative", ["narrative", "delete", "remove", "note"], ["Note deletion"], false, "low"),
      schema: NarrativeTools.DELETE_NARRATIVE_NOTE.inputSchema,
      handler: handleDeleteNarrativeNote
    },
    [NarrativeTools.GET_NARRATIVE_CONTEXT.name]: {
      metadata: meta(NarrativeTools.GET_NARRATIVE_CONTEXT.name, NarrativeTools.GET_NARRATIVE_CONTEXT.description, "narrative", ["narrative", "context", "llm", "inject", "prompt", "memory", "hot"], ["Aggregated context", "LLM prompt injection"], true, "high"),
      schema: NarrativeTools.GET_NARRATIVE_CONTEXT.inputSchema,
      handler: handleGetNarrativeContextNotes
    },
    // === PARTY TOOLS ===
    [PartyTools.CREATE_PARTY.name]: {
      metadata: meta(PartyTools.CREATE_PARTY.name, PartyTools.CREATE_PARTY.description, "party", ["party", "create", "new", "group", "adventuring"], ["Party formation", "Member setup"], false, "medium"),
      schema: PartyTools.CREATE_PARTY.inputSchema,
      handler: handleCreateParty
    },
    [PartyTools.GET_PARTY.name]: {
      metadata: meta(PartyTools.GET_PARTY.name, PartyTools.GET_PARTY.description, "party", ["party", "get", "retrieve", "info", "members"], ["Full party info", "Member details"], true, "high"),
      schema: PartyTools.GET_PARTY.inputSchema,
      handler: handleGetParty
    },
    [PartyTools.LIST_PARTIES.name]: {
      metadata: meta(PartyTools.LIST_PARTIES.name, PartyTools.LIST_PARTIES.description, "party", ["party", "list", "all", "groups"], ["Party listing", "Multiple parties"], true, "medium"),
      schema: PartyTools.LIST_PARTIES.inputSchema,
      handler: handleListParties
    },
    [PartyTools.UPDATE_PARTY.name]: {
      metadata: meta(PartyTools.UPDATE_PARTY.name, PartyTools.UPDATE_PARTY.description, "party", ["party", "update", "modify", "edit"], ["Party metadata update"], false, "low"),
      schema: PartyTools.UPDATE_PARTY.inputSchema,
      handler: handleUpdateParty
    },
    [PartyTools.DELETE_PARTY.name]: {
      metadata: meta(PartyTools.DELETE_PARTY.name, PartyTools.DELETE_PARTY.description, "party", ["party", "delete", "remove", "disband"], ["Party deletion"], false, "low"),
      schema: PartyTools.DELETE_PARTY.inputSchema,
      handler: handleDeleteParty
    },
    [PartyTools.ADD_PARTY_MEMBER.name]: {
      metadata: meta(PartyTools.ADD_PARTY_MEMBER.name, PartyTools.ADD_PARTY_MEMBER.description, "party", ["party", "member", "add", "join", "recruit"], ["Member addition", "Role assignment"], false, "low"),
      schema: PartyTools.ADD_PARTY_MEMBER.inputSchema,
      handler: handleAddPartyMember
    },
    [PartyTools.REMOVE_PARTY_MEMBER.name]: {
      metadata: meta(PartyTools.REMOVE_PARTY_MEMBER.name, PartyTools.REMOVE_PARTY_MEMBER.description, "party", ["party", "member", "remove", "leave", "kick"], ["Member removal"], false, "low"),
      schema: PartyTools.REMOVE_PARTY_MEMBER.inputSchema,
      handler: handleRemovePartyMember
    },
    [PartyTools.UPDATE_PARTY_MEMBER.name]: {
      metadata: meta(PartyTools.UPDATE_PARTY_MEMBER.name, PartyTools.UPDATE_PARTY_MEMBER.description, "party", ["party", "member", "update", "role", "position"], ["Member role/position update"], false, "low"),
      schema: PartyTools.UPDATE_PARTY_MEMBER.inputSchema,
      handler: handleUpdatePartyMember
    },
    [PartyTools.SET_PARTY_LEADER.name]: {
      metadata: meta(PartyTools.SET_PARTY_LEADER.name, PartyTools.SET_PARTY_LEADER.description, "party", ["party", "leader", "designate", "captain"], ["Leader assignment"], false, "low"),
      schema: PartyTools.SET_PARTY_LEADER.inputSchema,
      handler: handleSetPartyLeader
    },
    [PartyTools.SET_ACTIVE_CHARACTER.name]: {
      metadata: meta(PartyTools.SET_ACTIVE_CHARACTER.name, PartyTools.SET_ACTIVE_CHARACTER.description, "party", ["party", "active", "player", "character", "pov", "focus"], ["Active character selection", "POV"], false, "low"),
      schema: PartyTools.SET_ACTIVE_CHARACTER.inputSchema,
      handler: handleSetActiveCharacter
    },
    [PartyTools.GET_PARTY_MEMBERS.name]: {
      metadata: meta(PartyTools.GET_PARTY_MEMBERS.name, PartyTools.GET_PARTY_MEMBERS.description, "party", ["party", "member", "list", "all", "roster"], ["Member listing with details"], true, "high"),
      schema: PartyTools.GET_PARTY_MEMBERS.inputSchema,
      handler: handleGetPartyMembers
    },
    [PartyTools.GET_PARTY_CONTEXT.name]: {
      metadata: meta(PartyTools.GET_PARTY_CONTEXT.name, PartyTools.GET_PARTY_CONTEXT.description, "party", ["party", "context", "summary", "brief", "llm"], ["Condensed party context", "LLM-friendly format"], true, "medium"),
      schema: PartyTools.GET_PARTY_CONTEXT.inputSchema,
      handler: handleGetPartyContext
    },
    [PartyTools.GET_UNASSIGNED_CHARACTERS.name]: {
      metadata: meta(PartyTools.GET_UNASSIGNED_CHARACTERS.name, PartyTools.GET_UNASSIGNED_CHARACTERS.description, "character", ["character", "unassigned", "available", "free"], ["Available character listing"], false, "medium"),
      schema: PartyTools.GET_UNASSIGNED_CHARACTERS.inputSchema,
      handler: handleGetUnassignedCharacters
    },
    [PartyTools.MOVE_PARTY.name]: {
      metadata: meta(PartyTools.MOVE_PARTY.name, PartyTools.MOVE_PARTY.description, "spatial", ["party", "move", "travel", "location", "position"], ["Party positioning", "World map movement"], false, "low"),
      schema: PartyTools.MOVE_PARTY.inputSchema,
      handler: handleMoveParty
    },
    [PartyTools.GET_PARTY_POSITION.name]: {
      metadata: meta(PartyTools.GET_PARTY_POSITION.name, PartyTools.GET_PARTY_POSITION.description, "spatial", ["party", "position", "location", "coordinates", "where"], ["Party location retrieval"], false, "low"),
      schema: PartyTools.GET_PARTY_POSITION.inputSchema,
      handler: handleGetPartyPosition
    },
    [PartyTools.GET_PARTIES_IN_REGION.name]: {
      metadata: meta(PartyTools.GET_PARTIES_IN_REGION.name, PartyTools.GET_PARTIES_IN_REGION.description, "spatial", ["party", "region", "nearby", "proximity", "search"], ["Regional party discovery"], false, "medium"),
      schema: PartyTools.GET_PARTIES_IN_REGION.inputSchema,
      handler: handleGetPartiesInRegion
    },
    // === INVENTORY TOOLS ===
    [InventoryTools.CREATE_ITEM_TEMPLATE.name]: {
      metadata: meta(InventoryTools.CREATE_ITEM_TEMPLATE.name, InventoryTools.CREATE_ITEM_TEMPLATE.description, "inventory", ["item", "template", "create", "type", "define"], ["Item type creation", "Properties"], false, "low"),
      schema: InventoryTools.CREATE_ITEM_TEMPLATE.inputSchema,
      handler: handleCreateItemTemplate
    },
    [InventoryTools.GIVE_ITEM.name]: {
      metadata: meta(InventoryTools.GIVE_ITEM.name, InventoryTools.GIVE_ITEM.description, "inventory", ["item", "give", "grant", "add", "receive"], ["Item assignment", "Quantity tracking"], false, "low"),
      schema: InventoryTools.GIVE_ITEM.inputSchema,
      handler: handleGiveItem
    },
    [InventoryTools.REMOVE_ITEM.name]: {
      metadata: meta(InventoryTools.REMOVE_ITEM.name, InventoryTools.REMOVE_ITEM.description, "inventory", ["item", "remove", "drop", "delete", "discard"], ["Item removal"], false, "low"),
      schema: InventoryTools.REMOVE_ITEM.inputSchema,
      handler: handleRemoveItem
    },
    [InventoryTools.EQUIP_ITEM.name]: {
      metadata: meta(InventoryTools.EQUIP_ITEM.name, InventoryTools.EQUIP_ITEM.description, "inventory", ["item", "equip", "wield", "wear", "slot"], ["Equipment slot management"], false, "low"),
      schema: InventoryTools.EQUIP_ITEM.inputSchema,
      handler: handleEquipItem
    },
    [InventoryTools.UNEQUIP_ITEM.name]: {
      metadata: meta(InventoryTools.UNEQUIP_ITEM.name, InventoryTools.UNEQUIP_ITEM.description, "inventory", ["item", "unequip", "remove", "store", "doff"], ["Equipment removal"], false, "low"),
      schema: InventoryTools.UNEQUIP_ITEM.inputSchema,
      handler: handleUnequipItem
    },
    [InventoryTools.GET_INVENTORY.name]: {
      metadata: meta(InventoryTools.GET_INVENTORY.name, InventoryTools.GET_INVENTORY.description, "inventory", ["inventory", "items", "list", "bag", "backpack"], ["Inventory listing", "Item tracking"], true, "medium"),
      schema: InventoryTools.GET_INVENTORY.inputSchema,
      handler: handleGetInventory
    },
    [InventoryTools.GET_ITEM.name]: {
      metadata: meta(InventoryTools.GET_ITEM.name, InventoryTools.GET_ITEM.description, "inventory", ["item", "get", "retrieve", "details", "info"], ["Item details"], false, "low"),
      schema: InventoryTools.GET_ITEM.inputSchema,
      handler: handleGetItem
    },
    [InventoryTools.LIST_ITEMS.name]: {
      metadata: meta(InventoryTools.LIST_ITEMS.name, InventoryTools.LIST_ITEMS.description, "inventory", ["item", "list", "all", "template", "catalog"], ["Item type listing"], false, "medium"),
      schema: InventoryTools.LIST_ITEMS.inputSchema,
      handler: handleListItems
    },
    [InventoryTools.SEARCH_ITEMS.name]: {
      metadata: meta(InventoryTools.SEARCH_ITEMS.name, InventoryTools.SEARCH_ITEMS.description, "inventory", ["item", "search", "filter", "find", "query"], ["Item search/filtering"], false, "medium"),
      schema: InventoryTools.SEARCH_ITEMS.inputSchema,
      handler: handleSearchItems
    },
    [InventoryTools.UPDATE_ITEM.name]: {
      metadata: meta(InventoryTools.UPDATE_ITEM.name, InventoryTools.UPDATE_ITEM.description, "inventory", ["item", "update", "modify", "edit"], ["Item property updates"], false, "low"),
      schema: InventoryTools.UPDATE_ITEM.inputSchema,
      handler: handleUpdateItem
    },
    [InventoryTools.DELETE_ITEM.name]: {
      metadata: meta(InventoryTools.DELETE_ITEM.name, InventoryTools.DELETE_ITEM.description, "inventory", ["item", "delete", "remove", "type"], ["Item type deletion"], false, "low"),
      schema: InventoryTools.DELETE_ITEM.inputSchema,
      handler: handleDeleteItem
    },
    [InventoryTools.TRANSFER_ITEM.name]: {
      metadata: meta(InventoryTools.TRANSFER_ITEM.name, InventoryTools.TRANSFER_ITEM.description, "inventory", ["item", "transfer", "trade", "exchange", "give"], ["Item exchange between characters"], false, "low"),
      schema: InventoryTools.TRANSFER_ITEM.inputSchema,
      handler: handleTransferItem
    },
    [InventoryTools.USE_ITEM.name]: {
      metadata: meta(InventoryTools.USE_ITEM.name, InventoryTools.USE_ITEM.description, "inventory", ["item", "use", "consume", "activate", "potion"], ["Consumable item usage"], false, "medium"),
      schema: InventoryTools.USE_ITEM.inputSchema,
      handler: handleUseItem
    },
    [InventoryTools.GET_INVENTORY_DETAILED.name]: {
      metadata: meta(InventoryTools.GET_INVENTORY_DETAILED.name, InventoryTools.GET_INVENTORY_DETAILED.description, "inventory", ["inventory", "detailed", "full", "equipped", "complete"], ["Detailed inventory with equipped items"], true, "high"),
      schema: InventoryTools.GET_INVENTORY_DETAILED.inputSchema,
      handler: handleGetInventoryDetailed
    },
    // === QUEST TOOLS ===
    [QuestTools.CREATE_QUEST.name]: {
      metadata: meta(QuestTools.CREATE_QUEST.name, QuestTools.CREATE_QUEST.description, "quest", ["quest", "create", "new", "mission", "objective"], ["Quest creation", "Objective setup"], false, "medium"),
      schema: QuestTools.CREATE_QUEST.inputSchema,
      handler: handleCreateQuest
    },
    [QuestTools.GET_QUEST.name]: {
      metadata: meta(QuestTools.GET_QUEST.name, QuestTools.GET_QUEST.description, "quest", ["quest", "get", "retrieve", "details", "info"], ["Quest retrieval with objectives"], false, "medium"),
      schema: QuestTools.GET_QUEST.inputSchema,
      handler: handleGetQuest
    },
    [QuestTools.LIST_QUESTS.name]: {
      metadata: meta(QuestTools.LIST_QUESTS.name, QuestTools.LIST_QUESTS.description, "quest", ["quest", "list", "all", "query", "active"], ["Quest listing", "Filtering"], true, "medium"),
      schema: QuestTools.LIST_QUESTS.inputSchema,
      handler: handleListQuests
    },
    [QuestTools.ASSIGN_QUEST.name]: {
      metadata: meta(QuestTools.ASSIGN_QUEST.name, QuestTools.ASSIGN_QUEST.description, "quest", ["quest", "assign", "give", "character", "accept"], ["Quest assignment to character"], false, "low"),
      schema: QuestTools.ASSIGN_QUEST.inputSchema,
      handler: handleAssignQuest
    },
    [QuestTools.UPDATE_OBJECTIVE.name]: {
      metadata: meta(QuestTools.UPDATE_OBJECTIVE.name, QuestTools.UPDATE_OBJECTIVE.description, "quest", ["quest", "objective", "progress", "update", "track"], ["Objective progress tracking"], false, "low"),
      schema: QuestTools.UPDATE_OBJECTIVE.inputSchema,
      handler: handleUpdateObjective
    },
    [QuestTools.COMPLETE_OBJECTIVE.name]: {
      metadata: meta(QuestTools.COMPLETE_OBJECTIVE.name, QuestTools.COMPLETE_OBJECTIVE.description, "quest", ["quest", "objective", "complete", "finish", "done"], ["Objective completion"], false, "low"),
      schema: QuestTools.COMPLETE_OBJECTIVE.inputSchema,
      handler: handleCompleteObjective
    },
    [QuestTools.COMPLETE_QUEST.name]: {
      metadata: meta(QuestTools.COMPLETE_QUEST.name, QuestTools.COMPLETE_QUEST.description, "quest", ["quest", "complete", "finish", "reward", "turn-in"], ["Quest completion", "Reward granting"], false, "medium"),
      schema: QuestTools.COMPLETE_QUEST.inputSchema,
      handler: handleCompleteQuest
    },
    [QuestTools.GET_QUEST_LOG.name]: {
      metadata: meta(QuestTools.GET_QUEST_LOG.name, QuestTools.GET_QUEST_LOG.description, "quest", ["quest", "log", "character", "journal", "active"], ["Character quest history", "Active quests"], true, "medium"),
      schema: QuestTools.GET_QUEST_LOG.inputSchema,
      handler: handleGetQuestLog
    },
    // === MATH TOOLS ===
    [MathTools.DICE_ROLL.name]: {
      metadata: meta(MathTools.DICE_ROLL.name, MathTools.DICE_ROLL.description, "math", ["dice", "roll", "random", "d20", "d6", "probability"], ["Dice rolling", "Probability notation support"], false, "low", false),
      schema: MathTools.DICE_ROLL.inputSchema,
      handler: handleDiceRoll
    },
    [MathTools.PROBABILITY_CALCULATE.name]: {
      metadata: meta(MathTools.PROBABILITY_CALCULATE.name, MathTools.PROBABILITY_CALCULATE.description, "math", ["probability", "calculate", "chance", "odds", "statistics"], ["Probability calculation", "Distribution analysis"], false, "low"),
      schema: MathTools.PROBABILITY_CALCULATE.inputSchema,
      handler: handleProbabilityCalculate
    },
    [MathTools.ALGEBRA_SOLVE.name]: {
      metadata: meta(MathTools.ALGEBRA_SOLVE.name, MathTools.ALGEBRA_SOLVE.description, "math", ["algebra", "solve", "equation", "math", "variable"], ["Equation solving", "Variable isolation"], false, "low"),
      schema: MathTools.ALGEBRA_SOLVE.inputSchema,
      handler: handleAlgebraSolve
    },
    [MathTools.ALGEBRA_SIMPLIFY.name]: {
      metadata: meta(MathTools.ALGEBRA_SIMPLIFY.name, MathTools.ALGEBRA_SIMPLIFY.description, "math", ["algebra", "simplify", "expression", "reduce"], ["Expression simplification"], false, "low"),
      schema: MathTools.ALGEBRA_SIMPLIFY.inputSchema,
      handler: handleAlgebraSimplify
    },
    [MathTools.PHYSICS_PROJECTILE.name]: {
      metadata: meta(MathTools.PHYSICS_PROJECTILE.name, MathTools.PHYSICS_PROJECTILE.description, "math", ["physics", "projectile", "trajectory", "motion", "ballistics"], ["Projectile motion calculation", "Range/impact"], false, "low"),
      schema: MathTools.PHYSICS_PROJECTILE.inputSchema,
      handler: handlePhysicsProjectile
    },
    // === STRATEGY TOOLS ===
    [StrategyTools.CREATE_NATION.name]: {
      metadata: meta(StrategyTools.CREATE_NATION.name, StrategyTools.CREATE_NATION.description, "strategy", ["nation", "create", "new", "country", "faction"], ["Nation creation", "Ideology/resources setup"], false, "medium"),
      schema: StrategyTools.CREATE_NATION.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.CREATE_NATION.name, args)
    },
    [StrategyTools.GET_STRATEGY_STATE.name]: {
      metadata: meta(StrategyTools.GET_STRATEGY_STATE.name, StrategyTools.GET_STRATEGY_STATE.description, "strategy", ["strategy", "state", "world", "nations", "fog"], ["World strategy state", "Fog of war"], true, "high"),
      schema: StrategyTools.GET_STRATEGY_STATE.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.GET_STRATEGY_STATE.name, args)
    },
    [StrategyTools.GET_NATION_STATE.name]: {
      metadata: meta(StrategyTools.GET_NATION_STATE.name, StrategyTools.GET_NATION_STATE.description, "strategy", ["nation", "state", "private", "info", "resources"], ["Nation private state", "Resources"], false, "medium"),
      schema: StrategyTools.GET_NATION_STATE.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.GET_NATION_STATE.name, args)
    },
    [StrategyTools.PROPOSE_ALLIANCE.name]: {
      metadata: meta(StrategyTools.PROPOSE_ALLIANCE.name, StrategyTools.PROPOSE_ALLIANCE.description, "strategy", ["alliance", "propose", "diplomacy", "treaty", "pact"], ["Alliance proposal", "Diplomacy"], false, "low"),
      schema: StrategyTools.PROPOSE_ALLIANCE.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.PROPOSE_ALLIANCE.name, args)
    },
    [StrategyTools.CLAIM_REGION.name]: {
      metadata: meta(StrategyTools.CLAIM_REGION.name, StrategyTools.CLAIM_REGION.description, "strategy", ["claim", "region", "territory", "nation", "expand"], ["Territorial claim", "Justification"], false, "low"),
      schema: StrategyTools.CLAIM_REGION.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.CLAIM_REGION.name, args)
    },
    [StrategyTools.RESOLVE_TURN.name]: {
      metadata: meta(StrategyTools.RESOLVE_TURN.name, StrategyTools.RESOLVE_TURN.description, "strategy", ["turn", "resolve", "process", "strategy", "economy"], ["Turn processing", "Conflict resolution"], true, "high"),
      schema: StrategyTools.RESOLVE_TURN.inputSchema,
      handler: (args) => handleStrategyTool(StrategyTools.RESOLVE_TURN.name, args)
    },
    // === TURN MANAGEMENT TOOLS ===
    [TurnManagementTools.INIT_TURN_STATE.name]: {
      metadata: meta(TurnManagementTools.INIT_TURN_STATE.name, TurnManagementTools.INIT_TURN_STATE.description, "turn-management", ["turn", "init", "initialize", "state", "setup"], ["Turn state initialization"], false, "low"),
      schema: TurnManagementTools.INIT_TURN_STATE.inputSchema,
      handler: (args) => handleTurnManagementTool(TurnManagementTools.INIT_TURN_STATE.name, args)
    },
    [TurnManagementTools.GET_TURN_STATUS.name]: {
      metadata: meta(TurnManagementTools.GET_TURN_STATUS.name, TurnManagementTools.GET_TURN_STATUS.description, "turn-management", ["turn", "status", "ready", "nations", "phase"], ["Current turn status", "Ready status"], false, "medium"),
      schema: TurnManagementTools.GET_TURN_STATUS.inputSchema,
      handler: (args) => handleTurnManagementTool(TurnManagementTools.GET_TURN_STATUS.name, args)
    },
    [TurnManagementTools.SUBMIT_TURN_ACTIONS.name]: {
      metadata: meta(TurnManagementTools.SUBMIT_TURN_ACTIONS.name, TurnManagementTools.SUBMIT_TURN_ACTIONS.description, "turn-management", ["turn", "action", "submit", "batch", "orders"], ["Batch action submission"], false, "medium"),
      schema: TurnManagementTools.SUBMIT_TURN_ACTIONS.inputSchema,
      handler: (args) => handleTurnManagementTool(TurnManagementTools.SUBMIT_TURN_ACTIONS.name, args)
    },
    [TurnManagementTools.MARK_READY.name]: {
      metadata: meta(TurnManagementTools.MARK_READY.name, TurnManagementTools.MARK_READY.description, "turn-management", ["turn", "ready", "mark", "status", "done"], ["Turn readiness marking"], false, "low"),
      schema: TurnManagementTools.MARK_READY.inputSchema,
      handler: (args) => handleTurnManagementTool(TurnManagementTools.MARK_READY.name, args)
    },
    [TurnManagementTools.POLL_TURN_RESULTS.name]: {
      metadata: meta(TurnManagementTools.POLL_TURN_RESULTS.name, TurnManagementTools.POLL_TURN_RESULTS.description, "turn-management", ["turn", "results", "poll", "outcome", "resolution"], ["Turn result polling", "Outcome"], false, "medium"),
      schema: TurnManagementTools.POLL_TURN_RESULTS.inputSchema,
      handler: (args) => handleTurnManagementTool(TurnManagementTools.POLL_TURN_RESULTS.name, args)
    },
    // === SECRET TOOLS ===
    [SecretTools.CREATE_SECRET.name]: {
      metadata: meta(SecretTools.CREATE_SECRET.name, SecretTools.CREATE_SECRET.description, "secret", ["secret", "create", "dm", "hidden", "mystery"], ["Secret creation", "Reveal conditions"], false, "medium"),
      schema: SecretTools.CREATE_SECRET.inputSchema,
      handler: handleCreateSecret
    },
    [SecretTools.GET_SECRET.name]: {
      metadata: meta(SecretTools.GET_SECRET.name, SecretTools.GET_SECRET.description, "secret", ["secret", "get", "retrieve", "dm", "view"], ["Secret retrieval (DM only)"], false, "low"),
      schema: SecretTools.GET_SECRET.inputSchema,
      handler: handleGetSecret
    },
    [SecretTools.LIST_SECRETS.name]: {
      metadata: meta(SecretTools.LIST_SECRETS.name, SecretTools.LIST_SECRETS.description, "secret", ["secret", "list", "all", "dm", "query"], ["Secret listing (DM only)"], true, "medium"),
      schema: SecretTools.LIST_SECRETS.inputSchema,
      handler: handleListSecrets
    },
    [SecretTools.UPDATE_SECRET.name]: {
      metadata: meta(SecretTools.UPDATE_SECRET.name, SecretTools.UPDATE_SECRET.description, "secret", ["secret", "update", "modify", "dm", "edit"], ["Secret modification"], false, "low"),
      schema: SecretTools.UPDATE_SECRET.inputSchema,
      handler: handleUpdateSecret
    },
    [SecretTools.DELETE_SECRET.name]: {
      metadata: meta(SecretTools.DELETE_SECRET.name, SecretTools.DELETE_SECRET.description, "secret", ["secret", "delete", "remove", "dm"], ["Secret deletion"], false, "low"),
      schema: SecretTools.DELETE_SECRET.inputSchema,
      handler: handleDeleteSecret
    },
    [SecretTools.REVEAL_SECRET.name]: {
      metadata: meta(SecretTools.REVEAL_SECRET.name, SecretTools.REVEAL_SECRET.description, "secret", ["secret", "reveal", "disclosure", "player", "spoiler"], ["Secret revealing", "Spoiler formatting"], false, "medium"),
      schema: SecretTools.REVEAL_SECRET.inputSchema,
      handler: handleRevealSecret
    },
    [SecretTools.CHECK_REVEAL_CONDITIONS.name]: {
      metadata: meta(SecretTools.CHECK_REVEAL_CONDITIONS.name, SecretTools.CHECK_REVEAL_CONDITIONS.description, "secret", ["secret", "reveal", "check", "condition", "trigger"], ["Reveal condition evaluation"], false, "medium"),
      schema: SecretTools.CHECK_REVEAL_CONDITIONS.inputSchema,
      handler: handleCheckRevealConditions
    },
    [SecretTools.GET_SECRETS_FOR_CONTEXT.name]: {
      metadata: meta(SecretTools.GET_SECRETS_FOR_CONTEXT.name, SecretTools.GET_SECRETS_FOR_CONTEXT.description, "secret", ["secret", "context", "dm", "prompt", "inject"], ["Context-injected secrets (DM prompts)"], true, "high"),
      schema: SecretTools.GET_SECRETS_FOR_CONTEXT.inputSchema,
      handler: handleGetSecretsForContext
    },
    [SecretTools.CHECK_FOR_LEAKS.name]: {
      metadata: meta(SecretTools.CHECK_FOR_LEAKS.name, SecretTools.CHECK_FOR_LEAKS.description, "secret", ["secret", "leak", "detect", "check", "safety"], ["Secret leak detection"], false, "low"),
      schema: SecretTools.CHECK_FOR_LEAKS.inputSchema,
      handler: handleCheckForLeaks
    },
    // === REST TOOLS ===
    [RestTools.TAKE_LONG_REST.name]: {
      metadata: meta(RestTools.TAKE_LONG_REST.name, RestTools.TAKE_LONG_REST.description, "rest", ["rest", "long", "sleep", "recovery", "heal", "8hours"], ["Long rest (8 hours)", "HP recovery"], false, "low"),
      schema: RestTools.TAKE_LONG_REST.inputSchema,
      handler: handleTakeLongRest
    },
    [RestTools.TAKE_SHORT_REST.name]: {
      metadata: meta(RestTools.TAKE_SHORT_REST.name, RestTools.TAKE_SHORT_REST.description, "rest", ["rest", "short", "sleep", "recovery", "hit-dice", "1hour"], ["Short rest (1 hour)", "Hit die usage"], false, "low"),
      schema: RestTools.TAKE_SHORT_REST.inputSchema,
      handler: handleTakeShortRest
    },
    // === CONCENTRATION TOOLS ===
    [ConcentrationTools.CHECK_CONCENTRATION_SAVE.name]: {
      metadata: meta(ConcentrationTools.CHECK_CONCENTRATION_SAVE.name, ConcentrationTools.CHECK_CONCENTRATION_SAVE.description, "concentration", ["concentration", "save", "damage", "maintain", "constitution"], ["Concentration save throwing"], false, "low"),
      schema: ConcentrationTools.CHECK_CONCENTRATION_SAVE.inputSchema,
      handler: handleCheckConcentrationSave
    },
    [ConcentrationTools.BREAK_CONCENTRATION.name]: {
      metadata: meta(ConcentrationTools.BREAK_CONCENTRATION.name, ConcentrationTools.BREAK_CONCENTRATION.description, "concentration", ["concentration", "break", "end", "spell", "drop"], ["Voluntary concentration break"], false, "low"),
      schema: ConcentrationTools.BREAK_CONCENTRATION.inputSchema,
      handler: handleBreakConcentration
    },
    [ConcentrationTools.GET_CONCENTRATION_STATE.name]: {
      metadata: meta(ConcentrationTools.GET_CONCENTRATION_STATE.name, ConcentrationTools.GET_CONCENTRATION_STATE.description, "concentration", ["concentration", "state", "spell", "duration", "active"], ["Current concentration info"], false, "low"),
      schema: ConcentrationTools.GET_CONCENTRATION_STATE.inputSchema,
      handler: handleGetConcentrationState
    },
    [ConcentrationTools.CHECK_CONCENTRATION_DURATION.name]: {
      metadata: meta(ConcentrationTools.CHECK_CONCENTRATION_DURATION.name, ConcentrationTools.CHECK_CONCENTRATION_DURATION.description, "concentration", ["concentration", "duration", "expire", "round", "time"], ["Duration checking", "Auto-expiration"], false, "low"),
      schema: ConcentrationTools.CHECK_CONCENTRATION_DURATION.inputSchema,
      handler: handleCheckConcentrationDuration
    },
    [ConcentrationTools.CHECK_AUTO_BREAK.name]: {
      metadata: meta(ConcentrationTools.CHECK_AUTO_BREAK.name, ConcentrationTools.CHECK_AUTO_BREAK.description, "concentration", ["concentration", "break", "condition", "auto", "incapacitated"], ["Automatic break detection"], false, "low"),
      schema: ConcentrationTools.CHECK_AUTO_BREAK.inputSchema,
      handler: handleCheckAutoBreak
    },
    // === SCROLL TOOLS ===
    [ScrollTools.USE_SPELL_SCROLL.name]: {
      metadata: meta(ScrollTools.USE_SPELL_SCROLL.name, ScrollTools.USE_SPELL_SCROLL.description, "scroll", ["scroll", "use", "spell", "cast", "arcana"], ["Spell scroll usage", "Arcana checks"], false, "medium"),
      schema: ScrollTools.USE_SPELL_SCROLL.inputSchema,
      handler: handleUseSpellScroll
    },
    [ScrollTools.CREATE_SPELL_SCROLL.name]: {
      metadata: meta(ScrollTools.CREATE_SPELL_SCROLL.name, ScrollTools.CREATE_SPELL_SCROLL.description, "scroll", ["scroll", "create", "spell", "new", "scribe"], ["Spell scroll creation", "DC setup"], false, "low"),
      schema: ScrollTools.CREATE_SPELL_SCROLL.inputSchema,
      handler: handleCreateSpellScroll
    },
    [ScrollTools.IDENTIFY_SCROLL.name]: {
      metadata: meta(ScrollTools.IDENTIFY_SCROLL.name, ScrollTools.IDENTIFY_SCROLL.description, "scroll", ["scroll", "identify", "arcana", "check", "read"], ["Scroll identification", "Arcana DC"], false, "low"),
      schema: ScrollTools.IDENTIFY_SCROLL.inputSchema,
      handler: handleIdentifyScroll
    },
    [ScrollTools.GET_SCROLL_USE_DC.name]: {
      metadata: meta(ScrollTools.GET_SCROLL_USE_DC.name, ScrollTools.GET_SCROLL_USE_DC.description, "scroll", ["scroll", "dc", "difficulty", "class", "level"], ["DC calculation for scroll usage"], false, "low"),
      schema: ScrollTools.GET_SCROLL_USE_DC.inputSchema,
      handler: handleGetScrollUseDC
    },
    [ScrollTools.GET_SCROLL_DETAILS.name]: {
      metadata: meta(ScrollTools.GET_SCROLL_DETAILS.name, ScrollTools.GET_SCROLL_DETAILS.description, "scroll", ["scroll", "details", "info", "spell", "properties"], ["Scroll details retrieval"], false, "low"),
      schema: ScrollTools.GET_SCROLL_DETAILS.inputSchema,
      handler: handleGetScrollDetails
    },
    [ScrollTools.CHECK_SCROLL_USABILITY.name]: {
      metadata: meta(ScrollTools.CHECK_SCROLL_USABILITY.name, ScrollTools.CHECK_SCROLL_USABILITY.description, "scroll", ["scroll", "usable", "check", "class", "can-use"], ["Scroll usability checking"], false, "low"),
      schema: ScrollTools.CHECK_SCROLL_USABILITY.inputSchema,
      handler: handleCheckScrollUsability
    },
    // === AURA TOOLS ===
    [AuraTools.CREATE_AURA.name]: {
      metadata: meta(AuraTools.CREATE_AURA.name, AuraTools.CREATE_AURA.description, "aura", ["aura", "create", "effect", "area", "spirit-guardians"], ["Aura creation", "Effect setup", "Concentration"], false, "medium"),
      schema: AuraTools.CREATE_AURA.inputSchema,
      handler: handleCreateAura
    },
    [AuraTools.GET_ACTIVE_AURAS.name]: {
      metadata: meta(AuraTools.GET_ACTIVE_AURAS.name, AuraTools.GET_ACTIVE_AURAS.description, "aura", ["aura", "active", "list", "effect", "current"], ["Active aura listing"], true, "medium"),
      schema: AuraTools.GET_ACTIVE_AURAS.inputSchema,
      handler: handleGetActiveAuras
    },
    [AuraTools.GET_AURAS_AFFECTING_CHARACTER.name]: {
      metadata: meta(AuraTools.GET_AURAS_AFFECTING_CHARACTER.name, AuraTools.GET_AURAS_AFFECTING_CHARACTER.description, "aura", ["aura", "character", "affecting", "effect", "check"], ["Character-specific aura list"], false, "medium"),
      schema: AuraTools.GET_AURAS_AFFECTING_CHARACTER.inputSchema,
      handler: handleGetAurasAffectingCharacter
    },
    [AuraTools.PROCESS_AURA_EFFECTS.name]: {
      metadata: meta(AuraTools.PROCESS_AURA_EFFECTS.name, AuraTools.PROCESS_AURA_EFFECTS.description, "aura", ["aura", "effect", "process", "trigger", "apply"], ["Aura effect processing"], false, "low"),
      schema: AuraTools.PROCESS_AURA_EFFECTS.inputSchema,
      handler: handleProcessAuraEffects
    },
    [AuraTools.REMOVE_AURA.name]: {
      metadata: meta(AuraTools.REMOVE_AURA.name, AuraTools.REMOVE_AURA.description, "aura", ["aura", "remove", "end", "effect", "dismiss"], ["Aura removal"], false, "low"),
      schema: AuraTools.REMOVE_AURA.inputSchema,
      handler: handleRemoveAura
    },
    [AuraTools.REMOVE_CHARACTER_AURAS.name]: {
      metadata: meta(AuraTools.REMOVE_CHARACTER_AURAS.name, AuraTools.REMOVE_CHARACTER_AURAS.description, "aura", ["aura", "character", "remove", "all", "clear"], ["Bulk aura removal for character"], false, "low"),
      schema: AuraTools.REMOVE_CHARACTER_AURAS.inputSchema,
      handler: handleRemoveCharacterAuras
    },
    [AuraTools.EXPIRE_AURAS.name]: {
      metadata: meta(AuraTools.EXPIRE_AURAS.name, AuraTools.EXPIRE_AURAS.description, "aura", ["aura", "expire", "duration", "check", "cleanup"], ["Expired aura cleanup"], false, "low"),
      schema: AuraTools.EXPIRE_AURAS.inputSchema,
      handler: handleExpireAuras
    },
    // === NPC MEMORY TOOLS ===
    [NpcMemoryTools.GET_NPC_RELATIONSHIP.name]: {
      metadata: meta(NpcMemoryTools.GET_NPC_RELATIONSHIP.name, NpcMemoryTools.GET_NPC_RELATIONSHIP.description, "npc", ["npc", "relationship", "disposition", "familiarity", "status"], ["Relationship retrieval", "Status info"], false, "low"),
      schema: NpcMemoryTools.GET_NPC_RELATIONSHIP.inputSchema,
      handler: handleGetNpcRelationship
    },
    [NpcMemoryTools.UPDATE_NPC_RELATIONSHIP.name]: {
      metadata: meta(NpcMemoryTools.UPDATE_NPC_RELATIONSHIP.name, NpcMemoryTools.UPDATE_NPC_RELATIONSHIP.description, "npc", ["npc", "relationship", "update", "disposition", "change"], ["Relationship modification"], false, "low"),
      schema: NpcMemoryTools.UPDATE_NPC_RELATIONSHIP.inputSchema,
      handler: handleUpdateNpcRelationship
    },
    [NpcMemoryTools.RECORD_CONVERSATION_MEMORY.name]: {
      metadata: meta(NpcMemoryTools.RECORD_CONVERSATION_MEMORY.name, NpcMemoryTools.RECORD_CONVERSATION_MEMORY.description, "npc", ["npc", "memory", "conversation", "record", "log"], ["Conversation logging", "Importance tracking"], false, "low"),
      schema: NpcMemoryTools.RECORD_CONVERSATION_MEMORY.inputSchema,
      handler: handleRecordConversationMemory
    },
    [NpcMemoryTools.GET_CONVERSATION_HISTORY.name]: {
      metadata: meta(NpcMemoryTools.GET_CONVERSATION_HISTORY.name, NpcMemoryTools.GET_CONVERSATION_HISTORY.description, "npc", ["npc", "conversation", "history", "memory", "past"], ["Interaction history retrieval"], true, "medium"),
      schema: NpcMemoryTools.GET_CONVERSATION_HISTORY.inputSchema,
      handler: handleGetConversationHistory
    },
    [NpcMemoryTools.GET_RECENT_INTERACTIONS.name]: {
      metadata: meta(NpcMemoryTools.GET_RECENT_INTERACTIONS.name, NpcMemoryTools.GET_RECENT_INTERACTIONS.description, "npc", ["npc", "recent", "interaction", "history", "latest"], ["Recent interaction listing"], true, "medium"),
      schema: NpcMemoryTools.GET_RECENT_INTERACTIONS.inputSchema,
      handler: handleGetRecentInteractions
    },
    [NpcMemoryTools.GET_NPC_CONTEXT.name]: {
      metadata: meta(NpcMemoryTools.GET_NPC_CONTEXT.name, NpcMemoryTools.GET_NPC_CONTEXT.description, "npc", ["npc", "context", "info", "relationship", "llm"], ["NPC context injection", "LLM-friendly"], true, "medium"),
      schema: NpcMemoryTools.GET_NPC_CONTEXT.inputSchema,
      handler: handleGetNpcContext
    },
    [NpcMemoryTools.INTERACT_SOCIALLY.name]: {
      metadata: meta(NpcMemoryTools.INTERACT_SOCIALLY.name, NpcMemoryTools.INTERACT_SOCIALLY.description, "npc", ["npc", "interact", "social", "conversation", "speak"], ["Social interaction", "Stealth vs Perception"], false, "medium"),
      schema: NpcMemoryTools.INTERACT_SOCIALLY.inputSchema,
      handler: handleInteractSocially
    },
    // === SPATIAL TOOLS ===
    [SpatialTools.LOOK_AT_SURROUNDINGS.name]: {
      metadata: meta(SpatialTools.LOOK_AT_SURROUNDINGS.name, SpatialTools.LOOK_AT_SURROUNDINGS.description, "spatial", ["spatial", "surroundings", "look", "perception", "room"], ["Environment description", "Darkness handling"], true, "high"),
      schema: SpatialTools.LOOK_AT_SURROUNDINGS.inputSchema,
      handler: handleLookAtSurroundings
    },
    [SpatialTools.GENERATE_ROOM_NODE.name]: {
      metadata: meta(SpatialTools.GENERATE_ROOM_NODE.name, SpatialTools.GENERATE_ROOM_NODE.description, "spatial", ["spatial", "room", "generate", "node", "create"], ["Room generation", "Atmosphere setup"], false, "medium"),
      schema: SpatialTools.GENERATE_ROOM_NODE.inputSchema,
      handler: handleGenerateRoomNode
    },
    [SpatialTools.GET_ROOM_EXITS.name]: {
      metadata: meta(SpatialTools.GET_ROOM_EXITS.name, SpatialTools.GET_ROOM_EXITS.description, "spatial", ["spatial", "exit", "room", "direction", "doors"], ["Exit listing", "Navigation"], false, "low"),
      schema: SpatialTools.GET_ROOM_EXITS.inputSchema,
      handler: handleGetRoomExits
    },
    [SpatialTools.MOVE_CHARACTER_TO_ROOM.name]: {
      metadata: meta(SpatialTools.MOVE_CHARACTER_TO_ROOM.name, SpatialTools.MOVE_CHARACTER_TO_ROOM.description, "spatial", ["spatial", "move", "character", "room", "enter"], ["Character positioning", "Location tracking"], false, "low"),
      schema: SpatialTools.MOVE_CHARACTER_TO_ROOM.inputSchema,
      handler: handleMoveCharacterToRoom
    },
    // === THEFT TOOLS ===
    [TheftTools.STEAL_ITEM.name]: {
      metadata: meta(TheftTools.STEAL_ITEM.name, TheftTools.STEAL_ITEM.description, "theft", ["theft", "steal", "item", "heat", "crime"], ["Item theft", "Heat generation"], false, "low"),
      schema: TheftTools.STEAL_ITEM.inputSchema,
      handler: handleStealItem
    },
    [TheftTools.CHECK_ITEM_STOLEN.name]: {
      metadata: meta(TheftTools.CHECK_ITEM_STOLEN.name, TheftTools.CHECK_ITEM_STOLEN.description, "theft", ["theft", "stolen", "check", "status", "provenance"], ["Theft status checking"], false, "low"),
      schema: TheftTools.CHECK_ITEM_STOLEN.inputSchema,
      handler: handleCheckItemStolen
    },
    [TheftTools.CHECK_STOLEN_ITEMS_ON_CHARACTER.name]: {
      metadata: meta(TheftTools.CHECK_STOLEN_ITEMS_ON_CHARACTER.name, TheftTools.CHECK_STOLEN_ITEMS_ON_CHARACTER.description, "theft", ["theft", "stolen", "check", "inventory", "search"], ["Character theft detection"], false, "medium"),
      schema: TheftTools.CHECK_STOLEN_ITEMS_ON_CHARACTER.inputSchema,
      handler: handleCheckStolenItemsOnCharacter
    },
    [TheftTools.CHECK_ITEM_RECOGNITION.name]: {
      metadata: meta(TheftTools.CHECK_ITEM_RECOGNITION.name, TheftTools.CHECK_ITEM_RECOGNITION.description, "theft", ["theft", "recognition", "npc", "detection", "owner"], ["NPC item recognition"], false, "low"),
      schema: TheftTools.CHECK_ITEM_RECOGNITION.inputSchema,
      handler: handleCheckItemRecognition
    },
    [TheftTools.SELL_TO_FENCE.name]: {
      metadata: meta(TheftTools.SELL_TO_FENCE.name, TheftTools.SELL_TO_FENCE.description, "theft", ["theft", "fence", "sell", "stolen", "black-market"], ["Stolen item fencing"], false, "low"),
      schema: TheftTools.SELL_TO_FENCE.inputSchema,
      handler: handleSellToFence
    },
    [TheftTools.REGISTER_FENCE.name]: {
      metadata: meta(TheftTools.REGISTER_FENCE.name, TheftTools.REGISTER_FENCE.description, "theft", ["theft", "fence", "register", "npc", "dealer"], ["Fence NPC registration"], false, "low"),
      schema: TheftTools.REGISTER_FENCE.inputSchema,
      handler: handleRegisterFence
    },
    [TheftTools.REPORT_THEFT.name]: {
      metadata: meta(TheftTools.REPORT_THEFT.name, TheftTools.REPORT_THEFT.description, "theft", ["theft", "report", "guards", "bounty", "crime"], ["Theft reporting", "Bounty setting"], false, "low"),
      schema: TheftTools.REPORT_THEFT.inputSchema,
      handler: handleReportTheft
    },
    [TheftTools.ADVANCE_HEAT_DECAY.name]: {
      metadata: meta(TheftTools.ADVANCE_HEAT_DECAY.name, TheftTools.ADVANCE_HEAT_DECAY.description, "theft", ["theft", "heat", "decay", "time", "cooldown"], ["Heat level decay tracking"], false, "low"),
      schema: TheftTools.ADVANCE_HEAT_DECAY.inputSchema,
      handler: handleAdvanceHeatDecay
    },
    [TheftTools.GET_FENCE.name]: {
      metadata: meta(TheftTools.GET_FENCE.name, TheftTools.GET_FENCE.description, "theft", ["theft", "fence", "info", "npc", "dealer"], ["Fence information retrieval"], false, "low"),
      schema: TheftTools.GET_FENCE.inputSchema,
      handler: handleGetFence
    },
    [TheftTools.LIST_FENCES.name]: {
      metadata: meta(TheftTools.LIST_FENCES.name, TheftTools.LIST_FENCES.description, "theft", ["theft", "fence", "list", "all", "dealers"], ["Fence listing"], false, "medium"),
      schema: TheftTools.LIST_FENCES.inputSchema,
      handler: handleListFences
    },
    // === CORPSE/LOOT TOOLS ===
    [CorpseTools.GET_CORPSE.name]: {
      metadata: meta(CorpseTools.GET_CORPSE.name, CorpseTools.GET_CORPSE.description, "corpse", ["corpse", "get", "loot", "body", "dead"], ["Corpse retrieval with loot"], false, "medium"),
      schema: CorpseTools.GET_CORPSE.inputSchema,
      handler: handleGetCorpse
    },
    [CorpseTools.GET_CORPSE_BY_CHARACTER.name]: {
      metadata: meta(CorpseTools.GET_CORPSE_BY_CHARACTER.name, CorpseTools.GET_CORPSE_BY_CHARACTER.description, "corpse", ["corpse", "character", "body", "death", "remains"], ["Dead character's corpse"], false, "low"),
      schema: CorpseTools.GET_CORPSE_BY_CHARACTER.inputSchema,
      handler: handleGetCorpseByCharacter
    },
    [CorpseTools.LIST_CORPSES_IN_ENCOUNTER.name]: {
      metadata: meta(CorpseTools.LIST_CORPSES_IN_ENCOUNTER.name, CorpseTools.LIST_CORPSES_IN_ENCOUNTER.description, "corpse", ["corpse", "encounter", "list", "battle", "dead"], ["Encounter corpse listing"], true, "medium"),
      schema: CorpseTools.LIST_CORPSES_IN_ENCOUNTER.inputSchema,
      handler: handleListCorpsesInEncounter
    },
    [CorpseTools.LIST_CORPSES_NEARBY.name]: {
      metadata: meta(CorpseTools.LIST_CORPSES_NEARBY.name, CorpseTools.LIST_CORPSES_NEARBY.description, "corpse", ["corpse", "nearby", "proximity", "region", "search"], ["Spatial corpse discovery"], false, "medium"),
      schema: CorpseTools.LIST_CORPSES_NEARBY.inputSchema,
      handler: handleListCorpsesNearby
    },
    [CorpseTools.LOOT_CORPSE.name]: {
      metadata: meta(CorpseTools.LOOT_CORPSE.name, CorpseTools.LOOT_CORPSE.description, "corpse", ["corpse", "loot", "item", "take", "pickup"], ["Corpse looting", "Item extraction"], false, "low"),
      schema: CorpseTools.LOOT_CORPSE.inputSchema,
      handler: handleLootCorpse
    },
    [CorpseTools.HARVEST_CORPSE.name]: {
      metadata: meta(CorpseTools.HARVEST_CORPSE.name, CorpseTools.HARVEST_CORPSE.description, "corpse", ["corpse", "harvest", "resource", "material", "skin"], ["Resource harvesting", "Skill checks"], false, "low"),
      schema: CorpseTools.HARVEST_CORPSE.inputSchema,
      handler: handleHarvestCorpse
    },
    [CorpseTools.CREATE_CORPSE.name]: {
      metadata: meta(CorpseTools.CREATE_CORPSE.name, CorpseTools.CREATE_CORPSE.description, "corpse", ["corpse", "create", "death", "body", "manual"], ["Corpse creation for dead NPCs"], false, "low"),
      schema: CorpseTools.CREATE_CORPSE.inputSchema,
      handler: handleCreateCorpse
    },
    [CorpseTools.GENERATE_LOOT.name]: {
      metadata: meta(CorpseTools.GENERATE_LOOT.name, CorpseTools.GENERATE_LOOT.description, "corpse", ["corpse", "loot", "generate", "table", "random"], ["Loot generation by CR/type"], false, "medium"),
      schema: CorpseTools.GENERATE_LOOT.inputSchema,
      handler: handleGenerateLoot
    },
    [CorpseTools.GET_CORPSE_INVENTORY.name]: {
      metadata: meta(CorpseTools.GET_CORPSE_INVENTORY.name, CorpseTools.GET_CORPSE_INVENTORY.description, "corpse", ["corpse", "inventory", "items", "loot", "contents"], ["Corpse inventory listing"], true, "medium"),
      schema: CorpseTools.GET_CORPSE_INVENTORY.inputSchema,
      handler: handleGetCorpseInventory
    },
    [CorpseTools.CREATE_LOOT_TABLE.name]: {
      metadata: meta(CorpseTools.CREATE_LOOT_TABLE.name, CorpseTools.CREATE_LOOT_TABLE.description, "corpse", ["corpse", "loot", "table", "template", "create"], ["Loot table creation", "Customization"], false, "medium"),
      schema: CorpseTools.CREATE_LOOT_TABLE.inputSchema,
      handler: handleCreateLootTable
    },
    [CorpseTools.GET_LOOT_TABLE.name]: {
      metadata: meta(CorpseTools.GET_LOOT_TABLE.name, CorpseTools.GET_LOOT_TABLE.description, "corpse", ["corpse", "loot", "table", "query", "get"], ["Loot table retrieval"], false, "medium"),
      schema: CorpseTools.GET_LOOT_TABLE.inputSchema,
      handler: handleGetLootTable
    },
    [CorpseTools.LIST_LOOT_TABLES.name]: {
      metadata: meta(CorpseTools.LIST_LOOT_TABLES.name, CorpseTools.LIST_LOOT_TABLES.description, "corpse", ["corpse", "loot", "table", "all", "list"], ["Loot table listing"], false, "medium"),
      schema: CorpseTools.LIST_LOOT_TABLES.inputSchema,
      handler: handleListLootTables
    },
    [CorpseTools.ADVANCE_CORPSE_DECAY.name]: {
      metadata: meta(CorpseTools.ADVANCE_CORPSE_DECAY.name, CorpseTools.ADVANCE_CORPSE_DECAY.description, "corpse", ["corpse", "decay", "time", "rot", "advance"], ["Corpse decay progression"], false, "low"),
      schema: CorpseTools.ADVANCE_CORPSE_DECAY.inputSchema,
      handler: handleAdvanceCorpseDecay
    },
    [CorpseTools.CLEANUP_CORPSES.name]: {
      metadata: meta(CorpseTools.CLEANUP_CORPSES.name, CorpseTools.CLEANUP_CORPSES.description, "corpse", ["corpse", "cleanup", "decay", "remove", "gone"], ["Decayed corpse cleanup"], false, "low"),
      schema: CorpseTools.CLEANUP_CORPSES.inputSchema,
      handler: handleCleanupCorpses
    },
    // === IMPROVISATION TOOLS ===
    [ImprovisationTools.RESOLVE_IMPROVISED_STUNT.name]: {
      metadata: meta(ImprovisationTools.RESOLVE_IMPROVISED_STUNT.name, ImprovisationTools.RESOLVE_IMPROVISED_STUNT.description, "improvisation", ["stunt", "improvise", "cool", "action", "creative"], ["Rule of Cool resolution", "Skill checks"], false, "medium"),
      schema: ImprovisationTools.RESOLVE_IMPROVISED_STUNT.inputSchema,
      handler: handleResolveImprovisedStunt
    },
    [ImprovisationTools.APPLY_CUSTOM_EFFECT.name]: {
      metadata: meta(ImprovisationTools.APPLY_CUSTOM_EFFECT.name, ImprovisationTools.APPLY_CUSTOM_EFFECT.description, "improvisation", ["effect", "custom", "apply", "buff", "curse", "boon"], ["Custom effect application", "Power levels"], false, "medium"),
      schema: ImprovisationTools.APPLY_CUSTOM_EFFECT.inputSchema,
      handler: handleApplyCustomEffect
    },
    [ImprovisationTools.GET_CUSTOM_EFFECTS.name]: {
      metadata: meta(ImprovisationTools.GET_CUSTOM_EFFECTS.name, ImprovisationTools.GET_CUSTOM_EFFECTS.description, "improvisation", ["effect", "custom", "list", "character", "active"], ["Active effect listing"], true, "medium"),
      schema: ImprovisationTools.GET_CUSTOM_EFFECTS.inputSchema,
      handler: handleGetCustomEffects
    },
    [ImprovisationTools.REMOVE_CUSTOM_EFFECT.name]: {
      metadata: meta(ImprovisationTools.REMOVE_CUSTOM_EFFECT.name, ImprovisationTools.REMOVE_CUSTOM_EFFECT.description, "improvisation", ["effect", "custom", "remove", "end", "dispel"], ["Effect removal"], false, "low"),
      schema: ImprovisationTools.REMOVE_CUSTOM_EFFECT.inputSchema,
      handler: handleRemoveCustomEffect
    },
    [ImprovisationTools.PROCESS_EFFECT_TRIGGERS.name]: {
      metadata: meta(ImprovisationTools.PROCESS_EFFECT_TRIGGERS.name, ImprovisationTools.PROCESS_EFFECT_TRIGGERS.description, "improvisation", ["effect", "trigger", "process", "event", "fire"], ["Effect trigger evaluation"], false, "low"),
      schema: ImprovisationTools.PROCESS_EFFECT_TRIGGERS.inputSchema,
      handler: handleProcessEffectTriggers
    },
    [ImprovisationTools.ADVANCE_EFFECT_DURATIONS.name]: {
      metadata: meta(ImprovisationTools.ADVANCE_EFFECT_DURATIONS.name, ImprovisationTools.ADVANCE_EFFECT_DURATIONS.description, "improvisation", ["effect", "duration", "advance", "round", "time"], ["Duration progression", "Expiration"], false, "low"),
      schema: ImprovisationTools.ADVANCE_EFFECT_DURATIONS.inputSchema,
      handler: handleAdvanceEffectDurations
    },
    [ImprovisationTools.ATTEMPT_ARCANE_SYNTHESIS.name]: {
      metadata: meta(ImprovisationTools.ATTEMPT_ARCANE_SYNTHESIS.name, ImprovisationTools.ATTEMPT_ARCANE_SYNTHESIS.description, "improvisation", ["spell", "synthesis", "create", "new", "wild-magic", "arcane"], ["Spell creation via Arcane Synthesis", "Wild Magic"], false, "high"),
      schema: ImprovisationTools.ATTEMPT_ARCANE_SYNTHESIS.inputSchema,
      handler: handleAttemptArcaneSynthesis
    },
    [ImprovisationTools.GET_SYNTHESIZED_SPELLS.name]: {
      metadata: meta(ImprovisationTools.GET_SYNTHESIZED_SPELLS.name, ImprovisationTools.GET_SYNTHESIZED_SPELLS.description, "improvisation", ["spell", "synthesis", "learned", "list", "created"], ["Learned synthesized spells listing"], false, "medium"),
      schema: ImprovisationTools.GET_SYNTHESIZED_SPELLS.inputSchema,
      handler: handleGetSynthesizedSpells
    },
    // === BATCH TOOLS ===
    [BatchTools.BATCH_CREATE_CHARACTERS.name]: {
      metadata: meta(BatchTools.BATCH_CREATE_CHARACTERS.name, BatchTools.BATCH_CREATE_CHARACTERS.description, "batch", ["batch", "character", "create", "multiple", "party", "squad"], ["Batch character creation", "Party generation"], false, "medium"),
      schema: BatchTools.BATCH_CREATE_CHARACTERS.inputSchema,
      handler: handleBatchCreateCharacters
    },
    [BatchTools.BATCH_CREATE_NPCS.name]: {
      metadata: meta(BatchTools.BATCH_CREATE_NPCS.name, BatchTools.BATCH_CREATE_NPCS.description, "batch", ["batch", "npc", "create", "multiple", "settlement", "population"], ["Batch NPC generation", "Settlement population"], false, "medium"),
      schema: BatchTools.BATCH_CREATE_NPCS.inputSchema,
      handler: handleBatchCreateNpcs
    },
    [BatchTools.BATCH_DISTRIBUTE_ITEMS.name]: {
      metadata: meta(BatchTools.BATCH_DISTRIBUTE_ITEMS.name, BatchTools.BATCH_DISTRIBUTE_ITEMS.description, "batch", ["batch", "item", "distribute", "loot", "equipment", "give"], ["Batch item distribution", "Loot sharing"], false, "medium"),
      schema: BatchTools.BATCH_DISTRIBUTE_ITEMS.inputSchema,
      handler: handleBatchDistributeItems
    },
    // === WORKFLOW TOOLS ===
    [WorkflowTools.EXECUTE_WORKFLOW.name]: {
      metadata: meta(WorkflowTools.EXECUTE_WORKFLOW.name, WorkflowTools.EXECUTE_WORKFLOW.description, "batch", ["workflow", "execute", "automation", "template", "batch"], ["Workflow execution", "Multi-step automation"], false, "high"),
      schema: WorkflowTools.EXECUTE_WORKFLOW.inputSchema,
      handler: handleExecuteWorkflow
    },
    [WorkflowTools.LIST_TEMPLATES.name]: {
      metadata: meta(WorkflowTools.LIST_TEMPLATES.name, WorkflowTools.LIST_TEMPLATES.description, "batch", ["workflow", "template", "list", "available"], ["Template listing"], false, "low"),
      schema: WorkflowTools.LIST_TEMPLATES.inputSchema,
      handler: handleListTemplates
    },
    [WorkflowTools.GET_TEMPLATE.name]: {
      metadata: meta(WorkflowTools.GET_TEMPLATE.name, WorkflowTools.GET_TEMPLATE.description, "batch", ["workflow", "template", "get", "details"], ["Template details"], false, "low"),
      schema: WorkflowTools.GET_TEMPLATE.inputSchema,
      handler: handleGetTemplate
    },
    // === EVENT INBOX TOOLS ===
    [EventInboxTools.POLL_EVENTS.name]: {
      metadata: meta(EventInboxTools.POLL_EVENTS.name, EventInboxTools.POLL_EVENTS.description, "meta", ["event", "poll", "inbox", "npc", "autonomous", "notification"], ["Event polling", "NPC autonomy"], false, "low"),
      schema: EventInboxTools.POLL_EVENTS.inputSchema,
      handler: handlePollEvents
    },
    [EventInboxTools.PUSH_EVENT.name]: {
      metadata: meta(EventInboxTools.PUSH_EVENT.name, EventInboxTools.PUSH_EVENT.description, "meta", ["event", "push", "queue", "npc", "action", "notification"], ["Event creation", "NPC action simulation"], false, "low"),
      schema: EventInboxTools.PUSH_EVENT.inputSchema,
      handler: handlePushEvent
    },
    [EventInboxTools.GET_EVENT_HISTORY.name]: {
      metadata: meta(EventInboxTools.GET_EVENT_HISTORY.name, EventInboxTools.GET_EVENT_HISTORY.description, "meta", ["event", "history", "log", "recent"], ["Event history"], false, "low"),
      schema: EventInboxTools.GET_EVENT_HISTORY.inputSchema,
      handler: handleGetEventHistory
    },
    [EventInboxTools.GET_PENDING_COUNT.name]: {
      metadata: meta(EventInboxTools.GET_PENDING_COUNT.name, EventInboxTools.GET_PENDING_COUNT.description, "meta", ["event", "count", "pending", "unread"], ["Pending event count"], false, "low"),
      schema: EventInboxTools.GET_PENDING_COUNT.inputSchema,
      handler: handleGetPendingCount
    },
    // === CONTEXT TOOLS ===
    [ContextTools.GET_NARRATIVE_CONTEXT.name]: {
      metadata: meta(ContextTools.GET_NARRATIVE_CONTEXT.name, ContextTools.GET_NARRATIVE_CONTEXT.description, "context", ["context", "narrative", "story", "prompt", "llm"], ["Narrative context aggregation"], true, "high"),
      schema: ContextTools.GET_NARRATIVE_CONTEXT.inputSchema,
      handler: handleGetNarrativeContext
    },
    // === SKILL CHECK TOOLS ===
    [SkillCheckTools.ROLL_SKILL_CHECK.name]: {
      metadata: meta(SkillCheckTools.ROLL_SKILL_CHECK.name, SkillCheckTools.ROLL_SKILL_CHECK.description, "math", ["skill", "check", "roll", "d20", "perception", "stealth", "athletics", "proficiency"], ["Stat-based skill checks", "Proficiency/expertise handling", "Advantage/disadvantage"], false, "low", false),
      schema: SkillCheckTools.ROLL_SKILL_CHECK.inputSchema,
      handler: handleRollSkillCheck
    },
    [SkillCheckTools.ROLL_ABILITY_CHECK.name]: {
      metadata: meta(SkillCheckTools.ROLL_ABILITY_CHECK.name, SkillCheckTools.ROLL_ABILITY_CHECK.description, "math", ["ability", "check", "roll", "d20", "str", "dex", "con", "int", "wis", "cha"], ["Raw ability checks", "No skill proficiency"], false, "low", false),
      schema: SkillCheckTools.ROLL_ABILITY_CHECK.inputSchema,
      handler: handleRollAbilityCheck
    },
    [SkillCheckTools.ROLL_SAVING_THROW.name]: {
      metadata: meta(SkillCheckTools.ROLL_SAVING_THROW.name, SkillCheckTools.ROLL_SAVING_THROW.description, "math", ["save", "saving", "throw", "roll", "d20", "reflex", "fortitude", "will"], ["Saving throws", "Save proficiency handling", "DC comparison"], false, "low", false),
      schema: SkillCheckTools.ROLL_SAVING_THROW.inputSchema,
      handler: handleRollSavingThrow
    }
    // Note: search_tools and load_tool_schema are registered separately in index.ts with full handlers
  };
  return cachedRegistry;
}
function getAllToolMetadata() {
  const registry2 = buildToolRegistry();
  return Object.values(registry2).map((entry) => entry.metadata);
}
function getToolHandler(toolName) {
  const registry2 = buildToolRegistry();
  return registry2[toolName]?.handler;
}
function getToolCategories() {
  const registry2 = buildToolRegistry();
  const counts = {};
  for (const entry of Object.values(registry2)) {
    const cat = entry.metadata.category;
    counts[cat] = (counts[cat] || 0) + 1;
  }
  return Object.entries(counts).map(([category, count]) => ({ category, count })).sort((a, b) => b.count - a.count);
}

// dist/server/meta-tools.js
var SearchToolsSchema = external_exports.object({
  query: external_exports.string().optional().describe("Natural language or keyword query to search for tools"),
  category: external_exports.enum([
    "world",
    "combat",
    "character",
    "inventory",
    "quest",
    "party",
    "math",
    "strategy",
    "secret",
    "concentration",
    "rest",
    "scroll",
    "aura",
    "npc",
    "spatial",
    "theft",
    "corpse",
    "improvisation",
    "turn-management",
    "meta"
  ]).optional().describe("Filter by category"),
  maxResults: external_exports.number().min(1).max(50).default(10).describe("Maximum results to return"),
  contextAwareOnly: external_exports.boolean().optional().describe("Only return context-aware tools")
});
function calculateRelevance(metadata, query) {
  if (!query)
    return 1;
  const queryLower = query.toLowerCase();
  const queryWords = queryLower.split(/\s+/);
  let score = 0;
  if (metadata.name.toLowerCase() === queryLower)
    return 100;
  if (metadata.name.toLowerCase().includes(queryLower))
    score += 50;
  for (const word of queryWords) {
    if (metadata.name.toLowerCase().includes(word))
      score += 20;
  }
  if (metadata.description.toLowerCase().includes(queryLower))
    score += 15;
  for (const word of queryWords) {
    if (metadata.description.toLowerCase().includes(word))
      score += 5;
  }
  for (const kw of metadata.keywords) {
    const kwLower = kw.toLowerCase();
    if (kwLower === queryLower)
      score += 30;
    else if (kwLower.includes(queryLower) || queryLower.includes(kwLower))
      score += 15;
    for (const word of queryWords) {
      if (kwLower === word)
        score += 10;
      else if (kwLower.includes(word))
        score += 5;
    }
  }
  for (const cap of metadata.capabilities) {
    if (cap.toLowerCase().includes(queryLower))
      score += 8;
    for (const word of queryWords) {
      if (cap.toLowerCase().includes(word))
        score += 3;
    }
  }
  return score;
}
async function handleSearchTools(args) {
  const allMetadata = getAllToolMetadata();
  let results = allMetadata;
  if (args.category) {
    results = results.filter((t) => t.category === args.category);
  }
  if (args.contextAwareOnly) {
    results = results.filter((t) => t.contextAware);
  }
  const scored = results.map((tool) => ({
    ...tool,
    relevanceScore: calculateRelevance(tool, args.query || "")
  }));
  let filtered = args.query ? scored.filter((t) => t.relevanceScore > 0) : scored;
  filtered.sort((a, b) => b.relevanceScore - a.relevanceScore);
  const truncated = filtered.slice(0, args.maxResults || 10);
  const suggestions = [];
  if (truncated.length === 0 && args.query) {
    suggestions.push(`No tools matched "${args.query}". Try broader keywords or browse by category.`);
  }
  if (truncated.length > 0) {
    suggestions.push("Use load_tool_schema to get full parameter details before calling a tool.");
  }
  const contextAwareCount = truncated.filter((t) => t.contextAware).length;
  if (contextAwareCount > 0) {
    suggestions.push(`${contextAwareCount} context-aware tools found - these return larger result sets.`);
  }
  const categoriesInResults = [...new Set(truncated.map((t) => t.category))];
  const content = [];
  const summary = {
    total_found: filtered.length,
    returned: truncated.length,
    categories: categoriesInResults,
    query_used: args.query || null,
    tools: truncated.map((t) => ({
      name: t.name,
      description: t.description,
      category: t.category,
      relevanceScore: t.relevanceScore,
      deferLoading: t.deferLoading
    })),
    categories_available: getToolCategories(),
    suggestions
  };
  content.push({ type: "text", text: JSON.stringify(summary, null, 2) });
  return { content };
}
var LoadToolSchemaSchema = external_exports.object({
  toolName: external_exports.string().describe("Name of the tool to load schema for")
});
async function handleLoadToolSchema(args) {
  const registry2 = buildToolRegistry();
  const tool = registry2[args.toolName];
  if (!tool) {
    const allNames = Object.keys(registry2);
    const similar = allNames.filter((name) => name.toLowerCase().includes(args.toolName.toLowerCase()) || args.toolName.toLowerCase().includes(name.toLowerCase().split("_")[0])).slice(0, 5);
    return {
      error: `Unknown tool: ${args.toolName}`,
      suggestion: "Use search_tools to find the correct tool name.",
      similarTools: similar.length > 0 ? similar : allNames.slice(0, 10)
    };
  }
  let fullSchema;
  const sessionIdExt = { sessionId: external_exports.string().optional().describe("Optional session ID for request tracking") };
  if (typeof tool.schema.extend === "function") {
    fullSchema = tool.schema.extend(sessionIdExt);
  } else {
    fullSchema = tool.schema.and(external_exports.object(sessionIdExt));
  }
  return {
    toolName: args.toolName,
    description: tool.metadata.description,
    inputSchema: fullSchema.shape || {},
    metadata: tool.metadata,
    note: `Schema loaded successfully. You can now call ${args.toolName} with these parameters.`
  };
}
var MetaTools = {
  SEARCH_TOOLS: {
    name: "search_tools",
    description: "Search for available RPG tools by category, capability, or keyword. Use this to discover tools before using them.",
    inputSchema: SearchToolsSchema
  },
  LOAD_TOOL_SCHEMA: {
    name: "load_tool_schema",
    description: "Load the full input schema for a specific tool (required before first use). Returns parameter definitions, types, and usage info.",
    inputSchema: LoadToolSchemaSchema
  }
};

// dist/engine/pubsub.js
var PubSub = class {
  subscribers = /* @__PURE__ */ new Map();
  subscribe(topic, callback) {
    if (!this.subscribers.has(topic)) {
      this.subscribers.set(topic, /* @__PURE__ */ new Set());
    }
    this.subscribers.get(topic).add(callback);
    return () => {
      const subs = this.subscribers.get(topic);
      if (subs) {
        subs.delete(callback);
        if (subs.size === 0) {
          this.subscribers.delete(topic);
        }
      }
    };
  }
  publish(topic, payload) {
    const subs = this.subscribers.get(topic);
    if (subs) {
      subs.forEach((callback) => {
        try {
          callback(payload);
        } catch (error) {
          console.error(`Error in subscriber for topic ${topic}:`, error);
        }
      });
    }
  }
};

// dist/server/events.js
init_zod();

// dist/server/types.js
init_zod();
function withSession(schema, handler) {
  const sessionSchema = external_exports.intersection(schema, external_exports.object({
    sessionId: external_exports.string().optional().default("default")
  }));
  return async (args) => {
    const parsed = sessionSchema.parse(args);
    const sessionId = parsed.sessionId;
    const ctx = { sessionId };
    return handler(parsed, ctx);
  };
}

// dist/server/events.js
var EventTools = {
  SUBSCRIBE: {
    name: "subscribe_to_events",
    description: "Subscribe to real-time events on world or combat topics. Events sent as JSON-RPC notifications.",
    inputSchema: external_exports.object({
      topics: external_exports.array(external_exports.enum(["world", "combat"])).min(1)
    })
  }
};
var activeSubscriptions = /* @__PURE__ */ new Map();
function registerEventTools(server, pubsub3) {
  server.tool(EventTools.SUBSCRIBE.name, EventTools.SUBSCRIBE.description, EventTools.SUBSCRIBE.inputSchema.extend({ sessionId: external_exports.string().optional() }).shape, withSession(EventTools.SUBSCRIBE.inputSchema, async (args, ctx) => {
    const { sessionId } = ctx;
    const existing = activeSubscriptions.get(sessionId) || [];
    existing.forEach((unsub) => unsub());
    const newSubs = [];
    for (const topic of args.topics) {
      const unsub = pubsub3.subscribe(topic, (payload) => {
        server.server.notification({
          method: "notifications/rpg/event",
          params: {
            topic,
            payload,
            sessionId
            // Optional: include sessionId in notification so client knows which session it's for
          }
        });
      });
      newSubs.push(unsub);
    }
    activeSubscriptions.set(sessionId, newSubs);
    return {
      content: [{
        type: "text",
        text: `Subscribed to topics: ${args.topics.join(", ")}`
      }]
    };
  }));
  const unsubscribeSchema = external_exports.object({});
  server.tool("unsubscribe_from_events", "Unsubscribe from all event topics", unsubscribeSchema.extend({ sessionId: external_exports.string().optional() }).shape, withSession(unsubscribeSchema, async (_args, ctx) => {
    const { sessionId } = ctx;
    const subs = activeSubscriptions.get(sessionId) || [];
    subs.forEach((unsub) => unsub());
    activeSubscriptions.delete(sessionId);
    return { content: [{ type: "text", text: "Unsubscribed from all topics" }] };
  }));
}

// dist/server/audit.js
var AuditLogger = class {
  repo;
  constructor() {
    const db = getDb(process.env.NODE_ENV === "test" ? ":memory:" : "rpg.db");
    this.repo = new AuditRepository(db);
  }
  wrapHandler(toolName, handler) {
    return async (args) => {
      const startTime = Date.now();
      let result;
      let error;
      try {
        result = await handler(args);
        return result;
      } catch (e) {
        error = e;
        throw e;
      } finally {
        try {
          this.repo.create({
            action: toolName,
            actorId: null,
            targetId: null,
            details: {
              args,
              result,
              error: error ? error.message : void 0,
              duration: Date.now() - startTime
            },
            timestamp: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (logError) {
          console.error("Failed to write audit log:", logError);
        }
      }
    };
  }
};

// dist/server/index.js
function setupShutdownHandlers() {
  let isShuttingDown = false;
  const shutdown = (signal) => {
    if (isShuttingDown)
      return;
    isShuttingDown = true;
    console.error(`[Server] Received ${signal}, shutting down gracefully...`);
    try {
      closeDb();
      console.error("[Server] Shutdown complete");
      process.exit(0);
    } catch (e) {
      console.error("[Server] Error during shutdown:", e.message);
      process.exit(1);
    }
  };
  process.on("SIGINT", () => shutdown("SIGINT"));
  process.on("SIGTERM", () => shutdown("SIGTERM"));
  process.on("SIGHUP", () => shutdown("SIGHUP"));
  if (process.platform === "win32") {
    process.on("SIGBREAK", () => shutdown("SIGBREAK"));
  }
  process.on("uncaughtException", (error) => {
    console.error("[Server] Uncaught exception:", error);
    shutdown("uncaughtException");
  });
  process.on("unhandledRejection", (reason) => {
    console.error("[Server] Unhandled rejection:", reason);
    shutdown("unhandledRejection");
  });
  process.on("exit", (code) => {
    if (!isShuttingDown) {
      console.error(`[Server] Process exiting with code ${code}`);
      closeDb();
    }
  });
}
async function main() {
  setupShutdownHandlers();
  console.error(`[Server] Database path: ${getDbPath()}`);
  const server = new McpServer({
    name: "rpg-mcp",
    version: "1.1.0"
  });
  const pubsub3 = new PubSub();
  setCombatPubSub(pubsub3);
  setWorldPubSub(pubsub3);
  registerEventTools(server, pubsub3);
  const auditLogger = new AuditLogger();
  server.tool(MetaTools.SEARCH_TOOLS.name, MetaTools.SEARCH_TOOLS.description, MetaTools.SEARCH_TOOLS.inputSchema.extend({ sessionId: external_exports.string().optional() }).shape, auditLogger.wrapHandler(MetaTools.SEARCH_TOOLS.name, withSession(MetaTools.SEARCH_TOOLS.inputSchema, handleSearchTools)));
  server.tool(MetaTools.LOAD_TOOL_SCHEMA.name, MetaTools.LOAD_TOOL_SCHEMA.description, MetaTools.LOAD_TOOL_SCHEMA.inputSchema.extend({ sessionId: external_exports.string().optional() }).shape, auditLogger.wrapHandler(MetaTools.LOAD_TOOL_SCHEMA.name, withSession(MetaTools.LOAD_TOOL_SCHEMA.inputSchema, handleLoadToolSchema)));
  const registry2 = buildToolRegistry();
  const toolCount = Object.keys(registry2).length;
  const sessionIdSchema = external_exports.object({ sessionId: external_exports.string().optional() });
  for (const [toolName, entry] of Object.entries(registry2)) {
    let extendedSchema;
    if (typeof entry.schema.extend === "function") {
      extendedSchema = entry.schema.extend({ sessionId: external_exports.string().optional() });
    } else if (typeof entry.schema.and === "function") {
      extendedSchema = entry.schema.and(sessionIdSchema);
    } else {
      extendedSchema = external_exports.intersection(entry.schema, sessionIdSchema);
    }
    server.tool(toolName, entry.metadata.description, extendedSchema.shape || extendedSchema._def?.schema?.shape || {}, auditLogger.wrapHandler(toolName, withSession(entry.schema, entry.handler)));
  }
  console.error(`[Server] Registered ${toolCount} tools with minimal schemas`);
  console.error(`[Server] Meta-tools: search_tools, load_tool_schema`);
  const args = process.argv.slice(2);
  const transportType = args.includes("--tcp") ? "tcp" : args.includes("--unix") || args.includes("--socket") ? "unix" : args.includes("--ws") || args.includes("--websocket") ? "websocket" : "stdio";
  if (transportType === "tcp") {
    const { TCPServerTransport: TCPServerTransport2 } = await Promise.resolve().then(() => (init_tcp(), tcp_exports));
    const portIndex = args.indexOf("--port");
    const port = portIndex !== -1 ? parseInt(args[portIndex + 1], 10) : 3e3;
    const transport = new TCPServerTransport2(port);
    await server.connect(transport);
    console.error(`RPG MCP Server running on TCP port ${port}`);
  } else if (transportType === "unix") {
    const { UnixServerTransport: UnixServerTransport2 } = await Promise.resolve().then(() => (init_unix(), unix_exports));
    let socketPath = "";
    const unixIndex = args.indexOf("--unix");
    const socketIndex = args.indexOf("--socket");
    if (unixIndex !== -1 && args[unixIndex + 1]) {
      socketPath = args[unixIndex + 1];
    } else if (socketIndex !== -1 && args[socketIndex + 1]) {
      socketPath = args[socketIndex + 1];
    }
    if (!socketPath) {
      socketPath = process.platform === "win32" ? "\\\\.\\pipe\\rpg-mcp" : "/tmp/rpg-mcp.sock";
    }
    const transport = new UnixServerTransport2(socketPath);
    await server.connect(transport);
    console.error(`RPG MCP Server running on Unix socket ${socketPath}`);
  } else if (transportType === "websocket") {
    const { WebSocketServerTransport: WebSocketServerTransport2 } = await Promise.resolve().then(() => (init_websocket(), websocket_exports));
    const portIndex = args.indexOf("--port");
    const port = portIndex !== -1 ? parseInt(args[portIndex + 1], 10) : 3001;
    const transport = new WebSocketServerTransport2(port);
    await server.connect(transport);
    console.error(`RPG MCP Server running on WebSocket port ${port}`);
  } else {
    const transport = new StdioServerTransport();
    await server.connect(transport);
    console.error("RPG MCP Server running on stdio");
  }
}
main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});
